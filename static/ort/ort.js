/*!
 * ONNX Runtime Web v1.20.0
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
"use strict";
var ort = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
  });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod2) => function __require2() {
    return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
  };
  var __export = (target, all) => {
    for (var name2 in all)
      __defProp(target, name2, { get: all[name2], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
    mod2
  ));
  var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);

  // common/dist/esm/backend-impl.js
  var backends, backendsSortedByPriority, registerBackend, tryResolveAndInitializeBackend, resolveBackendAndExecutionProviders;
  var init_backend_impl = __esm({
    "common/dist/esm/backend-impl.js"() {
      "use strict";
      backends = /* @__PURE__ */ new Map();
      backendsSortedByPriority = [];
      registerBackend = (name2, backend2, priority) => {
        if (backend2 && typeof backend2.init === "function" && typeof backend2.createInferenceSessionHandler === "function") {
          const currentBackend = backends.get(name2);
          if (currentBackend === void 0) {
            backends.set(name2, { backend: backend2, priority });
          } else if (currentBackend.priority > priority) {
            return;
          } else if (currentBackend.priority === priority) {
            if (currentBackend.backend !== backend2) {
              throw new Error(`cannot register backend "${name2}" using priority ${priority}`);
            }
          }
          if (priority >= 0) {
            const i = backendsSortedByPriority.indexOf(name2);
            if (i !== -1) {
              backendsSortedByPriority.splice(i, 1);
            }
            for (let i2 = 0; i2 < backendsSortedByPriority.length; i2++) {
              if (backends.get(backendsSortedByPriority[i2]).priority <= priority) {
                backendsSortedByPriority.splice(i2, 0, name2);
                return;
              }
            }
            backendsSortedByPriority.push(name2);
          }
          return;
        }
        throw new TypeError("not a valid backend");
      };
      tryResolveAndInitializeBackend = async (backendName) => {
        const backendInfo = backends.get(backendName);
        if (!backendInfo) {
          return "backend not found.";
        }
        if (backendInfo.initialized) {
          return backendInfo.backend;
        } else if (backendInfo.aborted) {
          return backendInfo.error;
        } else {
          const isInitializing = !!backendInfo.initPromise;
          try {
            if (!isInitializing) {
              backendInfo.initPromise = backendInfo.backend.init(backendName);
            }
            await backendInfo.initPromise;
            backendInfo.initialized = true;
            return backendInfo.backend;
          } catch (e) {
            if (!isInitializing) {
              backendInfo.error = `${e}`;
              backendInfo.aborted = true;
            }
            return backendInfo.error;
          } finally {
            delete backendInfo.initPromise;
          }
        }
      };
      resolveBackendAndExecutionProviders = async (options) => {
        const eps = options.executionProviders || [];
        const backendHints = eps.map((i) => typeof i === "string" ? i : i.name);
        const backendNames = backendHints.length === 0 ? backendsSortedByPriority : backendHints;
        let backend2;
        const errors = [];
        const availableBackendNames = /* @__PURE__ */ new Set();
        for (const backendName of backendNames) {
          const resolveResult = await tryResolveAndInitializeBackend(backendName);
          if (typeof resolveResult === "string") {
            errors.push({ name: backendName, err: resolveResult });
          } else {
            if (!backend2) {
              backend2 = resolveResult;
            }
            if (backend2 === resolveResult) {
              availableBackendNames.add(backendName);
            }
          }
        }
        if (!backend2) {
          throw new Error(`no available backend found. ERR: ${errors.map((e) => `[${e.name}] ${e.err}`).join(", ")}`);
        }
        for (const { name: name2, err } of errors) {
          if (backendHints.includes(name2)) {
            console.warn(`removing requested execution provider "${name2}" from session options because it is not available: ${err}`);
          }
        }
        const filteredEps = eps.filter((i) => availableBackendNames.has(typeof i === "string" ? i : i.name));
        return [
          backend2,
          new Proxy(options, {
            get: (target, prop) => {
              if (prop === "executionProviders") {
                return filteredEps;
              }
              return Reflect.get(target, prop);
            }
          })
        ];
      };
    }
  });

  // common/dist/esm/backend.js
  var init_backend = __esm({
    "common/dist/esm/backend.js"() {
      "use strict";
      init_backend_impl();
    }
  });

  // common/dist/esm/version.js
  var version;
  var init_version = __esm({
    "common/dist/esm/version.js"() {
      "use strict";
      version = "1.20.0";
    }
  });

  // common/dist/esm/env-impl.js
  var logLevelValue, env;
  var init_env_impl = __esm({
    "common/dist/esm/env-impl.js"() {
      "use strict";
      init_version();
      logLevelValue = "warning";
      env = {
        wasm: {},
        webgl: {},
        webgpu: {},
        versions: { common: version },
        set logLevel(value) {
          if (value === void 0) {
            return;
          }
          if (typeof value !== "string" || ["verbose", "info", "warning", "error", "fatal"].indexOf(value) === -1) {
            throw new Error(`Unsupported logging level: ${value}`);
          }
          logLevelValue = value;
        },
        get logLevel() {
          return logLevelValue;
        }
      };
      Object.defineProperty(env, "logLevel", { enumerable: true });
    }
  });

  // common/dist/esm/env.js
  var env2;
  var init_env = __esm({
    "common/dist/esm/env.js"() {
      "use strict";
      init_env_impl();
      env2 = env;
    }
  });

  // common/dist/esm/tensor-conversion-impl.js
  var tensorToDataURL, tensorToImageData;
  var init_tensor_conversion_impl = __esm({
    "common/dist/esm/tensor-conversion-impl.js"() {
      "use strict";
      tensorToDataURL = (tensor, options) => {
        const canvas = typeof document !== "undefined" ? document.createElement("canvas") : new OffscreenCanvas(1, 1);
        canvas.width = tensor.dims[3];
        canvas.height = tensor.dims[2];
        const pixels2DContext = canvas.getContext("2d");
        if (pixels2DContext != null) {
          let width;
          let height;
          if (options?.tensorLayout !== void 0 && options.tensorLayout === "NHWC") {
            width = tensor.dims[2];
            height = tensor.dims[3];
          } else {
            width = tensor.dims[3];
            height = tensor.dims[2];
          }
          const inputformat = options?.format !== void 0 ? options.format : "RGB";
          const norm = options?.norm;
          let normMean;
          let normBias;
          if (norm === void 0 || norm.mean === void 0) {
            normMean = [255, 255, 255, 255];
          } else {
            if (typeof norm.mean === "number") {
              normMean = [norm.mean, norm.mean, norm.mean, norm.mean];
            } else {
              normMean = [norm.mean[0], norm.mean[1], norm.mean[2], 0];
              if (norm.mean[3] !== void 0) {
                normMean[3] = norm.mean[3];
              }
            }
          }
          if (norm === void 0 || norm.bias === void 0) {
            normBias = [0, 0, 0, 0];
          } else {
            if (typeof norm.bias === "number") {
              normBias = [norm.bias, norm.bias, norm.bias, norm.bias];
            } else {
              normBias = [norm.bias[0], norm.bias[1], norm.bias[2], 0];
              if (norm.bias[3] !== void 0) {
                normBias[3] = norm.bias[3];
              }
            }
          }
          const stride = height * width;
          let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;
          if (inputformat === "RGBA") {
            rTensorPointer = 0;
            gTensorPointer = stride;
            bTensorPointer = stride * 2;
            aTensorPointer = stride * 3;
          } else if (inputformat === "RGB") {
            rTensorPointer = 0;
            gTensorPointer = stride;
            bTensorPointer = stride * 2;
          } else if (inputformat === "RBG") {
            rTensorPointer = 0;
            bTensorPointer = stride;
            gTensorPointer = stride * 2;
          }
          for (let i = 0; i < height; i++) {
            for (let j = 0; j < width; j++) {
              const R = (tensor.data[rTensorPointer++] - normBias[0]) * normMean[0];
              const G = (tensor.data[gTensorPointer++] - normBias[1]) * normMean[1];
              const B = (tensor.data[bTensorPointer++] - normBias[2]) * normMean[2];
              const A = aTensorPointer === -1 ? 255 : (tensor.data[aTensorPointer++] - normBias[3]) * normMean[3];
              pixels2DContext.fillStyle = "rgba(" + R + "," + G + "," + B + "," + A + ")";
              pixels2DContext.fillRect(j, i, 1, 1);
            }
          }
          if ("toDataURL" in canvas) {
            return canvas.toDataURL();
          } else {
            throw new Error("toDataURL is not supported");
          }
        } else {
          throw new Error("Can not access image data");
        }
      };
      tensorToImageData = (tensor, options) => {
        const pixels2DContext = typeof document !== "undefined" ? document.createElement("canvas").getContext("2d") : new OffscreenCanvas(1, 1).getContext("2d");
        let image;
        if (pixels2DContext != null) {
          let width;
          let height;
          let channels;
          if (options?.tensorLayout !== void 0 && options.tensorLayout === "NHWC") {
            width = tensor.dims[2];
            height = tensor.dims[1];
            channels = tensor.dims[3];
          } else {
            width = tensor.dims[3];
            height = tensor.dims[2];
            channels = tensor.dims[1];
          }
          const inputformat = options !== void 0 ? options.format !== void 0 ? options.format : "RGB" : "RGB";
          const norm = options?.norm;
          let normMean;
          let normBias;
          if (norm === void 0 || norm.mean === void 0) {
            normMean = [255, 255, 255, 255];
          } else {
            if (typeof norm.mean === "number") {
              normMean = [norm.mean, norm.mean, norm.mean, norm.mean];
            } else {
              normMean = [norm.mean[0], norm.mean[1], norm.mean[2], 255];
              if (norm.mean[3] !== void 0) {
                normMean[3] = norm.mean[3];
              }
            }
          }
          if (norm === void 0 || norm.bias === void 0) {
            normBias = [0, 0, 0, 0];
          } else {
            if (typeof norm.bias === "number") {
              normBias = [norm.bias, norm.bias, norm.bias, norm.bias];
            } else {
              normBias = [norm.bias[0], norm.bias[1], norm.bias[2], 0];
              if (norm.bias[3] !== void 0) {
                normBias[3] = norm.bias[3];
              }
            }
          }
          const stride = height * width;
          if (options !== void 0) {
            if (options.format !== void 0 && channels === 4 && options.format !== "RGBA" || channels === 3 && options.format !== "RGB" && options.format !== "BGR") {
              throw new Error("Tensor format doesn't match input tensor dims");
            }
          }
          const step = 4;
          let rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;
          let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;
          if (inputformat === "RGBA") {
            rTensorPointer = 0;
            gTensorPointer = stride;
            bTensorPointer = stride * 2;
            aTensorPointer = stride * 3;
          } else if (inputformat === "RGB") {
            rTensorPointer = 0;
            gTensorPointer = stride;
            bTensorPointer = stride * 2;
          } else if (inputformat === "RBG") {
            rTensorPointer = 0;
            bTensorPointer = stride;
            gTensorPointer = stride * 2;
          }
          image = pixels2DContext.createImageData(width, height);
          for (let i = 0; i < height * width; rImagePointer += step, gImagePointer += step, bImagePointer += step, aImagePointer += step, i++) {
            image.data[rImagePointer] = (tensor.data[rTensorPointer++] - normBias[0]) * normMean[0];
            image.data[gImagePointer] = (tensor.data[gTensorPointer++] - normBias[1]) * normMean[1];
            image.data[bImagePointer] = (tensor.data[bTensorPointer++] - normBias[2]) * normMean[2];
            image.data[aImagePointer] = aTensorPointer === -1 ? 255 : (tensor.data[aTensorPointer++] - normBias[3]) * normMean[3];
          }
        } else {
          throw new Error("Can not access image data");
        }
        return image;
      };
    }
  });

  // common/dist/esm/tensor-factory-impl.js
  var bufferToTensor, tensorFromImage, tensorFromTexture, tensorFromGpuBuffer, tensorFromMLTensor, tensorFromPinnedBuffer;
  var init_tensor_factory_impl = __esm({
    "common/dist/esm/tensor-factory-impl.js"() {
      "use strict";
      init_tensor_impl();
      bufferToTensor = (buffer, options) => {
        if (buffer === void 0) {
          throw new Error("Image buffer must be defined");
        }
        if (options.height === void 0 || options.width === void 0) {
          throw new Error("Image height and width must be defined");
        }
        if (options.tensorLayout === "NHWC") {
          throw new Error("NHWC Tensor layout is not supported yet");
        }
        const { height, width } = options;
        const norm = options.norm ?? { mean: 255, bias: 0 };
        let normMean;
        let normBias;
        if (typeof norm.mean === "number") {
          normMean = [norm.mean, norm.mean, norm.mean, norm.mean];
        } else {
          normMean = [norm.mean[0], norm.mean[1], norm.mean[2], norm.mean[3] ?? 255];
        }
        if (typeof norm.bias === "number") {
          normBias = [norm.bias, norm.bias, norm.bias, norm.bias];
        } else {
          normBias = [norm.bias[0], norm.bias[1], norm.bias[2], norm.bias[3] ?? 0];
        }
        const inputformat = options.format !== void 0 ? options.format : "RGBA";
        const outputformat = options.tensorFormat !== void 0 ? options.tensorFormat !== void 0 ? options.tensorFormat : "RGB" : "RGB";
        const stride = height * width;
        const float32Data = outputformat === "RGBA" ? new Float32Array(stride * 4) : new Float32Array(stride * 3);
        let step = 4, rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;
        let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;
        if (inputformat === "RGB") {
          step = 3;
          rImagePointer = 0;
          gImagePointer = 1;
          bImagePointer = 2;
          aImagePointer = -1;
        }
        if (outputformat === "RGBA") {
          aTensorPointer = stride * 3;
        } else if (outputformat === "RBG") {
          rTensorPointer = 0;
          bTensorPointer = stride;
          gTensorPointer = stride * 2;
        } else if (outputformat === "BGR") {
          bTensorPointer = 0;
          gTensorPointer = stride;
          rTensorPointer = stride * 2;
        }
        for (let i = 0; i < stride; i++, rImagePointer += step, bImagePointer += step, gImagePointer += step, aImagePointer += step) {
          float32Data[rTensorPointer++] = (buffer[rImagePointer] + normBias[0]) / normMean[0];
          float32Data[gTensorPointer++] = (buffer[gImagePointer] + normBias[1]) / normMean[1];
          float32Data[bTensorPointer++] = (buffer[bImagePointer] + normBias[2]) / normMean[2];
          if (aTensorPointer !== -1 && aImagePointer !== -1) {
            float32Data[aTensorPointer++] = (buffer[aImagePointer] + normBias[3]) / normMean[3];
          }
        }
        const outputTensor = outputformat === "RGBA" ? new Tensor("float32", float32Data, [1, 4, height, width]) : new Tensor("float32", float32Data, [1, 3, height, width]);
        return outputTensor;
      };
      tensorFromImage = async (image, options) => {
        const isHTMLImageEle = typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement;
        const isImageDataEle = typeof ImageData !== "undefined" && image instanceof ImageData;
        const isImageBitmap = typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap;
        const isString = typeof image === "string";
        let data;
        let bufferToTensorOptions = options ?? {};
        const createCanvas2 = () => {
          if (typeof document !== "undefined") {
            return document.createElement("canvas");
          } else if (typeof OffscreenCanvas !== "undefined") {
            return new OffscreenCanvas(1, 1);
          } else {
            throw new Error("Canvas is not supported");
          }
        };
        const createCanvasContext = (canvas) => {
          if (typeof HTMLCanvasElement !== "undefined" && canvas instanceof HTMLCanvasElement) {
            return canvas.getContext("2d");
          } else if (canvas instanceof OffscreenCanvas) {
            return canvas.getContext("2d");
          } else {
            return null;
          }
        };
        if (isHTMLImageEle) {
          const canvas = createCanvas2();
          canvas.width = image.width;
          canvas.height = image.height;
          const pixels2DContext = createCanvasContext(canvas);
          if (pixels2DContext != null) {
            let height = image.height;
            let width = image.width;
            if (options !== void 0 && options.resizedHeight !== void 0 && options.resizedWidth !== void 0) {
              height = options.resizedHeight;
              width = options.resizedWidth;
            }
            if (options !== void 0) {
              bufferToTensorOptions = options;
              if (options.tensorFormat !== void 0) {
                throw new Error("Image input config format must be RGBA for HTMLImageElement");
              } else {
                bufferToTensorOptions.tensorFormat = "RGBA";
              }
              bufferToTensorOptions.height = height;
              bufferToTensorOptions.width = width;
            } else {
              bufferToTensorOptions.tensorFormat = "RGBA";
              bufferToTensorOptions.height = height;
              bufferToTensorOptions.width = width;
            }
            pixels2DContext.drawImage(image, 0, 0);
            data = pixels2DContext.getImageData(0, 0, width, height).data;
          } else {
            throw new Error("Can not access image data");
          }
        } else if (isImageDataEle) {
          let height;
          let width;
          if (options !== void 0 && options.resizedWidth !== void 0 && options.resizedHeight !== void 0) {
            height = options.resizedHeight;
            width = options.resizedWidth;
          } else {
            height = image.height;
            width = image.width;
          }
          if (options !== void 0) {
            bufferToTensorOptions = options;
          }
          bufferToTensorOptions.format = "RGBA";
          bufferToTensorOptions.height = height;
          bufferToTensorOptions.width = width;
          if (options !== void 0) {
            const tempCanvas = createCanvas2();
            tempCanvas.width = width;
            tempCanvas.height = height;
            const pixels2DContext = createCanvasContext(tempCanvas);
            if (pixels2DContext != null) {
              pixels2DContext.putImageData(image, 0, 0);
              data = pixels2DContext.getImageData(0, 0, width, height).data;
            } else {
              throw new Error("Can not access image data");
            }
          } else {
            data = image.data;
          }
        } else if (isImageBitmap) {
          if (options === void 0) {
            throw new Error("Please provide image config with format for Imagebitmap");
          }
          const canvas = createCanvas2();
          canvas.width = image.width;
          canvas.height = image.height;
          const pixels2DContext = createCanvasContext(canvas);
          if (pixels2DContext != null) {
            const height = image.height;
            const width = image.width;
            pixels2DContext.drawImage(image, 0, 0, width, height);
            data = pixels2DContext.getImageData(0, 0, width, height).data;
            bufferToTensorOptions.height = height;
            bufferToTensorOptions.width = width;
            return bufferToTensor(data, bufferToTensorOptions);
          } else {
            throw new Error("Can not access image data");
          }
        } else if (isString) {
          return new Promise((resolve, reject) => {
            const canvas = createCanvas2();
            const context = createCanvasContext(canvas);
            if (!image || !context) {
              return reject();
            }
            const newImage = new Image();
            newImage.crossOrigin = "Anonymous";
            newImage.src = image;
            newImage.onload = () => {
              canvas.width = newImage.width;
              canvas.height = newImage.height;
              context.drawImage(newImage, 0, 0, canvas.width, canvas.height);
              const img = context.getImageData(0, 0, canvas.width, canvas.height);
              bufferToTensorOptions.height = canvas.height;
              bufferToTensorOptions.width = canvas.width;
              resolve(bufferToTensor(img.data, bufferToTensorOptions));
            };
          });
        } else {
          throw new Error("Input data provided is not supported - aborted tensor creation");
        }
        if (data !== void 0) {
          return bufferToTensor(data, bufferToTensorOptions);
        } else {
          throw new Error("Input data provided is not supported - aborted tensor creation");
        }
      };
      tensorFromTexture = (texture, options) => {
        const { width, height, download, dispose } = options;
        const dims = [1, height, width, 4];
        return new Tensor({ location: "texture", type: "float32", texture, dims, download, dispose });
      };
      tensorFromGpuBuffer = (gpuBuffer, options) => {
        const { dataType, dims, download, dispose } = options;
        return new Tensor({ location: "gpu-buffer", type: dataType ?? "float32", gpuBuffer, dims, download, dispose });
      };
      tensorFromMLTensor = (mlTensor, options) => {
        const { dataType, dims, download, dispose } = options;
        return new Tensor({ location: "ml-tensor", type: dataType ?? "float32", mlTensor, dims, download, dispose });
      };
      tensorFromPinnedBuffer = (type, buffer, dims) => new Tensor({ location: "cpu-pinned", type, data: buffer, dims: dims ?? [buffer.length] });
    }
  });

  // common/dist/esm/tensor-impl-type-mapping.js
  var NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP, NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP, isTypedArrayChecked, checkTypedArray;
  var init_tensor_impl_type_mapping = __esm({
    "common/dist/esm/tensor-impl-type-mapping.js"() {
      "use strict";
      NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP = /* @__PURE__ */ new Map([
        ["float32", Float32Array],
        ["uint8", Uint8Array],
        ["int8", Int8Array],
        ["uint16", Uint16Array],
        ["int16", Int16Array],
        ["int32", Int32Array],
        ["bool", Uint8Array],
        ["float64", Float64Array],
        ["uint32", Uint32Array],
        ["int4", Uint8Array],
        ["uint4", Uint8Array]
      ]);
      NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP = /* @__PURE__ */ new Map([
        [Float32Array, "float32"],
        [Uint8Array, "uint8"],
        [Int8Array, "int8"],
        [Uint16Array, "uint16"],
        [Int16Array, "int16"],
        [Int32Array, "int32"],
        [Float64Array, "float64"],
        [Uint32Array, "uint32"]
      ]);
      isTypedArrayChecked = false;
      checkTypedArray = () => {
        if (!isTypedArrayChecked) {
          isTypedArrayChecked = true;
          const isBigInt64ArrayAvailable = typeof BigInt64Array !== "undefined" && BigInt64Array.from;
          const isBigUint64ArrayAvailable = typeof BigUint64Array !== "undefined" && BigUint64Array.from;
          const isFloat16ArrayAvailable = typeof Float16Array !== "undefined" && Float16Array.from;
          if (isBigInt64ArrayAvailable) {
            NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("int64", BigInt64Array);
            NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigInt64Array, "int64");
          }
          if (isBigUint64ArrayAvailable) {
            NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("uint64", BigUint64Array);
            NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigUint64Array, "uint64");
          }
          if (isFloat16ArrayAvailable) {
            NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("float16", Float16Array);
            NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(Float16Array, "float16");
          } else {
            NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("float16", Uint16Array);
          }
        }
      };
    }
  });

  // common/dist/esm/tensor-utils-impl.js
  var calculateSize, tensorReshape;
  var init_tensor_utils_impl = __esm({
    "common/dist/esm/tensor-utils-impl.js"() {
      "use strict";
      init_tensor_impl();
      calculateSize = (dims) => {
        let size = 1;
        for (let i = 0; i < dims.length; i++) {
          const dim = dims[i];
          if (typeof dim !== "number" || !Number.isSafeInteger(dim)) {
            throw new TypeError(`dims[${i}] must be an integer, got: ${dim}`);
          }
          if (dim < 0) {
            throw new RangeError(`dims[${i}] must be a non-negative integer, got: ${dim}`);
          }
          size *= dim;
        }
        return size;
      };
      tensorReshape = (tensor, dims) => {
        switch (tensor.location) {
          case "cpu":
            return new Tensor(tensor.type, tensor.data, dims);
          case "cpu-pinned":
            return new Tensor({
              location: "cpu-pinned",
              data: tensor.data,
              type: tensor.type,
              dims
            });
          case "texture":
            return new Tensor({
              location: "texture",
              texture: tensor.texture,
              type: tensor.type,
              dims
            });
          case "gpu-buffer":
            return new Tensor({
              location: "gpu-buffer",
              gpuBuffer: tensor.gpuBuffer,
              type: tensor.type,
              dims
            });
          case "ml-tensor":
            return new Tensor({
              location: "ml-tensor",
              mlTensor: tensor.mlTensor,
              type: tensor.type,
              dims
            });
          default:
            throw new Error(`tensorReshape: tensor location ${tensor.location} is not supported`);
        }
      };
    }
  });

  // common/dist/esm/tensor-impl.js
  var Tensor;
  var init_tensor_impl = __esm({
    "common/dist/esm/tensor-impl.js"() {
      "use strict";
      init_tensor_conversion_impl();
      init_tensor_factory_impl();
      init_tensor_impl_type_mapping();
      init_tensor_utils_impl();
      Tensor = class {
        /**
         * implementation.
         */
        constructor(arg0, arg1, arg2) {
          checkTypedArray();
          let type;
          let dims;
          if (typeof arg0 === "object" && "location" in arg0) {
            this.dataLocation = arg0.location;
            type = arg0.type;
            dims = arg0.dims;
            switch (arg0.location) {
              case "cpu-pinned": {
                const expectedTypedArrayConstructor = NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(type);
                if (!expectedTypedArrayConstructor) {
                  throw new TypeError(`unsupported type "${type}" to create tensor from pinned buffer`);
                }
                if (!(arg0.data instanceof expectedTypedArrayConstructor)) {
                  throw new TypeError(`buffer should be of type ${expectedTypedArrayConstructor.name}`);
                }
                this.cpuData = arg0.data;
                break;
              }
              case "texture": {
                if (type !== "float32") {
                  throw new TypeError(`unsupported type "${type}" to create tensor from texture`);
                }
                this.gpuTextureData = arg0.texture;
                this.downloader = arg0.download;
                this.disposer = arg0.dispose;
                break;
              }
              case "gpu-buffer": {
                if (type !== "float32" && type !== "float16" && type !== "int32" && type !== "int64" && type !== "uint32" && type !== "uint8" && type !== "bool" && type !== "uint4" && type !== "int4") {
                  throw new TypeError(`unsupported type "${type}" to create tensor from gpu buffer`);
                }
                this.gpuBufferData = arg0.gpuBuffer;
                this.downloader = arg0.download;
                this.disposer = arg0.dispose;
                break;
              }
              case "ml-tensor": {
                if (type !== "float32" && type !== "float16" && type !== "int32" && type !== "int64" && type !== "uint32" && type !== "uint64" && type !== "int8" && type !== "uint8" && type !== "bool" && type !== "uint4" && type !== "int4") {
                  throw new TypeError(`unsupported type "${type}" to create tensor from MLTensor`);
                }
                this.mlTensorData = arg0.mlTensor;
                this.downloader = arg0.download;
                this.disposer = arg0.dispose;
                break;
              }
              default:
                throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`);
            }
          } else {
            let data;
            let maybeDims;
            if (typeof arg0 === "string") {
              type = arg0;
              maybeDims = arg2;
              if (arg0 === "string") {
                if (!Array.isArray(arg1)) {
                  throw new TypeError("A string tensor's data must be a string array.");
                }
                data = arg1;
              } else {
                const typedArrayConstructor = NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(arg0);
                if (typedArrayConstructor === void 0) {
                  throw new TypeError(`Unsupported tensor type: ${arg0}.`);
                }
                if (Array.isArray(arg1)) {
                  if (arg0 === "float16" && typedArrayConstructor === Uint16Array || arg0 === "uint4" || arg0 === "int4") {
                    throw new TypeError(`Creating a ${arg0} tensor from number array is not supported. Please use ${typedArrayConstructor.name} as data.`);
                  } else if (arg0 === "uint64" || arg0 === "int64") {
                    data = typedArrayConstructor.from(arg1, BigInt);
                  } else {
                    data = typedArrayConstructor.from(arg1);
                  }
                } else if (arg1 instanceof typedArrayConstructor) {
                  data = arg1;
                } else if (arg1 instanceof Uint8ClampedArray) {
                  if (arg0 === "uint8") {
                    data = Uint8Array.from(arg1);
                  } else {
                    throw new TypeError(`A Uint8ClampedArray tensor's data must be type of uint8`);
                  }
                } else {
                  throw new TypeError(`A ${type} tensor's data must be type of ${typedArrayConstructor}`);
                }
              }
            } else {
              maybeDims = arg1;
              if (Array.isArray(arg0)) {
                if (arg0.length === 0) {
                  throw new TypeError("Tensor type cannot be inferred from an empty array.");
                }
                const firstElementType = typeof arg0[0];
                if (firstElementType === "string") {
                  type = "string";
                  data = arg0;
                } else if (firstElementType === "boolean") {
                  type = "bool";
                  data = Uint8Array.from(arg0);
                } else {
                  throw new TypeError(`Invalid element type of data array: ${firstElementType}.`);
                }
              } else if (arg0 instanceof Uint8ClampedArray) {
                type = "uint8";
                data = Uint8Array.from(arg0);
              } else {
                const mappedType = NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.get(arg0.constructor);
                if (mappedType === void 0) {
                  throw new TypeError(`Unsupported type for tensor data: ${arg0.constructor}.`);
                }
                type = mappedType;
                data = arg0;
              }
            }
            if (maybeDims === void 0) {
              maybeDims = [data.length];
            } else if (!Array.isArray(maybeDims)) {
              throw new TypeError("A tensor's dims must be a number array");
            }
            dims = maybeDims;
            this.cpuData = data;
            this.dataLocation = "cpu";
          }
          const size = calculateSize(dims);
          if (this.cpuData && size !== this.cpuData.length) {
            if ((type === "uint4" || type === "int4") && Math.ceil(size / 2) === this.cpuData.length) {
            } else {
              throw new Error(`Tensor's size(${size}) does not match data length(${this.cpuData.length}).`);
            }
          }
          this.type = type;
          this.dims = dims;
          this.size = size;
        }
        // #endregion
        // #region factory
        static async fromImage(image, options) {
          return tensorFromImage(image, options);
        }
        static fromTexture(texture, options) {
          return tensorFromTexture(texture, options);
        }
        static fromGpuBuffer(gpuBuffer, options) {
          return tensorFromGpuBuffer(gpuBuffer, options);
        }
        static fromMLTensor(mlTensor, options) {
          return tensorFromMLTensor(mlTensor, options);
        }
        static fromPinnedBuffer(type, buffer, dims) {
          return tensorFromPinnedBuffer(type, buffer, dims);
        }
        // #endregion
        // #region conversions
        toDataURL(options) {
          return tensorToDataURL(this, options);
        }
        toImageData(options) {
          return tensorToImageData(this, options);
        }
        // #endregion
        // #region properties
        get data() {
          this.ensureValid();
          if (!this.cpuData) {
            throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");
          }
          return this.cpuData;
        }
        get location() {
          return this.dataLocation;
        }
        get texture() {
          this.ensureValid();
          if (!this.gpuTextureData) {
            throw new Error("The data is not stored as a WebGL texture.");
          }
          return this.gpuTextureData;
        }
        get gpuBuffer() {
          this.ensureValid();
          if (!this.gpuBufferData) {
            throw new Error("The data is not stored as a WebGPU buffer.");
          }
          return this.gpuBufferData;
        }
        get mlTensor() {
          this.ensureValid();
          if (!this.mlTensorData) {
            throw new Error("The data is not stored as a WebNN MLTensor.");
          }
          return this.mlTensorData;
        }
        // #endregion
        // #region methods
        async getData(releaseData) {
          this.ensureValid();
          switch (this.dataLocation) {
            case "cpu":
            case "cpu-pinned":
              return this.data;
            case "texture":
            case "gpu-buffer":
            case "ml-tensor": {
              if (!this.downloader) {
                throw new Error("The current tensor is not created with a specified data downloader.");
              }
              if (this.isDownloading) {
                throw new Error("The current tensor is being downloaded.");
              }
              try {
                this.isDownloading = true;
                const data = await this.downloader();
                this.downloader = void 0;
                this.dataLocation = "cpu";
                this.cpuData = data;
                if (releaseData && this.disposer) {
                  this.disposer();
                  this.disposer = void 0;
                }
                return data;
              } finally {
                this.isDownloading = false;
              }
            }
            default:
              throw new Error(`cannot get data from location: ${this.dataLocation}`);
          }
        }
        dispose() {
          if (this.isDownloading) {
            throw new Error("The current tensor is being downloaded.");
          }
          if (this.disposer) {
            this.disposer();
            this.disposer = void 0;
          }
          this.cpuData = void 0;
          this.gpuTextureData = void 0;
          this.gpuBufferData = void 0;
          this.mlTensorData = void 0;
          this.downloader = void 0;
          this.isDownloading = void 0;
          this.dataLocation = "none";
        }
        // #endregion
        // #region tensor utilities
        ensureValid() {
          if (this.dataLocation === "none") {
            throw new Error("The tensor is disposed.");
          }
        }
        reshape(dims) {
          this.ensureValid();
          if (this.downloader || this.disposer) {
            throw new Error("Cannot reshape a tensor that owns GPU resource.");
          }
          return tensorReshape(this, dims);
        }
      };
    }
  });

  // common/dist/esm/tensor.js
  var Tensor2;
  var init_tensor = __esm({
    "common/dist/esm/tensor.js"() {
      "use strict";
      init_tensor_impl();
      Tensor2 = Tensor;
    }
  });

  // common/dist/esm/trace.js
  var TRACE, TRACE_FUNC, TRACE_FUNC_BEGIN, TRACE_FUNC_END;
  var init_trace = __esm({
    "common/dist/esm/trace.js"() {
      "use strict";
      init_env_impl();
      TRACE = (deviceType, label) => {
        if (typeof env.trace === "undefined" ? !env.wasm.trace : !env.trace) {
          return;
        }
        console.timeStamp(`${deviceType}::ORT::${label}`);
      };
      TRACE_FUNC = (msg, extraMsg) => {
        const stack = new Error().stack?.split(/\r\n|\r|\n/g) || [];
        let hasTraceFunc = false;
        for (let i = 0; i < stack.length; i++) {
          if (hasTraceFunc && !stack[i].includes("TRACE_FUNC")) {
            let label = `FUNC_${msg}::${stack[i].trim().split(" ")[1]}`;
            if (extraMsg) {
              label += `::${extraMsg}`;
            }
            TRACE("CPU", label);
            return;
          }
          if (stack[i].includes("TRACE_FUNC")) {
            hasTraceFunc = true;
          }
        }
      };
      TRACE_FUNC_BEGIN = (extraMsg) => {
        if (typeof env.trace === "undefined" ? !env.wasm.trace : !env.trace) {
          return;
        }
        TRACE_FUNC("BEGIN", extraMsg);
      };
      TRACE_FUNC_END = (extraMsg) => {
        if (typeof env.trace === "undefined" ? !env.wasm.trace : !env.trace) {
          return;
        }
        TRACE_FUNC("END", extraMsg);
      };
    }
  });

  // common/dist/esm/inference-session-impl.js
  var InferenceSession;
  var init_inference_session_impl = __esm({
    "common/dist/esm/inference-session-impl.js"() {
      "use strict";
      init_backend_impl();
      init_tensor();
      init_trace();
      InferenceSession = class _InferenceSession {
        constructor(handler) {
          this.handler = handler;
        }
        async run(feeds, arg1, arg2) {
          TRACE_FUNC_BEGIN();
          const fetches = {};
          let options = {};
          if (typeof feeds !== "object" || feeds === null || feeds instanceof Tensor2 || Array.isArray(feeds)) {
            throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");
          }
          let isFetchesEmpty = true;
          if (typeof arg1 === "object") {
            if (arg1 === null) {
              throw new TypeError("Unexpected argument[1]: cannot be null.");
            }
            if (arg1 instanceof Tensor2) {
              throw new TypeError("'fetches' cannot be a Tensor");
            }
            if (Array.isArray(arg1)) {
              if (arg1.length === 0) {
                throw new TypeError("'fetches' cannot be an empty array.");
              }
              isFetchesEmpty = false;
              for (const name2 of arg1) {
                if (typeof name2 !== "string") {
                  throw new TypeError("'fetches' must be a string array or an object.");
                }
                if (this.outputNames.indexOf(name2) === -1) {
                  throw new RangeError(`'fetches' contains invalid output name: ${name2}.`);
                }
                fetches[name2] = null;
              }
              if (typeof arg2 === "object" && arg2 !== null) {
                options = arg2;
              } else if (typeof arg2 !== "undefined") {
                throw new TypeError("'options' must be an object.");
              }
            } else {
              let isFetches = false;
              const arg1Keys = Object.getOwnPropertyNames(arg1);
              for (const name2 of this.outputNames) {
                if (arg1Keys.indexOf(name2) !== -1) {
                  const v = arg1[name2];
                  if (v === null || v instanceof Tensor2) {
                    isFetches = true;
                    isFetchesEmpty = false;
                    fetches[name2] = v;
                  }
                }
              }
              if (isFetches) {
                if (typeof arg2 === "object" && arg2 !== null) {
                  options = arg2;
                } else if (typeof arg2 !== "undefined") {
                  throw new TypeError("'options' must be an object.");
                }
              } else {
                options = arg1;
              }
            }
          } else if (typeof arg1 !== "undefined") {
            throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");
          }
          for (const name2 of this.inputNames) {
            if (typeof feeds[name2] === "undefined") {
              throw new Error(`input '${name2}' is missing in 'feeds'.`);
            }
          }
          if (isFetchesEmpty) {
            for (const name2 of this.outputNames) {
              fetches[name2] = null;
            }
          }
          const results = await this.handler.run(feeds, fetches, options);
          const returnValue = {};
          for (const key in results) {
            if (Object.hasOwnProperty.call(results, key)) {
              const result = results[key];
              if (result instanceof Tensor2) {
                returnValue[key] = result;
              } else {
                returnValue[key] = new Tensor2(result.type, result.data, result.dims);
              }
            }
          }
          TRACE_FUNC_END();
          return returnValue;
        }
        async release() {
          return this.handler.dispose();
        }
        static async create(arg0, arg1, arg2, arg3) {
          TRACE_FUNC_BEGIN();
          let filePathOrUint8Array;
          let options = {};
          if (typeof arg0 === "string") {
            filePathOrUint8Array = arg0;
            if (typeof arg1 === "object" && arg1 !== null) {
              options = arg1;
            } else if (typeof arg1 !== "undefined") {
              throw new TypeError("'options' must be an object.");
            }
          } else if (arg0 instanceof Uint8Array) {
            filePathOrUint8Array = arg0;
            if (typeof arg1 === "object" && arg1 !== null) {
              options = arg1;
            } else if (typeof arg1 !== "undefined") {
              throw new TypeError("'options' must be an object.");
            }
          } else if (arg0 instanceof ArrayBuffer || typeof SharedArrayBuffer !== "undefined" && arg0 instanceof SharedArrayBuffer) {
            const buffer = arg0;
            let byteOffset = 0;
            let byteLength = arg0.byteLength;
            if (typeof arg1 === "object" && arg1 !== null) {
              options = arg1;
            } else if (typeof arg1 === "number") {
              byteOffset = arg1;
              if (!Number.isSafeInteger(byteOffset)) {
                throw new RangeError("'byteOffset' must be an integer.");
              }
              if (byteOffset < 0 || byteOffset >= buffer.byteLength) {
                throw new RangeError(`'byteOffset' is out of range [0, ${buffer.byteLength}).`);
              }
              byteLength = arg0.byteLength - byteOffset;
              if (typeof arg2 === "number") {
                byteLength = arg2;
                if (!Number.isSafeInteger(byteLength)) {
                  throw new RangeError("'byteLength' must be an integer.");
                }
                if (byteLength <= 0 || byteOffset + byteLength > buffer.byteLength) {
                  throw new RangeError(`'byteLength' is out of range (0, ${buffer.byteLength - byteOffset}].`);
                }
                if (typeof arg3 === "object" && arg3 !== null) {
                  options = arg3;
                } else if (typeof arg3 !== "undefined") {
                  throw new TypeError("'options' must be an object.");
                }
              } else if (typeof arg2 !== "undefined") {
                throw new TypeError("'byteLength' must be a number.");
              }
            } else if (typeof arg1 !== "undefined") {
              throw new TypeError("'options' must be an object.");
            }
            filePathOrUint8Array = new Uint8Array(buffer, byteOffset, byteLength);
          } else {
            throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");
          }
          const [backend2, optionsWithValidatedEPs] = await resolveBackendAndExecutionProviders(options);
          const handler = await backend2.createInferenceSessionHandler(filePathOrUint8Array, optionsWithValidatedEPs);
          TRACE_FUNC_END();
          return new _InferenceSession(handler);
        }
        startProfiling() {
          this.handler.startProfiling();
        }
        endProfiling() {
          this.handler.endProfiling();
        }
        get inputNames() {
          return this.handler.inputNames;
        }
        get outputNames() {
          return this.handler.outputNames;
        }
      };
    }
  });

  // common/dist/esm/inference-session.js
  var InferenceSession2;
  var init_inference_session = __esm({
    "common/dist/esm/inference-session.js"() {
      "use strict";
      init_inference_session_impl();
      InferenceSession2 = InferenceSession;
    }
  });

  // common/dist/esm/tensor-conversion.js
  var init_tensor_conversion = __esm({
    "common/dist/esm/tensor-conversion.js"() {
      "use strict";
    }
  });

  // common/dist/esm/tensor-factory.js
  var init_tensor_factory = __esm({
    "common/dist/esm/tensor-factory.js"() {
      "use strict";
    }
  });

  // common/dist/esm/onnx-model.js
  var init_onnx_model = __esm({
    "common/dist/esm/onnx-model.js"() {
      "use strict";
    }
  });

  // common/dist/esm/onnx-value.js
  var init_onnx_value = __esm({
    "common/dist/esm/onnx-value.js"() {
      "use strict";
    }
  });

  // common/dist/esm/training-session-impl.js
  var noBackendErrMsg, TrainingSession;
  var init_training_session_impl = __esm({
    "common/dist/esm/training-session-impl.js"() {
      "use strict";
      init_backend_impl();
      init_tensor();
      noBackendErrMsg = "Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.";
      TrainingSession = class _TrainingSession {
        constructor(handler, hasOptimizerModel, hasEvalModel) {
          this.handler = handler;
          this.hasOptimizerModel = hasOptimizerModel;
          this.hasEvalModel = hasEvalModel;
        }
        get trainingInputNames() {
          return this.handler.inputNames;
        }
        get trainingOutputNames() {
          return this.handler.outputNames;
        }
        get evalInputNames() {
          if (this.hasEvalModel) {
            return this.handler.evalInputNames;
          } else {
            throw new Error("This training session has no evalModel loaded.");
          }
        }
        get evalOutputNames() {
          if (this.hasEvalModel) {
            return this.handler.evalOutputNames;
          } else {
            throw new Error("This training session has no evalModel loaded.");
          }
        }
        static async create(trainingOptions, sessionOptions) {
          const evalModel = trainingOptions.evalModel || "";
          const optimizerModel = trainingOptions.optimizerModel || "";
          const options = sessionOptions || {};
          const [backend2, optionsWithValidatedEPs] = await resolveBackendAndExecutionProviders(options);
          if (backend2.createTrainingSessionHandler) {
            const handler = await backend2.createTrainingSessionHandler(trainingOptions.checkpointState, trainingOptions.trainModel, evalModel, optimizerModel, optionsWithValidatedEPs);
            return new _TrainingSession(handler, !!trainingOptions.optimizerModel, !!trainingOptions.evalModel);
          } else {
            throw new Error(noBackendErrMsg);
          }
        }
        /**
         * Helper function for runTrainStep and future runStep methods that handles the type-narrowing conversion from
         * the given parameters to SessionHandler.FetchesType and RunOptions.
         *
         * @param inputNames the feeds object is checked that they contain all input names in the provided list of input
         * names.
         * @param outputNames the fetches object is checked that their keys match up with valid names in the list of output
         * names.
         * @param feeds the required input
         * @param arg1 narrowed & converted into the SessionHandler.FetchesType or RunOptions object
         * @param arg2 optional RunOptions object.
         * @returns
         */
        typeNarrowingForRunStep(inputNames, outputNames, feeds, arg1, arg2) {
          const fetches = {};
          let options = {};
          if (typeof feeds !== "object" || feeds === null || feeds instanceof Tensor2 || Array.isArray(feeds)) {
            throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");
          }
          let isFetchesEmpty = true;
          if (typeof arg1 === "object") {
            if (arg1 === null) {
              throw new TypeError("Unexpected argument[1]: cannot be null.");
            }
            if (arg1 instanceof Tensor2) {
              throw new TypeError("'fetches' cannot be a Tensor");
            }
            if (Array.isArray(arg1)) {
              if (arg1.length === 0) {
                throw new TypeError("'fetches' cannot be an empty array.");
              }
              isFetchesEmpty = false;
              for (const name2 of arg1) {
                if (typeof name2 !== "string") {
                  throw new TypeError("'fetches' must be a string array or an object.");
                }
                if (outputNames.indexOf(name2) === -1) {
                  throw new RangeError(`'fetches' contains invalid output name: ${name2}.`);
                }
                fetches[name2] = null;
              }
              if (typeof arg2 === "object" && arg2 !== null) {
                options = arg2;
              } else if (typeof arg2 !== "undefined") {
                throw new TypeError("'options' must be an object.");
              }
            } else {
              let isFetches = false;
              const arg1Keys = Object.getOwnPropertyNames(arg1);
              for (const name2 of outputNames) {
                if (arg1Keys.indexOf(name2) !== -1) {
                  const v = arg1[name2];
                  if (v === null || v instanceof Tensor2) {
                    isFetches = true;
                    isFetchesEmpty = false;
                    fetches[name2] = v;
                  }
                }
              }
              if (isFetches) {
                if (typeof arg2 === "object" && arg2 !== null) {
                  options = arg2;
                } else if (typeof arg2 !== "undefined") {
                  throw new TypeError("'options' must be an object.");
                }
              } else {
                options = arg1;
              }
            }
          } else if (typeof arg1 !== "undefined") {
            throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");
          }
          for (const name2 of inputNames) {
            if (typeof feeds[name2] === "undefined") {
              throw new Error(`input '${name2}' is missing in 'feeds'.`);
            }
          }
          if (isFetchesEmpty) {
            for (const name2 of outputNames) {
              fetches[name2] = null;
            }
          }
          return [fetches, options];
        }
        /**
         * Helper method for runTrainStep and any other runStep methods. Takes the ReturnType result from the SessionHandler
         * and changes it into a map of Tensors.
         *
         * @param results
         * @returns
         */
        convertHandlerReturnTypeToMapOfTensors(results) {
          const returnValue = {};
          for (const key in results) {
            if (Object.hasOwnProperty.call(results, key)) {
              const result = results[key];
              if (result instanceof Tensor2) {
                returnValue[key] = result;
              } else {
                returnValue[key] = new Tensor2(result.type, result.data, result.dims);
              }
            }
          }
          return returnValue;
        }
        async lazyResetGrad() {
          await this.handler.lazyResetGrad();
        }
        async runTrainStep(feeds, arg1, arg2) {
          const [fetches, options] = this.typeNarrowingForRunStep(this.trainingInputNames, this.trainingOutputNames, feeds, arg1, arg2);
          const results = await this.handler.runTrainStep(feeds, fetches, options);
          return this.convertHandlerReturnTypeToMapOfTensors(results);
        }
        async runOptimizerStep(options) {
          if (this.hasOptimizerModel) {
            await this.handler.runOptimizerStep(options || {});
          } else {
            throw new Error("This TrainingSession has no OptimizerModel loaded.");
          }
        }
        async runEvalStep(feeds, arg1, arg2) {
          if (this.hasEvalModel) {
            const [fetches, options] = this.typeNarrowingForRunStep(this.evalInputNames, this.evalOutputNames, feeds, arg1, arg2);
            const results = await this.handler.runEvalStep(feeds, fetches, options);
            return this.convertHandlerReturnTypeToMapOfTensors(results);
          } else {
            throw new Error("This TrainingSession has no EvalModel loaded.");
          }
        }
        async getParametersSize(trainableOnly = true) {
          return this.handler.getParametersSize(trainableOnly);
        }
        async loadParametersBuffer(array, trainableOnly = true) {
          const paramsSize = await this.getParametersSize(trainableOnly);
          if (array.length !== 4 * paramsSize) {
            throw new Error("Size of the buffer passed into loadParametersBuffer must match the number of parameters in the model. Please use getParametersSize method to check.");
          }
          return this.handler.loadParametersBuffer(array, trainableOnly);
        }
        async getContiguousParameters(trainableOnly = true) {
          return this.handler.getContiguousParameters(trainableOnly);
        }
        async release() {
          return this.handler.dispose();
        }
      };
    }
  });

  // common/dist/esm/training-session.js
  var TrainingSession2;
  var init_training_session = __esm({
    "common/dist/esm/training-session.js"() {
      "use strict";
      init_training_session_impl();
      TrainingSession2 = TrainingSession;
    }
  });

  // common/dist/esm/index.js
  var esm_exports = {};
  __export(esm_exports, {
    InferenceSession: () => InferenceSession2,
    TRACE: () => TRACE,
    TRACE_FUNC_BEGIN: () => TRACE_FUNC_BEGIN,
    TRACE_FUNC_END: () => TRACE_FUNC_END,
    Tensor: () => Tensor2,
    TrainingSession: () => TrainingSession2,
    env: () => env2,
    registerBackend: () => registerBackend
  });
  var init_esm = __esm({
    "common/dist/esm/index.js"() {
      "use strict";
      init_backend();
      init_env();
      init_inference_session();
      init_tensor();
      init_tensor_conversion();
      init_tensor_factory();
      init_trace();
      init_onnx_model();
      init_onnx_value();
      init_training_session();
    }
  });

  // web/lib/onnxjs/instrument.ts
  function log(arg0, arg1, arg2, arg3) {
    if (arg1 === void 0) {
      return createCategorizedLogger(arg0);
    } else if (arg2 === void 0) {
      logInternal(arg0, arg1, 1);
    } else if (typeof arg2 === "number" && arg3 === void 0) {
      logInternal(arg0, arg1, arg2);
    } else if (typeof arg2 === "string" && arg3 === void 0) {
      logInternal(arg0, arg2, 1, arg1);
    } else if (typeof arg2 === "string" && typeof arg3 === "number") {
      logInternal(arg0, arg2, arg3, arg1);
    } else {
      throw new TypeError("input is valid");
    }
  }
  function createCategorizedLogger(category) {
    return {
      verbose: log.verbose.bind(null, category),
      info: log.info.bind(null, category),
      warning: log.warning.bind(null, category),
      error: log.error.bind(null, category),
      fatal: log.fatal.bind(null, category)
    };
  }
  function logInternal(severity, content, _stack, category) {
    const config = LOGGER_CONFIG_MAP[category || ""] || LOGGER_CONFIG_MAP[""];
    if (SEVERITY_VALUE[severity] < SEVERITY_VALUE[config.minimalSeverity]) {
      return;
    }
    if (config.logDateTime) {
      content = `${(/* @__PURE__ */ new Date()).toISOString()}|${content}`;
    }
    if (config.logSourceLocation) {
    }
    LOGGER_PROVIDER_MAP[config.provider].log(severity, content, category);
  }
  var NoOpLoggerProvider, ConsoleLoggerProvider, SEVERITY_VALUE, LOGGER_PROVIDER_MAP, LOGGER_DEFAULT_CONFIG, LOGGER_CONFIG_MAP, Logger, Event, EventRecord, Profiler, now;
  var init_instrument = __esm({
    "web/lib/onnxjs/instrument.ts"() {
      "use strict";
      NoOpLoggerProvider = class {
        log(_severity, _content, _category) {
        }
      };
      ConsoleLoggerProvider = class {
        log(severity, content, category) {
          console.log(`${this.color(severity)} ${category ? "\x1B[35m" + category + "\x1B[0m " : ""}${content}`);
        }
        color(severity) {
          switch (severity) {
            case "verbose":
              return "\x1B[34;40mv\x1B[0m";
            case "info":
              return "\x1B[32mi\x1B[0m";
            case "warning":
              return "\x1B[30;43mw\x1B[0m";
            case "error":
              return "\x1B[31;40me\x1B[0m";
            case "fatal":
              return "\x1B[101mf\x1B[0m";
            default:
              throw new Error(`unsupported severity: ${severity}`);
          }
        }
      };
      SEVERITY_VALUE = {
        verbose: 1e3,
        info: 2e3,
        warning: 4e3,
        error: 5e3,
        fatal: 6e3
      };
      LOGGER_PROVIDER_MAP = {
        ["none"]: new NoOpLoggerProvider(),
        ["console"]: new ConsoleLoggerProvider()
      };
      LOGGER_DEFAULT_CONFIG = {
        provider: "console",
        minimalSeverity: "warning",
        logDateTime: true,
        logSourceLocation: false
      };
      LOGGER_CONFIG_MAP = {
        [""]: LOGGER_DEFAULT_CONFIG
      };
      ((log3) => {
        function verbose(arg0, arg1) {
          log3("verbose", arg0, arg1);
        }
        log3.verbose = verbose;
        function info(arg0, arg1) {
          log3("info", arg0, arg1);
        }
        log3.info = info;
        function warning(arg0, arg1) {
          log3("warning", arg0, arg1);
        }
        log3.warning = warning;
        function error(arg0, arg1) {
          log3("error", arg0, arg1);
        }
        log3.error = error;
        function fatal(arg0, arg1) {
          log3("fatal", arg0, arg1);
        }
        log3.fatal = fatal;
        function reset(config) {
          LOGGER_CONFIG_MAP = {};
          set("", config || {});
        }
        log3.reset = reset;
        function set(category, config) {
          if (category === "*") {
            reset(config);
          } else {
            const previousConfig = LOGGER_CONFIG_MAP[category] || LOGGER_DEFAULT_CONFIG;
            LOGGER_CONFIG_MAP[category] = {
              provider: config.provider || previousConfig.provider,
              minimalSeverity: config.minimalSeverity || previousConfig.minimalSeverity,
              logDateTime: config.logDateTime === void 0 ? previousConfig.logDateTime : config.logDateTime,
              logSourceLocation: config.logSourceLocation === void 0 ? previousConfig.logSourceLocation : config.logSourceLocation
            };
          }
        }
        log3.set = set;
        function setWithEnv(env3) {
          const config = {};
          if (env3.logLevel) {
            config.minimalSeverity = env3.logLevel;
          }
          set("", config);
        }
        log3.setWithEnv = setWithEnv;
      })(log || (log = {}));
      Logger = log;
      Event = class {
        constructor(category, name2, startTime, endCallback, timer, ctx) {
          this.category = category;
          this.name = name2;
          this.startTime = startTime;
          this.endCallback = endCallback;
          this.timer = timer;
          this.ctx = ctx;
        }
        async end() {
          return this.endCallback(this);
        }
        async checkTimer() {
          if (this.ctx === void 0 || this.timer === void 0) {
            throw new Error("No webgl timer found");
          } else {
            this.ctx.endTimer();
            return this.ctx.waitForQueryAndGetTime(this.timer);
          }
        }
      };
      EventRecord = class {
        constructor(category, name2, startTime, endTime) {
          this.category = category;
          this.name = name2;
          this.startTime = startTime;
          this.endTime = endTime;
        }
      };
      Profiler = class {
        constructor(maxNumberEvents, flushBatchSize, flushIntervalInMilliseconds) {
          this._started = false;
          this._flushPointer = 0;
          this._started = false;
          this._maxNumberEvents = maxNumberEvents === void 0 ? 1e4 : maxNumberEvents;
          this._flushBatchSize = flushBatchSize === void 0 ? 10 : flushBatchSize;
          this._flushIntervalInMilliseconds = flushIntervalInMilliseconds === void 0 ? 5e3 : flushIntervalInMilliseconds;
        }
        static create(config) {
          if (config === void 0) {
            return new this();
          }
          return new this(config.maxNumberEvents, config.flushBatchSize, config.flushIntervalInMilliseconds);
        }
        // start profiling
        start() {
          this._started = true;
          this._timingEvents = [];
          this._flushTime = now();
          this._flushPointer = 0;
        }
        // stop profiling
        stop() {
          this._started = false;
          for (; this._flushPointer < this._timingEvents.length; this._flushPointer++) {
            this.logOneEvent(this._timingEvents[this._flushPointer]);
          }
        }
        event(category, name2, func, ctx) {
          const event = this._started ? this.begin(category, name2, ctx) : void 0;
          let isPromise = false;
          const res = func();
          if (res && typeof res.then === "function") {
            isPromise = true;
            return new Promise((resolve, reject) => {
              res.then(
                async (value) => {
                  if (event) {
                    await event.end();
                  }
                  resolve(value);
                },
                async (reason) => {
                  if (event) {
                    await event.end();
                  }
                  reject(reason);
                }
              );
            });
          }
          if (!isPromise && event) {
            const eventRes = event.end();
            if (eventRes && typeof eventRes.then === "function") {
              return new Promise((resolve, reject) => {
                eventRes.then(
                  () => {
                    resolve(res);
                  },
                  (reason) => {
                    reject(reason);
                  }
                );
              });
            }
          }
          return res;
        }
        // begin an event
        begin(category, name2, ctx) {
          if (!this._started) {
            throw new Error("profiler is not started yet");
          }
          if (ctx === void 0) {
            const startTime = now();
            this.flush(startTime);
            return new Event(category, name2, startTime, (e) => this.endSync(e));
          } else {
            const timer = ctx.beginTimer();
            return new Event(category, name2, 0, async (e) => this.end(e), timer, ctx);
          }
        }
        // end the specific event
        async end(event) {
          const endTime = await event.checkTimer();
          if (this._timingEvents.length < this._maxNumberEvents) {
            this._timingEvents.push(new EventRecord(event.category, event.name, event.startTime, endTime));
            this.flush(endTime);
          }
        }
        endSync(event) {
          const endTime = now();
          if (this._timingEvents.length < this._maxNumberEvents) {
            this._timingEvents.push(new EventRecord(event.category, event.name, event.startTime, endTime));
            this.flush(endTime);
          }
        }
        logOneEvent(event) {
          Logger.verbose(
            `Profiler.${event.category}`,
            `${(event.endTime - event.startTime).toFixed(2)}ms on event '${event.name}' at ${event.endTime.toFixed(2)}`
          );
        }
        flush(currentTime) {
          if (this._timingEvents.length - this._flushPointer >= this._flushBatchSize || currentTime - this._flushTime >= this._flushIntervalInMilliseconds) {
            for (const previousPointer = this._flushPointer; this._flushPointer < previousPointer + this._flushBatchSize && this._flushPointer < this._timingEvents.length; this._flushPointer++) {
              this.logOneEvent(this._timingEvents[this._flushPointer]);
            }
            this._flushTime = now();
          }
        }
        get started() {
          return this._started;
        }
      };
      now = typeof performance !== "undefined" && performance.now ? () => performance.now() : Date.now;
    }
  });

  // web/lib/onnxjs/opset.ts
  function resolveOperator(node, opsets, rules) {
    for (const rule of rules) {
      const opType = rule[0];
      const domain = rule[1];
      const versionSelector = rule[2];
      const opImpl = rule[3];
      const opInit = rule[4];
      if (node.opType === opType) {
        for (const opset of opsets) {
          if (opset.domain === domain || opset.domain === "ai.onnx" && domain === "") {
            if (matchSelector(opset.version, versionSelector)) {
              return { opImpl, opInit };
            }
          }
        }
      }
    }
    throw new TypeError(
      `cannot resolve operator '${node.opType}' with opsets: ${opsets.map((set) => `${set.domain || "ai.onnx"} v${set.version}`).join(", ")}`
    );
  }
  function matchSelector(version3, selector) {
    if (selector.endsWith("+")) {
      const rangeStart = Number.parseInt(selector.substring(0, selector.length - 1), 10);
      return !isNaN(rangeStart) && rangeStart <= version3;
    } else if (selector.split("-").length === 2) {
      const pair = selector.split("-");
      const rangeStart = Number.parseInt(pair[0], 10);
      const rangeEnd = Number.parseInt(pair[1], 10);
      return !isNaN(rangeStart) && !isNaN(rangeEnd) && rangeStart <= version3 && version3 <= rangeEnd;
    } else {
      return Number.parseInt(selector, 10) === version3;
    }
  }
  var init_opset = __esm({
    "web/lib/onnxjs/opset.ts"() {
      "use strict";
    }
  });

  // web/node_modules/guid-typescript/dist/guid.js
  var require_guid = __commonJS({
    "web/node_modules/guid-typescript/dist/guid.js"(exports2) {
      "use strict";
      exports2.__esModule = true;
      var Guid2 = (
        /** @class */
        function() {
          function Guid3(guid) {
            if (!guid) {
              throw new TypeError("Invalid argument; `value` has no value.");
            }
            this.value = Guid3.EMPTY;
            if (guid && Guid3.isGuid(guid)) {
              this.value = guid;
            }
          }
          Guid3.isGuid = function(guid) {
            var value = guid.toString();
            return guid && (guid instanceof Guid3 || Guid3.validator.test(value));
          };
          Guid3.create = function() {
            return new Guid3([Guid3.gen(2), Guid3.gen(1), Guid3.gen(1), Guid3.gen(1), Guid3.gen(3)].join("-"));
          };
          Guid3.createEmpty = function() {
            return new Guid3("emptyguid");
          };
          Guid3.parse = function(guid) {
            return new Guid3(guid);
          };
          Guid3.raw = function() {
            return [Guid3.gen(2), Guid3.gen(1), Guid3.gen(1), Guid3.gen(1), Guid3.gen(3)].join("-");
          };
          Guid3.gen = function(count) {
            var out = "";
            for (var i = 0; i < count; i++) {
              out += ((1 + Math.random()) * 65536 | 0).toString(16).substring(1);
            }
            return out;
          };
          Guid3.prototype.equals = function(other) {
            return Guid3.isGuid(other) && this.value === other.toString();
          };
          Guid3.prototype.isEmpty = function() {
            return this.value === Guid3.EMPTY;
          };
          Guid3.prototype.toString = function() {
            return this.value;
          };
          Guid3.prototype.toJSON = function() {
            return {
              value: this.value
            };
          };
          Guid3.validator = new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$", "i");
          Guid3.EMPTY = "00000000-0000-0000-0000-000000000000";
          return Guid3;
        }()
      );
      exports2.Guid = Guid2;
    }
  });

  // web/node_modules/long/index.js
  function Long(low, high, unsigned) {
    this.low = low | 0;
    this.high = high | 0;
    this.unsigned = !!unsigned;
  }
  function isLong(obj) {
    return (obj && obj["__isLong__"]) === true;
  }
  function ctz32(value) {
    var c = Math.clz32(value & -value);
    return value ? 31 - c : c;
  }
  function fromInt(value, unsigned) {
    var obj, cachedObj, cache2;
    if (unsigned) {
      value >>>= 0;
      if (cache2 = 0 <= value && value < 256) {
        cachedObj = UINT_CACHE[value];
        if (cachedObj)
          return cachedObj;
      }
      obj = fromBits(value, 0, true);
      if (cache2)
        UINT_CACHE[value] = obj;
      return obj;
    } else {
      value |= 0;
      if (cache2 = -128 <= value && value < 128) {
        cachedObj = INT_CACHE[value];
        if (cachedObj)
          return cachedObj;
      }
      obj = fromBits(value, value < 0 ? -1 : 0, false);
      if (cache2)
        INT_CACHE[value] = obj;
      return obj;
    }
  }
  function fromNumber(value, unsigned) {
    if (isNaN(value))
      return unsigned ? UZERO : ZERO;
    if (unsigned) {
      if (value < 0)
        return UZERO;
      if (value >= TWO_PWR_64_DBL)
        return MAX_UNSIGNED_VALUE;
    } else {
      if (value <= -TWO_PWR_63_DBL)
        return MIN_VALUE;
      if (value + 1 >= TWO_PWR_63_DBL)
        return MAX_VALUE;
    }
    if (value < 0)
      return fromNumber(-value, unsigned).neg();
    return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
  }
  function fromBits(lowBits, highBits, unsigned) {
    return new Long(lowBits, highBits, unsigned);
  }
  function fromString(str, unsigned, radix) {
    if (str.length === 0)
      throw Error("empty string");
    if (typeof unsigned === "number") {
      radix = unsigned;
      unsigned = false;
    } else {
      unsigned = !!unsigned;
    }
    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
      return unsigned ? UZERO : ZERO;
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
      throw RangeError("radix");
    var p;
    if ((p = str.indexOf("-")) > 0)
      throw Error("interior hyphen");
    else if (p === 0) {
      return fromString(str.substring(1), unsigned, radix).neg();
    }
    var radixToPower = fromNumber(pow_dbl(radix, 8));
    var result = ZERO;
    for (var i = 0; i < str.length; i += 8) {
      var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
      if (size < 8) {
        var power = fromNumber(pow_dbl(radix, size));
        result = result.mul(power).add(fromNumber(value));
      } else {
        result = result.mul(radixToPower);
        result = result.add(fromNumber(value));
      }
    }
    result.unsigned = unsigned;
    return result;
  }
  function fromValue(val, unsigned) {
    if (typeof val === "number")
      return fromNumber(val, unsigned);
    if (typeof val === "string")
      return fromString(val, unsigned);
    return fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
  }
  var wasm, INT_CACHE, UINT_CACHE, pow_dbl, TWO_PWR_16_DBL, TWO_PWR_24_DBL, TWO_PWR_32_DBL, TWO_PWR_64_DBL, TWO_PWR_63_DBL, TWO_PWR_24, ZERO, UZERO, ONE, UONE, NEG_ONE, MAX_VALUE, MAX_UNSIGNED_VALUE, MIN_VALUE, LongPrototype, long_default;
  var init_long = __esm({
    "web/node_modules/long/index.js"() {
      wasm = null;
      try {
        wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
          0,
          97,
          115,
          109,
          1,
          0,
          0,
          0,
          1,
          13,
          2,
          96,
          0,
          1,
          127,
          96,
          4,
          127,
          127,
          127,
          127,
          1,
          127,
          3,
          7,
          6,
          0,
          1,
          1,
          1,
          1,
          1,
          6,
          6,
          1,
          127,
          1,
          65,
          0,
          11,
          7,
          50,
          6,
          3,
          109,
          117,
          108,
          0,
          1,
          5,
          100,
          105,
          118,
          95,
          115,
          0,
          2,
          5,
          100,
          105,
          118,
          95,
          117,
          0,
          3,
          5,
          114,
          101,
          109,
          95,
          115,
          0,
          4,
          5,
          114,
          101,
          109,
          95,
          117,
          0,
          5,
          8,
          103,
          101,
          116,
          95,
          104,
          105,
          103,
          104,
          0,
          0,
          10,
          191,
          1,
          6,
          4,
          0,
          35,
          0,
          11,
          36,
          1,
          1,
          126,
          32,
          0,
          173,
          32,
          1,
          173,
          66,
          32,
          134,
          132,
          32,
          2,
          173,
          32,
          3,
          173,
          66,
          32,
          134,
          132,
          126,
          34,
          4,
          66,
          32,
          135,
          167,
          36,
          0,
          32,
          4,
          167,
          11,
          36,
          1,
          1,
          126,
          32,
          0,
          173,
          32,
          1,
          173,
          66,
          32,
          134,
          132,
          32,
          2,
          173,
          32,
          3,
          173,
          66,
          32,
          134,
          132,
          127,
          34,
          4,
          66,
          32,
          135,
          167,
          36,
          0,
          32,
          4,
          167,
          11,
          36,
          1,
          1,
          126,
          32,
          0,
          173,
          32,
          1,
          173,
          66,
          32,
          134,
          132,
          32,
          2,
          173,
          32,
          3,
          173,
          66,
          32,
          134,
          132,
          128,
          34,
          4,
          66,
          32,
          135,
          167,
          36,
          0,
          32,
          4,
          167,
          11,
          36,
          1,
          1,
          126,
          32,
          0,
          173,
          32,
          1,
          173,
          66,
          32,
          134,
          132,
          32,
          2,
          173,
          32,
          3,
          173,
          66,
          32,
          134,
          132,
          129,
          34,
          4,
          66,
          32,
          135,
          167,
          36,
          0,
          32,
          4,
          167,
          11,
          36,
          1,
          1,
          126,
          32,
          0,
          173,
          32,
          1,
          173,
          66,
          32,
          134,
          132,
          32,
          2,
          173,
          32,
          3,
          173,
          66,
          32,
          134,
          132,
          130,
          34,
          4,
          66,
          32,
          135,
          167,
          36,
          0,
          32,
          4,
          167,
          11
        ])), {}).exports;
      } catch (e) {
      }
      Long.prototype.__isLong__;
      Object.defineProperty(Long.prototype, "__isLong__", { value: true });
      Long.isLong = isLong;
      INT_CACHE = {};
      UINT_CACHE = {};
      Long.fromInt = fromInt;
      Long.fromNumber = fromNumber;
      Long.fromBits = fromBits;
      pow_dbl = Math.pow;
      Long.fromString = fromString;
      Long.fromValue = fromValue;
      TWO_PWR_16_DBL = 1 << 16;
      TWO_PWR_24_DBL = 1 << 24;
      TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
      TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
      TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
      TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
      ZERO = fromInt(0);
      Long.ZERO = ZERO;
      UZERO = fromInt(0, true);
      Long.UZERO = UZERO;
      ONE = fromInt(1);
      Long.ONE = ONE;
      UONE = fromInt(1, true);
      Long.UONE = UONE;
      NEG_ONE = fromInt(-1);
      Long.NEG_ONE = NEG_ONE;
      MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
      Long.MAX_VALUE = MAX_VALUE;
      MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
      Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
      MIN_VALUE = fromBits(0, 2147483648 | 0, false);
      Long.MIN_VALUE = MIN_VALUE;
      LongPrototype = Long.prototype;
      LongPrototype.toInt = function toInt() {
        return this.unsigned ? this.low >>> 0 : this.low;
      };
      LongPrototype.toNumber = function toNumber() {
        if (this.unsigned)
          return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
      };
      LongPrototype.toString = function toString(radix) {
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
          throw RangeError("radix");
        if (this.isZero())
          return "0";
        if (this.isNegative()) {
          if (this.eq(MIN_VALUE)) {
            var radixLong = fromNumber(radix), div2 = this.div(radixLong), rem1 = div2.mul(radixLong).sub(this);
            return div2.toString(radix) + rem1.toInt().toString(radix);
          } else
            return "-" + this.neg().toString(radix);
        }
        var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
        var result = "";
        while (true) {
          var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
          rem = remDiv;
          if (rem.isZero())
            return digits + result;
          else {
            while (digits.length < 6)
              digits = "0" + digits;
            result = "" + digits + result;
          }
        }
      };
      LongPrototype.getHighBits = function getHighBits() {
        return this.high;
      };
      LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
        return this.high >>> 0;
      };
      LongPrototype.getLowBits = function getLowBits() {
        return this.low;
      };
      LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
        return this.low >>> 0;
      };
      LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
        if (this.isNegative())
          return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
        var val = this.high != 0 ? this.high : this.low;
        for (var bit = 31; bit > 0; bit--)
          if ((val & 1 << bit) != 0)
            break;
        return this.high != 0 ? bit + 33 : bit + 1;
      };
      LongPrototype.isZero = function isZero() {
        return this.high === 0 && this.low === 0;
      };
      LongPrototype.eqz = LongPrototype.isZero;
      LongPrototype.isNegative = function isNegative() {
        return !this.unsigned && this.high < 0;
      };
      LongPrototype.isPositive = function isPositive() {
        return this.unsigned || this.high >= 0;
      };
      LongPrototype.isOdd = function isOdd() {
        return (this.low & 1) === 1;
      };
      LongPrototype.isEven = function isEven() {
        return (this.low & 1) === 0;
      };
      LongPrototype.equals = function equals(other) {
        if (!isLong(other))
          other = fromValue(other);
        if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
          return false;
        return this.high === other.high && this.low === other.low;
      };
      LongPrototype.eq = LongPrototype.equals;
      LongPrototype.notEquals = function notEquals(other) {
        return !this.eq(
          /* validates */
          other
        );
      };
      LongPrototype.neq = LongPrototype.notEquals;
      LongPrototype.ne = LongPrototype.notEquals;
      LongPrototype.lessThan = function lessThan(other) {
        return this.comp(
          /* validates */
          other
        ) < 0;
      };
      LongPrototype.lt = LongPrototype.lessThan;
      LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
        return this.comp(
          /* validates */
          other
        ) <= 0;
      };
      LongPrototype.lte = LongPrototype.lessThanOrEqual;
      LongPrototype.le = LongPrototype.lessThanOrEqual;
      LongPrototype.greaterThan = function greaterThan(other) {
        return this.comp(
          /* validates */
          other
        ) > 0;
      };
      LongPrototype.gt = LongPrototype.greaterThan;
      LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
        return this.comp(
          /* validates */
          other
        ) >= 0;
      };
      LongPrototype.gte = LongPrototype.greaterThanOrEqual;
      LongPrototype.ge = LongPrototype.greaterThanOrEqual;
      LongPrototype.compare = function compare(other) {
        if (!isLong(other))
          other = fromValue(other);
        if (this.eq(other))
          return 0;
        var thisNeg = this.isNegative(), otherNeg = other.isNegative();
        if (thisNeg && !otherNeg)
          return -1;
        if (!thisNeg && otherNeg)
          return 1;
        if (!this.unsigned)
          return this.sub(other).isNegative() ? -1 : 1;
        return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
      };
      LongPrototype.comp = LongPrototype.compare;
      LongPrototype.negate = function negate() {
        if (!this.unsigned && this.eq(MIN_VALUE))
          return MIN_VALUE;
        return this.not().add(ONE);
      };
      LongPrototype.neg = LongPrototype.negate;
      LongPrototype.add = function add(addend) {
        if (!isLong(addend))
          addend = fromValue(addend);
        var a48 = this.high >>> 16;
        var a32 = this.high & 65535;
        var a16 = this.low >>> 16;
        var a00 = this.low & 65535;
        var b48 = addend.high >>> 16;
        var b32 = addend.high & 65535;
        var b16 = addend.low >>> 16;
        var b00 = addend.low & 65535;
        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 + b00;
        c16 += c00 >>> 16;
        c00 &= 65535;
        c16 += a16 + b16;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c32 += a32 + b32;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c48 += a48 + b48;
        c48 &= 65535;
        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
      };
      LongPrototype.subtract = function subtract(subtrahend) {
        if (!isLong(subtrahend))
          subtrahend = fromValue(subtrahend);
        return this.add(subtrahend.neg());
      };
      LongPrototype.sub = LongPrototype.subtract;
      LongPrototype.multiply = function multiply(multiplier) {
        if (this.isZero())
          return this;
        if (!isLong(multiplier))
          multiplier = fromValue(multiplier);
        if (wasm) {
          var low = wasm["mul"](
            this.low,
            this.high,
            multiplier.low,
            multiplier.high
          );
          return fromBits(low, wasm["get_high"](), this.unsigned);
        }
        if (multiplier.isZero())
          return this.unsigned ? UZERO : ZERO;
        if (this.eq(MIN_VALUE))
          return multiplier.isOdd() ? MIN_VALUE : ZERO;
        if (multiplier.eq(MIN_VALUE))
          return this.isOdd() ? MIN_VALUE : ZERO;
        if (this.isNegative()) {
          if (multiplier.isNegative())
            return this.neg().mul(multiplier.neg());
          else
            return this.neg().mul(multiplier).neg();
        } else if (multiplier.isNegative())
          return this.mul(multiplier.neg()).neg();
        if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
          return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
        var a48 = this.high >>> 16;
        var a32 = this.high & 65535;
        var a16 = this.low >>> 16;
        var a00 = this.low & 65535;
        var b48 = multiplier.high >>> 16;
        var b32 = multiplier.high & 65535;
        var b16 = multiplier.low >>> 16;
        var b00 = multiplier.low & 65535;
        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 * b00;
        c16 += c00 >>> 16;
        c00 &= 65535;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c16 += a00 * b16;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c32 += a32 * b00;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c32 += a00 * b32;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
        c48 &= 65535;
        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
      };
      LongPrototype.mul = LongPrototype.multiply;
      LongPrototype.divide = function divide(divisor) {
        if (!isLong(divisor))
          divisor = fromValue(divisor);
        if (divisor.isZero())
          throw Error("division by zero");
        if (wasm) {
          if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
            return this;
          }
          var low = (this.unsigned ? wasm["div_u"] : wasm["div_s"])(
            this.low,
            this.high,
            divisor.low,
            divisor.high
          );
          return fromBits(low, wasm["get_high"](), this.unsigned);
        }
        if (this.isZero())
          return this.unsigned ? UZERO : ZERO;
        var approx, rem, res;
        if (!this.unsigned) {
          if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
              return MIN_VALUE;
            else if (divisor.eq(MIN_VALUE))
              return ONE;
            else {
              var halfThis = this.shr(1);
              approx = halfThis.div(divisor).shl(1);
              if (approx.eq(ZERO)) {
                return divisor.isNegative() ? ONE : NEG_ONE;
              } else {
                rem = this.sub(divisor.mul(approx));
                res = approx.add(rem.div(divisor));
                return res;
              }
            }
          } else if (divisor.eq(MIN_VALUE))
            return this.unsigned ? UZERO : ZERO;
          if (this.isNegative()) {
            if (divisor.isNegative())
              return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
          } else if (divisor.isNegative())
            return this.div(divisor.neg()).neg();
          res = ZERO;
        } else {
          if (!divisor.unsigned)
            divisor = divisor.toUnsigned();
          if (divisor.gt(this))
            return UZERO;
          if (divisor.gt(this.shru(1)))
            return UONE;
          res = UZERO;
        }
        rem = this;
        while (rem.gte(divisor)) {
          approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
          var log22 = Math.ceil(Math.log(approx) / Math.LN2), delta = log22 <= 48 ? 1 : pow_dbl(2, log22 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
          while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
          }
          if (approxRes.isZero())
            approxRes = ONE;
          res = res.add(approxRes);
          rem = rem.sub(approxRem);
        }
        return res;
      };
      LongPrototype.div = LongPrototype.divide;
      LongPrototype.modulo = function modulo(divisor) {
        if (!isLong(divisor))
          divisor = fromValue(divisor);
        if (wasm) {
          var low = (this.unsigned ? wasm["rem_u"] : wasm["rem_s"])(
            this.low,
            this.high,
            divisor.low,
            divisor.high
          );
          return fromBits(low, wasm["get_high"](), this.unsigned);
        }
        return this.sub(this.div(divisor).mul(divisor));
      };
      LongPrototype.mod = LongPrototype.modulo;
      LongPrototype.rem = LongPrototype.modulo;
      LongPrototype.not = function not() {
        return fromBits(~this.low, ~this.high, this.unsigned);
      };
      LongPrototype.countLeadingZeros = function countLeadingZeros() {
        return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
      };
      LongPrototype.clz = LongPrototype.countLeadingZeros;
      LongPrototype.countTrailingZeros = function countTrailingZeros() {
        return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
      };
      LongPrototype.ctz = LongPrototype.countTrailingZeros;
      LongPrototype.and = function and(other) {
        if (!isLong(other))
          other = fromValue(other);
        return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
      };
      LongPrototype.or = function or(other) {
        if (!isLong(other))
          other = fromValue(other);
        return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
      };
      LongPrototype.xor = function xor(other) {
        if (!isLong(other))
          other = fromValue(other);
        return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
      };
      LongPrototype.shiftLeft = function shiftLeft(numBits) {
        if (isLong(numBits))
          numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
          return this;
        else if (numBits < 32)
          return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
        else
          return fromBits(0, this.low << numBits - 32, this.unsigned);
      };
      LongPrototype.shl = LongPrototype.shiftLeft;
      LongPrototype.shiftRight = function shiftRight(numBits) {
        if (isLong(numBits))
          numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
          return this;
        else if (numBits < 32)
          return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
        else
          return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
      };
      LongPrototype.shr = LongPrototype.shiftRight;
      LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
        if (isLong(numBits))
          numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
          return this;
        if (numBits < 32)
          return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >>> numBits, this.unsigned);
        if (numBits === 32)
          return fromBits(this.high, 0, this.unsigned);
        return fromBits(this.high >>> numBits - 32, 0, this.unsigned);
      };
      LongPrototype.shru = LongPrototype.shiftRightUnsigned;
      LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
      LongPrototype.rotateLeft = function rotateLeft(numBits) {
        var b;
        if (isLong(numBits))
          numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
          return this;
        if (numBits === 32)
          return fromBits(this.high, this.low, this.unsigned);
        if (numBits < 32) {
          b = 32 - numBits;
          return fromBits(this.low << numBits | this.high >>> b, this.high << numBits | this.low >>> b, this.unsigned);
        }
        numBits -= 32;
        b = 32 - numBits;
        return fromBits(this.high << numBits | this.low >>> b, this.low << numBits | this.high >>> b, this.unsigned);
      };
      LongPrototype.rotl = LongPrototype.rotateLeft;
      LongPrototype.rotateRight = function rotateRight(numBits) {
        var b;
        if (isLong(numBits))
          numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
          return this;
        if (numBits === 32)
          return fromBits(this.high, this.low, this.unsigned);
        if (numBits < 32) {
          b = 32 - numBits;
          return fromBits(this.high << b | this.low >>> numBits, this.low << b | this.high >>> numBits, this.unsigned);
        }
        numBits -= 32;
        b = 32 - numBits;
        return fromBits(this.low << b | this.high >>> numBits, this.high << b | this.low >>> numBits, this.unsigned);
      };
      LongPrototype.rotr = LongPrototype.rotateRight;
      LongPrototype.toSigned = function toSigned() {
        if (!this.unsigned)
          return this;
        return fromBits(this.low, this.high, false);
      };
      LongPrototype.toUnsigned = function toUnsigned() {
        if (this.unsigned)
          return this;
        return fromBits(this.low, this.high, true);
      };
      LongPrototype.toBytes = function toBytes(le) {
        return le ? this.toBytesLE() : this.toBytesBE();
      };
      LongPrototype.toBytesLE = function toBytesLE() {
        var hi = this.high, lo = this.low;
        return [
          lo & 255,
          lo >>> 8 & 255,
          lo >>> 16 & 255,
          lo >>> 24,
          hi & 255,
          hi >>> 8 & 255,
          hi >>> 16 & 255,
          hi >>> 24
        ];
      };
      LongPrototype.toBytesBE = function toBytesBE() {
        var hi = this.high, lo = this.low;
        return [
          hi >>> 24,
          hi >>> 16 & 255,
          hi >>> 8 & 255,
          hi & 255,
          lo >>> 24,
          lo >>> 16 & 255,
          lo >>> 8 & 255,
          lo & 255
        ];
      };
      Long.fromBytes = function fromBytes(bytes, unsigned, le) {
        return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
      };
      Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
        return new Long(
          bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24,
          bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24,
          unsigned
        );
      };
      Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
        return new Long(
          bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7],
          bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3],
          unsigned
        );
      };
      long_default = Long;
    }
  });

  // web/node_modules/flatbuffers/js/flatbuffers.mjs
  var flatbuffers;
  var init_flatbuffers = __esm({
    "web/node_modules/flatbuffers/js/flatbuffers.mjs"() {
      flatbuffers = {};
      flatbuffers.Offset;
      flatbuffers.Table;
      flatbuffers.SIZEOF_SHORT = 2;
      flatbuffers.SIZEOF_INT = 4;
      flatbuffers.FILE_IDENTIFIER_LENGTH = 4;
      flatbuffers.SIZE_PREFIX_LENGTH = 4;
      flatbuffers.Encoding = {
        UTF8_BYTES: 1,
        UTF16_STRING: 2
      };
      flatbuffers.int32 = new Int32Array(2);
      flatbuffers.float32 = new Float32Array(flatbuffers.int32.buffer);
      flatbuffers.float64 = new Float64Array(flatbuffers.int32.buffer);
      flatbuffers.isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;
      flatbuffers.Long = function(low, high) {
        this.low = low | 0;
        this.high = high | 0;
      };
      flatbuffers.Long.create = function(low, high) {
        return low == 0 && high == 0 ? flatbuffers.Long.ZERO : new flatbuffers.Long(low, high);
      };
      flatbuffers.Long.prototype.toFloat64 = function() {
        return (this.low >>> 0) + this.high * 4294967296;
      };
      flatbuffers.Long.prototype.equals = function(other) {
        return this.low == other.low && this.high == other.high;
      };
      flatbuffers.Long.ZERO = new flatbuffers.Long(0, 0);
      flatbuffers.Builder = function(opt_initial_size) {
        if (!opt_initial_size) {
          var initial_size = 1024;
        } else {
          var initial_size = opt_initial_size;
        }
        this.bb = flatbuffers.ByteBuffer.allocate(initial_size);
        this.space = initial_size;
        this.minalign = 1;
        this.vtable = null;
        this.vtable_in_use = 0;
        this.isNested = false;
        this.object_start = 0;
        this.vtables = [];
        this.vector_num_elems = 0;
        this.force_defaults = false;
      };
      flatbuffers.Builder.prototype.clear = function() {
        this.bb.clear();
        this.space = this.bb.capacity();
        this.minalign = 1;
        this.vtable = null;
        this.vtable_in_use = 0;
        this.isNested = false;
        this.object_start = 0;
        this.vtables = [];
        this.vector_num_elems = 0;
        this.force_defaults = false;
      };
      flatbuffers.Builder.prototype.forceDefaults = function(forceDefaults) {
        this.force_defaults = forceDefaults;
      };
      flatbuffers.Builder.prototype.dataBuffer = function() {
        return this.bb;
      };
      flatbuffers.Builder.prototype.asUint8Array = function() {
        return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());
      };
      flatbuffers.Builder.prototype.prep = function(size, additional_bytes) {
        if (size > this.minalign) {
          this.minalign = size;
        }
        var align_size = ~(this.bb.capacity() - this.space + additional_bytes) + 1 & size - 1;
        while (this.space < align_size + size + additional_bytes) {
          var old_buf_size = this.bb.capacity();
          this.bb = flatbuffers.Builder.growByteBuffer(this.bb);
          this.space += this.bb.capacity() - old_buf_size;
        }
        this.pad(align_size);
      };
      flatbuffers.Builder.prototype.pad = function(byte_size) {
        for (var i = 0; i < byte_size; i++) {
          this.bb.writeInt8(--this.space, 0);
        }
      };
      flatbuffers.Builder.prototype.writeInt8 = function(value) {
        this.bb.writeInt8(this.space -= 1, value);
      };
      flatbuffers.Builder.prototype.writeInt16 = function(value) {
        this.bb.writeInt16(this.space -= 2, value);
      };
      flatbuffers.Builder.prototype.writeInt32 = function(value) {
        this.bb.writeInt32(this.space -= 4, value);
      };
      flatbuffers.Builder.prototype.writeInt64 = function(value) {
        this.bb.writeInt64(this.space -= 8, value);
      };
      flatbuffers.Builder.prototype.writeFloat32 = function(value) {
        this.bb.writeFloat32(this.space -= 4, value);
      };
      flatbuffers.Builder.prototype.writeFloat64 = function(value) {
        this.bb.writeFloat64(this.space -= 8, value);
      };
      flatbuffers.Builder.prototype.addInt8 = function(value) {
        this.prep(1, 0);
        this.writeInt8(value);
      };
      flatbuffers.Builder.prototype.addInt16 = function(value) {
        this.prep(2, 0);
        this.writeInt16(value);
      };
      flatbuffers.Builder.prototype.addInt32 = function(value) {
        this.prep(4, 0);
        this.writeInt32(value);
      };
      flatbuffers.Builder.prototype.addInt64 = function(value) {
        this.prep(8, 0);
        this.writeInt64(value);
      };
      flatbuffers.Builder.prototype.addFloat32 = function(value) {
        this.prep(4, 0);
        this.writeFloat32(value);
      };
      flatbuffers.Builder.prototype.addFloat64 = function(value) {
        this.prep(8, 0);
        this.writeFloat64(value);
      };
      flatbuffers.Builder.prototype.addFieldInt8 = function(voffset, value, defaultValue) {
        if (this.force_defaults || value != defaultValue) {
          this.addInt8(value);
          this.slot(voffset);
        }
      };
      flatbuffers.Builder.prototype.addFieldInt16 = function(voffset, value, defaultValue) {
        if (this.force_defaults || value != defaultValue) {
          this.addInt16(value);
          this.slot(voffset);
        }
      };
      flatbuffers.Builder.prototype.addFieldInt32 = function(voffset, value, defaultValue) {
        if (this.force_defaults || value != defaultValue) {
          this.addInt32(value);
          this.slot(voffset);
        }
      };
      flatbuffers.Builder.prototype.addFieldInt64 = function(voffset, value, defaultValue) {
        if (this.force_defaults || !value.equals(defaultValue)) {
          this.addInt64(value);
          this.slot(voffset);
        }
      };
      flatbuffers.Builder.prototype.addFieldFloat32 = function(voffset, value, defaultValue) {
        if (this.force_defaults || value != defaultValue) {
          this.addFloat32(value);
          this.slot(voffset);
        }
      };
      flatbuffers.Builder.prototype.addFieldFloat64 = function(voffset, value, defaultValue) {
        if (this.force_defaults || value != defaultValue) {
          this.addFloat64(value);
          this.slot(voffset);
        }
      };
      flatbuffers.Builder.prototype.addFieldOffset = function(voffset, value, defaultValue) {
        if (this.force_defaults || value != defaultValue) {
          this.addOffset(value);
          this.slot(voffset);
        }
      };
      flatbuffers.Builder.prototype.addFieldStruct = function(voffset, value, defaultValue) {
        if (value != defaultValue) {
          this.nested(value);
          this.slot(voffset);
        }
      };
      flatbuffers.Builder.prototype.nested = function(obj) {
        if (obj != this.offset()) {
          throw new Error("FlatBuffers: struct must be serialized inline.");
        }
      };
      flatbuffers.Builder.prototype.notNested = function() {
        if (this.isNested) {
          throw new Error("FlatBuffers: object serialization must not be nested.");
        }
      };
      flatbuffers.Builder.prototype.slot = function(voffset) {
        this.vtable[voffset] = this.offset();
      };
      flatbuffers.Builder.prototype.offset = function() {
        return this.bb.capacity() - this.space;
      };
      flatbuffers.Builder.growByteBuffer = function(bb) {
        var old_buf_size = bb.capacity();
        if (old_buf_size & 3221225472) {
          throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");
        }
        var new_buf_size = old_buf_size << 1;
        var nbb = flatbuffers.ByteBuffer.allocate(new_buf_size);
        nbb.setPosition(new_buf_size - old_buf_size);
        nbb.bytes().set(bb.bytes(), new_buf_size - old_buf_size);
        return nbb;
      };
      flatbuffers.Builder.prototype.addOffset = function(offset) {
        this.prep(flatbuffers.SIZEOF_INT, 0);
        this.writeInt32(this.offset() - offset + flatbuffers.SIZEOF_INT);
      };
      flatbuffers.Builder.prototype.startObject = function(numfields) {
        this.notNested();
        if (this.vtable == null) {
          this.vtable = [];
        }
        this.vtable_in_use = numfields;
        for (var i = 0; i < numfields; i++) {
          this.vtable[i] = 0;
        }
        this.isNested = true;
        this.object_start = this.offset();
      };
      flatbuffers.Builder.prototype.endObject = function() {
        if (this.vtable == null || !this.isNested) {
          throw new Error("FlatBuffers: endObject called without startObject");
        }
        this.addInt32(0);
        var vtableloc = this.offset();
        var i = this.vtable_in_use - 1;
        for (; i >= 0 && this.vtable[i] == 0; i--) {
        }
        var trimmed_size = i + 1;
        for (; i >= 0; i--) {
          this.addInt16(this.vtable[i] != 0 ? vtableloc - this.vtable[i] : 0);
        }
        var standard_fields = 2;
        this.addInt16(vtableloc - this.object_start);
        var len = (trimmed_size + standard_fields) * flatbuffers.SIZEOF_SHORT;
        this.addInt16(len);
        var existing_vtable = 0;
        var vt1 = this.space;
        outer_loop:
          for (i = 0; i < this.vtables.length; i++) {
            var vt2 = this.bb.capacity() - this.vtables[i];
            if (len == this.bb.readInt16(vt2)) {
              for (var j = flatbuffers.SIZEOF_SHORT; j < len; j += flatbuffers.SIZEOF_SHORT) {
                if (this.bb.readInt16(vt1 + j) != this.bb.readInt16(vt2 + j)) {
                  continue outer_loop;
                }
              }
              existing_vtable = this.vtables[i];
              break;
            }
          }
        if (existing_vtable) {
          this.space = this.bb.capacity() - vtableloc;
          this.bb.writeInt32(this.space, existing_vtable - vtableloc);
        } else {
          this.vtables.push(this.offset());
          this.bb.writeInt32(this.bb.capacity() - vtableloc, this.offset() - vtableloc);
        }
        this.isNested = false;
        return vtableloc;
      };
      flatbuffers.Builder.prototype.finish = function(root_table, opt_file_identifier, opt_size_prefix) {
        var size_prefix = opt_size_prefix ? flatbuffers.SIZE_PREFIX_LENGTH : 0;
        if (opt_file_identifier) {
          var file_identifier = opt_file_identifier;
          this.prep(this.minalign, flatbuffers.SIZEOF_INT + flatbuffers.FILE_IDENTIFIER_LENGTH + size_prefix);
          if (file_identifier.length != flatbuffers.FILE_IDENTIFIER_LENGTH) {
            throw new Error("FlatBuffers: file identifier must be length " + flatbuffers.FILE_IDENTIFIER_LENGTH);
          }
          for (var i = flatbuffers.FILE_IDENTIFIER_LENGTH - 1; i >= 0; i--) {
            this.writeInt8(file_identifier.charCodeAt(i));
          }
        }
        this.prep(this.minalign, flatbuffers.SIZEOF_INT + size_prefix);
        this.addOffset(root_table);
        if (size_prefix) {
          this.addInt32(this.bb.capacity() - this.space);
        }
        this.bb.setPosition(this.space);
      };
      flatbuffers.Builder.prototype.finishSizePrefixed = function(root_table, opt_file_identifier) {
        this.finish(root_table, opt_file_identifier, true);
      };
      flatbuffers.Builder.prototype.requiredField = function(table, field) {
        var table_start = this.bb.capacity() - table;
        var vtable_start = table_start - this.bb.readInt32(table_start);
        var ok = this.bb.readInt16(vtable_start + field) != 0;
        if (!ok) {
          throw new Error("FlatBuffers: field " + field + " must be set");
        }
      };
      flatbuffers.Builder.prototype.startVector = function(elem_size, num_elems, alignment) {
        this.notNested();
        this.vector_num_elems = num_elems;
        this.prep(flatbuffers.SIZEOF_INT, elem_size * num_elems);
        this.prep(alignment, elem_size * num_elems);
      };
      flatbuffers.Builder.prototype.endVector = function() {
        this.writeInt32(this.vector_num_elems);
        return this.offset();
      };
      flatbuffers.Builder.prototype.createString = function(s) {
        if (s instanceof Uint8Array) {
          var utf8 = s;
        } else {
          var utf8 = [];
          var i = 0;
          while (i < s.length) {
            var codePoint;
            var a = s.charCodeAt(i++);
            if (a < 55296 || a >= 56320) {
              codePoint = a;
            } else {
              var b = s.charCodeAt(i++);
              codePoint = (a << 10) + b + (65536 - (55296 << 10) - 56320);
            }
            if (codePoint < 128) {
              utf8.push(codePoint);
            } else {
              if (codePoint < 2048) {
                utf8.push(codePoint >> 6 & 31 | 192);
              } else {
                if (codePoint < 65536) {
                  utf8.push(codePoint >> 12 & 15 | 224);
                } else {
                  utf8.push(
                    codePoint >> 18 & 7 | 240,
                    codePoint >> 12 & 63 | 128
                  );
                }
                utf8.push(codePoint >> 6 & 63 | 128);
              }
              utf8.push(codePoint & 63 | 128);
            }
          }
        }
        this.addInt8(0);
        this.startVector(1, utf8.length, 1);
        this.bb.setPosition(this.space -= utf8.length);
        for (var i = 0, offset = this.space, bytes = this.bb.bytes(); i < utf8.length; i++) {
          bytes[offset++] = utf8[i];
        }
        return this.endVector();
      };
      flatbuffers.Builder.prototype.createLong = function(low, high) {
        return flatbuffers.Long.create(low, high);
      };
      flatbuffers.ByteBuffer = function(bytes) {
        this.bytes_ = bytes;
        this.position_ = 0;
      };
      flatbuffers.ByteBuffer.allocate = function(byte_size) {
        return new flatbuffers.ByteBuffer(new Uint8Array(byte_size));
      };
      flatbuffers.ByteBuffer.prototype.clear = function() {
        this.position_ = 0;
      };
      flatbuffers.ByteBuffer.prototype.bytes = function() {
        return this.bytes_;
      };
      flatbuffers.ByteBuffer.prototype.position = function() {
        return this.position_;
      };
      flatbuffers.ByteBuffer.prototype.setPosition = function(position) {
        this.position_ = position;
      };
      flatbuffers.ByteBuffer.prototype.capacity = function() {
        return this.bytes_.length;
      };
      flatbuffers.ByteBuffer.prototype.readInt8 = function(offset) {
        return this.readUint8(offset) << 24 >> 24;
      };
      flatbuffers.ByteBuffer.prototype.readUint8 = function(offset) {
        return this.bytes_[offset];
      };
      flatbuffers.ByteBuffer.prototype.readInt16 = function(offset) {
        return this.readUint16(offset) << 16 >> 16;
      };
      flatbuffers.ByteBuffer.prototype.readUint16 = function(offset) {
        return this.bytes_[offset] | this.bytes_[offset + 1] << 8;
      };
      flatbuffers.ByteBuffer.prototype.readInt32 = function(offset) {
        return this.bytes_[offset] | this.bytes_[offset + 1] << 8 | this.bytes_[offset + 2] << 16 | this.bytes_[offset + 3] << 24;
      };
      flatbuffers.ByteBuffer.prototype.readUint32 = function(offset) {
        return this.readInt32(offset) >>> 0;
      };
      flatbuffers.ByteBuffer.prototype.readInt64 = function(offset) {
        return new flatbuffers.Long(this.readInt32(offset), this.readInt32(offset + 4));
      };
      flatbuffers.ByteBuffer.prototype.readUint64 = function(offset) {
        return new flatbuffers.Long(this.readUint32(offset), this.readUint32(offset + 4));
      };
      flatbuffers.ByteBuffer.prototype.readFloat32 = function(offset) {
        flatbuffers.int32[0] = this.readInt32(offset);
        return flatbuffers.float32[0];
      };
      flatbuffers.ByteBuffer.prototype.readFloat64 = function(offset) {
        flatbuffers.int32[flatbuffers.isLittleEndian ? 0 : 1] = this.readInt32(offset);
        flatbuffers.int32[flatbuffers.isLittleEndian ? 1 : 0] = this.readInt32(offset + 4);
        return flatbuffers.float64[0];
      };
      flatbuffers.ByteBuffer.prototype.writeInt8 = function(offset, value) {
        this.bytes_[offset] = /** @type {number} */
        value;
      };
      flatbuffers.ByteBuffer.prototype.writeUint8 = function(offset, value) {
        this.bytes_[offset] = value;
      };
      flatbuffers.ByteBuffer.prototype.writeInt16 = function(offset, value) {
        this.bytes_[offset] = value;
        this.bytes_[offset + 1] = value >> 8;
      };
      flatbuffers.ByteBuffer.prototype.writeUint16 = function(offset, value) {
        this.bytes_[offset] = value;
        this.bytes_[offset + 1] = value >> 8;
      };
      flatbuffers.ByteBuffer.prototype.writeInt32 = function(offset, value) {
        this.bytes_[offset] = value;
        this.bytes_[offset + 1] = value >> 8;
        this.bytes_[offset + 2] = value >> 16;
        this.bytes_[offset + 3] = value >> 24;
      };
      flatbuffers.ByteBuffer.prototype.writeUint32 = function(offset, value) {
        this.bytes_[offset] = value;
        this.bytes_[offset + 1] = value >> 8;
        this.bytes_[offset + 2] = value >> 16;
        this.bytes_[offset + 3] = value >> 24;
      };
      flatbuffers.ByteBuffer.prototype.writeInt64 = function(offset, value) {
        this.writeInt32(offset, value.low);
        this.writeInt32(offset + 4, value.high);
      };
      flatbuffers.ByteBuffer.prototype.writeUint64 = function(offset, value) {
        this.writeUint32(offset, value.low);
        this.writeUint32(offset + 4, value.high);
      };
      flatbuffers.ByteBuffer.prototype.writeFloat32 = function(offset, value) {
        flatbuffers.float32[0] = value;
        this.writeInt32(offset, flatbuffers.int32[0]);
      };
      flatbuffers.ByteBuffer.prototype.writeFloat64 = function(offset, value) {
        flatbuffers.float64[0] = value;
        this.writeInt32(offset, flatbuffers.int32[flatbuffers.isLittleEndian ? 0 : 1]);
        this.writeInt32(offset + 4, flatbuffers.int32[flatbuffers.isLittleEndian ? 1 : 0]);
      };
      flatbuffers.ByteBuffer.prototype.getBufferIdentifier = function() {
        if (this.bytes_.length < this.position_ + flatbuffers.SIZEOF_INT + flatbuffers.FILE_IDENTIFIER_LENGTH) {
          throw new Error(
            "FlatBuffers: ByteBuffer is too short to contain an identifier."
          );
        }
        var result = "";
        for (var i = 0; i < flatbuffers.FILE_IDENTIFIER_LENGTH; i++) {
          result += String.fromCharCode(
            this.readInt8(this.position_ + flatbuffers.SIZEOF_INT + i)
          );
        }
        return result;
      };
      flatbuffers.ByteBuffer.prototype.__offset = function(bb_pos, vtable_offset) {
        var vtable = bb_pos - this.readInt32(bb_pos);
        return vtable_offset < this.readInt16(vtable) ? this.readInt16(vtable + vtable_offset) : 0;
      };
      flatbuffers.ByteBuffer.prototype.__union = function(t, offset) {
        t.bb_pos = offset + this.readInt32(offset);
        t.bb = this;
        return t;
      };
      flatbuffers.ByteBuffer.prototype.__string = function(offset, opt_encoding) {
        offset += this.readInt32(offset);
        var length = this.readInt32(offset);
        var result = "";
        var i = 0;
        offset += flatbuffers.SIZEOF_INT;
        if (opt_encoding === flatbuffers.Encoding.UTF8_BYTES) {
          return this.bytes_.subarray(offset, offset + length);
        }
        while (i < length) {
          var codePoint;
          var a = this.readUint8(offset + i++);
          if (a < 192) {
            codePoint = a;
          } else {
            var b = this.readUint8(offset + i++);
            if (a < 224) {
              codePoint = (a & 31) << 6 | b & 63;
            } else {
              var c = this.readUint8(offset + i++);
              if (a < 240) {
                codePoint = (a & 15) << 12 | (b & 63) << 6 | c & 63;
              } else {
                var d = this.readUint8(offset + i++);
                codePoint = (a & 7) << 18 | (b & 63) << 12 | (c & 63) << 6 | d & 63;
              }
            }
          }
          if (codePoint < 65536) {
            result += String.fromCharCode(codePoint);
          } else {
            codePoint -= 65536;
            result += String.fromCharCode(
              (codePoint >> 10) + 55296,
              (codePoint & (1 << 10) - 1) + 56320
            );
          }
        }
        return result;
      };
      flatbuffers.ByteBuffer.prototype.__indirect = function(offset) {
        return offset + this.readInt32(offset);
      };
      flatbuffers.ByteBuffer.prototype.__vector = function(offset) {
        return offset + this.readInt32(offset) + flatbuffers.SIZEOF_INT;
      };
      flatbuffers.ByteBuffer.prototype.__vector_len = function(offset) {
        return this.readInt32(offset + this.readInt32(offset));
      };
      flatbuffers.ByteBuffer.prototype.__has_identifier = function(ident) {
        if (ident.length != flatbuffers.FILE_IDENTIFIER_LENGTH) {
          throw new Error("FlatBuffers: file identifier must be length " + flatbuffers.FILE_IDENTIFIER_LENGTH);
        }
        for (var i = 0; i < flatbuffers.FILE_IDENTIFIER_LENGTH; i++) {
          if (ident.charCodeAt(i) != this.readInt8(this.position_ + flatbuffers.SIZEOF_INT + i)) {
            return false;
          }
        }
        return true;
      };
      flatbuffers.ByteBuffer.prototype.createLong = function(low, high) {
        return flatbuffers.Long.create(low, high);
      };
    }
  });

  // web/lib/onnxjs/ort-schema/flatbuffers/ort-generated.ts
  var onnxruntime;
  var init_ort_generated = __esm({
    "web/lib/onnxjs/ort-schema/flatbuffers/ort-generated.ts"() {
      "use strict";
      init_flatbuffers();
      ((onnxruntime2) => {
        let experimental;
        ((experimental2) => {
          let fbs;
          ((fbs2) => {
            let AttributeType;
            ((AttributeType2) => {
              AttributeType2[AttributeType2["UNDEFINED"] = 0] = "UNDEFINED";
              AttributeType2[AttributeType2["FLOAT"] = 1] = "FLOAT";
              AttributeType2[AttributeType2["INT"] = 2] = "INT";
              AttributeType2[AttributeType2["STRING"] = 3] = "STRING";
              AttributeType2[AttributeType2["TENSOR"] = 4] = "TENSOR";
              AttributeType2[AttributeType2["GRAPH"] = 5] = "GRAPH";
              AttributeType2[AttributeType2["FLOATS"] = 6] = "FLOATS";
              AttributeType2[AttributeType2["INTS"] = 7] = "INTS";
              AttributeType2[AttributeType2["STRINGS"] = 8] = "STRINGS";
              AttributeType2[AttributeType2["TENSORS"] = 9] = "TENSORS";
              AttributeType2[AttributeType2["GRAPHS"] = 10] = "GRAPHS";
              AttributeType2[AttributeType2["SPARSE_TENSOR"] = 11] = "SPARSE_TENSOR";
              AttributeType2[AttributeType2["SPARSE_TENSORS"] = 12] = "SPARSE_TENSORS";
            })(AttributeType = fbs2.AttributeType || (fbs2.AttributeType = {}));
          })(fbs = experimental2.fbs || (experimental2.fbs = {}));
        })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
      })(onnxruntime || (onnxruntime = {}));
      ((onnxruntime2) => {
        let experimental;
        ((experimental2) => {
          let fbs;
          ((fbs2) => {
            let DimensionValueType;
            ((DimensionValueType2) => {
              DimensionValueType2[DimensionValueType2["UNKNOWN"] = 0] = "UNKNOWN";
              DimensionValueType2[DimensionValueType2["VALUE"] = 1] = "VALUE";
              DimensionValueType2[DimensionValueType2["PARAM"] = 2] = "PARAM";
            })(DimensionValueType = fbs2.DimensionValueType || (fbs2.DimensionValueType = {}));
          })(fbs = experimental2.fbs || (experimental2.fbs = {}));
        })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
      })(onnxruntime || (onnxruntime = {}));
      ((onnxruntime2) => {
        let experimental;
        ((experimental2) => {
          let fbs;
          ((fbs2) => {
            let TensorDataType;
            ((TensorDataType2) => {
              TensorDataType2[TensorDataType2["UNDEFINED"] = 0] = "UNDEFINED";
              TensorDataType2[TensorDataType2["FLOAT"] = 1] = "FLOAT";
              TensorDataType2[TensorDataType2["UINT8"] = 2] = "UINT8";
              TensorDataType2[TensorDataType2["INT8"] = 3] = "INT8";
              TensorDataType2[TensorDataType2["UINT16"] = 4] = "UINT16";
              TensorDataType2[TensorDataType2["INT16"] = 5] = "INT16";
              TensorDataType2[TensorDataType2["INT32"] = 6] = "INT32";
              TensorDataType2[TensorDataType2["INT64"] = 7] = "INT64";
              TensorDataType2[TensorDataType2["STRING"] = 8] = "STRING";
              TensorDataType2[TensorDataType2["BOOL"] = 9] = "BOOL";
              TensorDataType2[TensorDataType2["FLOAT16"] = 10] = "FLOAT16";
              TensorDataType2[TensorDataType2["DOUBLE"] = 11] = "DOUBLE";
              TensorDataType2[TensorDataType2["UINT32"] = 12] = "UINT32";
              TensorDataType2[TensorDataType2["UINT64"] = 13] = "UINT64";
              TensorDataType2[TensorDataType2["COMPLEX64"] = 14] = "COMPLEX64";
              TensorDataType2[TensorDataType2["COMPLEX128"] = 15] = "COMPLEX128";
              TensorDataType2[TensorDataType2["BFLOAT16"] = 16] = "BFLOAT16";
              TensorDataType2[TensorDataType2["FLOAT8E4M3FN"] = 17] = "FLOAT8E4M3FN";
              TensorDataType2[TensorDataType2["FLOAT8E4M3FNUZ"] = 18] = "FLOAT8E4M3FNUZ";
              TensorDataType2[TensorDataType2["FLOAT8E5M2"] = 19] = "FLOAT8E5M2";
              TensorDataType2[TensorDataType2["FLOAT8E5M2FNUZ"] = 20] = "FLOAT8E5M2FNUZ";
            })(TensorDataType = fbs2.TensorDataType || (fbs2.TensorDataType = {}));
          })(fbs = experimental2.fbs || (experimental2.fbs = {}));
        })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
      })(onnxruntime || (onnxruntime = {}));
      ((onnxruntime2) => {
        let experimental;
        ((experimental2) => {
          let fbs;
          ((fbs2) => {
            let NodeType;
            ((NodeType2) => {
              NodeType2[NodeType2["Primitive"] = 0] = "Primitive";
              NodeType2[NodeType2["Fused"] = 1] = "Fused";
            })(NodeType = fbs2.NodeType || (fbs2.NodeType = {}));
          })(fbs = experimental2.fbs || (experimental2.fbs = {}));
        })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
      })(onnxruntime || (onnxruntime = {}));
      ((onnxruntime2) => {
        let experimental;
        ((experimental2) => {
          let fbs;
          ((fbs2) => {
            let TypeInfoValue;
            ((TypeInfoValue2) => {
              TypeInfoValue2[TypeInfoValue2["NONE"] = 0] = "NONE";
              TypeInfoValue2[TypeInfoValue2["tensor_type"] = 1] = "tensor_type";
              TypeInfoValue2[TypeInfoValue2["sequence_type"] = 2] = "sequence_type";
              TypeInfoValue2[TypeInfoValue2["map_type"] = 3] = "map_type";
            })(TypeInfoValue = fbs2.TypeInfoValue || (fbs2.TypeInfoValue = {}));
          })(fbs = experimental2.fbs || (experimental2.fbs = {}));
        })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
      })(onnxruntime || (onnxruntime = {}));
      ((onnxruntime2) => {
        let experimental;
        ((experimental2) => {
          let fbs;
          ((fbs2) => {
            class Shape {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns Shape
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param Shape= obj
               * @returns Shape
               */
              static getRootAsShape(bb, obj) {
                return (obj || new Shape()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param Shape= obj
               * @returns Shape
               */
              static getSizePrefixedRootAsShape(bb, obj) {
                bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
                return (obj || new Shape()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param number index
               * @param onnxruntime.experimental.fbs.Dimension= obj
               * @returns onnxruntime.experimental.fbs.Dimension
               */
              dim(index, obj) {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? (obj || new onnxruntime2.experimental.fbs.Dimension()).__init(
                  this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4),
                  this.bb
                ) : null;
              }
              /**
               * @returns number
               */
              dimLength() {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startShape(builder) {
                builder.startObject(1);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset dimOffset
               */
              static addDim(builder, dimOffset) {
                builder.addFieldOffset(0, dimOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<flatbuffers.Offset> data
               * @returns flatbuffers.Offset
               */
              static createDimVector(builder, data) {
                builder.startVector(4, data.length, 4);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addOffset(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startDimVector(builder, numElems) {
                builder.startVector(4, numElems, 4);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endShape(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createShape(builder, dimOffset) {
                Shape.startShape(builder);
                Shape.addDim(builder, dimOffset);
                return Shape.endShape(builder);
              }
            }
            fbs2.Shape = Shape;
          })(fbs = experimental2.fbs || (experimental2.fbs = {}));
        })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
      })(onnxruntime || (onnxruntime = {}));
      ((onnxruntime2) => {
        let experimental;
        ((experimental2) => {
          let fbs;
          ((fbs2) => {
            class Dimension {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns Dimension
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param Dimension= obj
               * @returns Dimension
               */
              static getRootAsDimension(bb, obj) {
                return (obj || new Dimension()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param Dimension= obj
               * @returns Dimension
               */
              static getSizePrefixedRootAsDimension(bb, obj) {
                bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
                return (obj || new Dimension()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param onnxruntime.experimental.fbs.DimensionValue= obj
               * @returns onnxruntime.experimental.fbs.DimensionValue|null
               */
              value(obj) {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? (obj || new onnxruntime2.experimental.fbs.DimensionValue()).__init(
                  this.bb.__indirect(this.bb_pos + offset),
                  this.bb
                ) : null;
              }
              denotation(optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startDimension(builder) {
                builder.startObject(2);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset valueOffset
               */
              static addValue(builder, valueOffset) {
                builder.addFieldOffset(0, valueOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset denotationOffset
               */
              static addDenotation(builder, denotationOffset) {
                builder.addFieldOffset(1, denotationOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endDimension(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createDimension(builder, valueOffset, denotationOffset) {
                Dimension.startDimension(builder);
                Dimension.addValue(builder, valueOffset);
                Dimension.addDenotation(builder, denotationOffset);
                return Dimension.endDimension(builder);
              }
            }
            fbs2.Dimension = Dimension;
          })(fbs = experimental2.fbs || (experimental2.fbs = {}));
        })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
      })(onnxruntime || (onnxruntime = {}));
      ((onnxruntime2) => {
        let experimental;
        ((experimental2) => {
          let fbs;
          ((fbs2) => {
            class DimensionValue {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns DimensionValue
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param DimensionValue= obj
               * @returns DimensionValue
               */
              static getRootAsDimensionValue(bb, obj) {
                return (obj || new DimensionValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param DimensionValue= obj
               * @returns DimensionValue
               */
              static getSizePrefixedRootAsDimensionValue(bb, obj) {
                bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
                return (obj || new DimensionValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @returns onnxruntime.experimental.fbs.DimensionValueType
               */
              dimType() {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? (
                  /**  */
                  this.bb.readInt8(this.bb_pos + offset)
                ) : 0 /* UNKNOWN */;
              }
              /**
               * @returns flatbuffers.Long
               */
              dimValue() {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);
              }
              dimParam(optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 8);
                return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startDimensionValue(builder) {
                builder.startObject(3);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param onnxruntime.experimental.fbs.DimensionValueType dimType
               */
              static addDimType(builder, dimType) {
                builder.addFieldInt8(0, dimType, 0 /* UNKNOWN */);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Long dimValue
               */
              static addDimValue(builder, dimValue) {
                builder.addFieldInt64(1, dimValue, builder.createLong(0, 0));
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset dimParamOffset
               */
              static addDimParam(builder, dimParamOffset) {
                builder.addFieldOffset(2, dimParamOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endDimensionValue(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createDimensionValue(builder, dimType, dimValue, dimParamOffset) {
                DimensionValue.startDimensionValue(builder);
                DimensionValue.addDimType(builder, dimType);
                DimensionValue.addDimValue(builder, dimValue);
                DimensionValue.addDimParam(builder, dimParamOffset);
                return DimensionValue.endDimensionValue(builder);
              }
            }
            fbs2.DimensionValue = DimensionValue;
          })(fbs = experimental2.fbs || (experimental2.fbs = {}));
        })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
      })(onnxruntime || (onnxruntime = {}));
      ((onnxruntime2) => {
        let experimental;
        ((experimental2) => {
          let fbs;
          ((fbs2) => {
            class TensorTypeAndShape {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns TensorTypeAndShape
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param TensorTypeAndShape= obj
               * @returns TensorTypeAndShape
               */
              static getRootAsTensorTypeAndShape(bb, obj) {
                return (obj || new TensorTypeAndShape()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param TensorTypeAndShape= obj
               * @returns TensorTypeAndShape
               */
              static getSizePrefixedRootAsTensorTypeAndShape(bb, obj) {
                bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
                return (obj || new TensorTypeAndShape()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @returns onnxruntime.experimental.fbs.TensorDataType
               */
              elemType() {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? (
                  /**  */
                  this.bb.readInt32(this.bb_pos + offset)
                ) : 0 /* UNDEFINED */;
              }
              /**
               * @param onnxruntime.experimental.fbs.Shape= obj
               * @returns onnxruntime.experimental.fbs.Shape|null
               */
              shape(obj) {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? (obj || new onnxruntime2.experimental.fbs.Shape()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startTensorTypeAndShape(builder) {
                builder.startObject(2);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param onnxruntime.experimental.fbs.TensorDataType elemType
               */
              static addElemType(builder, elemType) {
                builder.addFieldInt32(0, elemType, 0 /* UNDEFINED */);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset shapeOffset
               */
              static addShape(builder, shapeOffset) {
                builder.addFieldOffset(1, shapeOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endTensorTypeAndShape(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createTensorTypeAndShape(builder, elemType, shapeOffset) {
                TensorTypeAndShape.startTensorTypeAndShape(builder);
                TensorTypeAndShape.addElemType(builder, elemType);
                TensorTypeAndShape.addShape(builder, shapeOffset);
                return TensorTypeAndShape.endTensorTypeAndShape(builder);
              }
            }
            fbs2.TensorTypeAndShape = TensorTypeAndShape;
          })(fbs = experimental2.fbs || (experimental2.fbs = {}));
        })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
      })(onnxruntime || (onnxruntime = {}));
      ((onnxruntime2) => {
        let experimental;
        ((experimental2) => {
          let fbs;
          ((fbs2) => {
            class MapType {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns MapType
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param MapType= obj
               * @returns MapType
               */
              static getRootAsMapType(bb, obj) {
                return (obj || new MapType()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param MapType= obj
               * @returns MapType
               */
              static getSizePrefixedRootAsMapType(bb, obj) {
                bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
                return (obj || new MapType()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @returns onnxruntime.experimental.fbs.TensorDataType
               */
              keyType() {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? (
                  /**  */
                  this.bb.readInt32(this.bb_pos + offset)
                ) : 0 /* UNDEFINED */;
              }
              /**
               * @param onnxruntime.experimental.fbs.TypeInfo= obj
               * @returns onnxruntime.experimental.fbs.TypeInfo|null
               */
              valueType(obj) {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? (obj || new onnxruntime2.experimental.fbs.TypeInfo()).__init(
                  this.bb.__indirect(this.bb_pos + offset),
                  this.bb
                ) : null;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startMapType(builder) {
                builder.startObject(2);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param onnxruntime.experimental.fbs.TensorDataType keyType
               */
              static addKeyType(builder, keyType) {
                builder.addFieldInt32(0, keyType, 0 /* UNDEFINED */);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset valueTypeOffset
               */
              static addValueType(builder, valueTypeOffset) {
                builder.addFieldOffset(1, valueTypeOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endMapType(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createMapType(builder, keyType, valueTypeOffset) {
                MapType.startMapType(builder);
                MapType.addKeyType(builder, keyType);
                MapType.addValueType(builder, valueTypeOffset);
                return MapType.endMapType(builder);
              }
            }
            fbs2.MapType = MapType;
          })(fbs = experimental2.fbs || (experimental2.fbs = {}));
        })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
      })(onnxruntime || (onnxruntime = {}));
      ((onnxruntime2) => {
        let experimental;
        ((experimental2) => {
          let fbs;
          ((fbs2) => {
            class SequenceType {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns SequenceType
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param SequenceType= obj
               * @returns SequenceType
               */
              static getRootAsSequenceType(bb, obj) {
                return (obj || new SequenceType()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param SequenceType= obj
               * @returns SequenceType
               */
              static getSizePrefixedRootAsSequenceType(bb, obj) {
                bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
                return (obj || new SequenceType()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param onnxruntime.experimental.fbs.TypeInfo= obj
               * @returns onnxruntime.experimental.fbs.TypeInfo|null
               */
              elemType(obj) {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? (obj || new onnxruntime2.experimental.fbs.TypeInfo()).__init(
                  this.bb.__indirect(this.bb_pos + offset),
                  this.bb
                ) : null;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startSequenceType(builder) {
                builder.startObject(1);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset elemTypeOffset
               */
              static addElemType(builder, elemTypeOffset) {
                builder.addFieldOffset(0, elemTypeOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endSequenceType(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createSequenceType(builder, elemTypeOffset) {
                SequenceType.startSequenceType(builder);
                SequenceType.addElemType(builder, elemTypeOffset);
                return SequenceType.endSequenceType(builder);
              }
            }
            fbs2.SequenceType = SequenceType;
          })(fbs = experimental2.fbs || (experimental2.fbs = {}));
        })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
      })(onnxruntime || (onnxruntime = {}));
      ((onnxruntime2) => {
        let experimental;
        ((experimental2) => {
          let fbs;
          ((fbs2) => {
            class EdgeEnd {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns EdgeEnd
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @returns number
               */
              nodeIndex() {
                return this.bb.readUint32(this.bb_pos);
              }
              /**
               * @returns number
               */
              srcArgIndex() {
                return this.bb.readInt32(this.bb_pos + 4);
              }
              /**
               * @returns number
               */
              dstArgIndex() {
                return this.bb.readInt32(this.bb_pos + 8);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number node_index
               * @param number src_arg_index
               * @param number dst_arg_index
               * @returns flatbuffers.Offset
               */
              static createEdgeEnd(builder, node_index, src_arg_index, dst_arg_index) {
                builder.prep(4, 12);
                builder.writeInt32(dst_arg_index);
                builder.writeInt32(src_arg_index);
                builder.writeInt32(node_index);
                return builder.offset();
              }
            }
            fbs2.EdgeEnd = EdgeEnd;
          })(fbs = experimental2.fbs || (experimental2.fbs = {}));
        })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
      })(onnxruntime || (onnxruntime = {}));
      ((onnxruntime2) => {
        let experimental;
        ((experimental2) => {
          let fbs;
          ((fbs2) => {
            class NodeEdge {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns NodeEdge
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param NodeEdge= obj
               * @returns NodeEdge
               */
              static getRootAsNodeEdge(bb, obj) {
                return (obj || new NodeEdge()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param NodeEdge= obj
               * @returns NodeEdge
               */
              static getSizePrefixedRootAsNodeEdge(bb, obj) {
                bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
                return (obj || new NodeEdge()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @returns number
               */
              nodeIndex() {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
              }
              /**
               * @param number index
               * @param onnxruntime.experimental.fbs.EdgeEnd= obj
               * @returns onnxruntime.experimental.fbs.EdgeEnd
               */
              inputEdges(index, obj) {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? (obj || new onnxruntime2.experimental.fbs.EdgeEnd()).__init(
                  this.bb.__vector(this.bb_pos + offset) + index * 12,
                  this.bb
                ) : null;
              }
              /**
               * @returns number
               */
              inputEdgesLength() {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              /**
               * @param number index
               * @param onnxruntime.experimental.fbs.EdgeEnd= obj
               * @returns onnxruntime.experimental.fbs.EdgeEnd
               */
              outputEdges(index, obj) {
                let offset = this.bb.__offset(this.bb_pos, 8);
                return offset ? (obj || new onnxruntime2.experimental.fbs.EdgeEnd()).__init(
                  this.bb.__vector(this.bb_pos + offset) + index * 12,
                  this.bb
                ) : null;
              }
              /**
               * @returns number
               */
              outputEdgesLength() {
                let offset = this.bb.__offset(this.bb_pos, 8);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startNodeEdge(builder) {
                builder.startObject(3);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number nodeIndex
               */
              static addNodeIndex(builder, nodeIndex) {
                builder.addFieldInt32(0, nodeIndex, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset inputEdgesOffset
               */
              static addInputEdges(builder, inputEdgesOffset) {
                builder.addFieldOffset(1, inputEdgesOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startInputEdgesVector(builder, numElems) {
                builder.startVector(12, numElems, 4);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset outputEdgesOffset
               */
              static addOutputEdges(builder, outputEdgesOffset) {
                builder.addFieldOffset(2, outputEdgesOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startOutputEdgesVector(builder, numElems) {
                builder.startVector(12, numElems, 4);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endNodeEdge(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createNodeEdge(builder, nodeIndex, inputEdgesOffset, outputEdgesOffset) {
                NodeEdge.startNodeEdge(builder);
                NodeEdge.addNodeIndex(builder, nodeIndex);
                NodeEdge.addInputEdges(builder, inputEdgesOffset);
                NodeEdge.addOutputEdges(builder, outputEdgesOffset);
                return NodeEdge.endNodeEdge(builder);
              }
            }
            fbs2.NodeEdge = NodeEdge;
          })(fbs = experimental2.fbs || (experimental2.fbs = {}));
        })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
      })(onnxruntime || (onnxruntime = {}));
      ((onnxruntime2) => {
        let experimental;
        ((experimental2) => {
          let fbs;
          ((fbs2) => {
            class Node2 {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns Node
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param Node= obj
               * @returns Node
               */
              static getRootAsNode(bb, obj) {
                return (obj || new Node2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param Node= obj
               * @returns Node
               */
              static getSizePrefixedRootAsNode(bb, obj) {
                bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
                return (obj || new Node2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              name(optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
              }
              docString(optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
              }
              domain(optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 8);
                return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
              }
              /**
               * @returns number
               */
              sinceVersion() {
                let offset = this.bb.__offset(this.bb_pos, 10);
                return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
              }
              /**
               * @returns number
               */
              index() {
                let offset = this.bb.__offset(this.bb_pos, 12);
                return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
              }
              opType(optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 14);
                return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
              }
              /**
               * @returns onnxruntime.experimental.fbs.NodeType
               */
              type() {
                let offset = this.bb.__offset(this.bb_pos, 16);
                return offset ? (
                  /**  */
                  this.bb.readInt32(this.bb_pos + offset)
                ) : 0 /* Primitive */;
              }
              executionProviderType(optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 18);
                return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
              }
              inputs(index, optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 20);
                return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
              }
              /**
               * @returns number
               */
              inputsLength() {
                let offset = this.bb.__offset(this.bb_pos, 20);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              outputs(index, optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 22);
                return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
              }
              /**
               * @returns number
               */
              outputsLength() {
                let offset = this.bb.__offset(this.bb_pos, 22);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              /**
               * @param number index
               * @param onnxruntime.experimental.fbs.Attribute= obj
               * @returns onnxruntime.experimental.fbs.Attribute
               */
              attributes(index, obj) {
                let offset = this.bb.__offset(this.bb_pos, 24);
                return offset ? (obj || new onnxruntime2.experimental.fbs.Attribute()).__init(
                  this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4),
                  this.bb
                ) : null;
              }
              /**
               * @returns number
               */
              attributesLength() {
                let offset = this.bb.__offset(this.bb_pos, 24);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              /**
               * @param number index
               * @returns number
               */
              inputArgCounts(index) {
                let offset = this.bb.__offset(this.bb_pos, 26);
                return offset ? this.bb.readInt32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
              }
              /**
               * @returns number
               */
              inputArgCountsLength() {
                let offset = this.bb.__offset(this.bb_pos, 26);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              /**
               * @returns Int32Array
               */
              inputArgCountsArray() {
                let offset = this.bb.__offset(this.bb_pos, 26);
                return offset ? new Int32Array(
                  this.bb.bytes().buffer,
                  this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset),
                  this.bb.__vector_len(this.bb_pos + offset)
                ) : null;
              }
              implicitInputs(index, optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 28);
                return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
              }
              /**
               * @returns number
               */
              implicitInputsLength() {
                let offset = this.bb.__offset(this.bb_pos, 28);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startNode(builder) {
                builder.startObject(13);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset nameOffset
               */
              static addName(builder, nameOffset) {
                builder.addFieldOffset(0, nameOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset docStringOffset
               */
              static addDocString(builder, docStringOffset) {
                builder.addFieldOffset(1, docStringOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset domainOffset
               */
              static addDomain(builder, domainOffset) {
                builder.addFieldOffset(2, domainOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number sinceVersion
               */
              static addSinceVersion(builder, sinceVersion) {
                builder.addFieldInt32(3, sinceVersion, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number index
               */
              static addIndex(builder, index) {
                builder.addFieldInt32(4, index, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset opTypeOffset
               */
              static addOpType(builder, opTypeOffset) {
                builder.addFieldOffset(5, opTypeOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param onnxruntime.experimental.fbs.NodeType type
               */
              static addType(builder, type) {
                builder.addFieldInt32(6, type, 0 /* Primitive */);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset executionProviderTypeOffset
               */
              static addExecutionProviderType(builder, executionProviderTypeOffset) {
                builder.addFieldOffset(7, executionProviderTypeOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset inputsOffset
               */
              static addInputs(builder, inputsOffset) {
                builder.addFieldOffset(8, inputsOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<flatbuffers.Offset> data
               * @returns flatbuffers.Offset
               */
              static createInputsVector(builder, data) {
                builder.startVector(4, data.length, 4);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addOffset(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startInputsVector(builder, numElems) {
                builder.startVector(4, numElems, 4);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset outputsOffset
               */
              static addOutputs(builder, outputsOffset) {
                builder.addFieldOffset(9, outputsOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<flatbuffers.Offset> data
               * @returns flatbuffers.Offset
               */
              static createOutputsVector(builder, data) {
                builder.startVector(4, data.length, 4);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addOffset(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startOutputsVector(builder, numElems) {
                builder.startVector(4, numElems, 4);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset attributesOffset
               */
              static addAttributes(builder, attributesOffset) {
                builder.addFieldOffset(10, attributesOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<flatbuffers.Offset> data
               * @returns flatbuffers.Offset
               */
              static createAttributesVector(builder, data) {
                builder.startVector(4, data.length, 4);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addOffset(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startAttributesVector(builder, numElems) {
                builder.startVector(4, numElems, 4);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset inputArgCountsOffset
               */
              static addInputArgCounts(builder, inputArgCountsOffset) {
                builder.addFieldOffset(11, inputArgCountsOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<number> data
               * @returns flatbuffers.Offset
               */
              static createInputArgCountsVector(builder, data) {
                builder.startVector(4, data.length, 4);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addInt32(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startInputArgCountsVector(builder, numElems) {
                builder.startVector(4, numElems, 4);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset implicitInputsOffset
               */
              static addImplicitInputs(builder, implicitInputsOffset) {
                builder.addFieldOffset(12, implicitInputsOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<flatbuffers.Offset> data
               * @returns flatbuffers.Offset
               */
              static createImplicitInputsVector(builder, data) {
                builder.startVector(4, data.length, 4);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addOffset(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startImplicitInputsVector(builder, numElems) {
                builder.startVector(4, numElems, 4);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endNode(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createNode(builder, nameOffset, docStringOffset, domainOffset, sinceVersion, index, opTypeOffset, type, executionProviderTypeOffset, inputsOffset, outputsOffset, attributesOffset, inputArgCountsOffset, implicitInputsOffset) {
                Node2.startNode(builder);
                Node2.addName(builder, nameOffset);
                Node2.addDocString(builder, docStringOffset);
                Node2.addDomain(builder, domainOffset);
                Node2.addSinceVersion(builder, sinceVersion);
                Node2.addIndex(builder, index);
                Node2.addOpType(builder, opTypeOffset);
                Node2.addType(builder, type);
                Node2.addExecutionProviderType(builder, executionProviderTypeOffset);
                Node2.addInputs(builder, inputsOffset);
                Node2.addOutputs(builder, outputsOffset);
                Node2.addAttributes(builder, attributesOffset);
                Node2.addInputArgCounts(builder, inputArgCountsOffset);
                Node2.addImplicitInputs(builder, implicitInputsOffset);
                return Node2.endNode(builder);
              }
            }
            fbs2.Node = Node2;
          })(fbs = experimental2.fbs || (experimental2.fbs = {}));
        })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
      })(onnxruntime || (onnxruntime = {}));
      ((onnxruntime2) => {
        let experimental;
        ((experimental2) => {
          let fbs;
          ((fbs2) => {
            class ValueInfo {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns ValueInfo
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param ValueInfo= obj
               * @returns ValueInfo
               */
              static getRootAsValueInfo(bb, obj) {
                return (obj || new ValueInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param ValueInfo= obj
               * @returns ValueInfo
               */
              static getSizePrefixedRootAsValueInfo(bb, obj) {
                bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
                return (obj || new ValueInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              name(optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
              }
              docString(optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
              }
              /**
               * @param onnxruntime.experimental.fbs.TypeInfo= obj
               * @returns onnxruntime.experimental.fbs.TypeInfo|null
               */
              type(obj) {
                let offset = this.bb.__offset(this.bb_pos, 8);
                return offset ? (obj || new onnxruntime2.experimental.fbs.TypeInfo()).__init(
                  this.bb.__indirect(this.bb_pos + offset),
                  this.bb
                ) : null;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startValueInfo(builder) {
                builder.startObject(3);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset nameOffset
               */
              static addName(builder, nameOffset) {
                builder.addFieldOffset(0, nameOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset docStringOffset
               */
              static addDocString(builder, docStringOffset) {
                builder.addFieldOffset(1, docStringOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset typeOffset
               */
              static addType(builder, typeOffset) {
                builder.addFieldOffset(2, typeOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endValueInfo(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createValueInfo(builder, nameOffset, docStringOffset, typeOffset) {
                ValueInfo.startValueInfo(builder);
                ValueInfo.addName(builder, nameOffset);
                ValueInfo.addDocString(builder, docStringOffset);
                ValueInfo.addType(builder, typeOffset);
                return ValueInfo.endValueInfo(builder);
              }
            }
            fbs2.ValueInfo = ValueInfo;
          })(fbs = experimental2.fbs || (experimental2.fbs = {}));
        })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
      })(onnxruntime || (onnxruntime = {}));
      ((onnxruntime2) => {
        let experimental;
        ((experimental2) => {
          let fbs;
          ((fbs2) => {
            class TypeInfo {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns TypeInfo
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param TypeInfo= obj
               * @returns TypeInfo
               */
              static getRootAsTypeInfo(bb, obj) {
                return (obj || new TypeInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param TypeInfo= obj
               * @returns TypeInfo
               */
              static getSizePrefixedRootAsTypeInfo(bb, obj) {
                bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
                return (obj || new TypeInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              denotation(optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
              }
              /**
               * @returns onnxruntime.experimental.fbs.TypeInfoValue
               */
              valueType() {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? (
                  /**  */
                  this.bb.readUint8(this.bb_pos + offset)
                ) : 0 /* NONE */;
              }
              /**
               * @param flatbuffers.Table obj
               * @returns ?flatbuffers.Table
               */
              value(obj) {
                let offset = this.bb.__offset(this.bb_pos, 8);
                return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startTypeInfo(builder) {
                builder.startObject(3);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset denotationOffset
               */
              static addDenotation(builder, denotationOffset) {
                builder.addFieldOffset(0, denotationOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param onnxruntime.experimental.fbs.TypeInfoValue valueType
               */
              static addValueType(builder, valueType) {
                builder.addFieldInt8(1, valueType, 0 /* NONE */);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset valueOffset
               */
              static addValue(builder, valueOffset) {
                builder.addFieldOffset(2, valueOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endTypeInfo(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createTypeInfo(builder, denotationOffset, valueType, valueOffset) {
                TypeInfo.startTypeInfo(builder);
                TypeInfo.addDenotation(builder, denotationOffset);
                TypeInfo.addValueType(builder, valueType);
                TypeInfo.addValue(builder, valueOffset);
                return TypeInfo.endTypeInfo(builder);
              }
            }
            fbs2.TypeInfo = TypeInfo;
          })(fbs = experimental2.fbs || (experimental2.fbs = {}));
        })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
      })(onnxruntime || (onnxruntime = {}));
      ((onnxruntime2) => {
        let experimental;
        ((experimental2) => {
          let fbs;
          ((fbs2) => {
            class OperatorSetId {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns OperatorSetId
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param OperatorSetId= obj
               * @returns OperatorSetId
               */
              static getRootAsOperatorSetId(bb, obj) {
                return (obj || new OperatorSetId()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param OperatorSetId= obj
               * @returns OperatorSetId
               */
              static getSizePrefixedRootAsOperatorSetId(bb, obj) {
                bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
                return (obj || new OperatorSetId()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              domain(optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
              }
              /**
               * @returns flatbuffers.Long
               */
              version() {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startOperatorSetId(builder) {
                builder.startObject(2);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset domainOffset
               */
              static addDomain(builder, domainOffset) {
                builder.addFieldOffset(0, domainOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Long version
               */
              static addVersion(builder, version3) {
                builder.addFieldInt64(1, version3, builder.createLong(0, 0));
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endOperatorSetId(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createOperatorSetId(builder, domainOffset, version3) {
                OperatorSetId.startOperatorSetId(builder);
                OperatorSetId.addDomain(builder, domainOffset);
                OperatorSetId.addVersion(builder, version3);
                return OperatorSetId.endOperatorSetId(builder);
              }
            }
            fbs2.OperatorSetId = OperatorSetId;
          })(fbs = experimental2.fbs || (experimental2.fbs = {}));
        })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
      })(onnxruntime || (onnxruntime = {}));
      ((onnxruntime2) => {
        let experimental;
        ((experimental2) => {
          let fbs;
          ((fbs2) => {
            class Tensor4 {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns Tensor
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param Tensor= obj
               * @returns Tensor
               */
              static getRootAsTensor(bb, obj) {
                return (obj || new Tensor4()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param Tensor= obj
               * @returns Tensor
               */
              static getSizePrefixedRootAsTensor(bb, obj) {
                bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
                return (obj || new Tensor4()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              name(optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
              }
              docString(optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
              }
              /**
               * @param number index
               * @returns flatbuffers.Long
               */
              dims(index) {
                let offset = this.bb.__offset(this.bb_pos, 8);
                return offset ? this.bb.readInt64(this.bb.__vector(this.bb_pos + offset) + index * 8) : this.bb.createLong(0, 0);
              }
              /**
               * @returns number
               */
              dimsLength() {
                let offset = this.bb.__offset(this.bb_pos, 8);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              /**
               * @returns onnxruntime.experimental.fbs.TensorDataType
               */
              dataType() {
                let offset = this.bb.__offset(this.bb_pos, 10);
                return offset ? (
                  /**  */
                  this.bb.readInt32(this.bb_pos + offset)
                ) : 0 /* UNDEFINED */;
              }
              /**
               * @param number index
               * @returns number
               */
              rawData(index) {
                let offset = this.bb.__offset(this.bb_pos, 12);
                return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
              }
              /**
               * @returns number
               */
              rawDataLength() {
                let offset = this.bb.__offset(this.bb_pos, 12);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              /**
               * @returns Uint8Array
               */
              rawDataArray() {
                let offset = this.bb.__offset(this.bb_pos, 12);
                return offset ? new Uint8Array(
                  this.bb.bytes().buffer,
                  this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset),
                  this.bb.__vector_len(this.bb_pos + offset)
                ) : null;
              }
              stringData(index, optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 14);
                return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
              }
              /**
               * @returns number
               */
              stringDataLength() {
                let offset = this.bb.__offset(this.bb_pos, 14);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startTensor(builder) {
                builder.startObject(6);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset nameOffset
               */
              static addName(builder, nameOffset) {
                builder.addFieldOffset(0, nameOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset docStringOffset
               */
              static addDocString(builder, docStringOffset) {
                builder.addFieldOffset(1, docStringOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset dimsOffset
               */
              static addDims(builder, dimsOffset) {
                builder.addFieldOffset(2, dimsOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<flatbuffers.Long> data
               * @returns flatbuffers.Offset
               */
              static createDimsVector(builder, data) {
                builder.startVector(8, data.length, 8);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addInt64(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startDimsVector(builder, numElems) {
                builder.startVector(8, numElems, 8);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param onnxruntime.experimental.fbs.TensorDataType dataType
               */
              static addDataType(builder, dataType) {
                builder.addFieldInt32(3, dataType, 0 /* UNDEFINED */);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset rawDataOffset
               */
              static addRawData(builder, rawDataOffset) {
                builder.addFieldOffset(4, rawDataOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<number> data
               * @returns flatbuffers.Offset
               */
              static createRawDataVector(builder, data) {
                builder.startVector(1, data.length, 1);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addInt8(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startRawDataVector(builder, numElems) {
                builder.startVector(1, numElems, 1);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset stringDataOffset
               */
              static addStringData(builder, stringDataOffset) {
                builder.addFieldOffset(5, stringDataOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<flatbuffers.Offset> data
               * @returns flatbuffers.Offset
               */
              static createStringDataVector(builder, data) {
                builder.startVector(4, data.length, 4);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addOffset(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startStringDataVector(builder, numElems) {
                builder.startVector(4, numElems, 4);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endTensor(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createTensor(builder, nameOffset, docStringOffset, dimsOffset, dataType, rawDataOffset, stringDataOffset) {
                Tensor4.startTensor(builder);
                Tensor4.addName(builder, nameOffset);
                Tensor4.addDocString(builder, docStringOffset);
                Tensor4.addDims(builder, dimsOffset);
                Tensor4.addDataType(builder, dataType);
                Tensor4.addRawData(builder, rawDataOffset);
                Tensor4.addStringData(builder, stringDataOffset);
                return Tensor4.endTensor(builder);
              }
            }
            fbs2.Tensor = Tensor4;
          })(fbs = experimental2.fbs || (experimental2.fbs = {}));
        })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
      })(onnxruntime || (onnxruntime = {}));
      ((onnxruntime2) => {
        let experimental;
        ((experimental2) => {
          let fbs;
          ((fbs2) => {
            class SparseTensor {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns SparseTensor
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param SparseTensor= obj
               * @returns SparseTensor
               */
              static getRootAsSparseTensor(bb, obj) {
                return (obj || new SparseTensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param SparseTensor= obj
               * @returns SparseTensor
               */
              static getSizePrefixedRootAsSparseTensor(bb, obj) {
                bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
                return (obj || new SparseTensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param onnxruntime.experimental.fbs.Tensor= obj
               * @returns onnxruntime.experimental.fbs.Tensor|null
               */
              values(obj) {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? (obj || new onnxruntime2.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
              }
              /**
               * @param onnxruntime.experimental.fbs.Tensor= obj
               * @returns onnxruntime.experimental.fbs.Tensor|null
               */
              indices(obj) {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? (obj || new onnxruntime2.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
              }
              /**
               * @param number index
               * @returns flatbuffers.Long
               */
              dims(index) {
                let offset = this.bb.__offset(this.bb_pos, 8);
                return offset ? this.bb.readInt64(this.bb.__vector(this.bb_pos + offset) + index * 8) : this.bb.createLong(0, 0);
              }
              /**
               * @returns number
               */
              dimsLength() {
                let offset = this.bb.__offset(this.bb_pos, 8);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startSparseTensor(builder) {
                builder.startObject(3);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset valuesOffset
               */
              static addValues(builder, valuesOffset) {
                builder.addFieldOffset(0, valuesOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset indicesOffset
               */
              static addIndices(builder, indicesOffset) {
                builder.addFieldOffset(1, indicesOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset dimsOffset
               */
              static addDims(builder, dimsOffset) {
                builder.addFieldOffset(2, dimsOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<flatbuffers.Long> data
               * @returns flatbuffers.Offset
               */
              static createDimsVector(builder, data) {
                builder.startVector(8, data.length, 8);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addInt64(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startDimsVector(builder, numElems) {
                builder.startVector(8, numElems, 8);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endSparseTensor(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createSparseTensor(builder, valuesOffset, indicesOffset, dimsOffset) {
                SparseTensor.startSparseTensor(builder);
                SparseTensor.addValues(builder, valuesOffset);
                SparseTensor.addIndices(builder, indicesOffset);
                SparseTensor.addDims(builder, dimsOffset);
                return SparseTensor.endSparseTensor(builder);
              }
            }
            fbs2.SparseTensor = SparseTensor;
          })(fbs = experimental2.fbs || (experimental2.fbs = {}));
        })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
      })(onnxruntime || (onnxruntime = {}));
      ((onnxruntime2) => {
        let experimental;
        ((experimental2) => {
          let fbs;
          ((fbs2) => {
            class Attribute2 {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns Attribute
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param Attribute= obj
               * @returns Attribute
               */
              static getRootAsAttribute(bb, obj) {
                return (obj || new Attribute2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param Attribute= obj
               * @returns Attribute
               */
              static getSizePrefixedRootAsAttribute(bb, obj) {
                bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
                return (obj || new Attribute2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              name(optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
              }
              docString(optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
              }
              /**
               * @returns onnxruntime.experimental.fbs.AttributeType
               */
              type() {
                let offset = this.bb.__offset(this.bb_pos, 8);
                return offset ? (
                  /**  */
                  this.bb.readInt32(this.bb_pos + offset)
                ) : 0 /* UNDEFINED */;
              }
              /**
               * @returns number
               */
              f() {
                let offset = this.bb.__offset(this.bb_pos, 10);
                return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0;
              }
              /**
               * @returns flatbuffers.Long
               */
              i() {
                let offset = this.bb.__offset(this.bb_pos, 12);
                return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);
              }
              s(optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 14);
                return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
              }
              /**
               * @param onnxruntime.experimental.fbs.Tensor= obj
               * @returns onnxruntime.experimental.fbs.Tensor|null
               */
              t(obj) {
                let offset = this.bb.__offset(this.bb_pos, 16);
                return offset ? (obj || new onnxruntime2.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
              }
              /**
               * @param onnxruntime.experimental.fbs.Graph= obj
               * @returns onnxruntime.experimental.fbs.Graph|null
               */
              g(obj) {
                let offset = this.bb.__offset(this.bb_pos, 18);
                return offset ? (obj || new onnxruntime2.experimental.fbs.Graph()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
              }
              /**
               * @param number index
               * @returns number
               */
              floats(index) {
                let offset = this.bb.__offset(this.bb_pos, 20);
                return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
              }
              /**
               * @returns number
               */
              floatsLength() {
                let offset = this.bb.__offset(this.bb_pos, 20);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              /**
               * @returns Float32Array
               */
              floatsArray() {
                let offset = this.bb.__offset(this.bb_pos, 20);
                return offset ? new Float32Array(
                  this.bb.bytes().buffer,
                  this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset),
                  this.bb.__vector_len(this.bb_pos + offset)
                ) : null;
              }
              /**
               * @param number index
               * @returns flatbuffers.Long
               */
              ints(index) {
                let offset = this.bb.__offset(this.bb_pos, 22);
                return offset ? this.bb.readInt64(this.bb.__vector(this.bb_pos + offset) + index * 8) : this.bb.createLong(0, 0);
              }
              /**
               * @returns number
               */
              intsLength() {
                let offset = this.bb.__offset(this.bb_pos, 22);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              strings(index, optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 24);
                return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
              }
              /**
               * @returns number
               */
              stringsLength() {
                let offset = this.bb.__offset(this.bb_pos, 24);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              /**
               * @param number index
               * @param onnxruntime.experimental.fbs.Tensor= obj
               * @returns onnxruntime.experimental.fbs.Tensor
               */
              tensors(index, obj) {
                let offset = this.bb.__offset(this.bb_pos, 26);
                return offset ? (obj || new onnxruntime2.experimental.fbs.Tensor()).__init(
                  this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4),
                  this.bb
                ) : null;
              }
              /**
               * @returns number
               */
              tensorsLength() {
                let offset = this.bb.__offset(this.bb_pos, 26);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              /**
               * @param number index
               * @param onnxruntime.experimental.fbs.Graph= obj
               * @returns onnxruntime.experimental.fbs.Graph
               */
              graphs(index, obj) {
                let offset = this.bb.__offset(this.bb_pos, 28);
                return offset ? (obj || new onnxruntime2.experimental.fbs.Graph()).__init(
                  this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4),
                  this.bb
                ) : null;
              }
              /**
               * @returns number
               */
              graphsLength() {
                let offset = this.bb.__offset(this.bb_pos, 28);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startAttribute(builder) {
                builder.startObject(13);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset nameOffset
               */
              static addName(builder, nameOffset) {
                builder.addFieldOffset(0, nameOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset docStringOffset
               */
              static addDocString(builder, docStringOffset) {
                builder.addFieldOffset(1, docStringOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param onnxruntime.experimental.fbs.AttributeType type
               */
              static addType(builder, type) {
                builder.addFieldInt32(2, type, 0 /* UNDEFINED */);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number f
               */
              static addF(builder, f) {
                builder.addFieldFloat32(3, f, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Long i
               */
              static addI(builder, i) {
                builder.addFieldInt64(4, i, builder.createLong(0, 0));
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset sOffset
               */
              static addS(builder, sOffset) {
                builder.addFieldOffset(5, sOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset tOffset
               */
              static addT(builder, tOffset) {
                builder.addFieldOffset(6, tOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset gOffset
               */
              static addG(builder, gOffset) {
                builder.addFieldOffset(7, gOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset floatsOffset
               */
              static addFloats(builder, floatsOffset) {
                builder.addFieldOffset(8, floatsOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<number> data
               * @returns flatbuffers.Offset
               */
              static createFloatsVector(builder, data) {
                builder.startVector(4, data.length, 4);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addFloat32(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startFloatsVector(builder, numElems) {
                builder.startVector(4, numElems, 4);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset intsOffset
               */
              static addInts(builder, intsOffset) {
                builder.addFieldOffset(9, intsOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<flatbuffers.Long> data
               * @returns flatbuffers.Offset
               */
              static createIntsVector(builder, data) {
                builder.startVector(8, data.length, 8);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addInt64(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startIntsVector(builder, numElems) {
                builder.startVector(8, numElems, 8);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset stringsOffset
               */
              static addStrings(builder, stringsOffset) {
                builder.addFieldOffset(10, stringsOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<flatbuffers.Offset> data
               * @returns flatbuffers.Offset
               */
              static createStringsVector(builder, data) {
                builder.startVector(4, data.length, 4);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addOffset(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startStringsVector(builder, numElems) {
                builder.startVector(4, numElems, 4);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset tensorsOffset
               */
              static addTensors(builder, tensorsOffset) {
                builder.addFieldOffset(11, tensorsOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<flatbuffers.Offset> data
               * @returns flatbuffers.Offset
               */
              static createTensorsVector(builder, data) {
                builder.startVector(4, data.length, 4);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addOffset(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startTensorsVector(builder, numElems) {
                builder.startVector(4, numElems, 4);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset graphsOffset
               */
              static addGraphs(builder, graphsOffset) {
                builder.addFieldOffset(12, graphsOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<flatbuffers.Offset> data
               * @returns flatbuffers.Offset
               */
              static createGraphsVector(builder, data) {
                builder.startVector(4, data.length, 4);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addOffset(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startGraphsVector(builder, numElems) {
                builder.startVector(4, numElems, 4);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endAttribute(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createAttribute(builder, nameOffset, docStringOffset, type, f, i, sOffset, tOffset, gOffset, floatsOffset, intsOffset, stringsOffset, tensorsOffset, graphsOffset) {
                Attribute2.startAttribute(builder);
                Attribute2.addName(builder, nameOffset);
                Attribute2.addDocString(builder, docStringOffset);
                Attribute2.addType(builder, type);
                Attribute2.addF(builder, f);
                Attribute2.addI(builder, i);
                Attribute2.addS(builder, sOffset);
                Attribute2.addT(builder, tOffset);
                Attribute2.addG(builder, gOffset);
                Attribute2.addFloats(builder, floatsOffset);
                Attribute2.addInts(builder, intsOffset);
                Attribute2.addStrings(builder, stringsOffset);
                Attribute2.addTensors(builder, tensorsOffset);
                Attribute2.addGraphs(builder, graphsOffset);
                return Attribute2.endAttribute(builder);
              }
            }
            fbs2.Attribute = Attribute2;
          })(fbs = experimental2.fbs || (experimental2.fbs = {}));
        })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
      })(onnxruntime || (onnxruntime = {}));
      ((onnxruntime2) => {
        let experimental;
        ((experimental2) => {
          let fbs;
          ((fbs2) => {
            class Graph2 {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns Graph
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param Graph= obj
               * @returns Graph
               */
              static getRootAsGraph(bb, obj) {
                return (obj || new Graph2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param Graph= obj
               * @returns Graph
               */
              static getSizePrefixedRootAsGraph(bb, obj) {
                bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
                return (obj || new Graph2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param number index
               * @param onnxruntime.experimental.fbs.Tensor= obj
               * @returns onnxruntime.experimental.fbs.Tensor
               */
              initializers(index, obj) {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? (obj || new onnxruntime2.experimental.fbs.Tensor()).__init(
                  this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4),
                  this.bb
                ) : null;
              }
              /**
               * @returns number
               */
              initializersLength() {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              /**
               * @param number index
               * @param onnxruntime.experimental.fbs.ValueInfo= obj
               * @returns onnxruntime.experimental.fbs.ValueInfo
               */
              nodeArgs(index, obj) {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? (obj || new onnxruntime2.experimental.fbs.ValueInfo()).__init(
                  this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4),
                  this.bb
                ) : null;
              }
              /**
               * @returns number
               */
              nodeArgsLength() {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              /**
               * @param number index
               * @param onnxruntime.experimental.fbs.Node= obj
               * @returns onnxruntime.experimental.fbs.Node
               */
              nodes(index, obj) {
                let offset = this.bb.__offset(this.bb_pos, 8);
                return offset ? (obj || new onnxruntime2.experimental.fbs.Node()).__init(
                  this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4),
                  this.bb
                ) : null;
              }
              /**
               * @returns number
               */
              nodesLength() {
                let offset = this.bb.__offset(this.bb_pos, 8);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              /**
               * @returns number
               */
              maxNodeIndex() {
                let offset = this.bb.__offset(this.bb_pos, 10);
                return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
              }
              /**
               * @param number index
               * @param onnxruntime.experimental.fbs.NodeEdge= obj
               * @returns onnxruntime.experimental.fbs.NodeEdge
               */
              nodeEdges(index, obj) {
                let offset = this.bb.__offset(this.bb_pos, 12);
                return offset ? (obj || new onnxruntime2.experimental.fbs.NodeEdge()).__init(
                  this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4),
                  this.bb
                ) : null;
              }
              /**
               * @returns number
               */
              nodeEdgesLength() {
                let offset = this.bb.__offset(this.bb_pos, 12);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              inputs(index, optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 14);
                return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
              }
              /**
               * @returns number
               */
              inputsLength() {
                let offset = this.bb.__offset(this.bb_pos, 14);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              outputs(index, optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 16);
                return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
              }
              /**
               * @returns number
               */
              outputsLength() {
                let offset = this.bb.__offset(this.bb_pos, 16);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              /**
               * @param number index
               * @param onnxruntime.experimental.fbs.SparseTensor= obj
               * @returns onnxruntime.experimental.fbs.SparseTensor
               */
              sparseInitializers(index, obj) {
                let offset = this.bb.__offset(this.bb_pos, 18);
                return offset ? (obj || new onnxruntime2.experimental.fbs.SparseTensor()).__init(
                  this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4),
                  this.bb
                ) : null;
              }
              /**
               * @returns number
               */
              sparseInitializersLength() {
                let offset = this.bb.__offset(this.bb_pos, 18);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startGraph(builder) {
                builder.startObject(8);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset initializersOffset
               */
              static addInitializers(builder, initializersOffset) {
                builder.addFieldOffset(0, initializersOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<flatbuffers.Offset> data
               * @returns flatbuffers.Offset
               */
              static createInitializersVector(builder, data) {
                builder.startVector(4, data.length, 4);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addOffset(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startInitializersVector(builder, numElems) {
                builder.startVector(4, numElems, 4);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset nodeArgsOffset
               */
              static addNodeArgs(builder, nodeArgsOffset) {
                builder.addFieldOffset(1, nodeArgsOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<flatbuffers.Offset> data
               * @returns flatbuffers.Offset
               */
              static createNodeArgsVector(builder, data) {
                builder.startVector(4, data.length, 4);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addOffset(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startNodeArgsVector(builder, numElems) {
                builder.startVector(4, numElems, 4);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset nodesOffset
               */
              static addNodes(builder, nodesOffset) {
                builder.addFieldOffset(2, nodesOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<flatbuffers.Offset> data
               * @returns flatbuffers.Offset
               */
              static createNodesVector(builder, data) {
                builder.startVector(4, data.length, 4);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addOffset(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startNodesVector(builder, numElems) {
                builder.startVector(4, numElems, 4);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number maxNodeIndex
               */
              static addMaxNodeIndex(builder, maxNodeIndex) {
                builder.addFieldInt32(3, maxNodeIndex, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset nodeEdgesOffset
               */
              static addNodeEdges(builder, nodeEdgesOffset) {
                builder.addFieldOffset(4, nodeEdgesOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<flatbuffers.Offset> data
               * @returns flatbuffers.Offset
               */
              static createNodeEdgesVector(builder, data) {
                builder.startVector(4, data.length, 4);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addOffset(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startNodeEdgesVector(builder, numElems) {
                builder.startVector(4, numElems, 4);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset inputsOffset
               */
              static addInputs(builder, inputsOffset) {
                builder.addFieldOffset(5, inputsOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<flatbuffers.Offset> data
               * @returns flatbuffers.Offset
               */
              static createInputsVector(builder, data) {
                builder.startVector(4, data.length, 4);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addOffset(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startInputsVector(builder, numElems) {
                builder.startVector(4, numElems, 4);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset outputsOffset
               */
              static addOutputs(builder, outputsOffset) {
                builder.addFieldOffset(6, outputsOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<flatbuffers.Offset> data
               * @returns flatbuffers.Offset
               */
              static createOutputsVector(builder, data) {
                builder.startVector(4, data.length, 4);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addOffset(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startOutputsVector(builder, numElems) {
                builder.startVector(4, numElems, 4);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset sparseInitializersOffset
               */
              static addSparseInitializers(builder, sparseInitializersOffset) {
                builder.addFieldOffset(7, sparseInitializersOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<flatbuffers.Offset> data
               * @returns flatbuffers.Offset
               */
              static createSparseInitializersVector(builder, data) {
                builder.startVector(4, data.length, 4);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addOffset(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startSparseInitializersVector(builder, numElems) {
                builder.startVector(4, numElems, 4);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endGraph(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createGraph(builder, initializersOffset, nodeArgsOffset, nodesOffset, maxNodeIndex, nodeEdgesOffset, inputsOffset, outputsOffset, sparseInitializersOffset) {
                Graph2.startGraph(builder);
                Graph2.addInitializers(builder, initializersOffset);
                Graph2.addNodeArgs(builder, nodeArgsOffset);
                Graph2.addNodes(builder, nodesOffset);
                Graph2.addMaxNodeIndex(builder, maxNodeIndex);
                Graph2.addNodeEdges(builder, nodeEdgesOffset);
                Graph2.addInputs(builder, inputsOffset);
                Graph2.addOutputs(builder, outputsOffset);
                Graph2.addSparseInitializers(builder, sparseInitializersOffset);
                return Graph2.endGraph(builder);
              }
            }
            fbs2.Graph = Graph2;
          })(fbs = experimental2.fbs || (experimental2.fbs = {}));
        })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
      })(onnxruntime || (onnxruntime = {}));
      ((onnxruntime2) => {
        let experimental;
        ((experimental2) => {
          let fbs;
          ((fbs2) => {
            class Model2 {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns Model
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param Model= obj
               * @returns Model
               */
              static getRootAsModel(bb, obj) {
                return (obj || new Model2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param Model= obj
               * @returns Model
               */
              static getSizePrefixedRootAsModel(bb, obj) {
                bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
                return (obj || new Model2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @returns flatbuffers.Long
               */
              irVersion() {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);
              }
              /**
               * @param number index
               * @param onnxruntime.experimental.fbs.OperatorSetId= obj
               * @returns onnxruntime.experimental.fbs.OperatorSetId
               */
              opsetImport(index, obj) {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? (obj || new onnxruntime2.experimental.fbs.OperatorSetId()).__init(
                  this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4),
                  this.bb
                ) : null;
              }
              /**
               * @returns number
               */
              opsetImportLength() {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              producerName(optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 8);
                return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
              }
              producerVersion(optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 10);
                return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
              }
              domain(optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 12);
                return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
              }
              /**
               * @returns flatbuffers.Long
               */
              modelVersion() {
                let offset = this.bb.__offset(this.bb_pos, 14);
                return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);
              }
              docString(optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 16);
                return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
              }
              /**
               * @param onnxruntime.experimental.fbs.Graph= obj
               * @returns onnxruntime.experimental.fbs.Graph|null
               */
              graph(obj) {
                let offset = this.bb.__offset(this.bb_pos, 18);
                return offset ? (obj || new onnxruntime2.experimental.fbs.Graph()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
              }
              graphDocString(optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 20);
                return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startModel(builder) {
                builder.startObject(9);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Long irVersion
               */
              static addIrVersion(builder, irVersion) {
                builder.addFieldInt64(0, irVersion, builder.createLong(0, 0));
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset opsetImportOffset
               */
              static addOpsetImport(builder, opsetImportOffset) {
                builder.addFieldOffset(1, opsetImportOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<flatbuffers.Offset> data
               * @returns flatbuffers.Offset
               */
              static createOpsetImportVector(builder, data) {
                builder.startVector(4, data.length, 4);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addOffset(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startOpsetImportVector(builder, numElems) {
                builder.startVector(4, numElems, 4);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset producerNameOffset
               */
              static addProducerName(builder, producerNameOffset) {
                builder.addFieldOffset(2, producerNameOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset producerVersionOffset
               */
              static addProducerVersion(builder, producerVersionOffset) {
                builder.addFieldOffset(3, producerVersionOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset domainOffset
               */
              static addDomain(builder, domainOffset) {
                builder.addFieldOffset(4, domainOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Long modelVersion
               */
              static addModelVersion(builder, modelVersion) {
                builder.addFieldInt64(5, modelVersion, builder.createLong(0, 0));
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset docStringOffset
               */
              static addDocString(builder, docStringOffset) {
                builder.addFieldOffset(6, docStringOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset graphOffset
               */
              static addGraph(builder, graphOffset) {
                builder.addFieldOffset(7, graphOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset graphDocStringOffset
               */
              static addGraphDocString(builder, graphDocStringOffset) {
                builder.addFieldOffset(8, graphDocStringOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endModel(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createModel(builder, irVersion, opsetImportOffset, producerNameOffset, producerVersionOffset, domainOffset, modelVersion, docStringOffset, graphOffset, graphDocStringOffset) {
                Model2.startModel(builder);
                Model2.addIrVersion(builder, irVersion);
                Model2.addOpsetImport(builder, opsetImportOffset);
                Model2.addProducerName(builder, producerNameOffset);
                Model2.addProducerVersion(builder, producerVersionOffset);
                Model2.addDomain(builder, domainOffset);
                Model2.addModelVersion(builder, modelVersion);
                Model2.addDocString(builder, docStringOffset);
                Model2.addGraph(builder, graphOffset);
                Model2.addGraphDocString(builder, graphDocStringOffset);
                return Model2.endModel(builder);
              }
            }
            fbs2.Model = Model2;
          })(fbs = experimental2.fbs || (experimental2.fbs = {}));
        })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
      })(onnxruntime || (onnxruntime = {}));
      ((onnxruntime2) => {
        let experimental;
        ((experimental2) => {
          let fbs;
          ((fbs2) => {
            class KernelCreateInfos {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns KernelCreateInfos
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param KernelCreateInfos= obj
               * @returns KernelCreateInfos
               */
              static getRootAsKernelCreateInfos(bb, obj) {
                return (obj || new KernelCreateInfos()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param KernelCreateInfos= obj
               * @returns KernelCreateInfos
               */
              static getSizePrefixedRootAsKernelCreateInfos(bb, obj) {
                bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
                return (obj || new KernelCreateInfos()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param number index
               * @returns number
               */
              nodeIndices(index) {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? this.bb.readUint32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
              }
              /**
               * @returns number
               */
              nodeIndicesLength() {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              /**
               * @returns Uint32Array
               */
              nodeIndicesArray() {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? new Uint32Array(
                  this.bb.bytes().buffer,
                  this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset),
                  this.bb.__vector_len(this.bb_pos + offset)
                ) : null;
              }
              /**
               * @param number index
               * @returns flatbuffers.Long
               */
              kernelDefHashes(index) {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? this.bb.readUint64(this.bb.__vector(this.bb_pos + offset) + index * 8) : this.bb.createLong(0, 0);
              }
              /**
               * @returns number
               */
              kernelDefHashesLength() {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startKernelCreateInfos(builder) {
                builder.startObject(2);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset nodeIndicesOffset
               */
              static addNodeIndices(builder, nodeIndicesOffset) {
                builder.addFieldOffset(0, nodeIndicesOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<number> data
               * @returns flatbuffers.Offset
               */
              static createNodeIndicesVector(builder, data) {
                builder.startVector(4, data.length, 4);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addInt32(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startNodeIndicesVector(builder, numElems) {
                builder.startVector(4, numElems, 4);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset kernelDefHashesOffset
               */
              static addKernelDefHashes(builder, kernelDefHashesOffset) {
                builder.addFieldOffset(1, kernelDefHashesOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<flatbuffers.Long> data
               * @returns flatbuffers.Offset
               */
              static createKernelDefHashesVector(builder, data) {
                builder.startVector(8, data.length, 8);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addInt64(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startKernelDefHashesVector(builder, numElems) {
                builder.startVector(8, numElems, 8);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endKernelCreateInfos(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createKernelCreateInfos(builder, nodeIndicesOffset, kernelDefHashesOffset) {
                KernelCreateInfos.startKernelCreateInfos(builder);
                KernelCreateInfos.addNodeIndices(builder, nodeIndicesOffset);
                KernelCreateInfos.addKernelDefHashes(builder, kernelDefHashesOffset);
                return KernelCreateInfos.endKernelCreateInfos(builder);
              }
            }
            fbs2.KernelCreateInfos = KernelCreateInfos;
          })(fbs = experimental2.fbs || (experimental2.fbs = {}));
        })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
      })(onnxruntime || (onnxruntime = {}));
      ((onnxruntime2) => {
        let experimental;
        ((experimental2) => {
          let fbs;
          ((fbs2) => {
            class SubGraphSessionState {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns SubGraphSessionState
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param SubGraphSessionState= obj
               * @returns SubGraphSessionState
               */
              static getRootAsSubGraphSessionState(bb, obj) {
                return (obj || new SubGraphSessionState()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param SubGraphSessionState= obj
               * @returns SubGraphSessionState
               */
              static getSizePrefixedRootAsSubGraphSessionState(bb, obj) {
                bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
                return (obj || new SubGraphSessionState()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              graphId(optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
              }
              /**
               * @param onnxruntime.experimental.fbs.SessionState= obj
               * @returns onnxruntime.experimental.fbs.SessionState|null
               */
              sessionState(obj) {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? (obj || new onnxruntime2.experimental.fbs.SessionState()).__init(
                  this.bb.__indirect(this.bb_pos + offset),
                  this.bb
                ) : null;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startSubGraphSessionState(builder) {
                builder.startObject(2);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset graphIdOffset
               */
              static addGraphId(builder, graphIdOffset) {
                builder.addFieldOffset(0, graphIdOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset sessionStateOffset
               */
              static addSessionState(builder, sessionStateOffset) {
                builder.addFieldOffset(1, sessionStateOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endSubGraphSessionState(builder) {
                let offset = builder.endObject();
                builder.requiredField(offset, 4);
                return offset;
              }
              static createSubGraphSessionState(builder, graphIdOffset, sessionStateOffset) {
                SubGraphSessionState.startSubGraphSessionState(builder);
                SubGraphSessionState.addGraphId(builder, graphIdOffset);
                SubGraphSessionState.addSessionState(builder, sessionStateOffset);
                return SubGraphSessionState.endSubGraphSessionState(builder);
              }
            }
            fbs2.SubGraphSessionState = SubGraphSessionState;
          })(fbs = experimental2.fbs || (experimental2.fbs = {}));
        })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
      })(onnxruntime || (onnxruntime = {}));
      ((onnxruntime2) => {
        let experimental;
        ((experimental2) => {
          let fbs;
          ((fbs2) => {
            class SessionState {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns SessionState
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param SessionState= obj
               * @returns SessionState
               */
              static getRootAsSessionState(bb, obj) {
                return (obj || new SessionState()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param SessionState= obj
               * @returns SessionState
               */
              static getSizePrefixedRootAsSessionState(bb, obj) {
                bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
                return (obj || new SessionState()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param onnxruntime.experimental.fbs.KernelCreateInfos= obj
               * @returns onnxruntime.experimental.fbs.KernelCreateInfos|null
               */
              kernels(obj) {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? (obj || new onnxruntime2.experimental.fbs.KernelCreateInfos()).__init(
                  this.bb.__indirect(this.bb_pos + offset),
                  this.bb
                ) : null;
              }
              /**
               * @param number index
               * @param onnxruntime.experimental.fbs.SubGraphSessionState= obj
               * @returns onnxruntime.experimental.fbs.SubGraphSessionState
               */
              subGraphSessionStates(index, obj) {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? (obj || new onnxruntime2.experimental.fbs.SubGraphSessionState()).__init(
                  this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4),
                  this.bb
                ) : null;
              }
              /**
               * @returns number
               */
              subGraphSessionStatesLength() {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startSessionState(builder) {
                builder.startObject(2);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset kernelsOffset
               */
              static addKernels(builder, kernelsOffset) {
                builder.addFieldOffset(0, kernelsOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset subGraphSessionStatesOffset
               */
              static addSubGraphSessionStates(builder, subGraphSessionStatesOffset) {
                builder.addFieldOffset(1, subGraphSessionStatesOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<flatbuffers.Offset> data
               * @returns flatbuffers.Offset
               */
              static createSubGraphSessionStatesVector(builder, data) {
                builder.startVector(4, data.length, 4);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addOffset(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startSubGraphSessionStatesVector(builder, numElems) {
                builder.startVector(4, numElems, 4);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endSessionState(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createSessionState(builder, kernelsOffset, subGraphSessionStatesOffset) {
                SessionState.startSessionState(builder);
                SessionState.addKernels(builder, kernelsOffset);
                SessionState.addSubGraphSessionStates(builder, subGraphSessionStatesOffset);
                return SessionState.endSessionState(builder);
              }
            }
            fbs2.SessionState = SessionState;
          })(fbs = experimental2.fbs || (experimental2.fbs = {}));
        })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
      })(onnxruntime || (onnxruntime = {}));
      ((onnxruntime2) => {
        let experimental;
        ((experimental2) => {
          let fbs;
          ((fbs2) => {
            class InferenceSession7 {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns InferenceSession
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param InferenceSession= obj
               * @returns InferenceSession
               */
              static getRootAsInferenceSession(bb, obj) {
                return (obj || new InferenceSession7()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param InferenceSession= obj
               * @returns InferenceSession
               */
              static getSizePrefixedRootAsInferenceSession(bb, obj) {
                bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
                return (obj || new InferenceSession7()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @returns boolean
               */
              static bufferHasIdentifier(bb) {
                return bb.__has_identifier("ORTM");
              }
              ortVersion(optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
              }
              /**
               * @param onnxruntime.experimental.fbs.Model= obj
               * @returns onnxruntime.experimental.fbs.Model|null
               */
              model(obj) {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? (obj || new onnxruntime2.experimental.fbs.Model()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
              }
              /**
               * @param onnxruntime.experimental.fbs.SessionState= obj
               * @returns onnxruntime.experimental.fbs.SessionState|null
               */
              sessionState(obj) {
                let offset = this.bb.__offset(this.bb_pos, 8);
                return offset ? (obj || new onnxruntime2.experimental.fbs.SessionState()).__init(
                  this.bb.__indirect(this.bb_pos + offset),
                  this.bb
                ) : null;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startInferenceSession(builder) {
                builder.startObject(3);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset ortVersionOffset
               */
              static addOrtVersion(builder, ortVersionOffset) {
                builder.addFieldOffset(0, ortVersionOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset modelOffset
               */
              static addModel(builder, modelOffset) {
                builder.addFieldOffset(1, modelOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset sessionStateOffset
               */
              static addSessionState(builder, sessionStateOffset) {
                builder.addFieldOffset(2, sessionStateOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endInferenceSession(builder) {
                let offset = builder.endObject();
                return offset;
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset offset
               */
              static finishInferenceSessionBuffer(builder, offset) {
                builder.finish(offset, "ORTM");
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset offset
               */
              static finishSizePrefixedInferenceSessionBuffer(builder, offset) {
                builder.finish(offset, "ORTM", true);
              }
              static createInferenceSession(builder, ortVersionOffset, modelOffset, sessionStateOffset) {
                InferenceSession7.startInferenceSession(builder);
                InferenceSession7.addOrtVersion(builder, ortVersionOffset);
                InferenceSession7.addModel(builder, modelOffset);
                InferenceSession7.addSessionState(builder, sessionStateOffset);
                return InferenceSession7.endInferenceSession(builder);
              }
            }
            fbs2.InferenceSession = InferenceSession7;
          })(fbs = experimental2.fbs || (experimental2.fbs = {}));
        })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
      })(onnxruntime || (onnxruntime = {}));
    }
  });

  // web/node_modules/@protobufjs/aspromise/index.js
  var require_aspromise = __commonJS({
    "web/node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
      "use strict";
      module2.exports = asPromise;
      function asPromise(fn, ctx) {
        var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
        while (index < arguments.length)
          params[offset++] = arguments[index++];
        return new Promise(function executor(resolve, reject) {
          params[offset] = function callback(err) {
            if (pending) {
              pending = false;
              if (err)
                reject(err);
              else {
                var params2 = new Array(arguments.length - 1), offset2 = 0;
                while (offset2 < params2.length)
                  params2[offset2++] = arguments[offset2];
                resolve.apply(null, params2);
              }
            }
          };
          try {
            fn.apply(ctx || null, params);
          } catch (err) {
            if (pending) {
              pending = false;
              reject(err);
            }
          }
        });
      }
    }
  });

  // web/node_modules/@protobufjs/base64/index.js
  var require_base64 = __commonJS({
    "web/node_modules/@protobufjs/base64/index.js"(exports2) {
      "use strict";
      var base64 = exports2;
      base64.length = function length(string) {
        var p = string.length;
        if (!p)
          return 0;
        var n = 0;
        while (--p % 4 > 1 && string.charAt(p) === "=")
          ++n;
        return Math.ceil(string.length * 3) / 4 - n;
      };
      var b64 = new Array(64);
      var s64 = new Array(123);
      for (i = 0; i < 64; )
        s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
      var i;
      base64.encode = function encode(buffer, start, end) {
        var parts = null, chunk = [];
        var i2 = 0, j = 0, t;
        while (start < end) {
          var b = buffer[start++];
          switch (j) {
            case 0:
              chunk[i2++] = b64[b >> 2];
              t = (b & 3) << 4;
              j = 1;
              break;
            case 1:
              chunk[i2++] = b64[t | b >> 4];
              t = (b & 15) << 2;
              j = 2;
              break;
            case 2:
              chunk[i2++] = b64[t | b >> 6];
              chunk[i2++] = b64[b & 63];
              j = 0;
              break;
          }
          if (i2 > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i2 = 0;
          }
        }
        if (j) {
          chunk[i2++] = b64[t];
          chunk[i2++] = 61;
          if (j === 1)
            chunk[i2++] = 61;
        }
        if (parts) {
          if (i2)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
          return parts.join("");
        }
        return String.fromCharCode.apply(String, chunk.slice(0, i2));
      };
      var invalidEncoding = "invalid encoding";
      base64.decode = function decode(string, buffer, offset) {
        var start = offset;
        var j = 0, t;
        for (var i2 = 0; i2 < string.length; ) {
          var c = string.charCodeAt(i2++);
          if (c === 61 && j > 1)
            break;
          if ((c = s64[c]) === void 0)
            throw Error(invalidEncoding);
          switch (j) {
            case 0:
              t = c;
              j = 1;
              break;
            case 1:
              buffer[offset++] = t << 2 | (c & 48) >> 4;
              t = c;
              j = 2;
              break;
            case 2:
              buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
              t = c;
              j = 3;
              break;
            case 3:
              buffer[offset++] = (t & 3) << 6 | c;
              j = 0;
              break;
          }
        }
        if (j === 1)
          throw Error(invalidEncoding);
        return offset - start;
      };
      base64.test = function test(string) {
        return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
      };
    }
  });

  // web/node_modules/@protobufjs/eventemitter/index.js
  var require_eventemitter = __commonJS({
    "web/node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
      "use strict";
      module2.exports = EventEmitter;
      function EventEmitter() {
        this._listeners = {};
      }
      EventEmitter.prototype.on = function on(evt, fn, ctx) {
        (this._listeners[evt] || (this._listeners[evt] = [])).push({
          fn,
          ctx: ctx || this
        });
        return this;
      };
      EventEmitter.prototype.off = function off(evt, fn) {
        if (evt === void 0)
          this._listeners = {};
        else {
          if (fn === void 0)
            this._listeners[evt] = [];
          else {
            var listeners = this._listeners[evt];
            for (var i = 0; i < listeners.length; )
              if (listeners[i].fn === fn)
                listeners.splice(i, 1);
              else
                ++i;
          }
        }
        return this;
      };
      EventEmitter.prototype.emit = function emit(evt) {
        var listeners = this._listeners[evt];
        if (listeners) {
          var args = [], i = 1;
          for (; i < arguments.length; )
            args.push(arguments[i++]);
          for (i = 0; i < listeners.length; )
            listeners[i].fn.apply(listeners[i++].ctx, args);
        }
        return this;
      };
    }
  });

  // web/node_modules/@protobufjs/float/index.js
  var require_float = __commonJS({
    "web/node_modules/@protobufjs/float/index.js"(exports2, module2) {
      "use strict";
      module2.exports = factory(factory);
      function factory(exports3) {
        if (typeof Float32Array !== "undefined")
          (function() {
            var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
            function writeFloat_f32_cpy(val, buf, pos) {
              f32[0] = val;
              buf[pos] = f8b[0];
              buf[pos + 1] = f8b[1];
              buf[pos + 2] = f8b[2];
              buf[pos + 3] = f8b[3];
            }
            function writeFloat_f32_rev(val, buf, pos) {
              f32[0] = val;
              buf[pos] = f8b[3];
              buf[pos + 1] = f8b[2];
              buf[pos + 2] = f8b[1];
              buf[pos + 3] = f8b[0];
            }
            exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
            exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
            function readFloat_f32_cpy(buf, pos) {
              f8b[0] = buf[pos];
              f8b[1] = buf[pos + 1];
              f8b[2] = buf[pos + 2];
              f8b[3] = buf[pos + 3];
              return f32[0];
            }
            function readFloat_f32_rev(buf, pos) {
              f8b[3] = buf[pos];
              f8b[2] = buf[pos + 1];
              f8b[1] = buf[pos + 2];
              f8b[0] = buf[pos + 3];
              return f32[0];
            }
            exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
            exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
          })();
        else
          (function() {
            function writeFloat_ieee754(writeUint, val, buf, pos) {
              var sign = val < 0 ? 1 : 0;
              if (sign)
                val = -val;
              if (val === 0)
                writeUint(1 / val > 0 ? (
                  /* positive */
                  0
                ) : (
                  /* negative 0 */
                  2147483648
                ), buf, pos);
              else if (isNaN(val))
                writeUint(2143289344, buf, pos);
              else if (val > 34028234663852886e22)
                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
              else if (val < 11754943508222875e-54)
                writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);
              else {
                var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
              }
            }
            exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
            exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
            function readFloat_ieee754(readUint, buf, pos) {
              var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
              return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
            }
            exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
            exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
          })();
        if (typeof Float64Array !== "undefined")
          (function() {
            var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
            function writeDouble_f64_cpy(val, buf, pos) {
              f64[0] = val;
              buf[pos] = f8b[0];
              buf[pos + 1] = f8b[1];
              buf[pos + 2] = f8b[2];
              buf[pos + 3] = f8b[3];
              buf[pos + 4] = f8b[4];
              buf[pos + 5] = f8b[5];
              buf[pos + 6] = f8b[6];
              buf[pos + 7] = f8b[7];
            }
            function writeDouble_f64_rev(val, buf, pos) {
              f64[0] = val;
              buf[pos] = f8b[7];
              buf[pos + 1] = f8b[6];
              buf[pos + 2] = f8b[5];
              buf[pos + 3] = f8b[4];
              buf[pos + 4] = f8b[3];
              buf[pos + 5] = f8b[2];
              buf[pos + 6] = f8b[1];
              buf[pos + 7] = f8b[0];
            }
            exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
            exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
            function readDouble_f64_cpy(buf, pos) {
              f8b[0] = buf[pos];
              f8b[1] = buf[pos + 1];
              f8b[2] = buf[pos + 2];
              f8b[3] = buf[pos + 3];
              f8b[4] = buf[pos + 4];
              f8b[5] = buf[pos + 5];
              f8b[6] = buf[pos + 6];
              f8b[7] = buf[pos + 7];
              return f64[0];
            }
            function readDouble_f64_rev(buf, pos) {
              f8b[7] = buf[pos];
              f8b[6] = buf[pos + 1];
              f8b[5] = buf[pos + 2];
              f8b[4] = buf[pos + 3];
              f8b[3] = buf[pos + 4];
              f8b[2] = buf[pos + 5];
              f8b[1] = buf[pos + 6];
              f8b[0] = buf[pos + 7];
              return f64[0];
            }
            exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
            exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
          })();
        else
          (function() {
            function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
              var sign = val < 0 ? 1 : 0;
              if (sign)
                val = -val;
              if (val === 0) {
                writeUint(0, buf, pos + off0);
                writeUint(1 / val > 0 ? (
                  /* positive */
                  0
                ) : (
                  /* negative 0 */
                  2147483648
                ), buf, pos + off1);
              } else if (isNaN(val)) {
                writeUint(0, buf, pos + off0);
                writeUint(2146959360, buf, pos + off1);
              } else if (val > 17976931348623157e292) {
                writeUint(0, buf, pos + off0);
                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
              } else {
                var mantissa;
                if (val < 22250738585072014e-324) {
                  mantissa = val / 5e-324;
                  writeUint(mantissa >>> 0, buf, pos + off0);
                  writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
                } else {
                  var exponent = Math.floor(Math.log(val) / Math.LN2);
                  if (exponent === 1024)
                    exponent = 1023;
                  mantissa = val * Math.pow(2, -exponent);
                  writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                  writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
                }
              }
            }
            exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
            exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
            function readDouble_ieee754(readUint, off0, off1, buf, pos) {
              var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
              var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
              return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
            }
            exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
            exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
          })();
        return exports3;
      }
      function writeUintLE(val, buf, pos) {
        buf[pos] = val & 255;
        buf[pos + 1] = val >>> 8 & 255;
        buf[pos + 2] = val >>> 16 & 255;
        buf[pos + 3] = val >>> 24;
      }
      function writeUintBE(val, buf, pos) {
        buf[pos] = val >>> 24;
        buf[pos + 1] = val >>> 16 & 255;
        buf[pos + 2] = val >>> 8 & 255;
        buf[pos + 3] = val & 255;
      }
      function readUintLE(buf, pos) {
        return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
      }
      function readUintBE(buf, pos) {
        return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
      }
    }
  });

  // web/node_modules/@protobufjs/inquire/index.js
  var require_inquire = __commonJS({
    "web/node_modules/@protobufjs/inquire/index.js"(exports, module) {
      "use strict";
      module.exports = inquire;
      function inquire(moduleName) {
        try {
          var mod = eval("quire".replace(/^/, "re"))(moduleName);
          if (mod && (mod.length || Object.keys(mod).length))
            return mod;
        } catch (e) {
        }
        return null;
      }
    }
  });

  // web/node_modules/@protobufjs/utf8/index.js
  var require_utf8 = __commonJS({
    "web/node_modules/@protobufjs/utf8/index.js"(exports2) {
      "use strict";
      var utf8 = exports2;
      utf8.length = function utf8_length(string) {
        var len = 0, c = 0;
        for (var i = 0; i < string.length; ++i) {
          c = string.charCodeAt(i);
          if (c < 128)
            len += 1;
          else if (c < 2048)
            len += 2;
          else if ((c & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {
            ++i;
            len += 4;
          } else
            len += 3;
        }
        return len;
      };
      utf8.read = function utf8_read(buffer, start, end) {
        var len = end - start;
        if (len < 1)
          return "";
        var parts = null, chunk = [], i = 0, t;
        while (start < end) {
          t = buffer[start++];
          if (t < 128)
            chunk[i++] = t;
          else if (t > 191 && t < 224)
            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
          else if (t > 239 && t < 365) {
            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;
            chunk[i++] = 55296 + (t >> 10);
            chunk[i++] = 56320 + (t & 1023);
          } else
            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
          if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
          }
        }
        if (parts) {
          if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
          return parts.join("");
        }
        return String.fromCharCode.apply(String, chunk.slice(0, i));
      };
      utf8.write = function utf8_write(string, buffer, offset) {
        var start = offset, c1, c2;
        for (var i = 0; i < string.length; ++i) {
          c1 = string.charCodeAt(i);
          if (c1 < 128) {
            buffer[offset++] = c1;
          } else if (c1 < 2048) {
            buffer[offset++] = c1 >> 6 | 192;
            buffer[offset++] = c1 & 63 | 128;
          } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {
            c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
            ++i;
            buffer[offset++] = c1 >> 18 | 240;
            buffer[offset++] = c1 >> 12 & 63 | 128;
            buffer[offset++] = c1 >> 6 & 63 | 128;
            buffer[offset++] = c1 & 63 | 128;
          } else {
            buffer[offset++] = c1 >> 12 | 224;
            buffer[offset++] = c1 >> 6 & 63 | 128;
            buffer[offset++] = c1 & 63 | 128;
          }
        }
        return offset - start;
      };
    }
  });

  // web/node_modules/@protobufjs/pool/index.js
  var require_pool = __commonJS({
    "web/node_modules/@protobufjs/pool/index.js"(exports2, module2) {
      "use strict";
      module2.exports = pool;
      function pool(alloc, slice2, size) {
        var SIZE = size || 8192;
        var MAX = SIZE >>> 1;
        var slab = null;
        var offset = SIZE;
        return function pool_alloc(size2) {
          if (size2 < 1 || size2 > MAX)
            return alloc(size2);
          if (offset + size2 > SIZE) {
            slab = alloc(SIZE);
            offset = 0;
          }
          var buf = slice2.call(slab, offset, offset += size2);
          if (offset & 7)
            offset = (offset | 7) + 1;
          return buf;
        };
      }
    }
  });

  // web/node_modules/protobufjs/src/util/longbits.js
  var require_longbits = __commonJS({
    "web/node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
      "use strict";
      module2.exports = LongBits;
      var util = require_minimal();
      function LongBits(lo, hi) {
        this.lo = lo >>> 0;
        this.hi = hi >>> 0;
      }
      var zero = LongBits.zero = new LongBits(0, 0);
      zero.toNumber = function() {
        return 0;
      };
      zero.zzEncode = zero.zzDecode = function() {
        return this;
      };
      zero.length = function() {
        return 1;
      };
      var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
      LongBits.fromNumber = function fromNumber2(value) {
        if (value === 0)
          return zero;
        var sign = value < 0;
        if (sign)
          value = -value;
        var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
        if (sign) {
          hi = ~hi >>> 0;
          lo = ~lo >>> 0;
          if (++lo > 4294967295) {
            lo = 0;
            if (++hi > 4294967295)
              hi = 0;
          }
        }
        return new LongBits(lo, hi);
      };
      LongBits.from = function from(value) {
        if (typeof value === "number")
          return LongBits.fromNumber(value);
        if (util.isString(value)) {
          if (util.Long)
            value = util.Long.fromString(value);
          else
            return LongBits.fromNumber(parseInt(value, 10));
        }
        return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
      };
      LongBits.prototype.toNumber = function toNumber2(unsigned) {
        if (!unsigned && this.hi >>> 31) {
          var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
          if (!lo)
            hi = hi + 1 >>> 0;
          return -(lo + hi * 4294967296);
        }
        return this.lo + this.hi * 4294967296;
      };
      LongBits.prototype.toLong = function toLong(unsigned) {
        return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
      };
      var charCodeAt = String.prototype.charCodeAt;
      LongBits.fromHash = function fromHash(hash) {
        if (hash === zeroHash)
          return zero;
        return new LongBits(
          (charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0,
          (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0
        );
      };
      LongBits.prototype.toHash = function toHash() {
        return String.fromCharCode(
          this.lo & 255,
          this.lo >>> 8 & 255,
          this.lo >>> 16 & 255,
          this.lo >>> 24,
          this.hi & 255,
          this.hi >>> 8 & 255,
          this.hi >>> 16 & 255,
          this.hi >>> 24
        );
      };
      LongBits.prototype.zzEncode = function zzEncode() {
        var mask = this.hi >> 31;
        this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
        this.lo = (this.lo << 1 ^ mask) >>> 0;
        return this;
      };
      LongBits.prototype.zzDecode = function zzDecode() {
        var mask = -(this.lo & 1);
        this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
        this.hi = (this.hi >>> 1 ^ mask) >>> 0;
        return this;
      };
      LongBits.prototype.length = function length() {
        var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
        return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
      };
    }
  });

  // web/node_modules/protobufjs/src/util/minimal.js
  var require_minimal = __commonJS({
    "web/node_modules/protobufjs/src/util/minimal.js"(exports2) {
      "use strict";
      var util = exports2;
      util.asPromise = require_aspromise();
      util.base64 = require_base64();
      util.EventEmitter = require_eventemitter();
      util.float = require_float();
      util.inquire = require_inquire();
      util.utf8 = require_utf8();
      util.pool = require_pool();
      util.LongBits = require_longbits();
      util.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
      util.global = util.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
      util.emptyArray = Object.freeze ? Object.freeze([]) : (
        /* istanbul ignore next */
        []
      );
      util.emptyObject = Object.freeze ? Object.freeze({}) : (
        /* istanbul ignore next */
        {}
      );
      util.isInteger = Number.isInteger || /* istanbul ignore next */
      function isInteger(value) {
        return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
      };
      util.isString = function isString(value) {
        return typeof value === "string" || value instanceof String;
      };
      util.isObject = function isObject(value) {
        return value && typeof value === "object";
      };
      util.isset = /**
       * Checks if a property on a message is considered to be present.
       * @param {Object} obj Plain object or message instance
       * @param {string} prop Property name
       * @returns {boolean} `true` if considered to be present, otherwise `false`
       */
      util.isSet = function isSet(obj, prop) {
        var value = obj[prop];
        if (value != null && obj.hasOwnProperty(prop))
          return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
        return false;
      };
      util.Buffer = function() {
        try {
          var Buffer2 = util.inquire("buffer").Buffer;
          return Buffer2.prototype.utf8Write ? Buffer2 : (
            /* istanbul ignore next */
            null
          );
        } catch (e) {
          return null;
        }
      }();
      util._Buffer_from = null;
      util._Buffer_allocUnsafe = null;
      util.newBuffer = function newBuffer(sizeOrArray) {
        return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
      };
      util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      util.Long = /* istanbul ignore next */
      util.global.dcodeIO && /* istanbul ignore next */
      util.global.dcodeIO.Long || /* istanbul ignore next */
      util.global.Long || util.inquire("long");
      util.key2Re = /^true|false|0|1$/;
      util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
      util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
      util.longToHash = function longToHash(value) {
        return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
      };
      util.longFromHash = function longFromHash(hash, unsigned) {
        var bits = util.LongBits.fromHash(hash);
        if (util.Long)
          return util.Long.fromBits(bits.lo, bits.hi, unsigned);
        return bits.toNumber(Boolean(unsigned));
      };
      function merge(dst, src, ifNotSet) {
        for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
          if (dst[keys[i]] === void 0 || !ifNotSet)
            dst[keys[i]] = src[keys[i]];
        return dst;
      }
      util.merge = merge;
      util.lcFirst = function lcFirst(str) {
        return str.charAt(0).toLowerCase() + str.substring(1);
      };
      function newError(name2) {
        function CustomError(message, properties) {
          if (!(this instanceof CustomError))
            return new CustomError(message, properties);
          Object.defineProperty(this, "message", { get: function() {
            return message;
          } });
          if (Error.captureStackTrace)
            Error.captureStackTrace(this, CustomError);
          else
            Object.defineProperty(this, "stack", { value: new Error().stack || "" });
          if (properties)
            merge(this, properties);
        }
        CustomError.prototype = Object.create(Error.prototype, {
          constructor: {
            value: CustomError,
            writable: true,
            enumerable: false,
            configurable: true
          },
          name: {
            get: function get() {
              return name2;
            },
            set: void 0,
            enumerable: false,
            // configurable: false would accurately preserve the behavior of
            // the original, but I'm guessing that was not intentional.
            // For an actual error subclass, this property would
            // be configurable.
            configurable: true
          },
          toString: {
            value: function value() {
              return this.name + ": " + this.message;
            },
            writable: true,
            enumerable: false,
            configurable: true
          }
        });
        return CustomError;
      }
      util.newError = newError;
      util.ProtocolError = newError("ProtocolError");
      util.oneOfGetter = function getOneOf(fieldNames) {
        var fieldMap = {};
        for (var i = 0; i < fieldNames.length; ++i)
          fieldMap[fieldNames[i]] = 1;
        return function() {
          for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)
            if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)
              return keys[i2];
        };
      };
      util.oneOfSetter = function setOneOf(fieldNames) {
        return function(name2) {
          for (var i = 0; i < fieldNames.length; ++i)
            if (fieldNames[i] !== name2)
              delete this[fieldNames[i]];
        };
      };
      util.toJSONOptions = {
        longs: String,
        enums: String,
        bytes: String,
        json: true
      };
      util._configure = function() {
        var Buffer2 = util.Buffer;
        if (!Buffer2) {
          util._Buffer_from = util._Buffer_allocUnsafe = null;
          return;
        }
        util._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || /* istanbul ignore next */
        function Buffer_from(value, encoding) {
          return new Buffer2(value, encoding);
        };
        util._Buffer_allocUnsafe = Buffer2.allocUnsafe || /* istanbul ignore next */
        function Buffer_allocUnsafe(size) {
          return new Buffer2(size);
        };
      };
    }
  });

  // web/node_modules/protobufjs/src/writer.js
  var require_writer = __commonJS({
    "web/node_modules/protobufjs/src/writer.js"(exports2, module2) {
      "use strict";
      module2.exports = Writer;
      var util = require_minimal();
      var BufferWriter;
      var LongBits = util.LongBits;
      var base64 = util.base64;
      var utf8 = util.utf8;
      function Op(fn, len, val) {
        this.fn = fn;
        this.len = len;
        this.next = void 0;
        this.val = val;
      }
      function noop() {
      }
      function State(writer) {
        this.head = writer.head;
        this.tail = writer.tail;
        this.len = writer.len;
        this.next = writer.states;
      }
      function Writer() {
        this.len = 0;
        this.head = new Op(noop, 0, 0);
        this.tail = this.head;
        this.states = null;
      }
      var create = function create2() {
        return util.Buffer ? function create_buffer_setup() {
          return (Writer.create = function create_buffer() {
            return new BufferWriter();
          })();
        } : function create_array() {
          return new Writer();
        };
      };
      Writer.create = create();
      Writer.alloc = function alloc(size) {
        return new util.Array(size);
      };
      if (util.Array !== Array)
        Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
      Writer.prototype._push = function push(fn, len, val) {
        this.tail = this.tail.next = new Op(fn, len, val);
        this.len += len;
        return this;
      };
      function writeByte(val, buf, pos) {
        buf[pos] = val & 255;
      }
      function writeVarint32(val, buf, pos) {
        while (val > 127) {
          buf[pos++] = val & 127 | 128;
          val >>>= 7;
        }
        buf[pos] = val;
      }
      function VarintOp(len, val) {
        this.len = len;
        this.next = void 0;
        this.val = val;
      }
      VarintOp.prototype = Object.create(Op.prototype);
      VarintOp.prototype.fn = writeVarint32;
      Writer.prototype.uint32 = function write_uint32(value) {
        this.len += (this.tail = this.tail.next = new VarintOp(
          (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
          value
        )).len;
        return this;
      };
      Writer.prototype.int32 = function write_int32(value) {
        return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
      };
      Writer.prototype.sint32 = function write_sint32(value) {
        return this.uint32((value << 1 ^ value >> 31) >>> 0);
      };
      function writeVarint64(val, buf, pos) {
        while (val.hi) {
          buf[pos++] = val.lo & 127 | 128;
          val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
          val.hi >>>= 7;
        }
        while (val.lo > 127) {
          buf[pos++] = val.lo & 127 | 128;
          val.lo = val.lo >>> 7;
        }
        buf[pos++] = val.lo;
      }
      Writer.prototype.uint64 = function write_uint64(value) {
        var bits = LongBits.from(value);
        return this._push(writeVarint64, bits.length(), bits);
      };
      Writer.prototype.int64 = Writer.prototype.uint64;
      Writer.prototype.sint64 = function write_sint64(value) {
        var bits = LongBits.from(value).zzEncode();
        return this._push(writeVarint64, bits.length(), bits);
      };
      Writer.prototype.bool = function write_bool(value) {
        return this._push(writeByte, 1, value ? 1 : 0);
      };
      function writeFixed32(val, buf, pos) {
        buf[pos] = val & 255;
        buf[pos + 1] = val >>> 8 & 255;
        buf[pos + 2] = val >>> 16 & 255;
        buf[pos + 3] = val >>> 24;
      }
      Writer.prototype.fixed32 = function write_fixed32(value) {
        return this._push(writeFixed32, 4, value >>> 0);
      };
      Writer.prototype.sfixed32 = Writer.prototype.fixed32;
      Writer.prototype.fixed64 = function write_fixed64(value) {
        var bits = LongBits.from(value);
        return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
      };
      Writer.prototype.sfixed64 = Writer.prototype.fixed64;
      Writer.prototype.float = function write_float(value) {
        return this._push(util.float.writeFloatLE, 4, value);
      };
      Writer.prototype.double = function write_double(value) {
        return this._push(util.float.writeDoubleLE, 8, value);
      };
      var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
        buf.set(val, pos);
      } : function writeBytes_for(val, buf, pos) {
        for (var i = 0; i < val.length; ++i)
          buf[pos + i] = val[i];
      };
      Writer.prototype.bytes = function write_bytes(value) {
        var len = value.length >>> 0;
        if (!len)
          return this._push(writeByte, 1, 0);
        if (util.isString(value)) {
          var buf = Writer.alloc(len = base64.length(value));
          base64.decode(value, buf, 0);
          value = buf;
        }
        return this.uint32(len)._push(writeBytes, len, value);
      };
      Writer.prototype.string = function write_string(value) {
        var len = utf8.length(value);
        return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
      };
      Writer.prototype.fork = function fork() {
        this.states = new State(this);
        this.head = this.tail = new Op(noop, 0, 0);
        this.len = 0;
        return this;
      };
      Writer.prototype.reset = function reset() {
        if (this.states) {
          this.head = this.states.head;
          this.tail = this.states.tail;
          this.len = this.states.len;
          this.states = this.states.next;
        } else {
          this.head = this.tail = new Op(noop, 0, 0);
          this.len = 0;
        }
        return this;
      };
      Writer.prototype.ldelim = function ldelim() {
        var head = this.head, tail = this.tail, len = this.len;
        this.reset().uint32(len);
        if (len) {
          this.tail.next = head.next;
          this.tail = tail;
          this.len += len;
        }
        return this;
      };
      Writer.prototype.finish = function finish() {
        var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
        while (head) {
          head.fn(head.val, buf, pos);
          pos += head.len;
          head = head.next;
        }
        return buf;
      };
      Writer._configure = function(BufferWriter_) {
        BufferWriter = BufferWriter_;
        Writer.create = create();
        BufferWriter._configure();
      };
    }
  });

  // web/node_modules/protobufjs/src/writer_buffer.js
  var require_writer_buffer = __commonJS({
    "web/node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
      "use strict";
      module2.exports = BufferWriter;
      var Writer = require_writer();
      (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
      var util = require_minimal();
      function BufferWriter() {
        Writer.call(this);
      }
      BufferWriter._configure = function() {
        BufferWriter.alloc = util._Buffer_allocUnsafe;
        BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
          buf.set(val, pos);
        } : function writeBytesBuffer_copy(val, buf, pos) {
          if (val.copy)
            val.copy(buf, pos, 0, val.length);
          else
            for (var i = 0; i < val.length; )
              buf[pos++] = val[i++];
        };
      };
      BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
        if (util.isString(value))
          value = util._Buffer_from(value, "base64");
        var len = value.length >>> 0;
        this.uint32(len);
        if (len)
          this._push(BufferWriter.writeBytesBuffer, len, value);
        return this;
      };
      function writeStringBuffer(val, buf, pos) {
        if (val.length < 40)
          util.utf8.write(val, buf, pos);
        else if (buf.utf8Write)
          buf.utf8Write(val, pos);
        else
          buf.write(val, pos);
      }
      BufferWriter.prototype.string = function write_string_buffer(value) {
        var len = util.Buffer.byteLength(value);
        this.uint32(len);
        if (len)
          this._push(writeStringBuffer, len, value);
        return this;
      };
      BufferWriter._configure();
    }
  });

  // web/node_modules/protobufjs/src/reader.js
  var require_reader = __commonJS({
    "web/node_modules/protobufjs/src/reader.js"(exports2, module2) {
      "use strict";
      module2.exports = Reader;
      var util = require_minimal();
      var BufferReader;
      var LongBits = util.LongBits;
      var utf8 = util.utf8;
      function indexOutOfRange(reader, writeLength) {
        return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
      }
      function Reader(buffer) {
        this.buf = buffer;
        this.pos = 0;
        this.len = buffer.length;
      }
      var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer) {
        if (buffer instanceof Uint8Array || Array.isArray(buffer))
          return new Reader(buffer);
        throw Error("illegal buffer");
      } : function create_array2(buffer) {
        if (Array.isArray(buffer))
          return new Reader(buffer);
        throw Error("illegal buffer");
      };
      var create = function create2() {
        return util.Buffer ? function create_buffer_setup(buffer) {
          return (Reader.create = function create_buffer(buffer2) {
            return util.Buffer.isBuffer(buffer2) ? new BufferReader(buffer2) : create_array(buffer2);
          })(buffer);
        } : create_array;
      };
      Reader.create = create();
      Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */
      util.Array.prototype.slice;
      Reader.prototype.uint32 = function read_uint32_setup() {
        var value = 4294967295;
        return function read_uint32() {
          value = (this.buf[this.pos] & 127) >>> 0;
          if (this.buf[this.pos++] < 128)
            return value;
          value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return value;
          value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
          if (this.buf[this.pos++] < 128)
            return value;
          value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
          if (this.buf[this.pos++] < 128)
            return value;
          value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
          if (this.buf[this.pos++] < 128)
            return value;
          if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
          }
          return value;
        };
      }();
      Reader.prototype.int32 = function read_int32() {
        return this.uint32() | 0;
      };
      Reader.prototype.sint32 = function read_sint32() {
        var value = this.uint32();
        return value >>> 1 ^ -(value & 1) | 0;
      };
      function readLongVarint() {
        var bits = new LongBits(0, 0);
        var i = 0;
        if (this.len - this.pos > 4) {
          for (; i < 4; ++i) {
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
              return bits;
          }
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
          i = 0;
        } else {
          for (; i < 3; ++i) {
            if (this.pos >= this.len)
              throw indexOutOfRange(this);
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
              return bits;
          }
          bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
          return bits;
        }
        if (this.len - this.pos > 4) {
          for (; i < 5; ++i) {
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
              return bits;
          }
        } else {
          for (; i < 5; ++i) {
            if (this.pos >= this.len)
              throw indexOutOfRange(this);
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
              return bits;
          }
        }
        throw Error("invalid varint encoding");
      }
      Reader.prototype.bool = function read_bool() {
        return this.uint32() !== 0;
      };
      function readFixed32_end(buf, end) {
        return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
      }
      Reader.prototype.fixed32 = function read_fixed32() {
        if (this.pos + 4 > this.len)
          throw indexOutOfRange(this, 4);
        return readFixed32_end(this.buf, this.pos += 4);
      };
      Reader.prototype.sfixed32 = function read_sfixed32() {
        if (this.pos + 4 > this.len)
          throw indexOutOfRange(this, 4);
        return readFixed32_end(this.buf, this.pos += 4) | 0;
      };
      function readFixed64() {
        if (this.pos + 8 > this.len)
          throw indexOutOfRange(this, 8);
        return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
      }
      Reader.prototype.float = function read_float() {
        if (this.pos + 4 > this.len)
          throw indexOutOfRange(this, 4);
        var value = util.float.readFloatLE(this.buf, this.pos);
        this.pos += 4;
        return value;
      };
      Reader.prototype.double = function read_double() {
        if (this.pos + 8 > this.len)
          throw indexOutOfRange(this, 4);
        var value = util.float.readDoubleLE(this.buf, this.pos);
        this.pos += 8;
        return value;
      };
      Reader.prototype.bytes = function read_bytes() {
        var length = this.uint32(), start = this.pos, end = this.pos + length;
        if (end > this.len)
          throw indexOutOfRange(this, length);
        this.pos += length;
        if (Array.isArray(this.buf))
          return this.buf.slice(start, end);
        if (start === end) {
          var nativeBuffer = util.Buffer;
          return nativeBuffer ? nativeBuffer.alloc(0) : new this.buf.constructor(0);
        }
        return this._slice.call(this.buf, start, end);
      };
      Reader.prototype.string = function read_string() {
        var bytes = this.bytes();
        return utf8.read(bytes, 0, bytes.length);
      };
      Reader.prototype.skip = function skip(length) {
        if (typeof length === "number") {
          if (this.pos + length > this.len)
            throw indexOutOfRange(this, length);
          this.pos += length;
        } else {
          do {
            if (this.pos >= this.len)
              throw indexOutOfRange(this);
          } while (this.buf[this.pos++] & 128);
        }
        return this;
      };
      Reader.prototype.skipType = function(wireType) {
        switch (wireType) {
          case 0:
            this.skip();
            break;
          case 1:
            this.skip(8);
            break;
          case 2:
            this.skip(this.uint32());
            break;
          case 3:
            while ((wireType = this.uint32() & 7) !== 4) {
              this.skipType(wireType);
            }
            break;
          case 5:
            this.skip(4);
            break;
          default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
        }
        return this;
      };
      Reader._configure = function(BufferReader_) {
        BufferReader = BufferReader_;
        Reader.create = create();
        BufferReader._configure();
        var fn = util.Long ? "toLong" : (
          /* istanbul ignore next */
          "toNumber"
        );
        util.merge(Reader.prototype, {
          int64: function read_int64() {
            return readLongVarint.call(this)[fn](false);
          },
          uint64: function read_uint64() {
            return readLongVarint.call(this)[fn](true);
          },
          sint64: function read_sint64() {
            return readLongVarint.call(this).zzDecode()[fn](false);
          },
          fixed64: function read_fixed64() {
            return readFixed64.call(this)[fn](true);
          },
          sfixed64: function read_sfixed64() {
            return readFixed64.call(this)[fn](false);
          }
        });
      };
    }
  });

  // web/node_modules/protobufjs/src/reader_buffer.js
  var require_reader_buffer = __commonJS({
    "web/node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
      "use strict";
      module2.exports = BufferReader;
      var Reader = require_reader();
      (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
      var util = require_minimal();
      function BufferReader(buffer) {
        Reader.call(this, buffer);
      }
      BufferReader._configure = function() {
        if (util.Buffer)
          BufferReader.prototype._slice = util.Buffer.prototype.slice;
      };
      BufferReader.prototype.string = function read_string_buffer() {
        var len = this.uint32();
        return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
      };
      BufferReader._configure();
    }
  });

  // web/node_modules/protobufjs/src/rpc/service.js
  var require_service = __commonJS({
    "web/node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
      "use strict";
      module2.exports = Service;
      var util = require_minimal();
      (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
      function Service(rpcImpl, requestDelimited, responseDelimited) {
        if (typeof rpcImpl !== "function")
          throw TypeError("rpcImpl must be a function");
        util.EventEmitter.call(this);
        this.rpcImpl = rpcImpl;
        this.requestDelimited = Boolean(requestDelimited);
        this.responseDelimited = Boolean(responseDelimited);
      }
      Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
        if (!request)
          throw TypeError("request must be specified");
        var self2 = this;
        if (!callback)
          return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
        if (!self2.rpcImpl) {
          setTimeout(function() {
            callback(Error("already ended"));
          }, 0);
          return void 0;
        }
        try {
          return self2.rpcImpl(
            method,
            requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
            function rpcCallback(err, response) {
              if (err) {
                self2.emit("error", err, method);
                return callback(err);
              }
              if (response === null) {
                self2.end(
                  /* endedByRPC */
                  true
                );
                return void 0;
              }
              if (!(response instanceof responseCtor)) {
                try {
                  response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
                } catch (err2) {
                  self2.emit("error", err2, method);
                  return callback(err2);
                }
              }
              self2.emit("data", response, method);
              return callback(null, response);
            }
          );
        } catch (err) {
          self2.emit("error", err, method);
          setTimeout(function() {
            callback(err);
          }, 0);
          return void 0;
        }
      };
      Service.prototype.end = function end(endedByRPC) {
        if (this.rpcImpl) {
          if (!endedByRPC)
            this.rpcImpl(null, null, null);
          this.rpcImpl = null;
          this.emit("end").off();
        }
        return this;
      };
    }
  });

  // web/node_modules/protobufjs/src/rpc.js
  var require_rpc = __commonJS({
    "web/node_modules/protobufjs/src/rpc.js"(exports2) {
      "use strict";
      var rpc = exports2;
      rpc.Service = require_service();
    }
  });

  // web/node_modules/protobufjs/src/roots.js
  var require_roots = __commonJS({
    "web/node_modules/protobufjs/src/roots.js"(exports2, module2) {
      "use strict";
      module2.exports = {};
    }
  });

  // web/node_modules/protobufjs/src/index-minimal.js
  var require_index_minimal = __commonJS({
    "web/node_modules/protobufjs/src/index-minimal.js"(exports2) {
      "use strict";
      var protobuf = exports2;
      protobuf.build = "minimal";
      protobuf.Writer = require_writer();
      protobuf.BufferWriter = require_writer_buffer();
      protobuf.Reader = require_reader();
      protobuf.BufferReader = require_reader_buffer();
      protobuf.util = require_minimal();
      protobuf.rpc = require_rpc();
      protobuf.roots = require_roots();
      protobuf.configure = configure;
      function configure() {
        protobuf.util._configure();
        protobuf.Writer._configure(protobuf.BufferWriter);
        protobuf.Reader._configure(protobuf.BufferReader);
      }
      configure();
    }
  });

  // web/node_modules/protobufjs/minimal.js
  var require_minimal2 = __commonJS({
    "web/node_modules/protobufjs/minimal.js"(exports2, module2) {
      "use strict";
      module2.exports = require_index_minimal();
    }
  });

  // web/lib/onnxjs/ort-schema/protobuf/onnx.js
  var require_onnx = __commonJS({
    "web/lib/onnxjs/ort-schema/protobuf/onnx.js"(exports2, module2) {
      "use strict";
      var $protobuf = require_minimal2();
      var $Reader = $protobuf.Reader;
      var $Writer = $protobuf.Writer;
      var $util = $protobuf.util;
      var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
      $root.onnx = function() {
        var onnx6 = {};
        onnx6.Version = function() {
          var valuesById = {}, values = Object.create(valuesById);
          values[valuesById[0] = "_START_VERSION"] = 0;
          values[valuesById[1] = "IR_VERSION_2017_10_10"] = 1;
          values[valuesById[2] = "IR_VERSION_2017_10_30"] = 2;
          values[valuesById[3] = "IR_VERSION_2017_11_3"] = 3;
          values[valuesById[4] = "IR_VERSION_2019_1_22"] = 4;
          values[valuesById[5] = "IR_VERSION_2019_3_18"] = 5;
          values[valuesById[6] = "IR_VERSION_2019_9_19"] = 6;
          values[valuesById[7] = "IR_VERSION_2020_5_8"] = 7;
          values[valuesById[8] = "IR_VERSION_2021_7_30"] = 8;
          values[valuesById[9] = "IR_VERSION"] = 9;
          return values;
        }();
        onnx6.AttributeProto = function() {
          function AttributeProto(properties) {
            this.floats = [];
            this.ints = [];
            this.strings = [];
            this.tensors = [];
            this.graphs = [];
            this.sparseTensors = [];
            this.typeProtos = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          AttributeProto.prototype.name = "";
          AttributeProto.prototype.refAttrName = "";
          AttributeProto.prototype.docString = "";
          AttributeProto.prototype.type = 0;
          AttributeProto.prototype.f = 0;
          AttributeProto.prototype.i = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
          AttributeProto.prototype.s = $util.newBuffer([]);
          AttributeProto.prototype.t = null;
          AttributeProto.prototype.g = null;
          AttributeProto.prototype.sparseTensor = null;
          AttributeProto.prototype.tp = null;
          AttributeProto.prototype.floats = $util.emptyArray;
          AttributeProto.prototype.ints = $util.emptyArray;
          AttributeProto.prototype.strings = $util.emptyArray;
          AttributeProto.prototype.tensors = $util.emptyArray;
          AttributeProto.prototype.graphs = $util.emptyArray;
          AttributeProto.prototype.sparseTensors = $util.emptyArray;
          AttributeProto.prototype.typeProtos = $util.emptyArray;
          AttributeProto.create = function create(properties) {
            return new AttributeProto(properties);
          };
          AttributeProto.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(message.name);
            if (message.f != null && Object.hasOwnProperty.call(message, "f"))
              writer.uint32(
                /* id 2, wireType 5 =*/
                21
              ).float(message.f);
            if (message.i != null && Object.hasOwnProperty.call(message, "i"))
              writer.uint32(
                /* id 3, wireType 0 =*/
                24
              ).int64(message.i);
            if (message.s != null && Object.hasOwnProperty.call(message, "s"))
              writer.uint32(
                /* id 4, wireType 2 =*/
                34
              ).bytes(message.s);
            if (message.t != null && Object.hasOwnProperty.call(message, "t"))
              $root.onnx.TensorProto.encode(message.t, writer.uint32(
                /* id 5, wireType 2 =*/
                42
              ).fork()).ldelim();
            if (message.g != null && Object.hasOwnProperty.call(message, "g"))
              $root.onnx.GraphProto.encode(message.g, writer.uint32(
                /* id 6, wireType 2 =*/
                50
              ).fork()).ldelim();
            if (message.floats != null && message.floats.length) {
              writer.uint32(
                /* id 7, wireType 2 =*/
                58
              ).fork();
              for (var i = 0; i < message.floats.length; ++i)
                writer.float(message.floats[i]);
              writer.ldelim();
            }
            if (message.ints != null && message.ints.length) {
              writer.uint32(
                /* id 8, wireType 2 =*/
                66
              ).fork();
              for (var i = 0; i < message.ints.length; ++i)
                writer.int64(message.ints[i]);
              writer.ldelim();
            }
            if (message.strings != null && message.strings.length)
              for (var i = 0; i < message.strings.length; ++i)
                writer.uint32(
                  /* id 9, wireType 2 =*/
                  74
                ).bytes(message.strings[i]);
            if (message.tensors != null && message.tensors.length)
              for (var i = 0; i < message.tensors.length; ++i)
                $root.onnx.TensorProto.encode(message.tensors[i], writer.uint32(
                  /* id 10, wireType 2 =*/
                  82
                ).fork()).ldelim();
            if (message.graphs != null && message.graphs.length)
              for (var i = 0; i < message.graphs.length; ++i)
                $root.onnx.GraphProto.encode(message.graphs[i], writer.uint32(
                  /* id 11, wireType 2 =*/
                  90
                ).fork()).ldelim();
            if (message.docString != null && Object.hasOwnProperty.call(message, "docString"))
              writer.uint32(
                /* id 13, wireType 2 =*/
                106
              ).string(message.docString);
            if (message.tp != null && Object.hasOwnProperty.call(message, "tp"))
              $root.onnx.TypeProto.encode(message.tp, writer.uint32(
                /* id 14, wireType 2 =*/
                114
              ).fork()).ldelim();
            if (message.typeProtos != null && message.typeProtos.length)
              for (var i = 0; i < message.typeProtos.length; ++i)
                $root.onnx.TypeProto.encode(
                  message.typeProtos[i],
                  writer.uint32(
                    /* id 15, wireType 2 =*/
                    122
                  ).fork()
                ).ldelim();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
              writer.uint32(
                /* id 20, wireType 0 =*/
                160
              ).int32(message.type);
            if (message.refAttrName != null && Object.hasOwnProperty.call(message, "refAttrName"))
              writer.uint32(
                /* id 21, wireType 2 =*/
                170
              ).string(message.refAttrName);
            if (message.sparseTensor != null && Object.hasOwnProperty.call(message, "sparseTensor"))
              $root.onnx.SparseTensorProto.encode(
                message.sparseTensor,
                writer.uint32(
                  /* id 22, wireType 2 =*/
                  178
                ).fork()
              ).ldelim();
            if (message.sparseTensors != null && message.sparseTensors.length)
              for (var i = 0; i < message.sparseTensors.length; ++i)
                $root.onnx.SparseTensorProto.encode(
                  message.sparseTensors[i],
                  writer.uint32(
                    /* id 23, wireType 2 =*/
                    186
                  ).fork()
                ).ldelim();
            return writer;
          };
          AttributeProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          AttributeProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.AttributeProto();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.name = reader.string();
                  break;
                }
                case 21: {
                  message.refAttrName = reader.string();
                  break;
                }
                case 13: {
                  message.docString = reader.string();
                  break;
                }
                case 20: {
                  message.type = reader.int32();
                  break;
                }
                case 2: {
                  message.f = reader.float();
                  break;
                }
                case 3: {
                  message.i = reader.int64();
                  break;
                }
                case 4: {
                  message.s = reader.bytes();
                  break;
                }
                case 5: {
                  message.t = $root.onnx.TensorProto.decode(reader, reader.uint32());
                  break;
                }
                case 6: {
                  message.g = $root.onnx.GraphProto.decode(reader, reader.uint32());
                  break;
                }
                case 22: {
                  message.sparseTensor = $root.onnx.SparseTensorProto.decode(reader, reader.uint32());
                  break;
                }
                case 14: {
                  message.tp = $root.onnx.TypeProto.decode(reader, reader.uint32());
                  break;
                }
                case 7: {
                  if (!(message.floats && message.floats.length))
                    message.floats = [];
                  if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                      message.floats.push(reader.float());
                  } else
                    message.floats.push(reader.float());
                  break;
                }
                case 8: {
                  if (!(message.ints && message.ints.length))
                    message.ints = [];
                  if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                      message.ints.push(reader.int64());
                  } else
                    message.ints.push(reader.int64());
                  break;
                }
                case 9: {
                  if (!(message.strings && message.strings.length))
                    message.strings = [];
                  message.strings.push(reader.bytes());
                  break;
                }
                case 10: {
                  if (!(message.tensors && message.tensors.length))
                    message.tensors = [];
                  message.tensors.push($root.onnx.TensorProto.decode(reader, reader.uint32()));
                  break;
                }
                case 11: {
                  if (!(message.graphs && message.graphs.length))
                    message.graphs = [];
                  message.graphs.push($root.onnx.GraphProto.decode(reader, reader.uint32()));
                  break;
                }
                case 23: {
                  if (!(message.sparseTensors && message.sparseTensors.length))
                    message.sparseTensors = [];
                  message.sparseTensors.push($root.onnx.SparseTensorProto.decode(reader, reader.uint32()));
                  break;
                }
                case 15: {
                  if (!(message.typeProtos && message.typeProtos.length))
                    message.typeProtos = [];
                  message.typeProtos.push($root.onnx.TypeProto.decode(reader, reader.uint32()));
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          AttributeProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          AttributeProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.name != null && message.hasOwnProperty("name")) {
              if (!$util.isString(message.name))
                return "name: string expected";
            }
            if (message.refAttrName != null && message.hasOwnProperty("refAttrName")) {
              if (!$util.isString(message.refAttrName))
                return "refAttrName: string expected";
            }
            if (message.docString != null && message.hasOwnProperty("docString")) {
              if (!$util.isString(message.docString))
                return "docString: string expected";
            }
            if (message.type != null && message.hasOwnProperty("type"))
              switch (message.type) {
                default:
                  return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 11:
                case 13:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 12:
                case 14:
                  break;
              }
            if (message.f != null && message.hasOwnProperty("f")) {
              if (typeof message.f !== "number")
                return "f: number expected";
            }
            if (message.i != null && message.hasOwnProperty("i")) {
              if (!$util.isInteger(message.i) && !(message.i && $util.isInteger(message.i.low) && $util.isInteger(message.i.high)))
                return "i: integer|Long expected";
            }
            if (message.s != null && message.hasOwnProperty("s")) {
              if (!(message.s && typeof message.s.length === "number" || $util.isString(message.s)))
                return "s: buffer expected";
            }
            if (message.t != null && message.hasOwnProperty("t")) {
              var error = $root.onnx.TensorProto.verify(message.t);
              if (error)
                return "t." + error;
            }
            if (message.g != null && message.hasOwnProperty("g")) {
              var error = $root.onnx.GraphProto.verify(message.g);
              if (error)
                return "g." + error;
            }
            if (message.sparseTensor != null && message.hasOwnProperty("sparseTensor")) {
              var error = $root.onnx.SparseTensorProto.verify(message.sparseTensor);
              if (error)
                return "sparseTensor." + error;
            }
            if (message.tp != null && message.hasOwnProperty("tp")) {
              var error = $root.onnx.TypeProto.verify(message.tp);
              if (error)
                return "tp." + error;
            }
            if (message.floats != null && message.hasOwnProperty("floats")) {
              if (!Array.isArray(message.floats))
                return "floats: array expected";
              for (var i = 0; i < message.floats.length; ++i)
                if (typeof message.floats[i] !== "number")
                  return "floats: number[] expected";
            }
            if (message.ints != null && message.hasOwnProperty("ints")) {
              if (!Array.isArray(message.ints))
                return "ints: array expected";
              for (var i = 0; i < message.ints.length; ++i)
                if (!$util.isInteger(message.ints[i]) && !(message.ints[i] && $util.isInteger(message.ints[i].low) && $util.isInteger(message.ints[i].high)))
                  return "ints: integer|Long[] expected";
            }
            if (message.strings != null && message.hasOwnProperty("strings")) {
              if (!Array.isArray(message.strings))
                return "strings: array expected";
              for (var i = 0; i < message.strings.length; ++i)
                if (!(message.strings[i] && typeof message.strings[i].length === "number" || $util.isString(message.strings[i])))
                  return "strings: buffer[] expected";
            }
            if (message.tensors != null && message.hasOwnProperty("tensors")) {
              if (!Array.isArray(message.tensors))
                return "tensors: array expected";
              for (var i = 0; i < message.tensors.length; ++i) {
                var error = $root.onnx.TensorProto.verify(message.tensors[i]);
                if (error)
                  return "tensors." + error;
              }
            }
            if (message.graphs != null && message.hasOwnProperty("graphs")) {
              if (!Array.isArray(message.graphs))
                return "graphs: array expected";
              for (var i = 0; i < message.graphs.length; ++i) {
                var error = $root.onnx.GraphProto.verify(message.graphs[i]);
                if (error)
                  return "graphs." + error;
              }
            }
            if (message.sparseTensors != null && message.hasOwnProperty("sparseTensors")) {
              if (!Array.isArray(message.sparseTensors))
                return "sparseTensors: array expected";
              for (var i = 0; i < message.sparseTensors.length; ++i) {
                var error = $root.onnx.SparseTensorProto.verify(message.sparseTensors[i]);
                if (error)
                  return "sparseTensors." + error;
              }
            }
            if (message.typeProtos != null && message.hasOwnProperty("typeProtos")) {
              if (!Array.isArray(message.typeProtos))
                return "typeProtos: array expected";
              for (var i = 0; i < message.typeProtos.length; ++i) {
                var error = $root.onnx.TypeProto.verify(message.typeProtos[i]);
                if (error)
                  return "typeProtos." + error;
              }
            }
            return null;
          };
          AttributeProto.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.AttributeProto)
              return object;
            var message = new $root.onnx.AttributeProto();
            if (object.name != null)
              message.name = String(object.name);
            if (object.refAttrName != null)
              message.refAttrName = String(object.refAttrName);
            if (object.docString != null)
              message.docString = String(object.docString);
            switch (object.type) {
              default:
                if (typeof object.type === "number") {
                  message.type = object.type;
                  break;
                }
                break;
              case "UNDEFINED":
              case 0:
                message.type = 0;
                break;
              case "FLOAT":
              case 1:
                message.type = 1;
                break;
              case "INT":
              case 2:
                message.type = 2;
                break;
              case "STRING":
              case 3:
                message.type = 3;
                break;
              case "TENSOR":
              case 4:
                message.type = 4;
                break;
              case "GRAPH":
              case 5:
                message.type = 5;
                break;
              case "SPARSE_TENSOR":
              case 11:
                message.type = 11;
                break;
              case "TYPE_PROTO":
              case 13:
                message.type = 13;
                break;
              case "FLOATS":
              case 6:
                message.type = 6;
                break;
              case "INTS":
              case 7:
                message.type = 7;
                break;
              case "STRINGS":
              case 8:
                message.type = 8;
                break;
              case "TENSORS":
              case 9:
                message.type = 9;
                break;
              case "GRAPHS":
              case 10:
                message.type = 10;
                break;
              case "SPARSE_TENSORS":
              case 12:
                message.type = 12;
                break;
              case "TYPE_PROTOS":
              case 14:
                message.type = 14;
                break;
            }
            if (object.f != null)
              message.f = Number(object.f);
            if (object.i != null) {
              if ($util.Long)
                (message.i = $util.Long.fromValue(object.i)).unsigned = false;
              else if (typeof object.i === "string")
                message.i = parseInt(object.i, 10);
              else if (typeof object.i === "number")
                message.i = object.i;
              else if (typeof object.i === "object")
                message.i = new $util.LongBits(object.i.low >>> 0, object.i.high >>> 0).toNumber();
            }
            if (object.s != null) {
              if (typeof object.s === "string")
                $util.base64.decode(object.s, message.s = $util.newBuffer($util.base64.length(object.s)), 0);
              else if (object.s.length >= 0)
                message.s = object.s;
            }
            if (object.t != null) {
              if (typeof object.t !== "object")
                throw TypeError(".onnx.AttributeProto.t: object expected");
              message.t = $root.onnx.TensorProto.fromObject(object.t);
            }
            if (object.g != null) {
              if (typeof object.g !== "object")
                throw TypeError(".onnx.AttributeProto.g: object expected");
              message.g = $root.onnx.GraphProto.fromObject(object.g);
            }
            if (object.sparseTensor != null) {
              if (typeof object.sparseTensor !== "object")
                throw TypeError(".onnx.AttributeProto.sparseTensor: object expected");
              message.sparseTensor = $root.onnx.SparseTensorProto.fromObject(object.sparseTensor);
            }
            if (object.tp != null) {
              if (typeof object.tp !== "object")
                throw TypeError(".onnx.AttributeProto.tp: object expected");
              message.tp = $root.onnx.TypeProto.fromObject(object.tp);
            }
            if (object.floats) {
              if (!Array.isArray(object.floats))
                throw TypeError(".onnx.AttributeProto.floats: array expected");
              message.floats = [];
              for (var i = 0; i < object.floats.length; ++i)
                message.floats[i] = Number(object.floats[i]);
            }
            if (object.ints) {
              if (!Array.isArray(object.ints))
                throw TypeError(".onnx.AttributeProto.ints: array expected");
              message.ints = [];
              for (var i = 0; i < object.ints.length; ++i)
                if ($util.Long)
                  (message.ints[i] = $util.Long.fromValue(object.ints[i])).unsigned = false;
                else if (typeof object.ints[i] === "string")
                  message.ints[i] = parseInt(object.ints[i], 10);
                else if (typeof object.ints[i] === "number")
                  message.ints[i] = object.ints[i];
                else if (typeof object.ints[i] === "object")
                  message.ints[i] = new $util.LongBits(object.ints[i].low >>> 0, object.ints[i].high >>> 0).toNumber();
            }
            if (object.strings) {
              if (!Array.isArray(object.strings))
                throw TypeError(".onnx.AttributeProto.strings: array expected");
              message.strings = [];
              for (var i = 0; i < object.strings.length; ++i)
                if (typeof object.strings[i] === "string")
                  $util.base64.decode(
                    object.strings[i],
                    message.strings[i] = $util.newBuffer($util.base64.length(object.strings[i])),
                    0
                  );
                else if (object.strings[i].length >= 0)
                  message.strings[i] = object.strings[i];
            }
            if (object.tensors) {
              if (!Array.isArray(object.tensors))
                throw TypeError(".onnx.AttributeProto.tensors: array expected");
              message.tensors = [];
              for (var i = 0; i < object.tensors.length; ++i) {
                if (typeof object.tensors[i] !== "object")
                  throw TypeError(".onnx.AttributeProto.tensors: object expected");
                message.tensors[i] = $root.onnx.TensorProto.fromObject(object.tensors[i]);
              }
            }
            if (object.graphs) {
              if (!Array.isArray(object.graphs))
                throw TypeError(".onnx.AttributeProto.graphs: array expected");
              message.graphs = [];
              for (var i = 0; i < object.graphs.length; ++i) {
                if (typeof object.graphs[i] !== "object")
                  throw TypeError(".onnx.AttributeProto.graphs: object expected");
                message.graphs[i] = $root.onnx.GraphProto.fromObject(object.graphs[i]);
              }
            }
            if (object.sparseTensors) {
              if (!Array.isArray(object.sparseTensors))
                throw TypeError(".onnx.AttributeProto.sparseTensors: array expected");
              message.sparseTensors = [];
              for (var i = 0; i < object.sparseTensors.length; ++i) {
                if (typeof object.sparseTensors[i] !== "object")
                  throw TypeError(".onnx.AttributeProto.sparseTensors: object expected");
                message.sparseTensors[i] = $root.onnx.SparseTensorProto.fromObject(object.sparseTensors[i]);
              }
            }
            if (object.typeProtos) {
              if (!Array.isArray(object.typeProtos))
                throw TypeError(".onnx.AttributeProto.typeProtos: array expected");
              message.typeProtos = [];
              for (var i = 0; i < object.typeProtos.length; ++i) {
                if (typeof object.typeProtos[i] !== "object")
                  throw TypeError(".onnx.AttributeProto.typeProtos: object expected");
                message.typeProtos[i] = $root.onnx.TypeProto.fromObject(object.typeProtos[i]);
              }
            }
            return message;
          };
          AttributeProto.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults) {
              object.floats = [];
              object.ints = [];
              object.strings = [];
              object.tensors = [];
              object.graphs = [];
              object.typeProtos = [];
              object.sparseTensors = [];
            }
            if (options.defaults) {
              object.name = "";
              object.f = 0;
              if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.i = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else
                object.i = options.longs === String ? "0" : 0;
              if (options.bytes === String)
                object.s = "";
              else {
                object.s = [];
                if (options.bytes !== Array)
                  object.s = $util.newBuffer(object.s);
              }
              object.t = null;
              object.g = null;
              object.docString = "";
              object.tp = null;
              object.type = options.enums === String ? "UNDEFINED" : 0;
              object.refAttrName = "";
              object.sparseTensor = null;
            }
            if (message.name != null && message.hasOwnProperty("name"))
              object.name = message.name;
            if (message.f != null && message.hasOwnProperty("f"))
              object.f = options.json && !isFinite(message.f) ? String(message.f) : message.f;
            if (message.i != null && message.hasOwnProperty("i"))
              if (typeof message.i === "number")
                object.i = options.longs === String ? String(message.i) : message.i;
              else
                object.i = options.longs === String ? $util.Long.prototype.toString.call(message.i) : options.longs === Number ? new $util.LongBits(message.i.low >>> 0, message.i.high >>> 0).toNumber() : message.i;
            if (message.s != null && message.hasOwnProperty("s"))
              object.s = options.bytes === String ? $util.base64.encode(message.s, 0, message.s.length) : options.bytes === Array ? Array.prototype.slice.call(message.s) : message.s;
            if (message.t != null && message.hasOwnProperty("t"))
              object.t = $root.onnx.TensorProto.toObject(message.t, options);
            if (message.g != null && message.hasOwnProperty("g"))
              object.g = $root.onnx.GraphProto.toObject(message.g, options);
            if (message.floats && message.floats.length) {
              object.floats = [];
              for (var j = 0; j < message.floats.length; ++j)
                object.floats[j] = options.json && !isFinite(message.floats[j]) ? String(message.floats[j]) : message.floats[j];
            }
            if (message.ints && message.ints.length) {
              object.ints = [];
              for (var j = 0; j < message.ints.length; ++j)
                if (typeof message.ints[j] === "number")
                  object.ints[j] = options.longs === String ? String(message.ints[j]) : message.ints[j];
                else
                  object.ints[j] = options.longs === String ? $util.Long.prototype.toString.call(message.ints[j]) : options.longs === Number ? new $util.LongBits(message.ints[j].low >>> 0, message.ints[j].high >>> 0).toNumber() : message.ints[j];
            }
            if (message.strings && message.strings.length) {
              object.strings = [];
              for (var j = 0; j < message.strings.length; ++j)
                object.strings[j] = options.bytes === String ? $util.base64.encode(message.strings[j], 0, message.strings[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.strings[j]) : message.strings[j];
            }
            if (message.tensors && message.tensors.length) {
              object.tensors = [];
              for (var j = 0; j < message.tensors.length; ++j)
                object.tensors[j] = $root.onnx.TensorProto.toObject(message.tensors[j], options);
            }
            if (message.graphs && message.graphs.length) {
              object.graphs = [];
              for (var j = 0; j < message.graphs.length; ++j)
                object.graphs[j] = $root.onnx.GraphProto.toObject(message.graphs[j], options);
            }
            if (message.docString != null && message.hasOwnProperty("docString"))
              object.docString = message.docString;
            if (message.tp != null && message.hasOwnProperty("tp"))
              object.tp = $root.onnx.TypeProto.toObject(message.tp, options);
            if (message.typeProtos && message.typeProtos.length) {
              object.typeProtos = [];
              for (var j = 0; j < message.typeProtos.length; ++j)
                object.typeProtos[j] = $root.onnx.TypeProto.toObject(message.typeProtos[j], options);
            }
            if (message.type != null && message.hasOwnProperty("type"))
              object.type = options.enums === String ? $root.onnx.AttributeProto.AttributeType[message.type] === void 0 ? message.type : $root.onnx.AttributeProto.AttributeType[message.type] : message.type;
            if (message.refAttrName != null && message.hasOwnProperty("refAttrName"))
              object.refAttrName = message.refAttrName;
            if (message.sparseTensor != null && message.hasOwnProperty("sparseTensor"))
              object.sparseTensor = $root.onnx.SparseTensorProto.toObject(message.sparseTensor, options);
            if (message.sparseTensors && message.sparseTensors.length) {
              object.sparseTensors = [];
              for (var j = 0; j < message.sparseTensors.length; ++j)
                object.sparseTensors[j] = $root.onnx.SparseTensorProto.toObject(message.sparseTensors[j], options);
            }
            return object;
          };
          AttributeProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          AttributeProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/onnx.AttributeProto";
          };
          AttributeProto.AttributeType = function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNDEFINED"] = 0;
            values[valuesById[1] = "FLOAT"] = 1;
            values[valuesById[2] = "INT"] = 2;
            values[valuesById[3] = "STRING"] = 3;
            values[valuesById[4] = "TENSOR"] = 4;
            values[valuesById[5] = "GRAPH"] = 5;
            values[valuesById[11] = "SPARSE_TENSOR"] = 11;
            values[valuesById[13] = "TYPE_PROTO"] = 13;
            values[valuesById[6] = "FLOATS"] = 6;
            values[valuesById[7] = "INTS"] = 7;
            values[valuesById[8] = "STRINGS"] = 8;
            values[valuesById[9] = "TENSORS"] = 9;
            values[valuesById[10] = "GRAPHS"] = 10;
            values[valuesById[12] = "SPARSE_TENSORS"] = 12;
            values[valuesById[14] = "TYPE_PROTOS"] = 14;
            return values;
          }();
          return AttributeProto;
        }();
        onnx6.ValueInfoProto = function() {
          function ValueInfoProto(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          ValueInfoProto.prototype.name = "";
          ValueInfoProto.prototype.type = null;
          ValueInfoProto.prototype.docString = "";
          ValueInfoProto.create = function create(properties) {
            return new ValueInfoProto(properties);
          };
          ValueInfoProto.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(message.name);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
              $root.onnx.TypeProto.encode(message.type, writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim();
            if (message.docString != null && Object.hasOwnProperty.call(message, "docString"))
              writer.uint32(
                /* id 3, wireType 2 =*/
                26
              ).string(message.docString);
            return writer;
          };
          ValueInfoProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          ValueInfoProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.ValueInfoProto();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.name = reader.string();
                  break;
                }
                case 2: {
                  message.type = $root.onnx.TypeProto.decode(reader, reader.uint32());
                  break;
                }
                case 3: {
                  message.docString = reader.string();
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          ValueInfoProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          ValueInfoProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.name != null && message.hasOwnProperty("name")) {
              if (!$util.isString(message.name))
                return "name: string expected";
            }
            if (message.type != null && message.hasOwnProperty("type")) {
              var error = $root.onnx.TypeProto.verify(message.type);
              if (error)
                return "type." + error;
            }
            if (message.docString != null && message.hasOwnProperty("docString")) {
              if (!$util.isString(message.docString))
                return "docString: string expected";
            }
            return null;
          };
          ValueInfoProto.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.ValueInfoProto)
              return object;
            var message = new $root.onnx.ValueInfoProto();
            if (object.name != null)
              message.name = String(object.name);
            if (object.type != null) {
              if (typeof object.type !== "object")
                throw TypeError(".onnx.ValueInfoProto.type: object expected");
              message.type = $root.onnx.TypeProto.fromObject(object.type);
            }
            if (object.docString != null)
              message.docString = String(object.docString);
            return message;
          };
          ValueInfoProto.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              object.name = "";
              object.type = null;
              object.docString = "";
            }
            if (message.name != null && message.hasOwnProperty("name"))
              object.name = message.name;
            if (message.type != null && message.hasOwnProperty("type"))
              object.type = $root.onnx.TypeProto.toObject(message.type, options);
            if (message.docString != null && message.hasOwnProperty("docString"))
              object.docString = message.docString;
            return object;
          };
          ValueInfoProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          ValueInfoProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/onnx.ValueInfoProto";
          };
          return ValueInfoProto;
        }();
        onnx6.NodeProto = function() {
          function NodeProto(properties) {
            this.input = [];
            this.output = [];
            this.attribute = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          NodeProto.prototype.input = $util.emptyArray;
          NodeProto.prototype.output = $util.emptyArray;
          NodeProto.prototype.name = "";
          NodeProto.prototype.opType = "";
          NodeProto.prototype.domain = "";
          NodeProto.prototype.attribute = $util.emptyArray;
          NodeProto.prototype.docString = "";
          NodeProto.create = function create(properties) {
            return new NodeProto(properties);
          };
          NodeProto.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.input != null && message.input.length)
              for (var i = 0; i < message.input.length; ++i)
                writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).string(message.input[i]);
            if (message.output != null && message.output.length)
              for (var i = 0; i < message.output.length; ++i)
                writer.uint32(
                  /* id 2, wireType 2 =*/
                  18
                ).string(message.output[i]);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
              writer.uint32(
                /* id 3, wireType 2 =*/
                26
              ).string(message.name);
            if (message.opType != null && Object.hasOwnProperty.call(message, "opType"))
              writer.uint32(
                /* id 4, wireType 2 =*/
                34
              ).string(message.opType);
            if (message.attribute != null && message.attribute.length)
              for (var i = 0; i < message.attribute.length; ++i)
                $root.onnx.AttributeProto.encode(
                  message.attribute[i],
                  writer.uint32(
                    /* id 5, wireType 2 =*/
                    42
                  ).fork()
                ).ldelim();
            if (message.docString != null && Object.hasOwnProperty.call(message, "docString"))
              writer.uint32(
                /* id 6, wireType 2 =*/
                50
              ).string(message.docString);
            if (message.domain != null && Object.hasOwnProperty.call(message, "domain"))
              writer.uint32(
                /* id 7, wireType 2 =*/
                58
              ).string(message.domain);
            return writer;
          };
          NodeProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          NodeProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.NodeProto();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  if (!(message.input && message.input.length))
                    message.input = [];
                  message.input.push(reader.string());
                  break;
                }
                case 2: {
                  if (!(message.output && message.output.length))
                    message.output = [];
                  message.output.push(reader.string());
                  break;
                }
                case 3: {
                  message.name = reader.string();
                  break;
                }
                case 4: {
                  message.opType = reader.string();
                  break;
                }
                case 7: {
                  message.domain = reader.string();
                  break;
                }
                case 5: {
                  if (!(message.attribute && message.attribute.length))
                    message.attribute = [];
                  message.attribute.push($root.onnx.AttributeProto.decode(reader, reader.uint32()));
                  break;
                }
                case 6: {
                  message.docString = reader.string();
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          NodeProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          NodeProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.input != null && message.hasOwnProperty("input")) {
              if (!Array.isArray(message.input))
                return "input: array expected";
              for (var i = 0; i < message.input.length; ++i)
                if (!$util.isString(message.input[i]))
                  return "input: string[] expected";
            }
            if (message.output != null && message.hasOwnProperty("output")) {
              if (!Array.isArray(message.output))
                return "output: array expected";
              for (var i = 0; i < message.output.length; ++i)
                if (!$util.isString(message.output[i]))
                  return "output: string[] expected";
            }
            if (message.name != null && message.hasOwnProperty("name")) {
              if (!$util.isString(message.name))
                return "name: string expected";
            }
            if (message.opType != null && message.hasOwnProperty("opType")) {
              if (!$util.isString(message.opType))
                return "opType: string expected";
            }
            if (message.domain != null && message.hasOwnProperty("domain")) {
              if (!$util.isString(message.domain))
                return "domain: string expected";
            }
            if (message.attribute != null && message.hasOwnProperty("attribute")) {
              if (!Array.isArray(message.attribute))
                return "attribute: array expected";
              for (var i = 0; i < message.attribute.length; ++i) {
                var error = $root.onnx.AttributeProto.verify(message.attribute[i]);
                if (error)
                  return "attribute." + error;
              }
            }
            if (message.docString != null && message.hasOwnProperty("docString")) {
              if (!$util.isString(message.docString))
                return "docString: string expected";
            }
            return null;
          };
          NodeProto.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.NodeProto)
              return object;
            var message = new $root.onnx.NodeProto();
            if (object.input) {
              if (!Array.isArray(object.input))
                throw TypeError(".onnx.NodeProto.input: array expected");
              message.input = [];
              for (var i = 0; i < object.input.length; ++i)
                message.input[i] = String(object.input[i]);
            }
            if (object.output) {
              if (!Array.isArray(object.output))
                throw TypeError(".onnx.NodeProto.output: array expected");
              message.output = [];
              for (var i = 0; i < object.output.length; ++i)
                message.output[i] = String(object.output[i]);
            }
            if (object.name != null)
              message.name = String(object.name);
            if (object.opType != null)
              message.opType = String(object.opType);
            if (object.domain != null)
              message.domain = String(object.domain);
            if (object.attribute) {
              if (!Array.isArray(object.attribute))
                throw TypeError(".onnx.NodeProto.attribute: array expected");
              message.attribute = [];
              for (var i = 0; i < object.attribute.length; ++i) {
                if (typeof object.attribute[i] !== "object")
                  throw TypeError(".onnx.NodeProto.attribute: object expected");
                message.attribute[i] = $root.onnx.AttributeProto.fromObject(object.attribute[i]);
              }
            }
            if (object.docString != null)
              message.docString = String(object.docString);
            return message;
          };
          NodeProto.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults) {
              object.input = [];
              object.output = [];
              object.attribute = [];
            }
            if (options.defaults) {
              object.name = "";
              object.opType = "";
              object.docString = "";
              object.domain = "";
            }
            if (message.input && message.input.length) {
              object.input = [];
              for (var j = 0; j < message.input.length; ++j)
                object.input[j] = message.input[j];
            }
            if (message.output && message.output.length) {
              object.output = [];
              for (var j = 0; j < message.output.length; ++j)
                object.output[j] = message.output[j];
            }
            if (message.name != null && message.hasOwnProperty("name"))
              object.name = message.name;
            if (message.opType != null && message.hasOwnProperty("opType"))
              object.opType = message.opType;
            if (message.attribute && message.attribute.length) {
              object.attribute = [];
              for (var j = 0; j < message.attribute.length; ++j)
                object.attribute[j] = $root.onnx.AttributeProto.toObject(message.attribute[j], options);
            }
            if (message.docString != null && message.hasOwnProperty("docString"))
              object.docString = message.docString;
            if (message.domain != null && message.hasOwnProperty("domain"))
              object.domain = message.domain;
            return object;
          };
          NodeProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          NodeProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/onnx.NodeProto";
          };
          return NodeProto;
        }();
        onnx6.TrainingInfoProto = function() {
          function TrainingInfoProto(properties) {
            this.initializationBinding = [];
            this.updateBinding = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          TrainingInfoProto.prototype.initialization = null;
          TrainingInfoProto.prototype.algorithm = null;
          TrainingInfoProto.prototype.initializationBinding = $util.emptyArray;
          TrainingInfoProto.prototype.updateBinding = $util.emptyArray;
          TrainingInfoProto.create = function create(properties) {
            return new TrainingInfoProto(properties);
          };
          TrainingInfoProto.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.initialization != null && Object.hasOwnProperty.call(message, "initialization"))
              $root.onnx.GraphProto.encode(message.initialization, writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).fork()).ldelim();
            if (message.algorithm != null && Object.hasOwnProperty.call(message, "algorithm"))
              $root.onnx.GraphProto.encode(message.algorithm, writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim();
            if (message.initializationBinding != null && message.initializationBinding.length)
              for (var i = 0; i < message.initializationBinding.length; ++i)
                $root.onnx.StringStringEntryProto.encode(
                  message.initializationBinding[i],
                  writer.uint32(
                    /* id 3, wireType 2 =*/
                    26
                  ).fork()
                ).ldelim();
            if (message.updateBinding != null && message.updateBinding.length)
              for (var i = 0; i < message.updateBinding.length; ++i)
                $root.onnx.StringStringEntryProto.encode(
                  message.updateBinding[i],
                  writer.uint32(
                    /* id 4, wireType 2 =*/
                    34
                  ).fork()
                ).ldelim();
            return writer;
          };
          TrainingInfoProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          TrainingInfoProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.TrainingInfoProto();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.initialization = $root.onnx.GraphProto.decode(reader, reader.uint32());
                  break;
                }
                case 2: {
                  message.algorithm = $root.onnx.GraphProto.decode(reader, reader.uint32());
                  break;
                }
                case 3: {
                  if (!(message.initializationBinding && message.initializationBinding.length))
                    message.initializationBinding = [];
                  message.initializationBinding.push($root.onnx.StringStringEntryProto.decode(reader, reader.uint32()));
                  break;
                }
                case 4: {
                  if (!(message.updateBinding && message.updateBinding.length))
                    message.updateBinding = [];
                  message.updateBinding.push($root.onnx.StringStringEntryProto.decode(reader, reader.uint32()));
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          TrainingInfoProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          TrainingInfoProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.initialization != null && message.hasOwnProperty("initialization")) {
              var error = $root.onnx.GraphProto.verify(message.initialization);
              if (error)
                return "initialization." + error;
            }
            if (message.algorithm != null && message.hasOwnProperty("algorithm")) {
              var error = $root.onnx.GraphProto.verify(message.algorithm);
              if (error)
                return "algorithm." + error;
            }
            if (message.initializationBinding != null && message.hasOwnProperty("initializationBinding")) {
              if (!Array.isArray(message.initializationBinding))
                return "initializationBinding: array expected";
              for (var i = 0; i < message.initializationBinding.length; ++i) {
                var error = $root.onnx.StringStringEntryProto.verify(message.initializationBinding[i]);
                if (error)
                  return "initializationBinding." + error;
              }
            }
            if (message.updateBinding != null && message.hasOwnProperty("updateBinding")) {
              if (!Array.isArray(message.updateBinding))
                return "updateBinding: array expected";
              for (var i = 0; i < message.updateBinding.length; ++i) {
                var error = $root.onnx.StringStringEntryProto.verify(message.updateBinding[i]);
                if (error)
                  return "updateBinding." + error;
              }
            }
            return null;
          };
          TrainingInfoProto.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.TrainingInfoProto)
              return object;
            var message = new $root.onnx.TrainingInfoProto();
            if (object.initialization != null) {
              if (typeof object.initialization !== "object")
                throw TypeError(".onnx.TrainingInfoProto.initialization: object expected");
              message.initialization = $root.onnx.GraphProto.fromObject(object.initialization);
            }
            if (object.algorithm != null) {
              if (typeof object.algorithm !== "object")
                throw TypeError(".onnx.TrainingInfoProto.algorithm: object expected");
              message.algorithm = $root.onnx.GraphProto.fromObject(object.algorithm);
            }
            if (object.initializationBinding) {
              if (!Array.isArray(object.initializationBinding))
                throw TypeError(".onnx.TrainingInfoProto.initializationBinding: array expected");
              message.initializationBinding = [];
              for (var i = 0; i < object.initializationBinding.length; ++i) {
                if (typeof object.initializationBinding[i] !== "object")
                  throw TypeError(".onnx.TrainingInfoProto.initializationBinding: object expected");
                message.initializationBinding[i] = $root.onnx.StringStringEntryProto.fromObject(
                  object.initializationBinding[i]
                );
              }
            }
            if (object.updateBinding) {
              if (!Array.isArray(object.updateBinding))
                throw TypeError(".onnx.TrainingInfoProto.updateBinding: array expected");
              message.updateBinding = [];
              for (var i = 0; i < object.updateBinding.length; ++i) {
                if (typeof object.updateBinding[i] !== "object")
                  throw TypeError(".onnx.TrainingInfoProto.updateBinding: object expected");
                message.updateBinding[i] = $root.onnx.StringStringEntryProto.fromObject(object.updateBinding[i]);
              }
            }
            return message;
          };
          TrainingInfoProto.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults) {
              object.initializationBinding = [];
              object.updateBinding = [];
            }
            if (options.defaults) {
              object.initialization = null;
              object.algorithm = null;
            }
            if (message.initialization != null && message.hasOwnProperty("initialization"))
              object.initialization = $root.onnx.GraphProto.toObject(message.initialization, options);
            if (message.algorithm != null && message.hasOwnProperty("algorithm"))
              object.algorithm = $root.onnx.GraphProto.toObject(message.algorithm, options);
            if (message.initializationBinding && message.initializationBinding.length) {
              object.initializationBinding = [];
              for (var j = 0; j < message.initializationBinding.length; ++j)
                object.initializationBinding[j] = $root.onnx.StringStringEntryProto.toObject(
                  message.initializationBinding[j],
                  options
                );
            }
            if (message.updateBinding && message.updateBinding.length) {
              object.updateBinding = [];
              for (var j = 0; j < message.updateBinding.length; ++j)
                object.updateBinding[j] = $root.onnx.StringStringEntryProto.toObject(message.updateBinding[j], options);
            }
            return object;
          };
          TrainingInfoProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          TrainingInfoProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/onnx.TrainingInfoProto";
          };
          return TrainingInfoProto;
        }();
        onnx6.ModelProto = function() {
          function ModelProto(properties) {
            this.opsetImport = [];
            this.metadataProps = [];
            this.trainingInfo = [];
            this.functions = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          ModelProto.prototype.irVersion = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
          ModelProto.prototype.opsetImport = $util.emptyArray;
          ModelProto.prototype.producerName = "";
          ModelProto.prototype.producerVersion = "";
          ModelProto.prototype.domain = "";
          ModelProto.prototype.modelVersion = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
          ModelProto.prototype.docString = "";
          ModelProto.prototype.graph = null;
          ModelProto.prototype.metadataProps = $util.emptyArray;
          ModelProto.prototype.trainingInfo = $util.emptyArray;
          ModelProto.prototype.functions = $util.emptyArray;
          ModelProto.create = function create(properties) {
            return new ModelProto(properties);
          };
          ModelProto.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.irVersion != null && Object.hasOwnProperty.call(message, "irVersion"))
              writer.uint32(
                /* id 1, wireType 0 =*/
                8
              ).int64(message.irVersion);
            if (message.producerName != null && Object.hasOwnProperty.call(message, "producerName"))
              writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).string(message.producerName);
            if (message.producerVersion != null && Object.hasOwnProperty.call(message, "producerVersion"))
              writer.uint32(
                /* id 3, wireType 2 =*/
                26
              ).string(message.producerVersion);
            if (message.domain != null && Object.hasOwnProperty.call(message, "domain"))
              writer.uint32(
                /* id 4, wireType 2 =*/
                34
              ).string(message.domain);
            if (message.modelVersion != null && Object.hasOwnProperty.call(message, "modelVersion"))
              writer.uint32(
                /* id 5, wireType 0 =*/
                40
              ).int64(message.modelVersion);
            if (message.docString != null && Object.hasOwnProperty.call(message, "docString"))
              writer.uint32(
                /* id 6, wireType 2 =*/
                50
              ).string(message.docString);
            if (message.graph != null && Object.hasOwnProperty.call(message, "graph"))
              $root.onnx.GraphProto.encode(message.graph, writer.uint32(
                /* id 7, wireType 2 =*/
                58
              ).fork()).ldelim();
            if (message.opsetImport != null && message.opsetImport.length)
              for (var i = 0; i < message.opsetImport.length; ++i)
                $root.onnx.OperatorSetIdProto.encode(
                  message.opsetImport[i],
                  writer.uint32(
                    /* id 8, wireType 2 =*/
                    66
                  ).fork()
                ).ldelim();
            if (message.metadataProps != null && message.metadataProps.length)
              for (var i = 0; i < message.metadataProps.length; ++i)
                $root.onnx.StringStringEntryProto.encode(
                  message.metadataProps[i],
                  writer.uint32(
                    /* id 14, wireType 2 =*/
                    114
                  ).fork()
                ).ldelim();
            if (message.trainingInfo != null && message.trainingInfo.length)
              for (var i = 0; i < message.trainingInfo.length; ++i)
                $root.onnx.TrainingInfoProto.encode(
                  message.trainingInfo[i],
                  writer.uint32(
                    /* id 20, wireType 2 =*/
                    162
                  ).fork()
                ).ldelim();
            if (message.functions != null && message.functions.length)
              for (var i = 0; i < message.functions.length; ++i)
                $root.onnx.FunctionProto.encode(
                  message.functions[i],
                  writer.uint32(
                    /* id 25, wireType 2 =*/
                    202
                  ).fork()
                ).ldelim();
            return writer;
          };
          ModelProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          ModelProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.ModelProto();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.irVersion = reader.int64();
                  break;
                }
                case 8: {
                  if (!(message.opsetImport && message.opsetImport.length))
                    message.opsetImport = [];
                  message.opsetImport.push($root.onnx.OperatorSetIdProto.decode(reader, reader.uint32()));
                  break;
                }
                case 2: {
                  message.producerName = reader.string();
                  break;
                }
                case 3: {
                  message.producerVersion = reader.string();
                  break;
                }
                case 4: {
                  message.domain = reader.string();
                  break;
                }
                case 5: {
                  message.modelVersion = reader.int64();
                  break;
                }
                case 6: {
                  message.docString = reader.string();
                  break;
                }
                case 7: {
                  message.graph = $root.onnx.GraphProto.decode(reader, reader.uint32());
                  break;
                }
                case 14: {
                  if (!(message.metadataProps && message.metadataProps.length))
                    message.metadataProps = [];
                  message.metadataProps.push($root.onnx.StringStringEntryProto.decode(reader, reader.uint32()));
                  break;
                }
                case 20: {
                  if (!(message.trainingInfo && message.trainingInfo.length))
                    message.trainingInfo = [];
                  message.trainingInfo.push($root.onnx.TrainingInfoProto.decode(reader, reader.uint32()));
                  break;
                }
                case 25: {
                  if (!(message.functions && message.functions.length))
                    message.functions = [];
                  message.functions.push($root.onnx.FunctionProto.decode(reader, reader.uint32()));
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          ModelProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          ModelProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.irVersion != null && message.hasOwnProperty("irVersion")) {
              if (!$util.isInteger(message.irVersion) && !(message.irVersion && $util.isInteger(message.irVersion.low) && $util.isInteger(message.irVersion.high)))
                return "irVersion: integer|Long expected";
            }
            if (message.opsetImport != null && message.hasOwnProperty("opsetImport")) {
              if (!Array.isArray(message.opsetImport))
                return "opsetImport: array expected";
              for (var i = 0; i < message.opsetImport.length; ++i) {
                var error = $root.onnx.OperatorSetIdProto.verify(message.opsetImport[i]);
                if (error)
                  return "opsetImport." + error;
              }
            }
            if (message.producerName != null && message.hasOwnProperty("producerName")) {
              if (!$util.isString(message.producerName))
                return "producerName: string expected";
            }
            if (message.producerVersion != null && message.hasOwnProperty("producerVersion")) {
              if (!$util.isString(message.producerVersion))
                return "producerVersion: string expected";
            }
            if (message.domain != null && message.hasOwnProperty("domain")) {
              if (!$util.isString(message.domain))
                return "domain: string expected";
            }
            if (message.modelVersion != null && message.hasOwnProperty("modelVersion")) {
              if (!$util.isInteger(message.modelVersion) && !(message.modelVersion && $util.isInteger(message.modelVersion.low) && $util.isInteger(message.modelVersion.high)))
                return "modelVersion: integer|Long expected";
            }
            if (message.docString != null && message.hasOwnProperty("docString")) {
              if (!$util.isString(message.docString))
                return "docString: string expected";
            }
            if (message.graph != null && message.hasOwnProperty("graph")) {
              var error = $root.onnx.GraphProto.verify(message.graph);
              if (error)
                return "graph." + error;
            }
            if (message.metadataProps != null && message.hasOwnProperty("metadataProps")) {
              if (!Array.isArray(message.metadataProps))
                return "metadataProps: array expected";
              for (var i = 0; i < message.metadataProps.length; ++i) {
                var error = $root.onnx.StringStringEntryProto.verify(message.metadataProps[i]);
                if (error)
                  return "metadataProps." + error;
              }
            }
            if (message.trainingInfo != null && message.hasOwnProperty("trainingInfo")) {
              if (!Array.isArray(message.trainingInfo))
                return "trainingInfo: array expected";
              for (var i = 0; i < message.trainingInfo.length; ++i) {
                var error = $root.onnx.TrainingInfoProto.verify(message.trainingInfo[i]);
                if (error)
                  return "trainingInfo." + error;
              }
            }
            if (message.functions != null && message.hasOwnProperty("functions")) {
              if (!Array.isArray(message.functions))
                return "functions: array expected";
              for (var i = 0; i < message.functions.length; ++i) {
                var error = $root.onnx.FunctionProto.verify(message.functions[i]);
                if (error)
                  return "functions." + error;
              }
            }
            return null;
          };
          ModelProto.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.ModelProto)
              return object;
            var message = new $root.onnx.ModelProto();
            if (object.irVersion != null) {
              if ($util.Long)
                (message.irVersion = $util.Long.fromValue(object.irVersion)).unsigned = false;
              else if (typeof object.irVersion === "string")
                message.irVersion = parseInt(object.irVersion, 10);
              else if (typeof object.irVersion === "number")
                message.irVersion = object.irVersion;
              else if (typeof object.irVersion === "object")
                message.irVersion = new $util.LongBits(object.irVersion.low >>> 0, object.irVersion.high >>> 0).toNumber();
            }
            if (object.opsetImport) {
              if (!Array.isArray(object.opsetImport))
                throw TypeError(".onnx.ModelProto.opsetImport: array expected");
              message.opsetImport = [];
              for (var i = 0; i < object.opsetImport.length; ++i) {
                if (typeof object.opsetImport[i] !== "object")
                  throw TypeError(".onnx.ModelProto.opsetImport: object expected");
                message.opsetImport[i] = $root.onnx.OperatorSetIdProto.fromObject(object.opsetImport[i]);
              }
            }
            if (object.producerName != null)
              message.producerName = String(object.producerName);
            if (object.producerVersion != null)
              message.producerVersion = String(object.producerVersion);
            if (object.domain != null)
              message.domain = String(object.domain);
            if (object.modelVersion != null) {
              if ($util.Long)
                (message.modelVersion = $util.Long.fromValue(object.modelVersion)).unsigned = false;
              else if (typeof object.modelVersion === "string")
                message.modelVersion = parseInt(object.modelVersion, 10);
              else if (typeof object.modelVersion === "number")
                message.modelVersion = object.modelVersion;
              else if (typeof object.modelVersion === "object")
                message.modelVersion = new $util.LongBits(
                  object.modelVersion.low >>> 0,
                  object.modelVersion.high >>> 0
                ).toNumber();
            }
            if (object.docString != null)
              message.docString = String(object.docString);
            if (object.graph != null) {
              if (typeof object.graph !== "object")
                throw TypeError(".onnx.ModelProto.graph: object expected");
              message.graph = $root.onnx.GraphProto.fromObject(object.graph);
            }
            if (object.metadataProps) {
              if (!Array.isArray(object.metadataProps))
                throw TypeError(".onnx.ModelProto.metadataProps: array expected");
              message.metadataProps = [];
              for (var i = 0; i < object.metadataProps.length; ++i) {
                if (typeof object.metadataProps[i] !== "object")
                  throw TypeError(".onnx.ModelProto.metadataProps: object expected");
                message.metadataProps[i] = $root.onnx.StringStringEntryProto.fromObject(object.metadataProps[i]);
              }
            }
            if (object.trainingInfo) {
              if (!Array.isArray(object.trainingInfo))
                throw TypeError(".onnx.ModelProto.trainingInfo: array expected");
              message.trainingInfo = [];
              for (var i = 0; i < object.trainingInfo.length; ++i) {
                if (typeof object.trainingInfo[i] !== "object")
                  throw TypeError(".onnx.ModelProto.trainingInfo: object expected");
                message.trainingInfo[i] = $root.onnx.TrainingInfoProto.fromObject(object.trainingInfo[i]);
              }
            }
            if (object.functions) {
              if (!Array.isArray(object.functions))
                throw TypeError(".onnx.ModelProto.functions: array expected");
              message.functions = [];
              for (var i = 0; i < object.functions.length; ++i) {
                if (typeof object.functions[i] !== "object")
                  throw TypeError(".onnx.ModelProto.functions: object expected");
                message.functions[i] = $root.onnx.FunctionProto.fromObject(object.functions[i]);
              }
            }
            return message;
          };
          ModelProto.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults) {
              object.opsetImport = [];
              object.metadataProps = [];
              object.trainingInfo = [];
              object.functions = [];
            }
            if (options.defaults) {
              if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.irVersion = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else
                object.irVersion = options.longs === String ? "0" : 0;
              object.producerName = "";
              object.producerVersion = "";
              object.domain = "";
              if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.modelVersion = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else
                object.modelVersion = options.longs === String ? "0" : 0;
              object.docString = "";
              object.graph = null;
            }
            if (message.irVersion != null && message.hasOwnProperty("irVersion"))
              if (typeof message.irVersion === "number")
                object.irVersion = options.longs === String ? String(message.irVersion) : message.irVersion;
              else
                object.irVersion = options.longs === String ? $util.Long.prototype.toString.call(message.irVersion) : options.longs === Number ? new $util.LongBits(message.irVersion.low >>> 0, message.irVersion.high >>> 0).toNumber() : message.irVersion;
            if (message.producerName != null && message.hasOwnProperty("producerName"))
              object.producerName = message.producerName;
            if (message.producerVersion != null && message.hasOwnProperty("producerVersion"))
              object.producerVersion = message.producerVersion;
            if (message.domain != null && message.hasOwnProperty("domain"))
              object.domain = message.domain;
            if (message.modelVersion != null && message.hasOwnProperty("modelVersion"))
              if (typeof message.modelVersion === "number")
                object.modelVersion = options.longs === String ? String(message.modelVersion) : message.modelVersion;
              else
                object.modelVersion = options.longs === String ? $util.Long.prototype.toString.call(message.modelVersion) : options.longs === Number ? new $util.LongBits(message.modelVersion.low >>> 0, message.modelVersion.high >>> 0).toNumber() : message.modelVersion;
            if (message.docString != null && message.hasOwnProperty("docString"))
              object.docString = message.docString;
            if (message.graph != null && message.hasOwnProperty("graph"))
              object.graph = $root.onnx.GraphProto.toObject(message.graph, options);
            if (message.opsetImport && message.opsetImport.length) {
              object.opsetImport = [];
              for (var j = 0; j < message.opsetImport.length; ++j)
                object.opsetImport[j] = $root.onnx.OperatorSetIdProto.toObject(message.opsetImport[j], options);
            }
            if (message.metadataProps && message.metadataProps.length) {
              object.metadataProps = [];
              for (var j = 0; j < message.metadataProps.length; ++j)
                object.metadataProps[j] = $root.onnx.StringStringEntryProto.toObject(message.metadataProps[j], options);
            }
            if (message.trainingInfo && message.trainingInfo.length) {
              object.trainingInfo = [];
              for (var j = 0; j < message.trainingInfo.length; ++j)
                object.trainingInfo[j] = $root.onnx.TrainingInfoProto.toObject(message.trainingInfo[j], options);
            }
            if (message.functions && message.functions.length) {
              object.functions = [];
              for (var j = 0; j < message.functions.length; ++j)
                object.functions[j] = $root.onnx.FunctionProto.toObject(message.functions[j], options);
            }
            return object;
          };
          ModelProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          ModelProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/onnx.ModelProto";
          };
          return ModelProto;
        }();
        onnx6.StringStringEntryProto = function() {
          function StringStringEntryProto(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          StringStringEntryProto.prototype.key = "";
          StringStringEntryProto.prototype.value = "";
          StringStringEntryProto.create = function create(properties) {
            return new StringStringEntryProto(properties);
          };
          StringStringEntryProto.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.key != null && Object.hasOwnProperty.call(message, "key"))
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(message.key);
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
              writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).string(message.value);
            return writer;
          };
          StringStringEntryProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          StringStringEntryProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.StringStringEntryProto();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.key = reader.string();
                  break;
                }
                case 2: {
                  message.value = reader.string();
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          StringStringEntryProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          StringStringEntryProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.key != null && message.hasOwnProperty("key")) {
              if (!$util.isString(message.key))
                return "key: string expected";
            }
            if (message.value != null && message.hasOwnProperty("value")) {
              if (!$util.isString(message.value))
                return "value: string expected";
            }
            return null;
          };
          StringStringEntryProto.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.StringStringEntryProto)
              return object;
            var message = new $root.onnx.StringStringEntryProto();
            if (object.key != null)
              message.key = String(object.key);
            if (object.value != null)
              message.value = String(object.value);
            return message;
          };
          StringStringEntryProto.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              object.key = "";
              object.value = "";
            }
            if (message.key != null && message.hasOwnProperty("key"))
              object.key = message.key;
            if (message.value != null && message.hasOwnProperty("value"))
              object.value = message.value;
            return object;
          };
          StringStringEntryProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          StringStringEntryProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/onnx.StringStringEntryProto";
          };
          return StringStringEntryProto;
        }();
        onnx6.TensorAnnotation = function() {
          function TensorAnnotation(properties) {
            this.quantParameterTensorNames = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          TensorAnnotation.prototype.tensorName = "";
          TensorAnnotation.prototype.quantParameterTensorNames = $util.emptyArray;
          TensorAnnotation.create = function create(properties) {
            return new TensorAnnotation(properties);
          };
          TensorAnnotation.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.tensorName != null && Object.hasOwnProperty.call(message, "tensorName"))
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(message.tensorName);
            if (message.quantParameterTensorNames != null && message.quantParameterTensorNames.length)
              for (var i = 0; i < message.quantParameterTensorNames.length; ++i)
                $root.onnx.StringStringEntryProto.encode(
                  message.quantParameterTensorNames[i],
                  writer.uint32(
                    /* id 2, wireType 2 =*/
                    18
                  ).fork()
                ).ldelim();
            return writer;
          };
          TensorAnnotation.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          TensorAnnotation.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.TensorAnnotation();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.tensorName = reader.string();
                  break;
                }
                case 2: {
                  if (!(message.quantParameterTensorNames && message.quantParameterTensorNames.length))
                    message.quantParameterTensorNames = [];
                  message.quantParameterTensorNames.push($root.onnx.StringStringEntryProto.decode(reader, reader.uint32()));
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          TensorAnnotation.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          TensorAnnotation.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.tensorName != null && message.hasOwnProperty("tensorName")) {
              if (!$util.isString(message.tensorName))
                return "tensorName: string expected";
            }
            if (message.quantParameterTensorNames != null && message.hasOwnProperty("quantParameterTensorNames")) {
              if (!Array.isArray(message.quantParameterTensorNames))
                return "quantParameterTensorNames: array expected";
              for (var i = 0; i < message.quantParameterTensorNames.length; ++i) {
                var error = $root.onnx.StringStringEntryProto.verify(message.quantParameterTensorNames[i]);
                if (error)
                  return "quantParameterTensorNames." + error;
              }
            }
            return null;
          };
          TensorAnnotation.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.TensorAnnotation)
              return object;
            var message = new $root.onnx.TensorAnnotation();
            if (object.tensorName != null)
              message.tensorName = String(object.tensorName);
            if (object.quantParameterTensorNames) {
              if (!Array.isArray(object.quantParameterTensorNames))
                throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");
              message.quantParameterTensorNames = [];
              for (var i = 0; i < object.quantParameterTensorNames.length; ++i) {
                if (typeof object.quantParameterTensorNames[i] !== "object")
                  throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");
                message.quantParameterTensorNames[i] = $root.onnx.StringStringEntryProto.fromObject(
                  object.quantParameterTensorNames[i]
                );
              }
            }
            return message;
          };
          TensorAnnotation.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults)
              object.quantParameterTensorNames = [];
            if (options.defaults)
              object.tensorName = "";
            if (message.tensorName != null && message.hasOwnProperty("tensorName"))
              object.tensorName = message.tensorName;
            if (message.quantParameterTensorNames && message.quantParameterTensorNames.length) {
              object.quantParameterTensorNames = [];
              for (var j = 0; j < message.quantParameterTensorNames.length; ++j)
                object.quantParameterTensorNames[j] = $root.onnx.StringStringEntryProto.toObject(
                  message.quantParameterTensorNames[j],
                  options
                );
            }
            return object;
          };
          TensorAnnotation.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          TensorAnnotation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/onnx.TensorAnnotation";
          };
          return TensorAnnotation;
        }();
        onnx6.GraphProto = function() {
          function GraphProto(properties) {
            this.node = [];
            this.initializer = [];
            this.sparseInitializer = [];
            this.input = [];
            this.output = [];
            this.valueInfo = [];
            this.quantizationAnnotation = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          GraphProto.prototype.node = $util.emptyArray;
          GraphProto.prototype.name = "";
          GraphProto.prototype.initializer = $util.emptyArray;
          GraphProto.prototype.sparseInitializer = $util.emptyArray;
          GraphProto.prototype.docString = "";
          GraphProto.prototype.input = $util.emptyArray;
          GraphProto.prototype.output = $util.emptyArray;
          GraphProto.prototype.valueInfo = $util.emptyArray;
          GraphProto.prototype.quantizationAnnotation = $util.emptyArray;
          GraphProto.create = function create(properties) {
            return new GraphProto(properties);
          };
          GraphProto.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.node != null && message.node.length)
              for (var i = 0; i < message.node.length; ++i)
                $root.onnx.NodeProto.encode(message.node[i], writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).fork()).ldelim();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
              writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).string(message.name);
            if (message.initializer != null && message.initializer.length)
              for (var i = 0; i < message.initializer.length; ++i)
                $root.onnx.TensorProto.encode(
                  message.initializer[i],
                  writer.uint32(
                    /* id 5, wireType 2 =*/
                    42
                  ).fork()
                ).ldelim();
            if (message.docString != null && Object.hasOwnProperty.call(message, "docString"))
              writer.uint32(
                /* id 10, wireType 2 =*/
                82
              ).string(message.docString);
            if (message.input != null && message.input.length)
              for (var i = 0; i < message.input.length; ++i)
                $root.onnx.ValueInfoProto.encode(
                  message.input[i],
                  writer.uint32(
                    /* id 11, wireType 2 =*/
                    90
                  ).fork()
                ).ldelim();
            if (message.output != null && message.output.length)
              for (var i = 0; i < message.output.length; ++i)
                $root.onnx.ValueInfoProto.encode(
                  message.output[i],
                  writer.uint32(
                    /* id 12, wireType 2 =*/
                    98
                  ).fork()
                ).ldelim();
            if (message.valueInfo != null && message.valueInfo.length)
              for (var i = 0; i < message.valueInfo.length; ++i)
                $root.onnx.ValueInfoProto.encode(
                  message.valueInfo[i],
                  writer.uint32(
                    /* id 13, wireType 2 =*/
                    106
                  ).fork()
                ).ldelim();
            if (message.quantizationAnnotation != null && message.quantizationAnnotation.length)
              for (var i = 0; i < message.quantizationAnnotation.length; ++i)
                $root.onnx.TensorAnnotation.encode(
                  message.quantizationAnnotation[i],
                  writer.uint32(
                    /* id 14, wireType 2 =*/
                    114
                  ).fork()
                ).ldelim();
            if (message.sparseInitializer != null && message.sparseInitializer.length)
              for (var i = 0; i < message.sparseInitializer.length; ++i)
                $root.onnx.SparseTensorProto.encode(
                  message.sparseInitializer[i],
                  writer.uint32(
                    /* id 15, wireType 2 =*/
                    122
                  ).fork()
                ).ldelim();
            return writer;
          };
          GraphProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          GraphProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.GraphProto();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  if (!(message.node && message.node.length))
                    message.node = [];
                  message.node.push($root.onnx.NodeProto.decode(reader, reader.uint32()));
                  break;
                }
                case 2: {
                  message.name = reader.string();
                  break;
                }
                case 5: {
                  if (!(message.initializer && message.initializer.length))
                    message.initializer = [];
                  message.initializer.push($root.onnx.TensorProto.decode(reader, reader.uint32()));
                  break;
                }
                case 15: {
                  if (!(message.sparseInitializer && message.sparseInitializer.length))
                    message.sparseInitializer = [];
                  message.sparseInitializer.push($root.onnx.SparseTensorProto.decode(reader, reader.uint32()));
                  break;
                }
                case 10: {
                  message.docString = reader.string();
                  break;
                }
                case 11: {
                  if (!(message.input && message.input.length))
                    message.input = [];
                  message.input.push($root.onnx.ValueInfoProto.decode(reader, reader.uint32()));
                  break;
                }
                case 12: {
                  if (!(message.output && message.output.length))
                    message.output = [];
                  message.output.push($root.onnx.ValueInfoProto.decode(reader, reader.uint32()));
                  break;
                }
                case 13: {
                  if (!(message.valueInfo && message.valueInfo.length))
                    message.valueInfo = [];
                  message.valueInfo.push($root.onnx.ValueInfoProto.decode(reader, reader.uint32()));
                  break;
                }
                case 14: {
                  if (!(message.quantizationAnnotation && message.quantizationAnnotation.length))
                    message.quantizationAnnotation = [];
                  message.quantizationAnnotation.push($root.onnx.TensorAnnotation.decode(reader, reader.uint32()));
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          GraphProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          GraphProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.node != null && message.hasOwnProperty("node")) {
              if (!Array.isArray(message.node))
                return "node: array expected";
              for (var i = 0; i < message.node.length; ++i) {
                var error = $root.onnx.NodeProto.verify(message.node[i]);
                if (error)
                  return "node." + error;
              }
            }
            if (message.name != null && message.hasOwnProperty("name")) {
              if (!$util.isString(message.name))
                return "name: string expected";
            }
            if (message.initializer != null && message.hasOwnProperty("initializer")) {
              if (!Array.isArray(message.initializer))
                return "initializer: array expected";
              for (var i = 0; i < message.initializer.length; ++i) {
                var error = $root.onnx.TensorProto.verify(message.initializer[i]);
                if (error)
                  return "initializer." + error;
              }
            }
            if (message.sparseInitializer != null && message.hasOwnProperty("sparseInitializer")) {
              if (!Array.isArray(message.sparseInitializer))
                return "sparseInitializer: array expected";
              for (var i = 0; i < message.sparseInitializer.length; ++i) {
                var error = $root.onnx.SparseTensorProto.verify(message.sparseInitializer[i]);
                if (error)
                  return "sparseInitializer." + error;
              }
            }
            if (message.docString != null && message.hasOwnProperty("docString")) {
              if (!$util.isString(message.docString))
                return "docString: string expected";
            }
            if (message.input != null && message.hasOwnProperty("input")) {
              if (!Array.isArray(message.input))
                return "input: array expected";
              for (var i = 0; i < message.input.length; ++i) {
                var error = $root.onnx.ValueInfoProto.verify(message.input[i]);
                if (error)
                  return "input." + error;
              }
            }
            if (message.output != null && message.hasOwnProperty("output")) {
              if (!Array.isArray(message.output))
                return "output: array expected";
              for (var i = 0; i < message.output.length; ++i) {
                var error = $root.onnx.ValueInfoProto.verify(message.output[i]);
                if (error)
                  return "output." + error;
              }
            }
            if (message.valueInfo != null && message.hasOwnProperty("valueInfo")) {
              if (!Array.isArray(message.valueInfo))
                return "valueInfo: array expected";
              for (var i = 0; i < message.valueInfo.length; ++i) {
                var error = $root.onnx.ValueInfoProto.verify(message.valueInfo[i]);
                if (error)
                  return "valueInfo." + error;
              }
            }
            if (message.quantizationAnnotation != null && message.hasOwnProperty("quantizationAnnotation")) {
              if (!Array.isArray(message.quantizationAnnotation))
                return "quantizationAnnotation: array expected";
              for (var i = 0; i < message.quantizationAnnotation.length; ++i) {
                var error = $root.onnx.TensorAnnotation.verify(message.quantizationAnnotation[i]);
                if (error)
                  return "quantizationAnnotation." + error;
              }
            }
            return null;
          };
          GraphProto.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.GraphProto)
              return object;
            var message = new $root.onnx.GraphProto();
            if (object.node) {
              if (!Array.isArray(object.node))
                throw TypeError(".onnx.GraphProto.node: array expected");
              message.node = [];
              for (var i = 0; i < object.node.length; ++i) {
                if (typeof object.node[i] !== "object")
                  throw TypeError(".onnx.GraphProto.node: object expected");
                message.node[i] = $root.onnx.NodeProto.fromObject(object.node[i]);
              }
            }
            if (object.name != null)
              message.name = String(object.name);
            if (object.initializer) {
              if (!Array.isArray(object.initializer))
                throw TypeError(".onnx.GraphProto.initializer: array expected");
              message.initializer = [];
              for (var i = 0; i < object.initializer.length; ++i) {
                if (typeof object.initializer[i] !== "object")
                  throw TypeError(".onnx.GraphProto.initializer: object expected");
                message.initializer[i] = $root.onnx.TensorProto.fromObject(object.initializer[i]);
              }
            }
            if (object.sparseInitializer) {
              if (!Array.isArray(object.sparseInitializer))
                throw TypeError(".onnx.GraphProto.sparseInitializer: array expected");
              message.sparseInitializer = [];
              for (var i = 0; i < object.sparseInitializer.length; ++i) {
                if (typeof object.sparseInitializer[i] !== "object")
                  throw TypeError(".onnx.GraphProto.sparseInitializer: object expected");
                message.sparseInitializer[i] = $root.onnx.SparseTensorProto.fromObject(object.sparseInitializer[i]);
              }
            }
            if (object.docString != null)
              message.docString = String(object.docString);
            if (object.input) {
              if (!Array.isArray(object.input))
                throw TypeError(".onnx.GraphProto.input: array expected");
              message.input = [];
              for (var i = 0; i < object.input.length; ++i) {
                if (typeof object.input[i] !== "object")
                  throw TypeError(".onnx.GraphProto.input: object expected");
                message.input[i] = $root.onnx.ValueInfoProto.fromObject(object.input[i]);
              }
            }
            if (object.output) {
              if (!Array.isArray(object.output))
                throw TypeError(".onnx.GraphProto.output: array expected");
              message.output = [];
              for (var i = 0; i < object.output.length; ++i) {
                if (typeof object.output[i] !== "object")
                  throw TypeError(".onnx.GraphProto.output: object expected");
                message.output[i] = $root.onnx.ValueInfoProto.fromObject(object.output[i]);
              }
            }
            if (object.valueInfo) {
              if (!Array.isArray(object.valueInfo))
                throw TypeError(".onnx.GraphProto.valueInfo: array expected");
              message.valueInfo = [];
              for (var i = 0; i < object.valueInfo.length; ++i) {
                if (typeof object.valueInfo[i] !== "object")
                  throw TypeError(".onnx.GraphProto.valueInfo: object expected");
                message.valueInfo[i] = $root.onnx.ValueInfoProto.fromObject(object.valueInfo[i]);
              }
            }
            if (object.quantizationAnnotation) {
              if (!Array.isArray(object.quantizationAnnotation))
                throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");
              message.quantizationAnnotation = [];
              for (var i = 0; i < object.quantizationAnnotation.length; ++i) {
                if (typeof object.quantizationAnnotation[i] !== "object")
                  throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");
                message.quantizationAnnotation[i] = $root.onnx.TensorAnnotation.fromObject(object.quantizationAnnotation[i]);
              }
            }
            return message;
          };
          GraphProto.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults) {
              object.node = [];
              object.initializer = [];
              object.input = [];
              object.output = [];
              object.valueInfo = [];
              object.quantizationAnnotation = [];
              object.sparseInitializer = [];
            }
            if (options.defaults) {
              object.name = "";
              object.docString = "";
            }
            if (message.node && message.node.length) {
              object.node = [];
              for (var j = 0; j < message.node.length; ++j)
                object.node[j] = $root.onnx.NodeProto.toObject(message.node[j], options);
            }
            if (message.name != null && message.hasOwnProperty("name"))
              object.name = message.name;
            if (message.initializer && message.initializer.length) {
              object.initializer = [];
              for (var j = 0; j < message.initializer.length; ++j)
                object.initializer[j] = $root.onnx.TensorProto.toObject(message.initializer[j], options);
            }
            if (message.docString != null && message.hasOwnProperty("docString"))
              object.docString = message.docString;
            if (message.input && message.input.length) {
              object.input = [];
              for (var j = 0; j < message.input.length; ++j)
                object.input[j] = $root.onnx.ValueInfoProto.toObject(message.input[j], options);
            }
            if (message.output && message.output.length) {
              object.output = [];
              for (var j = 0; j < message.output.length; ++j)
                object.output[j] = $root.onnx.ValueInfoProto.toObject(message.output[j], options);
            }
            if (message.valueInfo && message.valueInfo.length) {
              object.valueInfo = [];
              for (var j = 0; j < message.valueInfo.length; ++j)
                object.valueInfo[j] = $root.onnx.ValueInfoProto.toObject(message.valueInfo[j], options);
            }
            if (message.quantizationAnnotation && message.quantizationAnnotation.length) {
              object.quantizationAnnotation = [];
              for (var j = 0; j < message.quantizationAnnotation.length; ++j)
                object.quantizationAnnotation[j] = $root.onnx.TensorAnnotation.toObject(
                  message.quantizationAnnotation[j],
                  options
                );
            }
            if (message.sparseInitializer && message.sparseInitializer.length) {
              object.sparseInitializer = [];
              for (var j = 0; j < message.sparseInitializer.length; ++j)
                object.sparseInitializer[j] = $root.onnx.SparseTensorProto.toObject(message.sparseInitializer[j], options);
            }
            return object;
          };
          GraphProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          GraphProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/onnx.GraphProto";
          };
          return GraphProto;
        }();
        onnx6.TensorProto = function() {
          function TensorProto(properties) {
            this.dims = [];
            this.floatData = [];
            this.int32Data = [];
            this.stringData = [];
            this.int64Data = [];
            this.externalData = [];
            this.doubleData = [];
            this.uint64Data = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          TensorProto.prototype.dims = $util.emptyArray;
          TensorProto.prototype.dataType = 0;
          TensorProto.prototype.segment = null;
          TensorProto.prototype.floatData = $util.emptyArray;
          TensorProto.prototype.int32Data = $util.emptyArray;
          TensorProto.prototype.stringData = $util.emptyArray;
          TensorProto.prototype.int64Data = $util.emptyArray;
          TensorProto.prototype.name = "";
          TensorProto.prototype.docString = "";
          TensorProto.prototype.rawData = $util.newBuffer([]);
          TensorProto.prototype.externalData = $util.emptyArray;
          TensorProto.prototype.dataLocation = 0;
          TensorProto.prototype.doubleData = $util.emptyArray;
          TensorProto.prototype.uint64Data = $util.emptyArray;
          TensorProto.create = function create(properties) {
            return new TensorProto(properties);
          };
          TensorProto.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.dims != null && message.dims.length) {
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).fork();
              for (var i = 0; i < message.dims.length; ++i)
                writer.int64(message.dims[i]);
              writer.ldelim();
            }
            if (message.dataType != null && Object.hasOwnProperty.call(message, "dataType"))
              writer.uint32(
                /* id 2, wireType 0 =*/
                16
              ).int32(message.dataType);
            if (message.segment != null && Object.hasOwnProperty.call(message, "segment"))
              $root.onnx.TensorProto.Segment.encode(
                message.segment,
                writer.uint32(
                  /* id 3, wireType 2 =*/
                  26
                ).fork()
              ).ldelim();
            if (message.floatData != null && message.floatData.length) {
              writer.uint32(
                /* id 4, wireType 2 =*/
                34
              ).fork();
              for (var i = 0; i < message.floatData.length; ++i)
                writer.float(message.floatData[i]);
              writer.ldelim();
            }
            if (message.int32Data != null && message.int32Data.length) {
              writer.uint32(
                /* id 5, wireType 2 =*/
                42
              ).fork();
              for (var i = 0; i < message.int32Data.length; ++i)
                writer.int32(message.int32Data[i]);
              writer.ldelim();
            }
            if (message.stringData != null && message.stringData.length)
              for (var i = 0; i < message.stringData.length; ++i)
                writer.uint32(
                  /* id 6, wireType 2 =*/
                  50
                ).bytes(message.stringData[i]);
            if (message.int64Data != null && message.int64Data.length) {
              writer.uint32(
                /* id 7, wireType 2 =*/
                58
              ).fork();
              for (var i = 0; i < message.int64Data.length; ++i)
                writer.int64(message.int64Data[i]);
              writer.ldelim();
            }
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
              writer.uint32(
                /* id 8, wireType 2 =*/
                66
              ).string(message.name);
            if (message.rawData != null && Object.hasOwnProperty.call(message, "rawData"))
              writer.uint32(
                /* id 9, wireType 2 =*/
                74
              ).bytes(message.rawData);
            if (message.doubleData != null && message.doubleData.length) {
              writer.uint32(
                /* id 10, wireType 2 =*/
                82
              ).fork();
              for (var i = 0; i < message.doubleData.length; ++i)
                writer.double(message.doubleData[i]);
              writer.ldelim();
            }
            if (message.uint64Data != null && message.uint64Data.length) {
              writer.uint32(
                /* id 11, wireType 2 =*/
                90
              ).fork();
              for (var i = 0; i < message.uint64Data.length; ++i)
                writer.uint64(message.uint64Data[i]);
              writer.ldelim();
            }
            if (message.docString != null && Object.hasOwnProperty.call(message, "docString"))
              writer.uint32(
                /* id 12, wireType 2 =*/
                98
              ).string(message.docString);
            if (message.externalData != null && message.externalData.length)
              for (var i = 0; i < message.externalData.length; ++i)
                $root.onnx.StringStringEntryProto.encode(
                  message.externalData[i],
                  writer.uint32(
                    /* id 13, wireType 2 =*/
                    106
                  ).fork()
                ).ldelim();
            if (message.dataLocation != null && Object.hasOwnProperty.call(message, "dataLocation"))
              writer.uint32(
                /* id 14, wireType 0 =*/
                112
              ).int32(message.dataLocation);
            return writer;
          };
          TensorProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          TensorProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.TensorProto();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  if (!(message.dims && message.dims.length))
                    message.dims = [];
                  if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                      message.dims.push(reader.int64());
                  } else
                    message.dims.push(reader.int64());
                  break;
                }
                case 2: {
                  message.dataType = reader.int32();
                  break;
                }
                case 3: {
                  message.segment = $root.onnx.TensorProto.Segment.decode(reader, reader.uint32());
                  break;
                }
                case 4: {
                  if (!(message.floatData && message.floatData.length))
                    message.floatData = [];
                  if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                      message.floatData.push(reader.float());
                  } else
                    message.floatData.push(reader.float());
                  break;
                }
                case 5: {
                  if (!(message.int32Data && message.int32Data.length))
                    message.int32Data = [];
                  if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                      message.int32Data.push(reader.int32());
                  } else
                    message.int32Data.push(reader.int32());
                  break;
                }
                case 6: {
                  if (!(message.stringData && message.stringData.length))
                    message.stringData = [];
                  message.stringData.push(reader.bytes());
                  break;
                }
                case 7: {
                  if (!(message.int64Data && message.int64Data.length))
                    message.int64Data = [];
                  if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                      message.int64Data.push(reader.int64());
                  } else
                    message.int64Data.push(reader.int64());
                  break;
                }
                case 8: {
                  message.name = reader.string();
                  break;
                }
                case 12: {
                  message.docString = reader.string();
                  break;
                }
                case 9: {
                  message.rawData = reader.bytes();
                  break;
                }
                case 13: {
                  if (!(message.externalData && message.externalData.length))
                    message.externalData = [];
                  message.externalData.push($root.onnx.StringStringEntryProto.decode(reader, reader.uint32()));
                  break;
                }
                case 14: {
                  message.dataLocation = reader.int32();
                  break;
                }
                case 10: {
                  if (!(message.doubleData && message.doubleData.length))
                    message.doubleData = [];
                  if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                      message.doubleData.push(reader.double());
                  } else
                    message.doubleData.push(reader.double());
                  break;
                }
                case 11: {
                  if (!(message.uint64Data && message.uint64Data.length))
                    message.uint64Data = [];
                  if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                      message.uint64Data.push(reader.uint64());
                  } else
                    message.uint64Data.push(reader.uint64());
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          TensorProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          TensorProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.dims != null && message.hasOwnProperty("dims")) {
              if (!Array.isArray(message.dims))
                return "dims: array expected";
              for (var i = 0; i < message.dims.length; ++i)
                if (!$util.isInteger(message.dims[i]) && !(message.dims[i] && $util.isInteger(message.dims[i].low) && $util.isInteger(message.dims[i].high)))
                  return "dims: integer|Long[] expected";
            }
            if (message.dataType != null && message.hasOwnProperty("dataType")) {
              if (!$util.isInteger(message.dataType))
                return "dataType: integer expected";
            }
            if (message.segment != null && message.hasOwnProperty("segment")) {
              var error = $root.onnx.TensorProto.Segment.verify(message.segment);
              if (error)
                return "segment." + error;
            }
            if (message.floatData != null && message.hasOwnProperty("floatData")) {
              if (!Array.isArray(message.floatData))
                return "floatData: array expected";
              for (var i = 0; i < message.floatData.length; ++i)
                if (typeof message.floatData[i] !== "number")
                  return "floatData: number[] expected";
            }
            if (message.int32Data != null && message.hasOwnProperty("int32Data")) {
              if (!Array.isArray(message.int32Data))
                return "int32Data: array expected";
              for (var i = 0; i < message.int32Data.length; ++i)
                if (!$util.isInteger(message.int32Data[i]))
                  return "int32Data: integer[] expected";
            }
            if (message.stringData != null && message.hasOwnProperty("stringData")) {
              if (!Array.isArray(message.stringData))
                return "stringData: array expected";
              for (var i = 0; i < message.stringData.length; ++i)
                if (!(message.stringData[i] && typeof message.stringData[i].length === "number" || $util.isString(message.stringData[i])))
                  return "stringData: buffer[] expected";
            }
            if (message.int64Data != null && message.hasOwnProperty("int64Data")) {
              if (!Array.isArray(message.int64Data))
                return "int64Data: array expected";
              for (var i = 0; i < message.int64Data.length; ++i)
                if (!$util.isInteger(message.int64Data[i]) && !(message.int64Data[i] && $util.isInteger(message.int64Data[i].low) && $util.isInteger(message.int64Data[i].high)))
                  return "int64Data: integer|Long[] expected";
            }
            if (message.name != null && message.hasOwnProperty("name")) {
              if (!$util.isString(message.name))
                return "name: string expected";
            }
            if (message.docString != null && message.hasOwnProperty("docString")) {
              if (!$util.isString(message.docString))
                return "docString: string expected";
            }
            if (message.rawData != null && message.hasOwnProperty("rawData")) {
              if (!(message.rawData && typeof message.rawData.length === "number" || $util.isString(message.rawData)))
                return "rawData: buffer expected";
            }
            if (message.externalData != null && message.hasOwnProperty("externalData")) {
              if (!Array.isArray(message.externalData))
                return "externalData: array expected";
              for (var i = 0; i < message.externalData.length; ++i) {
                var error = $root.onnx.StringStringEntryProto.verify(message.externalData[i]);
                if (error)
                  return "externalData." + error;
              }
            }
            if (message.dataLocation != null && message.hasOwnProperty("dataLocation"))
              switch (message.dataLocation) {
                default:
                  return "dataLocation: enum value expected";
                case 0:
                case 1:
                  break;
              }
            if (message.doubleData != null && message.hasOwnProperty("doubleData")) {
              if (!Array.isArray(message.doubleData))
                return "doubleData: array expected";
              for (var i = 0; i < message.doubleData.length; ++i)
                if (typeof message.doubleData[i] !== "number")
                  return "doubleData: number[] expected";
            }
            if (message.uint64Data != null && message.hasOwnProperty("uint64Data")) {
              if (!Array.isArray(message.uint64Data))
                return "uint64Data: array expected";
              for (var i = 0; i < message.uint64Data.length; ++i)
                if (!$util.isInteger(message.uint64Data[i]) && !(message.uint64Data[i] && $util.isInteger(message.uint64Data[i].low) && $util.isInteger(message.uint64Data[i].high)))
                  return "uint64Data: integer|Long[] expected";
            }
            return null;
          };
          TensorProto.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.TensorProto)
              return object;
            var message = new $root.onnx.TensorProto();
            if (object.dims) {
              if (!Array.isArray(object.dims))
                throw TypeError(".onnx.TensorProto.dims: array expected");
              message.dims = [];
              for (var i = 0; i < object.dims.length; ++i)
                if ($util.Long)
                  (message.dims[i] = $util.Long.fromValue(object.dims[i])).unsigned = false;
                else if (typeof object.dims[i] === "string")
                  message.dims[i] = parseInt(object.dims[i], 10);
                else if (typeof object.dims[i] === "number")
                  message.dims[i] = object.dims[i];
                else if (typeof object.dims[i] === "object")
                  message.dims[i] = new $util.LongBits(object.dims[i].low >>> 0, object.dims[i].high >>> 0).toNumber();
            }
            if (object.dataType != null)
              message.dataType = object.dataType | 0;
            if (object.segment != null) {
              if (typeof object.segment !== "object")
                throw TypeError(".onnx.TensorProto.segment: object expected");
              message.segment = $root.onnx.TensorProto.Segment.fromObject(object.segment);
            }
            if (object.floatData) {
              if (!Array.isArray(object.floatData))
                throw TypeError(".onnx.TensorProto.floatData: array expected");
              message.floatData = [];
              for (var i = 0; i < object.floatData.length; ++i)
                message.floatData[i] = Number(object.floatData[i]);
            }
            if (object.int32Data) {
              if (!Array.isArray(object.int32Data))
                throw TypeError(".onnx.TensorProto.int32Data: array expected");
              message.int32Data = [];
              for (var i = 0; i < object.int32Data.length; ++i)
                message.int32Data[i] = object.int32Data[i] | 0;
            }
            if (object.stringData) {
              if (!Array.isArray(object.stringData))
                throw TypeError(".onnx.TensorProto.stringData: array expected");
              message.stringData = [];
              for (var i = 0; i < object.stringData.length; ++i)
                if (typeof object.stringData[i] === "string")
                  $util.base64.decode(
                    object.stringData[i],
                    message.stringData[i] = $util.newBuffer($util.base64.length(object.stringData[i])),
                    0
                  );
                else if (object.stringData[i].length >= 0)
                  message.stringData[i] = object.stringData[i];
            }
            if (object.int64Data) {
              if (!Array.isArray(object.int64Data))
                throw TypeError(".onnx.TensorProto.int64Data: array expected");
              message.int64Data = [];
              for (var i = 0; i < object.int64Data.length; ++i)
                if ($util.Long)
                  (message.int64Data[i] = $util.Long.fromValue(object.int64Data[i])).unsigned = false;
                else if (typeof object.int64Data[i] === "string")
                  message.int64Data[i] = parseInt(object.int64Data[i], 10);
                else if (typeof object.int64Data[i] === "number")
                  message.int64Data[i] = object.int64Data[i];
                else if (typeof object.int64Data[i] === "object")
                  message.int64Data[i] = new $util.LongBits(
                    object.int64Data[i].low >>> 0,
                    object.int64Data[i].high >>> 0
                  ).toNumber();
            }
            if (object.name != null)
              message.name = String(object.name);
            if (object.docString != null)
              message.docString = String(object.docString);
            if (object.rawData != null) {
              if (typeof object.rawData === "string")
                $util.base64.decode(
                  object.rawData,
                  message.rawData = $util.newBuffer($util.base64.length(object.rawData)),
                  0
                );
              else if (object.rawData.length >= 0)
                message.rawData = object.rawData;
            }
            if (object.externalData) {
              if (!Array.isArray(object.externalData))
                throw TypeError(".onnx.TensorProto.externalData: array expected");
              message.externalData = [];
              for (var i = 0; i < object.externalData.length; ++i) {
                if (typeof object.externalData[i] !== "object")
                  throw TypeError(".onnx.TensorProto.externalData: object expected");
                message.externalData[i] = $root.onnx.StringStringEntryProto.fromObject(object.externalData[i]);
              }
            }
            switch (object.dataLocation) {
              default:
                if (typeof object.dataLocation === "number") {
                  message.dataLocation = object.dataLocation;
                  break;
                }
                break;
              case "DEFAULT":
              case 0:
                message.dataLocation = 0;
                break;
              case "EXTERNAL":
              case 1:
                message.dataLocation = 1;
                break;
            }
            if (object.doubleData) {
              if (!Array.isArray(object.doubleData))
                throw TypeError(".onnx.TensorProto.doubleData: array expected");
              message.doubleData = [];
              for (var i = 0; i < object.doubleData.length; ++i)
                message.doubleData[i] = Number(object.doubleData[i]);
            }
            if (object.uint64Data) {
              if (!Array.isArray(object.uint64Data))
                throw TypeError(".onnx.TensorProto.uint64Data: array expected");
              message.uint64Data = [];
              for (var i = 0; i < object.uint64Data.length; ++i)
                if ($util.Long)
                  (message.uint64Data[i] = $util.Long.fromValue(object.uint64Data[i])).unsigned = true;
                else if (typeof object.uint64Data[i] === "string")
                  message.uint64Data[i] = parseInt(object.uint64Data[i], 10);
                else if (typeof object.uint64Data[i] === "number")
                  message.uint64Data[i] = object.uint64Data[i];
                else if (typeof object.uint64Data[i] === "object")
                  message.uint64Data[i] = new $util.LongBits(
                    object.uint64Data[i].low >>> 0,
                    object.uint64Data[i].high >>> 0
                  ).toNumber(true);
            }
            return message;
          };
          TensorProto.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults) {
              object.dims = [];
              object.floatData = [];
              object.int32Data = [];
              object.stringData = [];
              object.int64Data = [];
              object.doubleData = [];
              object.uint64Data = [];
              object.externalData = [];
            }
            if (options.defaults) {
              object.dataType = 0;
              object.segment = null;
              object.name = "";
              if (options.bytes === String)
                object.rawData = "";
              else {
                object.rawData = [];
                if (options.bytes !== Array)
                  object.rawData = $util.newBuffer(object.rawData);
              }
              object.docString = "";
              object.dataLocation = options.enums === String ? "DEFAULT" : 0;
            }
            if (message.dims && message.dims.length) {
              object.dims = [];
              for (var j = 0; j < message.dims.length; ++j)
                if (typeof message.dims[j] === "number")
                  object.dims[j] = options.longs === String ? String(message.dims[j]) : message.dims[j];
                else
                  object.dims[j] = options.longs === String ? $util.Long.prototype.toString.call(message.dims[j]) : options.longs === Number ? new $util.LongBits(message.dims[j].low >>> 0, message.dims[j].high >>> 0).toNumber() : message.dims[j];
            }
            if (message.dataType != null && message.hasOwnProperty("dataType"))
              object.dataType = message.dataType;
            if (message.segment != null && message.hasOwnProperty("segment"))
              object.segment = $root.onnx.TensorProto.Segment.toObject(message.segment, options);
            if (message.floatData && message.floatData.length) {
              object.floatData = [];
              for (var j = 0; j < message.floatData.length; ++j)
                object.floatData[j] = options.json && !isFinite(message.floatData[j]) ? String(message.floatData[j]) : message.floatData[j];
            }
            if (message.int32Data && message.int32Data.length) {
              object.int32Data = [];
              for (var j = 0; j < message.int32Data.length; ++j)
                object.int32Data[j] = message.int32Data[j];
            }
            if (message.stringData && message.stringData.length) {
              object.stringData = [];
              for (var j = 0; j < message.stringData.length; ++j)
                object.stringData[j] = options.bytes === String ? $util.base64.encode(message.stringData[j], 0, message.stringData[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.stringData[j]) : message.stringData[j];
            }
            if (message.int64Data && message.int64Data.length) {
              object.int64Data = [];
              for (var j = 0; j < message.int64Data.length; ++j)
                if (typeof message.int64Data[j] === "number")
                  object.int64Data[j] = options.longs === String ? String(message.int64Data[j]) : message.int64Data[j];
                else
                  object.int64Data[j] = options.longs === String ? $util.Long.prototype.toString.call(message.int64Data[j]) : options.longs === Number ? new $util.LongBits(message.int64Data[j].low >>> 0, message.int64Data[j].high >>> 0).toNumber() : message.int64Data[j];
            }
            if (message.name != null && message.hasOwnProperty("name"))
              object.name = message.name;
            if (message.rawData != null && message.hasOwnProperty("rawData"))
              object.rawData = options.bytes === String ? $util.base64.encode(message.rawData, 0, message.rawData.length) : options.bytes === Array ? Array.prototype.slice.call(message.rawData) : message.rawData;
            if (message.doubleData && message.doubleData.length) {
              object.doubleData = [];
              for (var j = 0; j < message.doubleData.length; ++j)
                object.doubleData[j] = options.json && !isFinite(message.doubleData[j]) ? String(message.doubleData[j]) : message.doubleData[j];
            }
            if (message.uint64Data && message.uint64Data.length) {
              object.uint64Data = [];
              for (var j = 0; j < message.uint64Data.length; ++j)
                if (typeof message.uint64Data[j] === "number")
                  object.uint64Data[j] = options.longs === String ? String(message.uint64Data[j]) : message.uint64Data[j];
                else
                  object.uint64Data[j] = options.longs === String ? $util.Long.prototype.toString.call(message.uint64Data[j]) : options.longs === Number ? new $util.LongBits(message.uint64Data[j].low >>> 0, message.uint64Data[j].high >>> 0).toNumber(true) : message.uint64Data[j];
            }
            if (message.docString != null && message.hasOwnProperty("docString"))
              object.docString = message.docString;
            if (message.externalData && message.externalData.length) {
              object.externalData = [];
              for (var j = 0; j < message.externalData.length; ++j)
                object.externalData[j] = $root.onnx.StringStringEntryProto.toObject(message.externalData[j], options);
            }
            if (message.dataLocation != null && message.hasOwnProperty("dataLocation"))
              object.dataLocation = options.enums === String ? $root.onnx.TensorProto.DataLocation[message.dataLocation] === void 0 ? message.dataLocation : $root.onnx.TensorProto.DataLocation[message.dataLocation] : message.dataLocation;
            return object;
          };
          TensorProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          TensorProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/onnx.TensorProto";
          };
          TensorProto.DataType = function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNDEFINED"] = 0;
            values[valuesById[1] = "FLOAT"] = 1;
            values[valuesById[2] = "UINT8"] = 2;
            values[valuesById[3] = "INT8"] = 3;
            values[valuesById[4] = "UINT16"] = 4;
            values[valuesById[5] = "INT16"] = 5;
            values[valuesById[6] = "INT32"] = 6;
            values[valuesById[7] = "INT64"] = 7;
            values[valuesById[8] = "STRING"] = 8;
            values[valuesById[9] = "BOOL"] = 9;
            values[valuesById[10] = "FLOAT16"] = 10;
            values[valuesById[11] = "DOUBLE"] = 11;
            values[valuesById[12] = "UINT32"] = 12;
            values[valuesById[13] = "UINT64"] = 13;
            values[valuesById[14] = "COMPLEX64"] = 14;
            values[valuesById[15] = "COMPLEX128"] = 15;
            values[valuesById[16] = "BFLOAT16"] = 16;
            values[valuesById[17] = "FLOAT8E4M3FN"] = 17;
            values[valuesById[18] = "FLOAT8E4M3FNUZ"] = 18;
            values[valuesById[19] = "FLOAT8E5M2"] = 19;
            values[valuesById[20] = "FLOAT8E5M2FNUZ"] = 20;
            return values;
          }();
          TensorProto.Segment = function() {
            function Segment(properties) {
              if (properties) {
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            Segment.prototype.begin = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            Segment.prototype.end = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            Segment.create = function create(properties) {
              return new Segment(properties);
            };
            Segment.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.begin != null && Object.hasOwnProperty.call(message, "begin"))
                writer.uint32(
                  /* id 1, wireType 0 =*/
                  8
                ).int64(message.begin);
              if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                writer.uint32(
                  /* id 2, wireType 0 =*/
                  16
                ).int64(message.end);
              return writer;
            };
            Segment.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            Segment.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.TensorProto.Segment();
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.begin = reader.int64();
                    break;
                  }
                  case 2: {
                    message.end = reader.int64();
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            Segment.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            Segment.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.begin != null && message.hasOwnProperty("begin")) {
                if (!$util.isInteger(message.begin) && !(message.begin && $util.isInteger(message.begin.low) && $util.isInteger(message.begin.high)))
                  return "begin: integer|Long expected";
              }
              if (message.end != null && message.hasOwnProperty("end")) {
                if (!$util.isInteger(message.end) && !(message.end && $util.isInteger(message.end.low) && $util.isInteger(message.end.high)))
                  return "end: integer|Long expected";
              }
              return null;
            };
            Segment.fromObject = function fromObject(object) {
              if (object instanceof $root.onnx.TensorProto.Segment)
                return object;
              var message = new $root.onnx.TensorProto.Segment();
              if (object.begin != null) {
                if ($util.Long)
                  (message.begin = $util.Long.fromValue(object.begin)).unsigned = false;
                else if (typeof object.begin === "string")
                  message.begin = parseInt(object.begin, 10);
                else if (typeof object.begin === "number")
                  message.begin = object.begin;
                else if (typeof object.begin === "object")
                  message.begin = new $util.LongBits(object.begin.low >>> 0, object.begin.high >>> 0).toNumber();
              }
              if (object.end != null) {
                if ($util.Long)
                  (message.end = $util.Long.fromValue(object.end)).unsigned = false;
                else if (typeof object.end === "string")
                  message.end = parseInt(object.end, 10);
                else if (typeof object.end === "number")
                  message.end = object.end;
                else if (typeof object.end === "object")
                  message.end = new $util.LongBits(object.end.low >>> 0, object.end.high >>> 0).toNumber();
              }
              return message;
            };
            Segment.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.defaults) {
                if ($util.Long) {
                  var long = new $util.Long(0, 0, false);
                  object.begin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                  object.begin = options.longs === String ? "0" : 0;
                if ($util.Long) {
                  var long = new $util.Long(0, 0, false);
                  object.end = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                  object.end = options.longs === String ? "0" : 0;
              }
              if (message.begin != null && message.hasOwnProperty("begin"))
                if (typeof message.begin === "number")
                  object.begin = options.longs === String ? String(message.begin) : message.begin;
                else
                  object.begin = options.longs === String ? $util.Long.prototype.toString.call(message.begin) : options.longs === Number ? new $util.LongBits(message.begin.low >>> 0, message.begin.high >>> 0).toNumber() : message.begin;
              if (message.end != null && message.hasOwnProperty("end"))
                if (typeof message.end === "number")
                  object.end = options.longs === String ? String(message.end) : message.end;
                else
                  object.end = options.longs === String ? $util.Long.prototype.toString.call(message.end) : options.longs === Number ? new $util.LongBits(message.end.low >>> 0, message.end.high >>> 0).toNumber() : message.end;
              return object;
            };
            Segment.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            Segment.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === void 0) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return typeUrlPrefix + "/onnx.TensorProto.Segment";
            };
            return Segment;
          }();
          TensorProto.DataLocation = function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "DEFAULT"] = 0;
            values[valuesById[1] = "EXTERNAL"] = 1;
            return values;
          }();
          return TensorProto;
        }();
        onnx6.SparseTensorProto = function() {
          function SparseTensorProto(properties) {
            this.dims = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          SparseTensorProto.prototype.values = null;
          SparseTensorProto.prototype.indices = null;
          SparseTensorProto.prototype.dims = $util.emptyArray;
          SparseTensorProto.create = function create(properties) {
            return new SparseTensorProto(properties);
          };
          SparseTensorProto.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.values != null && Object.hasOwnProperty.call(message, "values"))
              $root.onnx.TensorProto.encode(message.values, writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).fork()).ldelim();
            if (message.indices != null && Object.hasOwnProperty.call(message, "indices"))
              $root.onnx.TensorProto.encode(message.indices, writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim();
            if (message.dims != null && message.dims.length) {
              writer.uint32(
                /* id 3, wireType 2 =*/
                26
              ).fork();
              for (var i = 0; i < message.dims.length; ++i)
                writer.int64(message.dims[i]);
              writer.ldelim();
            }
            return writer;
          };
          SparseTensorProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          SparseTensorProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.SparseTensorProto();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.values = $root.onnx.TensorProto.decode(reader, reader.uint32());
                  break;
                }
                case 2: {
                  message.indices = $root.onnx.TensorProto.decode(reader, reader.uint32());
                  break;
                }
                case 3: {
                  if (!(message.dims && message.dims.length))
                    message.dims = [];
                  if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                      message.dims.push(reader.int64());
                  } else
                    message.dims.push(reader.int64());
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          SparseTensorProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          SparseTensorProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.values != null && message.hasOwnProperty("values")) {
              var error = $root.onnx.TensorProto.verify(message.values);
              if (error)
                return "values." + error;
            }
            if (message.indices != null && message.hasOwnProperty("indices")) {
              var error = $root.onnx.TensorProto.verify(message.indices);
              if (error)
                return "indices." + error;
            }
            if (message.dims != null && message.hasOwnProperty("dims")) {
              if (!Array.isArray(message.dims))
                return "dims: array expected";
              for (var i = 0; i < message.dims.length; ++i)
                if (!$util.isInteger(message.dims[i]) && !(message.dims[i] && $util.isInteger(message.dims[i].low) && $util.isInteger(message.dims[i].high)))
                  return "dims: integer|Long[] expected";
            }
            return null;
          };
          SparseTensorProto.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.SparseTensorProto)
              return object;
            var message = new $root.onnx.SparseTensorProto();
            if (object.values != null) {
              if (typeof object.values !== "object")
                throw TypeError(".onnx.SparseTensorProto.values: object expected");
              message.values = $root.onnx.TensorProto.fromObject(object.values);
            }
            if (object.indices != null) {
              if (typeof object.indices !== "object")
                throw TypeError(".onnx.SparseTensorProto.indices: object expected");
              message.indices = $root.onnx.TensorProto.fromObject(object.indices);
            }
            if (object.dims) {
              if (!Array.isArray(object.dims))
                throw TypeError(".onnx.SparseTensorProto.dims: array expected");
              message.dims = [];
              for (var i = 0; i < object.dims.length; ++i)
                if ($util.Long)
                  (message.dims[i] = $util.Long.fromValue(object.dims[i])).unsigned = false;
                else if (typeof object.dims[i] === "string")
                  message.dims[i] = parseInt(object.dims[i], 10);
                else if (typeof object.dims[i] === "number")
                  message.dims[i] = object.dims[i];
                else if (typeof object.dims[i] === "object")
                  message.dims[i] = new $util.LongBits(object.dims[i].low >>> 0, object.dims[i].high >>> 0).toNumber();
            }
            return message;
          };
          SparseTensorProto.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults)
              object.dims = [];
            if (options.defaults) {
              object.values = null;
              object.indices = null;
            }
            if (message.values != null && message.hasOwnProperty("values"))
              object.values = $root.onnx.TensorProto.toObject(message.values, options);
            if (message.indices != null && message.hasOwnProperty("indices"))
              object.indices = $root.onnx.TensorProto.toObject(message.indices, options);
            if (message.dims && message.dims.length) {
              object.dims = [];
              for (var j = 0; j < message.dims.length; ++j)
                if (typeof message.dims[j] === "number")
                  object.dims[j] = options.longs === String ? String(message.dims[j]) : message.dims[j];
                else
                  object.dims[j] = options.longs === String ? $util.Long.prototype.toString.call(message.dims[j]) : options.longs === Number ? new $util.LongBits(message.dims[j].low >>> 0, message.dims[j].high >>> 0).toNumber() : message.dims[j];
            }
            return object;
          };
          SparseTensorProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          SparseTensorProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/onnx.SparseTensorProto";
          };
          return SparseTensorProto;
        }();
        onnx6.TensorShapeProto = function() {
          function TensorShapeProto(properties) {
            this.dim = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          TensorShapeProto.prototype.dim = $util.emptyArray;
          TensorShapeProto.create = function create(properties) {
            return new TensorShapeProto(properties);
          };
          TensorShapeProto.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.dim != null && message.dim.length)
              for (var i = 0; i < message.dim.length; ++i)
                $root.onnx.TensorShapeProto.Dimension.encode(
                  message.dim[i],
                  writer.uint32(
                    /* id 1, wireType 2 =*/
                    10
                  ).fork()
                ).ldelim();
            return writer;
          };
          TensorShapeProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          TensorShapeProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.TensorShapeProto();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  if (!(message.dim && message.dim.length))
                    message.dim = [];
                  message.dim.push($root.onnx.TensorShapeProto.Dimension.decode(reader, reader.uint32()));
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          TensorShapeProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          TensorShapeProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.dim != null && message.hasOwnProperty("dim")) {
              if (!Array.isArray(message.dim))
                return "dim: array expected";
              for (var i = 0; i < message.dim.length; ++i) {
                var error = $root.onnx.TensorShapeProto.Dimension.verify(message.dim[i]);
                if (error)
                  return "dim." + error;
              }
            }
            return null;
          };
          TensorShapeProto.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.TensorShapeProto)
              return object;
            var message = new $root.onnx.TensorShapeProto();
            if (object.dim) {
              if (!Array.isArray(object.dim))
                throw TypeError(".onnx.TensorShapeProto.dim: array expected");
              message.dim = [];
              for (var i = 0; i < object.dim.length; ++i) {
                if (typeof object.dim[i] !== "object")
                  throw TypeError(".onnx.TensorShapeProto.dim: object expected");
                message.dim[i] = $root.onnx.TensorShapeProto.Dimension.fromObject(object.dim[i]);
              }
            }
            return message;
          };
          TensorShapeProto.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults)
              object.dim = [];
            if (message.dim && message.dim.length) {
              object.dim = [];
              for (var j = 0; j < message.dim.length; ++j)
                object.dim[j] = $root.onnx.TensorShapeProto.Dimension.toObject(message.dim[j], options);
            }
            return object;
          };
          TensorShapeProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          TensorShapeProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/onnx.TensorShapeProto";
          };
          TensorShapeProto.Dimension = function() {
            function Dimension(properties) {
              if (properties) {
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            Dimension.prototype.dimValue = null;
            Dimension.prototype.dimParam = null;
            Dimension.prototype.denotation = "";
            var $oneOfFields;
            Object.defineProperty(Dimension.prototype, "value", {
              get: $util.oneOfGetter($oneOfFields = ["dimValue", "dimParam"]),
              set: $util.oneOfSetter($oneOfFields)
            });
            Dimension.create = function create(properties) {
              return new Dimension(properties);
            };
            Dimension.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.dimValue != null && Object.hasOwnProperty.call(message, "dimValue"))
                writer.uint32(
                  /* id 1, wireType 0 =*/
                  8
                ).int64(message.dimValue);
              if (message.dimParam != null && Object.hasOwnProperty.call(message, "dimParam"))
                writer.uint32(
                  /* id 2, wireType 2 =*/
                  18
                ).string(message.dimParam);
              if (message.denotation != null && Object.hasOwnProperty.call(message, "denotation"))
                writer.uint32(
                  /* id 3, wireType 2 =*/
                  26
                ).string(message.denotation);
              return writer;
            };
            Dimension.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            Dimension.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.TensorShapeProto.Dimension();
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.dimValue = reader.int64();
                    break;
                  }
                  case 2: {
                    message.dimParam = reader.string();
                    break;
                  }
                  case 3: {
                    message.denotation = reader.string();
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            Dimension.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            Dimension.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              var properties = {};
              if (message.dimValue != null && message.hasOwnProperty("dimValue")) {
                properties.value = 1;
                if (!$util.isInteger(message.dimValue) && !(message.dimValue && $util.isInteger(message.dimValue.low) && $util.isInteger(message.dimValue.high)))
                  return "dimValue: integer|Long expected";
              }
              if (message.dimParam != null && message.hasOwnProperty("dimParam")) {
                if (properties.value === 1)
                  return "value: multiple values";
                properties.value = 1;
                if (!$util.isString(message.dimParam))
                  return "dimParam: string expected";
              }
              if (message.denotation != null && message.hasOwnProperty("denotation")) {
                if (!$util.isString(message.denotation))
                  return "denotation: string expected";
              }
              return null;
            };
            Dimension.fromObject = function fromObject(object) {
              if (object instanceof $root.onnx.TensorShapeProto.Dimension)
                return object;
              var message = new $root.onnx.TensorShapeProto.Dimension();
              if (object.dimValue != null) {
                if ($util.Long)
                  (message.dimValue = $util.Long.fromValue(object.dimValue)).unsigned = false;
                else if (typeof object.dimValue === "string")
                  message.dimValue = parseInt(object.dimValue, 10);
                else if (typeof object.dimValue === "number")
                  message.dimValue = object.dimValue;
                else if (typeof object.dimValue === "object")
                  message.dimValue = new $util.LongBits(object.dimValue.low >>> 0, object.dimValue.high >>> 0).toNumber();
              }
              if (object.dimParam != null)
                message.dimParam = String(object.dimParam);
              if (object.denotation != null)
                message.denotation = String(object.denotation);
              return message;
            };
            Dimension.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.defaults)
                object.denotation = "";
              if (message.dimValue != null && message.hasOwnProperty("dimValue")) {
                if (typeof message.dimValue === "number")
                  object.dimValue = options.longs === String ? String(message.dimValue) : message.dimValue;
                else
                  object.dimValue = options.longs === String ? $util.Long.prototype.toString.call(message.dimValue) : options.longs === Number ? new $util.LongBits(message.dimValue.low >>> 0, message.dimValue.high >>> 0).toNumber() : message.dimValue;
                if (options.oneofs)
                  object.value = "dimValue";
              }
              if (message.dimParam != null && message.hasOwnProperty("dimParam")) {
                object.dimParam = message.dimParam;
                if (options.oneofs)
                  object.value = "dimParam";
              }
              if (message.denotation != null && message.hasOwnProperty("denotation"))
                object.denotation = message.denotation;
              return object;
            };
            Dimension.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            Dimension.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === void 0) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return typeUrlPrefix + "/onnx.TensorShapeProto.Dimension";
            };
            return Dimension;
          }();
          return TensorShapeProto;
        }();
        onnx6.TypeProto = function() {
          function TypeProto(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          TypeProto.prototype.tensorType = null;
          TypeProto.prototype.sequenceType = null;
          TypeProto.prototype.mapType = null;
          TypeProto.prototype.optionalType = null;
          TypeProto.prototype.sparseTensorType = null;
          TypeProto.prototype.denotation = "";
          var $oneOfFields;
          Object.defineProperty(TypeProto.prototype, "value", {
            get: $util.oneOfGetter(
              $oneOfFields = ["tensorType", "sequenceType", "mapType", "optionalType", "sparseTensorType"]
            ),
            set: $util.oneOfSetter($oneOfFields)
          });
          TypeProto.create = function create(properties) {
            return new TypeProto(properties);
          };
          TypeProto.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.tensorType != null && Object.hasOwnProperty.call(message, "tensorType"))
              $root.onnx.TypeProto.Tensor.encode(
                message.tensorType,
                writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).fork()
              ).ldelim();
            if (message.sequenceType != null && Object.hasOwnProperty.call(message, "sequenceType"))
              $root.onnx.TypeProto.Sequence.encode(
                message.sequenceType,
                writer.uint32(
                  /* id 4, wireType 2 =*/
                  34
                ).fork()
              ).ldelim();
            if (message.mapType != null && Object.hasOwnProperty.call(message, "mapType"))
              $root.onnx.TypeProto.Map.encode(message.mapType, writer.uint32(
                /* id 5, wireType 2 =*/
                42
              ).fork()).ldelim();
            if (message.denotation != null && Object.hasOwnProperty.call(message, "denotation"))
              writer.uint32(
                /* id 6, wireType 2 =*/
                50
              ).string(message.denotation);
            if (message.sparseTensorType != null && Object.hasOwnProperty.call(message, "sparseTensorType"))
              $root.onnx.TypeProto.SparseTensor.encode(
                message.sparseTensorType,
                writer.uint32(
                  /* id 8, wireType 2 =*/
                  66
                ).fork()
              ).ldelim();
            if (message.optionalType != null && Object.hasOwnProperty.call(message, "optionalType"))
              $root.onnx.TypeProto.Optional.encode(
                message.optionalType,
                writer.uint32(
                  /* id 9, wireType 2 =*/
                  74
                ).fork()
              ).ldelim();
            return writer;
          };
          TypeProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          TypeProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.TypeProto();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.tensorType = $root.onnx.TypeProto.Tensor.decode(reader, reader.uint32());
                  break;
                }
                case 4: {
                  message.sequenceType = $root.onnx.TypeProto.Sequence.decode(reader, reader.uint32());
                  break;
                }
                case 5: {
                  message.mapType = $root.onnx.TypeProto.Map.decode(reader, reader.uint32());
                  break;
                }
                case 9: {
                  message.optionalType = $root.onnx.TypeProto.Optional.decode(reader, reader.uint32());
                  break;
                }
                case 8: {
                  message.sparseTensorType = $root.onnx.TypeProto.SparseTensor.decode(reader, reader.uint32());
                  break;
                }
                case 6: {
                  message.denotation = reader.string();
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          TypeProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          TypeProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            var properties = {};
            if (message.tensorType != null && message.hasOwnProperty("tensorType")) {
              properties.value = 1;
              {
                var error = $root.onnx.TypeProto.Tensor.verify(message.tensorType);
                if (error)
                  return "tensorType." + error;
              }
            }
            if (message.sequenceType != null && message.hasOwnProperty("sequenceType")) {
              if (properties.value === 1)
                return "value: multiple values";
              properties.value = 1;
              {
                var error = $root.onnx.TypeProto.Sequence.verify(message.sequenceType);
                if (error)
                  return "sequenceType." + error;
              }
            }
            if (message.mapType != null && message.hasOwnProperty("mapType")) {
              if (properties.value === 1)
                return "value: multiple values";
              properties.value = 1;
              {
                var error = $root.onnx.TypeProto.Map.verify(message.mapType);
                if (error)
                  return "mapType." + error;
              }
            }
            if (message.optionalType != null && message.hasOwnProperty("optionalType")) {
              if (properties.value === 1)
                return "value: multiple values";
              properties.value = 1;
              {
                var error = $root.onnx.TypeProto.Optional.verify(message.optionalType);
                if (error)
                  return "optionalType." + error;
              }
            }
            if (message.sparseTensorType != null && message.hasOwnProperty("sparseTensorType")) {
              if (properties.value === 1)
                return "value: multiple values";
              properties.value = 1;
              {
                var error = $root.onnx.TypeProto.SparseTensor.verify(message.sparseTensorType);
                if (error)
                  return "sparseTensorType." + error;
              }
            }
            if (message.denotation != null && message.hasOwnProperty("denotation")) {
              if (!$util.isString(message.denotation))
                return "denotation: string expected";
            }
            return null;
          };
          TypeProto.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.TypeProto)
              return object;
            var message = new $root.onnx.TypeProto();
            if (object.tensorType != null) {
              if (typeof object.tensorType !== "object")
                throw TypeError(".onnx.TypeProto.tensorType: object expected");
              message.tensorType = $root.onnx.TypeProto.Tensor.fromObject(object.tensorType);
            }
            if (object.sequenceType != null) {
              if (typeof object.sequenceType !== "object")
                throw TypeError(".onnx.TypeProto.sequenceType: object expected");
              message.sequenceType = $root.onnx.TypeProto.Sequence.fromObject(object.sequenceType);
            }
            if (object.mapType != null) {
              if (typeof object.mapType !== "object")
                throw TypeError(".onnx.TypeProto.mapType: object expected");
              message.mapType = $root.onnx.TypeProto.Map.fromObject(object.mapType);
            }
            if (object.optionalType != null) {
              if (typeof object.optionalType !== "object")
                throw TypeError(".onnx.TypeProto.optionalType: object expected");
              message.optionalType = $root.onnx.TypeProto.Optional.fromObject(object.optionalType);
            }
            if (object.sparseTensorType != null) {
              if (typeof object.sparseTensorType !== "object")
                throw TypeError(".onnx.TypeProto.sparseTensorType: object expected");
              message.sparseTensorType = $root.onnx.TypeProto.SparseTensor.fromObject(object.sparseTensorType);
            }
            if (object.denotation != null)
              message.denotation = String(object.denotation);
            return message;
          };
          TypeProto.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults)
              object.denotation = "";
            if (message.tensorType != null && message.hasOwnProperty("tensorType")) {
              object.tensorType = $root.onnx.TypeProto.Tensor.toObject(message.tensorType, options);
              if (options.oneofs)
                object.value = "tensorType";
            }
            if (message.sequenceType != null && message.hasOwnProperty("sequenceType")) {
              object.sequenceType = $root.onnx.TypeProto.Sequence.toObject(message.sequenceType, options);
              if (options.oneofs)
                object.value = "sequenceType";
            }
            if (message.mapType != null && message.hasOwnProperty("mapType")) {
              object.mapType = $root.onnx.TypeProto.Map.toObject(message.mapType, options);
              if (options.oneofs)
                object.value = "mapType";
            }
            if (message.denotation != null && message.hasOwnProperty("denotation"))
              object.denotation = message.denotation;
            if (message.sparseTensorType != null && message.hasOwnProperty("sparseTensorType")) {
              object.sparseTensorType = $root.onnx.TypeProto.SparseTensor.toObject(message.sparseTensorType, options);
              if (options.oneofs)
                object.value = "sparseTensorType";
            }
            if (message.optionalType != null && message.hasOwnProperty("optionalType")) {
              object.optionalType = $root.onnx.TypeProto.Optional.toObject(message.optionalType, options);
              if (options.oneofs)
                object.value = "optionalType";
            }
            return object;
          };
          TypeProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          TypeProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/onnx.TypeProto";
          };
          TypeProto.Tensor = function() {
            function Tensor4(properties) {
              if (properties) {
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            Tensor4.prototype.elemType = 0;
            Tensor4.prototype.shape = null;
            Tensor4.create = function create(properties) {
              return new Tensor4(properties);
            };
            Tensor4.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.elemType != null && Object.hasOwnProperty.call(message, "elemType"))
                writer.uint32(
                  /* id 1, wireType 0 =*/
                  8
                ).int32(message.elemType);
              if (message.shape != null && Object.hasOwnProperty.call(message, "shape"))
                $root.onnx.TensorShapeProto.encode(message.shape, writer.uint32(
                  /* id 2, wireType 2 =*/
                  18
                ).fork()).ldelim();
              return writer;
            };
            Tensor4.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            Tensor4.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.TypeProto.Tensor();
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.elemType = reader.int32();
                    break;
                  }
                  case 2: {
                    message.shape = $root.onnx.TensorShapeProto.decode(reader, reader.uint32());
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            Tensor4.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            Tensor4.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.elemType != null && message.hasOwnProperty("elemType")) {
                if (!$util.isInteger(message.elemType))
                  return "elemType: integer expected";
              }
              if (message.shape != null && message.hasOwnProperty("shape")) {
                var error = $root.onnx.TensorShapeProto.verify(message.shape);
                if (error)
                  return "shape." + error;
              }
              return null;
            };
            Tensor4.fromObject = function fromObject(object) {
              if (object instanceof $root.onnx.TypeProto.Tensor)
                return object;
              var message = new $root.onnx.TypeProto.Tensor();
              if (object.elemType != null)
                message.elemType = object.elemType | 0;
              if (object.shape != null) {
                if (typeof object.shape !== "object")
                  throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");
                message.shape = $root.onnx.TensorShapeProto.fromObject(object.shape);
              }
              return message;
            };
            Tensor4.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.defaults) {
                object.elemType = 0;
                object.shape = null;
              }
              if (message.elemType != null && message.hasOwnProperty("elemType"))
                object.elemType = message.elemType;
              if (message.shape != null && message.hasOwnProperty("shape"))
                object.shape = $root.onnx.TensorShapeProto.toObject(message.shape, options);
              return object;
            };
            Tensor4.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            Tensor4.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === void 0) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return typeUrlPrefix + "/onnx.TypeProto.Tensor";
            };
            return Tensor4;
          }();
          TypeProto.Sequence = function() {
            function Sequence(properties) {
              if (properties) {
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            Sequence.prototype.elemType = null;
            Sequence.create = function create(properties) {
              return new Sequence(properties);
            };
            Sequence.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.elemType != null && Object.hasOwnProperty.call(message, "elemType"))
                $root.onnx.TypeProto.encode(message.elemType, writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).fork()).ldelim();
              return writer;
            };
            Sequence.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            Sequence.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.TypeProto.Sequence();
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.elemType = $root.onnx.TypeProto.decode(reader, reader.uint32());
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            Sequence.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            Sequence.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.elemType != null && message.hasOwnProperty("elemType")) {
                var error = $root.onnx.TypeProto.verify(message.elemType);
                if (error)
                  return "elemType." + error;
              }
              return null;
            };
            Sequence.fromObject = function fromObject(object) {
              if (object instanceof $root.onnx.TypeProto.Sequence)
                return object;
              var message = new $root.onnx.TypeProto.Sequence();
              if (object.elemType != null) {
                if (typeof object.elemType !== "object")
                  throw TypeError(".onnx.TypeProto.Sequence.elemType: object expected");
                message.elemType = $root.onnx.TypeProto.fromObject(object.elemType);
              }
              return message;
            };
            Sequence.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.defaults)
                object.elemType = null;
              if (message.elemType != null && message.hasOwnProperty("elemType"))
                object.elemType = $root.onnx.TypeProto.toObject(message.elemType, options);
              return object;
            };
            Sequence.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            Sequence.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === void 0) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return typeUrlPrefix + "/onnx.TypeProto.Sequence";
            };
            return Sequence;
          }();
          TypeProto.Map = function() {
            function Map2(properties) {
              if (properties) {
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            Map2.prototype.keyType = 0;
            Map2.prototype.valueType = null;
            Map2.create = function create(properties) {
              return new Map2(properties);
            };
            Map2.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.keyType != null && Object.hasOwnProperty.call(message, "keyType"))
                writer.uint32(
                  /* id 1, wireType 0 =*/
                  8
                ).int32(message.keyType);
              if (message.valueType != null && Object.hasOwnProperty.call(message, "valueType"))
                $root.onnx.TypeProto.encode(message.valueType, writer.uint32(
                  /* id 2, wireType 2 =*/
                  18
                ).fork()).ldelim();
              return writer;
            };
            Map2.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            Map2.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.TypeProto.Map();
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.keyType = reader.int32();
                    break;
                  }
                  case 2: {
                    message.valueType = $root.onnx.TypeProto.decode(reader, reader.uint32());
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            Map2.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            Map2.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.keyType != null && message.hasOwnProperty("keyType")) {
                if (!$util.isInteger(message.keyType))
                  return "keyType: integer expected";
              }
              if (message.valueType != null && message.hasOwnProperty("valueType")) {
                var error = $root.onnx.TypeProto.verify(message.valueType);
                if (error)
                  return "valueType." + error;
              }
              return null;
            };
            Map2.fromObject = function fromObject(object) {
              if (object instanceof $root.onnx.TypeProto.Map)
                return object;
              var message = new $root.onnx.TypeProto.Map();
              if (object.keyType != null)
                message.keyType = object.keyType | 0;
              if (object.valueType != null) {
                if (typeof object.valueType !== "object")
                  throw TypeError(".onnx.TypeProto.Map.valueType: object expected");
                message.valueType = $root.onnx.TypeProto.fromObject(object.valueType);
              }
              return message;
            };
            Map2.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.defaults) {
                object.keyType = 0;
                object.valueType = null;
              }
              if (message.keyType != null && message.hasOwnProperty("keyType"))
                object.keyType = message.keyType;
              if (message.valueType != null && message.hasOwnProperty("valueType"))
                object.valueType = $root.onnx.TypeProto.toObject(message.valueType, options);
              return object;
            };
            Map2.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            Map2.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === void 0) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return typeUrlPrefix + "/onnx.TypeProto.Map";
            };
            return Map2;
          }();
          TypeProto.Optional = function() {
            function Optional(properties) {
              if (properties) {
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            Optional.prototype.elemType = null;
            Optional.create = function create(properties) {
              return new Optional(properties);
            };
            Optional.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.elemType != null && Object.hasOwnProperty.call(message, "elemType"))
                $root.onnx.TypeProto.encode(message.elemType, writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).fork()).ldelim();
              return writer;
            };
            Optional.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            Optional.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.TypeProto.Optional();
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.elemType = $root.onnx.TypeProto.decode(reader, reader.uint32());
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            Optional.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            Optional.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.elemType != null && message.hasOwnProperty("elemType")) {
                var error = $root.onnx.TypeProto.verify(message.elemType);
                if (error)
                  return "elemType." + error;
              }
              return null;
            };
            Optional.fromObject = function fromObject(object) {
              if (object instanceof $root.onnx.TypeProto.Optional)
                return object;
              var message = new $root.onnx.TypeProto.Optional();
              if (object.elemType != null) {
                if (typeof object.elemType !== "object")
                  throw TypeError(".onnx.TypeProto.Optional.elemType: object expected");
                message.elemType = $root.onnx.TypeProto.fromObject(object.elemType);
              }
              return message;
            };
            Optional.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.defaults)
                object.elemType = null;
              if (message.elemType != null && message.hasOwnProperty("elemType"))
                object.elemType = $root.onnx.TypeProto.toObject(message.elemType, options);
              return object;
            };
            Optional.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            Optional.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === void 0) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return typeUrlPrefix + "/onnx.TypeProto.Optional";
            };
            return Optional;
          }();
          TypeProto.SparseTensor = function() {
            function SparseTensor(properties) {
              if (properties) {
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            SparseTensor.prototype.elemType = 0;
            SparseTensor.prototype.shape = null;
            SparseTensor.create = function create(properties) {
              return new SparseTensor(properties);
            };
            SparseTensor.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.elemType != null && Object.hasOwnProperty.call(message, "elemType"))
                writer.uint32(
                  /* id 1, wireType 0 =*/
                  8
                ).int32(message.elemType);
              if (message.shape != null && Object.hasOwnProperty.call(message, "shape"))
                $root.onnx.TensorShapeProto.encode(message.shape, writer.uint32(
                  /* id 2, wireType 2 =*/
                  18
                ).fork()).ldelim();
              return writer;
            };
            SparseTensor.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            SparseTensor.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.TypeProto.SparseTensor();
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.elemType = reader.int32();
                    break;
                  }
                  case 2: {
                    message.shape = $root.onnx.TensorShapeProto.decode(reader, reader.uint32());
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            SparseTensor.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            SparseTensor.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.elemType != null && message.hasOwnProperty("elemType")) {
                if (!$util.isInteger(message.elemType))
                  return "elemType: integer expected";
              }
              if (message.shape != null && message.hasOwnProperty("shape")) {
                var error = $root.onnx.TensorShapeProto.verify(message.shape);
                if (error)
                  return "shape." + error;
              }
              return null;
            };
            SparseTensor.fromObject = function fromObject(object) {
              if (object instanceof $root.onnx.TypeProto.SparseTensor)
                return object;
              var message = new $root.onnx.TypeProto.SparseTensor();
              if (object.elemType != null)
                message.elemType = object.elemType | 0;
              if (object.shape != null) {
                if (typeof object.shape !== "object")
                  throw TypeError(".onnx.TypeProto.SparseTensor.shape: object expected");
                message.shape = $root.onnx.TensorShapeProto.fromObject(object.shape);
              }
              return message;
            };
            SparseTensor.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.defaults) {
                object.elemType = 0;
                object.shape = null;
              }
              if (message.elemType != null && message.hasOwnProperty("elemType"))
                object.elemType = message.elemType;
              if (message.shape != null && message.hasOwnProperty("shape"))
                object.shape = $root.onnx.TensorShapeProto.toObject(message.shape, options);
              return object;
            };
            SparseTensor.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            SparseTensor.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === void 0) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return typeUrlPrefix + "/onnx.TypeProto.SparseTensor";
            };
            return SparseTensor;
          }();
          return TypeProto;
        }();
        onnx6.OperatorSetIdProto = function() {
          function OperatorSetIdProto(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          OperatorSetIdProto.prototype.domain = "";
          OperatorSetIdProto.prototype.version = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
          OperatorSetIdProto.create = function create(properties) {
            return new OperatorSetIdProto(properties);
          };
          OperatorSetIdProto.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.domain != null && Object.hasOwnProperty.call(message, "domain"))
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(message.domain);
            if (message.version != null && Object.hasOwnProperty.call(message, "version"))
              writer.uint32(
                /* id 2, wireType 0 =*/
                16
              ).int64(message.version);
            return writer;
          };
          OperatorSetIdProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          OperatorSetIdProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.OperatorSetIdProto();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.domain = reader.string();
                  break;
                }
                case 2: {
                  message.version = reader.int64();
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          OperatorSetIdProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          OperatorSetIdProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.domain != null && message.hasOwnProperty("domain")) {
              if (!$util.isString(message.domain))
                return "domain: string expected";
            }
            if (message.version != null && message.hasOwnProperty("version")) {
              if (!$util.isInteger(message.version) && !(message.version && $util.isInteger(message.version.low) && $util.isInteger(message.version.high)))
                return "version: integer|Long expected";
            }
            return null;
          };
          OperatorSetIdProto.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.OperatorSetIdProto)
              return object;
            var message = new $root.onnx.OperatorSetIdProto();
            if (object.domain != null)
              message.domain = String(object.domain);
            if (object.version != null) {
              if ($util.Long)
                (message.version = $util.Long.fromValue(object.version)).unsigned = false;
              else if (typeof object.version === "string")
                message.version = parseInt(object.version, 10);
              else if (typeof object.version === "number")
                message.version = object.version;
              else if (typeof object.version === "object")
                message.version = new $util.LongBits(object.version.low >>> 0, object.version.high >>> 0).toNumber();
            }
            return message;
          };
          OperatorSetIdProto.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              object.domain = "";
              if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.version = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else
                object.version = options.longs === String ? "0" : 0;
            }
            if (message.domain != null && message.hasOwnProperty("domain"))
              object.domain = message.domain;
            if (message.version != null && message.hasOwnProperty("version"))
              if (typeof message.version === "number")
                object.version = options.longs === String ? String(message.version) : message.version;
              else
                object.version = options.longs === String ? $util.Long.prototype.toString.call(message.version) : options.longs === Number ? new $util.LongBits(message.version.low >>> 0, message.version.high >>> 0).toNumber() : message.version;
            return object;
          };
          OperatorSetIdProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          OperatorSetIdProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/onnx.OperatorSetIdProto";
          };
          return OperatorSetIdProto;
        }();
        onnx6.OperatorStatus = function() {
          var valuesById = {}, values = Object.create(valuesById);
          values[valuesById[0] = "EXPERIMENTAL"] = 0;
          values[valuesById[1] = "STABLE"] = 1;
          return values;
        }();
        onnx6.FunctionProto = function() {
          function FunctionProto(properties) {
            this.input = [];
            this.output = [];
            this.attribute = [];
            this.attributeProto = [];
            this.node = [];
            this.opsetImport = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          FunctionProto.prototype.name = "";
          FunctionProto.prototype.input = $util.emptyArray;
          FunctionProto.prototype.output = $util.emptyArray;
          FunctionProto.prototype.attribute = $util.emptyArray;
          FunctionProto.prototype.attributeProto = $util.emptyArray;
          FunctionProto.prototype.node = $util.emptyArray;
          FunctionProto.prototype.docString = "";
          FunctionProto.prototype.opsetImport = $util.emptyArray;
          FunctionProto.prototype.domain = "";
          FunctionProto.create = function create(properties) {
            return new FunctionProto(properties);
          };
          FunctionProto.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(message.name);
            if (message.input != null && message.input.length)
              for (var i = 0; i < message.input.length; ++i)
                writer.uint32(
                  /* id 4, wireType 2 =*/
                  34
                ).string(message.input[i]);
            if (message.output != null && message.output.length)
              for (var i = 0; i < message.output.length; ++i)
                writer.uint32(
                  /* id 5, wireType 2 =*/
                  42
                ).string(message.output[i]);
            if (message.attribute != null && message.attribute.length)
              for (var i = 0; i < message.attribute.length; ++i)
                writer.uint32(
                  /* id 6, wireType 2 =*/
                  50
                ).string(message.attribute[i]);
            if (message.node != null && message.node.length)
              for (var i = 0; i < message.node.length; ++i)
                $root.onnx.NodeProto.encode(message.node[i], writer.uint32(
                  /* id 7, wireType 2 =*/
                  58
                ).fork()).ldelim();
            if (message.docString != null && Object.hasOwnProperty.call(message, "docString"))
              writer.uint32(
                /* id 8, wireType 2 =*/
                66
              ).string(message.docString);
            if (message.opsetImport != null && message.opsetImport.length)
              for (var i = 0; i < message.opsetImport.length; ++i)
                $root.onnx.OperatorSetIdProto.encode(
                  message.opsetImport[i],
                  writer.uint32(
                    /* id 9, wireType 2 =*/
                    74
                  ).fork()
                ).ldelim();
            if (message.domain != null && Object.hasOwnProperty.call(message, "domain"))
              writer.uint32(
                /* id 10, wireType 2 =*/
                82
              ).string(message.domain);
            if (message.attributeProto != null && message.attributeProto.length)
              for (var i = 0; i < message.attributeProto.length; ++i)
                $root.onnx.AttributeProto.encode(
                  message.attributeProto[i],
                  writer.uint32(
                    /* id 11, wireType 2 =*/
                    90
                  ).fork()
                ).ldelim();
            return writer;
          };
          FunctionProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          FunctionProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.FunctionProto();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.name = reader.string();
                  break;
                }
                case 4: {
                  if (!(message.input && message.input.length))
                    message.input = [];
                  message.input.push(reader.string());
                  break;
                }
                case 5: {
                  if (!(message.output && message.output.length))
                    message.output = [];
                  message.output.push(reader.string());
                  break;
                }
                case 6: {
                  if (!(message.attribute && message.attribute.length))
                    message.attribute = [];
                  message.attribute.push(reader.string());
                  break;
                }
                case 11: {
                  if (!(message.attributeProto && message.attributeProto.length))
                    message.attributeProto = [];
                  message.attributeProto.push($root.onnx.AttributeProto.decode(reader, reader.uint32()));
                  break;
                }
                case 7: {
                  if (!(message.node && message.node.length))
                    message.node = [];
                  message.node.push($root.onnx.NodeProto.decode(reader, reader.uint32()));
                  break;
                }
                case 8: {
                  message.docString = reader.string();
                  break;
                }
                case 9: {
                  if (!(message.opsetImport && message.opsetImport.length))
                    message.opsetImport = [];
                  message.opsetImport.push($root.onnx.OperatorSetIdProto.decode(reader, reader.uint32()));
                  break;
                }
                case 10: {
                  message.domain = reader.string();
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          FunctionProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          FunctionProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.name != null && message.hasOwnProperty("name")) {
              if (!$util.isString(message.name))
                return "name: string expected";
            }
            if (message.input != null && message.hasOwnProperty("input")) {
              if (!Array.isArray(message.input))
                return "input: array expected";
              for (var i = 0; i < message.input.length; ++i)
                if (!$util.isString(message.input[i]))
                  return "input: string[] expected";
            }
            if (message.output != null && message.hasOwnProperty("output")) {
              if (!Array.isArray(message.output))
                return "output: array expected";
              for (var i = 0; i < message.output.length; ++i)
                if (!$util.isString(message.output[i]))
                  return "output: string[] expected";
            }
            if (message.attribute != null && message.hasOwnProperty("attribute")) {
              if (!Array.isArray(message.attribute))
                return "attribute: array expected";
              for (var i = 0; i < message.attribute.length; ++i)
                if (!$util.isString(message.attribute[i]))
                  return "attribute: string[] expected";
            }
            if (message.attributeProto != null && message.hasOwnProperty("attributeProto")) {
              if (!Array.isArray(message.attributeProto))
                return "attributeProto: array expected";
              for (var i = 0; i < message.attributeProto.length; ++i) {
                var error = $root.onnx.AttributeProto.verify(message.attributeProto[i]);
                if (error)
                  return "attributeProto." + error;
              }
            }
            if (message.node != null && message.hasOwnProperty("node")) {
              if (!Array.isArray(message.node))
                return "node: array expected";
              for (var i = 0; i < message.node.length; ++i) {
                var error = $root.onnx.NodeProto.verify(message.node[i]);
                if (error)
                  return "node." + error;
              }
            }
            if (message.docString != null && message.hasOwnProperty("docString")) {
              if (!$util.isString(message.docString))
                return "docString: string expected";
            }
            if (message.opsetImport != null && message.hasOwnProperty("opsetImport")) {
              if (!Array.isArray(message.opsetImport))
                return "opsetImport: array expected";
              for (var i = 0; i < message.opsetImport.length; ++i) {
                var error = $root.onnx.OperatorSetIdProto.verify(message.opsetImport[i]);
                if (error)
                  return "opsetImport." + error;
              }
            }
            if (message.domain != null && message.hasOwnProperty("domain")) {
              if (!$util.isString(message.domain))
                return "domain: string expected";
            }
            return null;
          };
          FunctionProto.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.FunctionProto)
              return object;
            var message = new $root.onnx.FunctionProto();
            if (object.name != null)
              message.name = String(object.name);
            if (object.input) {
              if (!Array.isArray(object.input))
                throw TypeError(".onnx.FunctionProto.input: array expected");
              message.input = [];
              for (var i = 0; i < object.input.length; ++i)
                message.input[i] = String(object.input[i]);
            }
            if (object.output) {
              if (!Array.isArray(object.output))
                throw TypeError(".onnx.FunctionProto.output: array expected");
              message.output = [];
              for (var i = 0; i < object.output.length; ++i)
                message.output[i] = String(object.output[i]);
            }
            if (object.attribute) {
              if (!Array.isArray(object.attribute))
                throw TypeError(".onnx.FunctionProto.attribute: array expected");
              message.attribute = [];
              for (var i = 0; i < object.attribute.length; ++i)
                message.attribute[i] = String(object.attribute[i]);
            }
            if (object.attributeProto) {
              if (!Array.isArray(object.attributeProto))
                throw TypeError(".onnx.FunctionProto.attributeProto: array expected");
              message.attributeProto = [];
              for (var i = 0; i < object.attributeProto.length; ++i) {
                if (typeof object.attributeProto[i] !== "object")
                  throw TypeError(".onnx.FunctionProto.attributeProto: object expected");
                message.attributeProto[i] = $root.onnx.AttributeProto.fromObject(object.attributeProto[i]);
              }
            }
            if (object.node) {
              if (!Array.isArray(object.node))
                throw TypeError(".onnx.FunctionProto.node: array expected");
              message.node = [];
              for (var i = 0; i < object.node.length; ++i) {
                if (typeof object.node[i] !== "object")
                  throw TypeError(".onnx.FunctionProto.node: object expected");
                message.node[i] = $root.onnx.NodeProto.fromObject(object.node[i]);
              }
            }
            if (object.docString != null)
              message.docString = String(object.docString);
            if (object.opsetImport) {
              if (!Array.isArray(object.opsetImport))
                throw TypeError(".onnx.FunctionProto.opsetImport: array expected");
              message.opsetImport = [];
              for (var i = 0; i < object.opsetImport.length; ++i) {
                if (typeof object.opsetImport[i] !== "object")
                  throw TypeError(".onnx.FunctionProto.opsetImport: object expected");
                message.opsetImport[i] = $root.onnx.OperatorSetIdProto.fromObject(object.opsetImport[i]);
              }
            }
            if (object.domain != null)
              message.domain = String(object.domain);
            return message;
          };
          FunctionProto.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults) {
              object.input = [];
              object.output = [];
              object.attribute = [];
              object.node = [];
              object.opsetImport = [];
              object.attributeProto = [];
            }
            if (options.defaults) {
              object.name = "";
              object.docString = "";
              object.domain = "";
            }
            if (message.name != null && message.hasOwnProperty("name"))
              object.name = message.name;
            if (message.input && message.input.length) {
              object.input = [];
              for (var j = 0; j < message.input.length; ++j)
                object.input[j] = message.input[j];
            }
            if (message.output && message.output.length) {
              object.output = [];
              for (var j = 0; j < message.output.length; ++j)
                object.output[j] = message.output[j];
            }
            if (message.attribute && message.attribute.length) {
              object.attribute = [];
              for (var j = 0; j < message.attribute.length; ++j)
                object.attribute[j] = message.attribute[j];
            }
            if (message.node && message.node.length) {
              object.node = [];
              for (var j = 0; j < message.node.length; ++j)
                object.node[j] = $root.onnx.NodeProto.toObject(message.node[j], options);
            }
            if (message.docString != null && message.hasOwnProperty("docString"))
              object.docString = message.docString;
            if (message.opsetImport && message.opsetImport.length) {
              object.opsetImport = [];
              for (var j = 0; j < message.opsetImport.length; ++j)
                object.opsetImport[j] = $root.onnx.OperatorSetIdProto.toObject(message.opsetImport[j], options);
            }
            if (message.domain != null && message.hasOwnProperty("domain"))
              object.domain = message.domain;
            if (message.attributeProto && message.attributeProto.length) {
              object.attributeProto = [];
              for (var j = 0; j < message.attributeProto.length; ++j)
                object.attributeProto[j] = $root.onnx.AttributeProto.toObject(message.attributeProto[j], options);
            }
            return object;
          };
          FunctionProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          FunctionProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/onnx.FunctionProto";
          };
          return FunctionProto;
        }();
        return onnx6;
      }();
      module2.exports = $root;
    }
  });

  // web/lib/onnxjs/util.ts
  function assert(expr, msg) {
    if (!expr) {
      throw new Error(typeof msg === "string" ? msg : msg());
    }
  }
  function decodeUtf8String(buffer) {
    return new TextDecoder().decode(buffer);
  }
  var import_onnx, ArrayUtil, MatMulUtil, BroadcastUtil, GemmUtil, ProtoUtil, LongUtil, ShapeUtil, SplitUtil, PoolConvUtil, MIN_CLIP, MAX_CLIP;
  var init_util = __esm({
    "web/lib/onnxjs/util.ts"() {
      "use strict";
      init_flatbuffers();
      init_long();
      import_onnx = __toESM(require_onnx());
      init_tensor2();
      ArrayUtil = class {
        /**
         * Verifies if 2 input arrays contain the same elements.
         * @param n1 Array 1
         * @param n2 Array 2
         * @returns Whether these 2 are equal
         */
        static arraysEqual(n1, n2) {
          if (n1.length !== n2.length) {
            return false;
          }
          for (let i = 0; i < n1.length; i++) {
            if (n1[i] !== n2[i]) {
              return false;
            }
          }
          return true;
        }
      };
      MatMulUtil = class {
        /**
         * Fix the input shapes for MatMul operation if they need fixing
         * @param dimsA The shape of tensor A. Should be an array of positive integers
         * @param dimsB The shape of tensor B. Should be an array of positive integers
         * @returns A tuple containing the preprocessed input shapes as required by ONNX specifications
         */
        static preprocessInputShapes(dimsA, dimsB) {
          const a = dimsA.length === 1 ? [1, dimsA[0]] : dimsA;
          const b = dimsB.length === 1 ? [dimsB[0], 1] : dimsB;
          return [a, b];
        }
        /**
         * Fix the output shape computed for MatMul operation if it needs fixing
         * @param outputShape The computed outputShape. Should be an array (atleast of length 2) of positive integers.
         * This will be mutated.
         * @param aRank The rank of tensor A.
         * @param bRank The rank of tensor B.
         */
        static postprocessOutputShape(outputShape, aRank, bRank) {
          if (aRank === 1) {
            outputShape.splice(outputShape.length - 2, 1);
          }
          if (bRank === 1) {
            outputShape.pop();
          }
        }
        /**
         * Calculate the expected shape when matrix multiplication
         * @param a The shape of tensor A. Should be a tuple of 2 positive integers
         * @param b The shape of tensor B. Should be a tuple of 2 positive integers
         * @returns The expected shape of the result, or undefined if N/A
         */
        static calcMatMulShape(a, b) {
          return a[1] !== b[0] ? void 0 : [a[0], b[1]];
        }
      };
      BroadcastUtil = class _BroadcastUtil {
        /**
         * Calculate the expected shape when broadcasting 2 tensors
         * @param a The shape of tensor A. Should be an array of positive integers
         * @param b The shape of tensor B. Should be an array of positive integers
         * @param isMatMul Whether the operation is MatMul
         * @returns The expected shape of the result, or undefined if N/A
         */
        static calcShape(adims, bdims, isMatMul = false) {
          const arank = adims.length;
          const brank = bdims.length;
          if (arank === 0) {
            return bdims;
          }
          if (brank === 0) {
            return adims;
          }
          const crank = Math.max(adims.length, bdims.length);
          const cdims = new Array(crank);
          if (isMatMul) {
            if (arank < 2 || brank < 2) {
              return void 0;
            }
            const cShapeMatMul = MatMulUtil.calcMatMulShape(
              [adims[arank - 2], adims[arank - 1]],
              [bdims[brank - 2], bdims[brank - 1]]
            );
            if (cShapeMatMul === void 0) {
              return void 0;
            }
            [cdims[crank - 2], cdims[crank - 1]] = cShapeMatMul;
          }
          for (let i = isMatMul ? 3 : 1; i <= crank; i++) {
            const aLen = arank - i < 0 ? 1 : adims[arank - i];
            const bLen = brank - i < 0 ? 1 : bdims[brank - i];
            if (aLen !== bLen && aLen > 1 && bLen > 1) {
              return void 0;
            }
            cdims[crank - i] = Math.max(aLen, bLen);
          }
          return cdims;
        }
        /**
         * Given the indices of a broadcasted tensor, calculate the original indices
         * @param broadcastedIndices The given indices of the broadcasted tensor.
         * @param originalShape The original shape of the tensor before broadcas
         * @returns The calculated indices that maps to the original tensor.
         */
        static index(broadcastedIndices, originalShape) {
          const originalIndices = new Array(originalShape.length);
          _BroadcastUtil.fillIndex(broadcastedIndices, originalShape, originalIndices);
          return originalIndices;
        }
        /**
         * Given the indices of a broadcasted tensor, calculate the original indices
         * @param broadcastedIndices The given indices of the broadcasted tensor.
         * @param originalShape The original shape of the tensor before broadcast
         * @param originalIndices The mapping of broadcastedIndices to the originalIndices (output parameter - will be
         *     mutated).
         */
        static fillIndex(broadcastedIndices, originalShape, originalIndices) {
          const dimOffset = broadcastedIndices.length - originalShape.length;
          for (let i = 0; i < originalShape.length; i++) {
            originalIndices[i] = broadcastedIndices[dimOffset + i] % originalShape[i];
          }
        }
        /**
         * Perform the broadcasting operation on the specific operator
         * @param a The input tensor A
         * @param b The input tensor B
         * @param op The operator lambda function
         * @param inplace Whether to write the result back to A.
         * @returns The result tensor, or undefined if input not broadcastable.
         */
        static calc(a, b, op, inplace, resultType) {
          const outputShape = _BroadcastUtil.calcShape(a.dims, b.dims);
          if (outputShape) {
            if (inplace && !ShapeUtil.areEqual(outputShape, a.dims)) {
              return void 0;
            }
            const size = ShapeUtil.size(outputShape);
            const c = inplace ? a : new Tensor3(outputShape, resultType || a.type);
            if (outputShape.length === 0) {
              c.set([], op(a.get([]), b.get([])));
            } else {
              const outputIndices = new Array(outputShape.length);
              const originalIndicesA = new Array(a.dims.length);
              const originalIndicesB = new Array(b.dims.length);
              let valA = 0;
              let valB = 0;
              let isAScalar = false;
              let isBScalar = false;
              if (a.dims.length === 0) {
                valA = a.get([]);
                isAScalar = true;
              }
              if (b.dims.length === 0) {
                valB = b.get([]);
                isBScalar = true;
              }
              let rest;
              for (let i = 0; i < size; i++) {
                rest = i;
                for (let j = outputShape.length - 1; j >= 0; j--) {
                  outputIndices[j] = rest % outputShape[j];
                  rest = Math.floor(rest / outputShape[j]);
                }
                if (!isAScalar) {
                  _BroadcastUtil.fillIndex(outputIndices, a.dims, originalIndicesA);
                  valA = a.get(originalIndicesA);
                }
                if (!isBScalar) {
                  _BroadcastUtil.fillIndex(outputIndices, b.dims, originalIndicesB);
                  valB = b.get(originalIndicesB);
                }
                c.set(outputIndices, op(valA, valB));
              }
            }
            return c;
          }
          return void 0;
        }
        /**
         * Determine if a shape is unidirectional broadcastable to another shape
         * @param shape The input shape
         * @param finalShape The desired shape after broadcasting
         */
        static isValidBroadcast(shape2, finalShape) {
          const inputRank = shape2.length;
          const finalRank = finalShape.length;
          if (inputRank > finalRank) {
            return false;
          }
          for (let i = 1; i <= inputRank; i++) {
            if (shape2[inputRank - i] !== 1 && shape2[inputRank - i] !== finalShape[finalRank - i]) {
              return false;
            }
          }
          return true;
        }
        /**
         * Determine the broadcasted dims in input shape based on the given output shape.
         * Note that this function only returns the broadcasted dims.
         * @param inputShape The input shape
         * @param outputShape The output shape
         * @returns The broadcasted dims in input shape.
         */
        static getBroadcastDims(inputShape, outputShape) {
          const inRank = inputShape.length;
          const dims = [];
          for (let i = 0; i < inRank; i++) {
            const dim = inRank - 1 - i;
            const a = inputShape[dim] || 1;
            const b = outputShape[outputShape.length - 1 - i] || 1;
            if (b > 1 && a === 1) {
              dims.unshift(dim);
            }
          }
          return dims;
        }
      };
      GemmUtil = class {
        // will make sure input shapes are compatible for this op
        // and return back the shape of the output in the form of a tuple
        // will throw exception if the input shapes are not compatible
        static getShapeOfGemmResult(leftShape, transLeft, rightShape, transRight, biasShape) {
          if (leftShape.length !== 2 || rightShape.length !== 2) {
            throw new Error("shape need to be of size 2");
          }
          let M;
          let K;
          let N;
          if (transLeft) {
            M = leftShape[1];
            K = leftShape[0];
          } else {
            M = leftShape[0];
            K = leftShape[1];
          }
          let kDim = -1;
          if (transRight) {
            N = rightShape[0];
            kDim = 1;
          } else {
            N = rightShape[1];
            kDim = 0;
          }
          if (rightShape[kDim] !== K) {
            throw new Error("dimension mismatch");
          }
          if (M <= 0 || N <= 0 || K <= 0) {
            throw new Error("invalid shape specified");
          }
          if (biasShape && !BroadcastUtil.isValidBroadcast(biasShape, [M, N])) {
            throw new Error("gemm: invalid bias shape for broadcast");
          }
          return [M, N, K];
        }
      };
      ProtoUtil = class _ProtoUtil {
        static tensorDataTypeFromProto(typeProto) {
          switch (typeProto) {
            case import_onnx.onnx.TensorProto.DataType.INT8:
              return "int8";
            case import_onnx.onnx.TensorProto.DataType.UINT8:
              return "uint8";
            case import_onnx.onnx.TensorProto.DataType.BOOL:
              return "bool";
            case import_onnx.onnx.TensorProto.DataType.INT16:
              return "int16";
            case import_onnx.onnx.TensorProto.DataType.UINT16:
              return "uint16";
            case import_onnx.onnx.TensorProto.DataType.INT32:
              return "int32";
            case import_onnx.onnx.TensorProto.DataType.UINT32:
              return "uint32";
            case import_onnx.onnx.TensorProto.DataType.FLOAT:
              return "float32";
            case import_onnx.onnx.TensorProto.DataType.DOUBLE:
              return "float64";
            case import_onnx.onnx.TensorProto.DataType.STRING:
              return "string";
            case import_onnx.onnx.TensorProto.DataType.INT64:
              return "int32";
            case import_onnx.onnx.TensorProto.DataType.UINT64:
              return "uint32";
            default:
              throw new Error(`unsupported data type: ${import_onnx.onnx.TensorProto.DataType[typeProto]}`);
          }
        }
        static tensorDataTypeStringToEnum(type) {
          switch (type) {
            case "int8":
              return import_onnx.onnx.TensorProto.DataType.INT8;
            case "uint8":
              return import_onnx.onnx.TensorProto.DataType.UINT8;
            case "bool":
              return import_onnx.onnx.TensorProto.DataType.BOOL;
            case "int16":
              return import_onnx.onnx.TensorProto.DataType.INT16;
            case "uint16":
              return import_onnx.onnx.TensorProto.DataType.UINT16;
            case "int32":
              return import_onnx.onnx.TensorProto.DataType.INT32;
            case "uint32":
              return import_onnx.onnx.TensorProto.DataType.UINT32;
            case "float32":
              return import_onnx.onnx.TensorProto.DataType.FLOAT;
            case "float64":
              return import_onnx.onnx.TensorProto.DataType.DOUBLE;
            case "string":
              return import_onnx.onnx.TensorProto.DataType.STRING;
            case "int64":
              return import_onnx.onnx.TensorProto.DataType.INT64;
            case "uint64":
              return import_onnx.onnx.TensorProto.DataType.UINT64;
            default:
              throw new Error(`unsupported data type: ${type}`);
          }
        }
        static tensorDimsFromProto(dims) {
          return dims.map((d) => long_default.isLong(d) ? d.toNumber() : d);
        }
        static tensorValueTypeFromProto(valueType) {
          return {
            tensorType: _ProtoUtil.tensorDataTypeFromProto(valueType.elemType),
            shape: { dims: _ProtoUtil.tensorDimsFromProto(valueType.shape.dim.map((d) => d.dimValue)) }
          };
        }
        static tensorDimsFromORTFormat(tensor) {
          const dims = [];
          for (let i = 0; i < tensor.dimsLength(); i++) {
            dims.push(LongUtil.longToNumber(tensor.dims(i)));
          }
          return dims;
        }
        static tensorAttributesFromORTFormat(node) {
          const attributes = [];
          for (let i = 0; i < node.attributesLength(); i++) {
            attributes.push(node.attributes(i));
          }
          return attributes;
        }
      };
      LongUtil = class {
        // This function is called to get a number from long type of data for attribute, dim, and ir version,
        // which values are signed integers.
        // To make it more generic, add an optional parameter to convert to a unsigned number.
        static longToNumber(n, unsigned) {
          if (long_default.isLong(n)) {
            return n.toNumber();
          } else if (n instanceof flatbuffers.Long) {
            return long_default.fromValue({ low: n.low, high: n.high, unsigned: unsigned ?? false }).toNumber();
          }
          return n;
        }
        static isLong(n) {
          return long_default.isLong(n) || n instanceof flatbuffers.Long;
        }
      };
      ShapeUtil = class _ShapeUtil {
        static size(dims) {
          return _ShapeUtil.getSizeFromDimensionRange(dims, 0, dims.length);
        }
        // `axis` inclusive
        static sizeFromDimension(dims, axis) {
          if (axis < 0 || axis > dims.length) {
            throw new Error(`invalid dimension of ${axis} for sizeFromDimension as Tensor has ${dims.length} dimensions.`);
          }
          return _ShapeUtil.getSizeFromDimensionRange(dims, axis, dims.length);
        }
        // `axis` exclusive
        static sizeToDimension(dims, axis) {
          if (axis < 0 || axis > dims.length) {
            throw new Error(`invalid dimension of ${axis} for sizeToDimension as Tensor has ${dims.length} dimensions.`);
          }
          return _ShapeUtil.getSizeFromDimensionRange(dims, 0, axis);
        }
        static getSizeFromDimensionRange(dims, start, end) {
          let size = 1;
          for (let i = start; i < end; i++) {
            if (dims[i] <= 0) {
              throw new Error(
                // eslint-disable-next-line max-len
                "cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them."
              );
            }
            size *= dims[i];
          }
          return size;
        }
        static computeStrides(dims) {
          const rank = dims.length;
          if (rank === 0) {
            return [];
          } else if (rank === 1) {
            return [1];
          }
          const strides = new Array(rank);
          strides[rank - 1] = 1;
          strides[rank - 2] = dims[rank - 1];
          for (let i = rank - 3; i >= 0; --i) {
            strides[i] = strides[i + 1] * dims[i + 1];
          }
          return strides;
        }
        static transpose(dims) {
          const copy = dims.slice();
          return copy.reverse();
        }
        static indicesToOffset(indices, strides, axis) {
          if (axis === void 0) {
            axis = indices.length;
          }
          let offset = 0;
          for (let i = 0; i < axis; ++i) {
            offset += strides[i] * indices[i];
          }
          return offset;
        }
        static offsetToIndices(offset, strides) {
          const rank = strides.length;
          if (rank === 0) {
            return [];
          } else if (rank === 1) {
            return [offset * strides[0]];
          }
          const indices = new Array(strides.length);
          for (let i = 0; i < indices.length - 1; ++i) {
            indices[i] = Math.floor(offset / strides[i]);
            offset -= indices[i] * strides[i];
          }
          indices[indices.length - 1] = offset;
          return indices;
        }
        /**
         * normailze axis of range [-r, r) into [0, r).
         */
        static normalizeAxis(axis, tensorRank) {
          if (axis < -tensorRank && axis >= tensorRank) {
            throw new Error("unsupported axis for this operation.");
          }
          return axis < 0 ? axis + tensorRank : axis;
        }
        static normalizeAxes(axes, tensorRank) {
          return axes.map((x) => this.normalizeAxis(x, tensorRank));
        }
        // Increment an index into a tensor (in lexicographic
        // ordering), wrapping around the specified upper_bound.
        /**
         * Increment an index into a tensor (in lexicographic ordering), wrapping around the specified upper_bound.
         * @param index Given index to increment (Will be mutated)
         * @param dims The dimensions of the tensor for which the given index corresponds to
         * @param axisToIncrementOn The 1-indexed axis to increment on. If undefined, axisToIncrementOn == rank
         */
        static incrementIndex(index, dims, axisToIncrementOn) {
          if (dims.length === 0 || index.length === 0) {
            throw new Error("Index incrementing unsupported for scalar Tensor");
          }
          if (axisToIncrementOn === void 0) {
            axisToIncrementOn = dims.length;
          } else {
            if (axisToIncrementOn <= 0 || axisToIncrementOn > dims.length) {
              throw new Error("Incorrect axis to increment on");
            }
          }
          for (let k = axisToIncrementOn - 1; k >= 0; --k) {
            index[k]++;
            if (index[k] < dims[k]) {
              break;
            }
            index[k] = 0;
          }
        }
        /**
         * Produces a new dimensions array based on the values in the 'originalDimensions' and 'shape' array
         * Used in Reshape
         * @param originalDims Original Shape array
         * @param shapeHints array containing values to compute the new dimensions
         * For example:
         * originalDims = [2,2] and shapeHints = [0,-1] will return [2,2]
         * originalDims = [2,2] and shapeHints = [4] will return [4]
         * originalDims = [2,2] and shapeHints = [5] will throw an exception
         * https://github.com/onnx/onnx/blob/main/docs/Operators.md#Reshape
         */
        static calculateReshapedDims(originalDims, shapeHints) {
          if (shapeHints.length === 0) {
            if (originalDims.length === 0 || _ShapeUtil.size(originalDims) === 1) {
              return [];
            } else {
              throw new Error("cannot reshape to a scalar Tensor");
            }
          }
          const nDims = shapeHints.length;
          const reshapedDims = new Array(nDims);
          let unknownDimension = -1;
          let newTensorSize = 1;
          for (let i = 0; i < nDims; i++) {
            if (shapeHints[i] < -1) {
              throw new Error("a dimension in shape hints cannot be less than -1");
            }
            if (shapeHints[i] === -1) {
              if (unknownDimension !== -1) {
                throw new Error("at most one dimension in shape hints can be -1");
              }
              unknownDimension = i;
            } else {
              if (shapeHints[i] === 0) {
                if (i >= originalDims.length) {
                  throw new Error("the dimension with value zero exceeds the dimension size of the input tensor");
                }
                reshapedDims[i] = originalDims[i];
              } else {
                reshapedDims[i] = shapeHints[i];
              }
              newTensorSize *= reshapedDims[i];
            }
          }
          const oldTensorSize = _ShapeUtil.size(originalDims);
          if (unknownDimension !== -1) {
            if (oldTensorSize % newTensorSize !== 0) {
              throw new Error(
                `the input tensor cannot be reshaped to the requested shape. Input shape: [${originalDims}] Output shape: [${shapeHints}]`
              );
            }
            reshapedDims[unknownDimension] = oldTensorSize / newTensorSize;
          } else {
            if (newTensorSize !== oldTensorSize) {
              throw new Error("reshapedDims and originalDims don't have matching sizes");
            }
          }
          return reshapedDims;
        }
        /**
         * Sorts a given array based on the indices in the Perm array
         * Used in Transpose
         * @param a Array to be sorted such as dims or strides
         * @param perm Perm given; if null a will be reversed
         */
        static sortBasedOnPerm(a, perm) {
          if (perm) {
            return perm.map((v) => a[v]);
          } else {
            return a.slice().reverse();
          }
        }
        /**
         * Pads a given shape according to the padding values
         * @param dims shape of the Tensor to be padded
         * @param pad pad values
         */
        static padShape(dims, pad) {
          const rank = dims.length;
          return dims.map((v, i) => v + pad[i] + pad[i + rank]);
        }
        /**
         * Determines if the two shapes are identical
         * @param shape1
         * @param shape2
         */
        static areEqual(shape1, shape2) {
          if (shape1.length !== shape2.length) {
            return false;
          }
          return shape1.every((v, i) => v === shape2[i]);
        }
        /**
         * Validates if the given `dims` or `shape` is valid in ONNX.js context and returns data size
         * @param dims - input `dims` that needs to be checked
         */
        static validateDimsAndCalcSize(dims) {
          if (dims.length > 6) {
            throw new TypeError("Only rank 0 to 6 is supported for tensor shape.");
          }
          let size = 1;
          for (const n of dims) {
            if (!Number.isInteger(n)) {
              throw new TypeError(`Invalid shape: ${n} is not an integer`);
            }
            if (n < 0 || n > 2147483647) {
              throw new TypeError(`Invalid shape: length ${n} is not allowed`);
            }
            size *= n;
          }
          return size;
        }
        /**
         * Determines the shape of output tensor y = flatten(x, axis)
         * @param dims - shape of input tensor
         * @param axis - flatten axis, in the range [-r, r]
         */
        static flattenShape(dims, axis) {
          if (axis < 0) {
            axis += dims.length;
          }
          const total = dims.reduce((x, y) => x * y, 1);
          const right = dims.slice(axis).reduce((x, y) => x * y, 1);
          const outputDims = [total / right, right];
          return outputDims;
        }
        /**
         * Determines the shape of output tensor y = squeeze(x, axes)
         * @param dims - shape of input tensor
         * @param axes - squeeze axes
         */
        static squeezeShape(dims, axes) {
          const outputDims = new Array();
          axes = _ShapeUtil.normalizeAxes(axes, dims.length);
          for (let i = 0; i < dims.length; i++) {
            const inSqueezeList = axes.indexOf(i) >= 0;
            if (inSqueezeList && dims[i] !== 1) {
              throw new Error("squeeze an axis of size different than 1");
            }
            if (axes.length === 0 && dims[i] > 1 || axes.length > 0 && !inSqueezeList) {
              outputDims.push(dims[i]);
            }
          }
          return outputDims;
        }
        /**
         * Determines the shape of output tensor y = unsqueeze(x, axes)
         * @param dims - shape of input tensor
         * @param axes - unsqueeze axes
         */
        static unsqueezeShape(dims, axes) {
          const outputDims = new Array(dims.length + axes.length);
          outputDims.fill(0);
          for (let i = 0; i < axes.length; i++) {
            const axis = _ShapeUtil.normalizeAxis(axes[i], outputDims.length);
            if (axis >= outputDims.length) {
              throw new Error("'axes' has an out of range axis");
            }
            if (outputDims[axis] !== 0) {
              throw new Error("'axes' has a duplicate axis");
            }
            outputDims[axis] = 1;
          }
          let inputDimsIterator = 0;
          for (let i = 0; i < outputDims.length; i++) {
            if (outputDims[i] === 0) {
              outputDims[i] = dims[inputDimsIterator++];
            }
          }
          if (inputDimsIterator !== dims.length) {
            throw new Error("the unsqueezed dimension could not be established");
          }
          return outputDims;
        }
      };
      SplitUtil = class _SplitUtil {
        /**
         * Calculates new Shapes from existing one and the splits given along the axis provides
         * @param dims Shape of the Tensor to be splitted into two or more Shapes
         * @param axis The dimension along which the Tensor will be split
         * @param splits Offsets for the start of each split
         */
        static splitShape(dims, axis, split2, numOutputs) {
          if (split2.length === 0) {
            if (!numOutputs) {
              throw new Error("need to know number of outputs when the 'split' attribute is not specified");
            }
            _SplitUtil.determineSplit(dims[axis], numOutputs, split2);
          }
          const shapes = [];
          const offsets = [0];
          for (let i = 0; i < split2.length; ++i) {
            if (i !== 0) {
              offsets.push(offsets[i - 1] + split2[i - 1]);
            }
            const shape2 = dims.slice();
            shape2[axis] = split2[i];
            shapes.push(shape2);
          }
          return [shapes, offsets];
        }
        static determineSplit(numElementsAlongAxis, numOutputs, split2) {
          if (numElementsAlongAxis % numOutputs !== 0) {
            throw new Error("cannot split tensor to equal sized parts");
          }
          for (let i = 0; i < numOutputs; ++i) {
            split2.push(numElementsAlongAxis / numOutputs);
          }
        }
      };
      PoolConvUtil = class _PoolConvUtil {
        /**
         * Adjust the kernel, strides, pads to correct rank. Set to default value if not present
         * @param isGlobalOperator If true, perform global pooling.
         * @param inputDims The input tensor dimension.
         * @param kernelShape The size of the kernel along each axis.
         * @param strides Stride along each axis.
         * @param dilations Dilation along each axis.
         * @param pads Padding for the beginning and ending along each axis.
         */
        static adjustPoolAttributes(isGlobalOperator, inputDims, kernelShape, strides, dilations, pads) {
          if (!isGlobalOperator && kernelShape.length !== inputDims.length - 2) {
            throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");
          }
          if (isGlobalOperator) {
            for (let dim = 0; dim < inputDims.length - 2; dim++) {
              if (dim >= kernelShape.length) {
                kernelShape.push(inputDims[dim + 2]);
              } else {
                kernelShape[dim] = inputDims[dim + 2];
              }
            }
          }
          for (let dim = 0; dim < kernelShape.length; dim++) {
            if (dim < strides.length) {
              if (strides[dim] < 0) {
                throw new Error("strides should be greater than or equal to 1");
              }
            } else {
              strides.push(1);
            }
          }
          for (let dim = 0; dim < kernelShape.length; dim++) {
            if (dim < dilations.length) {
              if (dilations[dim] < 0) {
                throw new Error("dilations should be greater than or equal to 1");
              }
            } else {
              dilations.push(1);
            }
          }
          for (let dim = 0; dim < kernelShape.length * 2; dim++) {
            if (dim < pads.length) {
              if (pads[dim] < 0) {
                throw new Error("pad should be greater than or equal to 1");
              }
            } else {
              pads.push(0);
            }
          }
          for (let dim = 0; dim < kernelShape.length; dim++) {
            if (kernelShape[dim] <= 0) {
              throw new Error("kernel shapes need to be greater than 0");
            }
            if (pads[dim] >= kernelShape[dim] || pads[dim + kernelShape.length] >= kernelShape[dim]) {
              throw new Error("pads should be smaller than kernel");
            }
          }
        }
        // adjust pad values based on 'autoPad' attribute
        static adjustPadsBasedOnAutoPad(inputDims, strides, dilations, kernelShape, pads, autoPad) {
          if (!autoPad) {
            return;
          }
          if (pads.length !== 2 * (inputDims.length - 2)) {
            throw new Error("length of pads should be twice the length of data dimensions");
          }
          if (strides.length !== inputDims.length - 2) {
            throw new Error("length of strides should be the length of data dimensions");
          }
          if (kernelShape.length !== inputDims.length - 2) {
            throw new Error("length of kernel shapes should be the length of data dimensions");
          }
          for (let dim = 0; dim < inputDims.length - 2; dim++) {
            _PoolConvUtil.adjustPadAndReturnShape(
              inputDims[dim + 2],
              strides[dim],
              dilations[dim],
              kernelShape[dim],
              pads,
              dim,
              dim + inputDims.length - 2,
              autoPad
            );
          }
        }
        /**
         * Calculate the output shape for Pool ops based on input attributes. (Should be used only for Pool ops)
         * @param isGlobalOperator If true, perform global pooling.
         * @param inputDims The input tensor dimension. (inputs[0].dims)
         * @param strides Stride along each axis.
         * @param dilations Dilation along each axis.
         * @param kernelShape The size of the kernel along each axis.
         * @param pads Padding for the beginning and ending along each axis.
         * @param autoPad DEPRECATED attribute supported for legacy models. Specifies how to implicitly calculate pads in each
         *     dimension. Can take values NOTSET, SAME_UPPER, SAME_LOWER, or VALID.
         */
        static computePoolOutputShape(isGlobalOperator, inputDims, strides, dilations, kernelShape, pads, autoPad) {
          if (inputDims.length <= 0) {
            throw new Error("input shape must be of size greater than 0");
          }
          const outputDims = [inputDims[0], inputDims[1]];
          _PoolConvUtil.computeShapeHelper(
            isGlobalOperator,
            inputDims,
            outputDims,
            strides,
            dilations,
            kernelShape,
            pads,
            autoPad
          );
          return outputDims;
        }
        /**
         * Calculate the output shape for Conv op based on input attributes. (Should be used only for Conv op)
         * @param inputDims The input tensor dimension. (inputs[0].dims)
         * @param filterDims The filter tensor dimension. (inputs[1].dims)
         * @param strides Stride along each axis.
         * @param kernelShape The size of the kernel along each axis.
         * @param pads Padding for the beginning and ending along each axis.
         * @param autoPad DEPRECATED attribute supported for legacy models. Specifies how to implicitly calculate pads in each
         *     dimension. Can take values NOTSET, SAME_UPPER, SAME_LOWER, or VALID.
         */
        static computeConvOutputShape(inputDims, filterDims, strides, dilations, kernelShape, pads, autoPad) {
          if (inputDims.length <= 0 || filterDims.length <= 0) {
            throw new Error("invalid input tensor dims or invalid filter tensor dims");
          }
          const outputDims = [inputDims[0], filterDims[0]];
          _PoolConvUtil.computeShapeHelper(false, inputDims, outputDims, strides, dilations, kernelShape, pads, autoPad);
          return outputDims;
        }
        // will compute output shapes for data dimensions ONLY (i.e.) no batch size and channels
        // called by computePoolOutputShape() and computeConvOutputShape()
        // adjust pads based on 'autoPad' attribute prior to shape computation
        static computeShapeHelper(isGlobalOperator, inputDims, outputDims, strides, dilations, kernelShape, pads, autoPad) {
          if (isGlobalOperator) {
            for (let dim = 0; dim < inputDims.length - 2; dim++) {
              outputDims.push(1);
            }
          } else {
            for (let dim = 0; dim < inputDims.length - 2; dim++) {
              outputDims.push(
                _PoolConvUtil.adjustPadAndReturnShape(
                  inputDims[dim + 2],
                  strides[dim],
                  dilations[dim],
                  kernelShape[dim],
                  pads,
                  dim,
                  dim + inputDims.length - 2,
                  autoPad
                )
              );
            }
          }
        }
        // helper for computeShapeHelper() and adjustPadsBasedOnAutoPad()
        // adjusts pad value for given 'autoPad' string and computes output shape along a particular dimension
        static adjustPadAndReturnShape(inSize, stride, dilation, kernel, pads, padHeadIndex, padTailIndex, autoPad) {
          const dkernel = dilation * (kernel - 1) + 1;
          if (autoPad && autoPad !== "NOTSET") {
            switch (autoPad) {
              case "VALID":
                pads[padHeadIndex] = 0;
                pads[padTailIndex] = 0;
                return Math.floor((inSize - dkernel) / stride + 1);
              case "SAME_LOWER":
              case "SAME_UPPER":
                if (dilation !== 1) {
                  throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");
                } else {
                  const legacyTargetSize = (inSize + stride - 1) / stride;
                  const padNeeded = (legacyTargetSize - 1) * stride + kernel - inSize;
                  pads[padHeadIndex] = autoPad === "SAME_LOWER" ? Math.floor((padNeeded + 1) / 2) : Math.floor(padNeeded / 2);
                  pads[padTailIndex] = padNeeded - pads[padHeadIndex];
                  return Math.floor((inSize + padNeeded - kernel) / stride + 1);
                }
              default:
                throw new Error("Unsupported AutoPad type");
            }
          } else {
            return Math.floor((inSize + pads[padHeadIndex] + pads[padTailIndex] - dkernel) / stride + 1);
          }
        }
      };
      MIN_CLIP = -34028234663852886e22;
      MAX_CLIP = 34028234663852886e22;
    }
  });

  // web/lib/onnxjs/tensor.ts
  function sizeof(type) {
    switch (type) {
      case "bool":
      case "int8":
      case "uint8":
        return 1;
      case "int16":
      case "uint16":
        return 2;
      case "int32":
      case "uint32":
      case "float32":
        return 4;
      case "float64":
        return 8;
      default:
        throw new Error(`cannot calculate sizeof() on type ${type}`);
    }
  }
  function sizeofProto(type) {
    switch (type) {
      case import_onnx2.onnx.TensorProto.DataType.UINT8:
      case import_onnx2.onnx.TensorProto.DataType.INT8:
      case import_onnx2.onnx.TensorProto.DataType.BOOL:
        return 1;
      case import_onnx2.onnx.TensorProto.DataType.UINT16:
      case import_onnx2.onnx.TensorProto.DataType.INT16:
        return 2;
      case import_onnx2.onnx.TensorProto.DataType.FLOAT:
      case import_onnx2.onnx.TensorProto.DataType.INT32:
      case import_onnx2.onnx.TensorProto.DataType.UINT32:
        return 4;
      case import_onnx2.onnx.TensorProto.DataType.INT64:
      case import_onnx2.onnx.TensorProto.DataType.DOUBLE:
      case import_onnx2.onnx.TensorProto.DataType.UINT64:
        return 8;
      default:
        throw new Error(`cannot calculate sizeof() on type ${import_onnx2.onnx.TensorProto.DataType[type]}`);
    }
  }
  function createView(dataBuffer, type) {
    return new (dataviewConstructor(type))(dataBuffer);
  }
  function dataviewConstructor(type) {
    switch (type) {
      case "bool":
      case "uint8":
        return Uint8Array;
      case "int8":
        return Int8Array;
      case "int16":
        return Int16Array;
      case "uint16":
        return Uint16Array;
      case "int32":
        return Int32Array;
      case "uint32":
        return Uint32Array;
      case "int64":
        return BigInt64Array;
      case "float32":
        return Float32Array;
      case "float64":
        return Float64Array;
      default:
        throw new Error("unspecified error");
    }
  }
  function longToNumber(i, type) {
    if (type === import_onnx2.onnx.TensorProto.DataType.INT64 || type === ortFbs.TensorDataType.INT64) {
      if (i.greaterThanOrEqual(2147483648) || i.lessThan(-2147483648)) {
        throw new TypeError("int64 is not supported");
      }
    } else if (type === import_onnx2.onnx.TensorProto.DataType.UINT32 || type === ortFbs.TensorDataType.UINT32 || type === import_onnx2.onnx.TensorProto.DataType.UINT64 || type === ortFbs.TensorDataType.UINT64) {
      if (i.greaterThanOrEqual(4294967296) || i.lessThan(0)) {
        throw new TypeError("uint64 is not supported");
      }
    } else {
      throw new TypeError(`not a LONG type: ${import_onnx2.onnx.TensorProto.DataType[type]}`);
    }
    return i.toNumber();
  }
  function readProto(view, type, byteOffset) {
    switch (type) {
      case import_onnx2.onnx.TensorProto.DataType.BOOL:
      case import_onnx2.onnx.TensorProto.DataType.UINT8:
        return view.getUint8(byteOffset);
      case import_onnx2.onnx.TensorProto.DataType.INT8:
        return view.getInt8(byteOffset);
      case import_onnx2.onnx.TensorProto.DataType.UINT16:
        return view.getUint16(byteOffset, true);
      case import_onnx2.onnx.TensorProto.DataType.INT16:
        return view.getInt16(byteOffset, true);
      case import_onnx2.onnx.TensorProto.DataType.FLOAT:
        return view.getFloat32(byteOffset, true);
      case import_onnx2.onnx.TensorProto.DataType.INT32:
        return view.getInt32(byteOffset, true);
      case import_onnx2.onnx.TensorProto.DataType.UINT32:
        return view.getUint32(byteOffset, true);
      case import_onnx2.onnx.TensorProto.DataType.INT64:
        return longToNumber(
          long_default.fromBits(view.getUint32(byteOffset, true), view.getUint32(byteOffset + 4, true), false),
          type
        );
      case import_onnx2.onnx.TensorProto.DataType.DOUBLE:
        return view.getFloat64(byteOffset, true);
      case import_onnx2.onnx.TensorProto.DataType.UINT64:
        return longToNumber(
          long_default.fromBits(view.getUint32(byteOffset, true), view.getUint32(byteOffset + 4, true), true),
          type
        );
      default:
        throw new Error(`cannot read from DataView for type ${import_onnx2.onnx.TensorProto.DataType[type]}`);
    }
  }
  var import_guid_typescript, import_onnx2, ortFbs, Tensor3;
  var init_tensor2 = __esm({
    "web/lib/onnxjs/tensor.ts"() {
      "use strict";
      import_guid_typescript = __toESM(require_guid());
      init_long();
      init_ort_generated();
      import_onnx2 = __toESM(require_onnx());
      init_util();
      ortFbs = onnxruntime.experimental.fbs;
      Tensor3 = class _Tensor {
        constructor(dims, type, dataProvider, asyncDataProvider, cache2, dataId = import_guid_typescript.Guid.create()) {
          this.dims = dims;
          this.type = type;
          this.dataProvider = dataProvider;
          this.asyncDataProvider = asyncDataProvider;
          this.cache = cache2;
          this.dataId = dataId;
          this.size = ShapeUtil.validateDimsAndCalcSize(dims);
          const size = this.size;
          const empty = dataProvider === void 0 && asyncDataProvider === void 0 && cache2 === void 0;
          if (cache2 !== void 0) {
            if (cache2.length !== size) {
              throw new RangeError("Input dims doesn't match data length.");
            }
          }
          if (type === "string") {
            if (cache2 !== void 0 && (!Array.isArray(cache2) || !cache2.every((i) => typeof i === "string"))) {
              throw new TypeError("cache should be a string array");
            }
            if (empty) {
              this.cache = new Array(size);
            }
          } else {
            if (cache2 !== void 0) {
              const constructor = dataviewConstructor(type);
              if (!(cache2 instanceof constructor)) {
                throw new TypeError(`cache should be type ${constructor.name}`);
              }
            }
            if (empty) {
              const buf = new ArrayBuffer(size * sizeof(type));
              this.cache = createView(buf, type);
            }
          }
        }
        /**
         * get the underlying tensor data
         */
        get data() {
          if (this.cache === void 0) {
            const data = this.dataProvider(this.dataId);
            if (data.length !== this.size) {
              throw new Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");
            }
            this.cache = data;
          }
          return this.cache;
        }
        /**
         * get the underlying string tensor data. Should only use when type is STRING
         */
        get stringData() {
          if (this.type !== "string") {
            throw new TypeError("data type is not string");
          }
          return this.data;
        }
        /**
         * get the underlying integer tensor data. Should only use when type is one of the following: (UINT8, INT8, UINT16,
         * INT16, INT32, UINT32, BOOL)
         */
        get integerData() {
          switch (this.type) {
            case "uint8":
            case "int8":
            case "uint16":
            case "int16":
            case "int32":
            case "uint32":
            case "bool":
              return this.data;
            default:
              throw new TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)");
          }
        }
        /**
         * get the underlying float tensor data. Should only use when type is one of the following: (FLOAT, DOUBLE)
         */
        get floatData() {
          switch (this.type) {
            case "float32":
            case "float64":
              return this.data;
            default:
              throw new TypeError("data type is not float (float32, float64)");
          }
        }
        /**
         * get the underlying number tensor data. Should only use when type is one of the following: (UINT8, INT8, UINT16,
         * INT16, INT32, UINT32, BOOL, FLOAT, DOUBLE)
         */
        get numberData() {
          if (this.type !== "string") {
            return this.data;
          }
          throw new TypeError("type cannot be non-number (string)");
        }
        /**
         * get value of an element at the given indices
         */
        get(indices) {
          return this.data[ShapeUtil.indicesToOffset(indices, this.strides)];
        }
        /**
         * set value of an element at the given indices
         */
        set(indices, value) {
          this.data[ShapeUtil.indicesToOffset(indices, this.strides)] = value;
        }
        /**
         * get the underlying tensor data asynchronously
         */
        async getData() {
          if (this.cache === void 0) {
            this.cache = await this.asyncDataProvider(this.dataId);
          }
          return this.cache;
        }
        /**
         * get the strides for each dimension
         */
        get strides() {
          if (!this._strides) {
            this._strides = ShapeUtil.computeStrides(this.dims);
          }
          return this._strides;
        }
        /**
         * Construct new Tensor from a ONNX Tensor object
         * @param tensorProto the ONNX Tensor
         */
        static fromProto(tensorProto) {
          if (!tensorProto) {
            throw new Error("cannot construct Value from an empty tensor");
          }
          const type = ProtoUtil.tensorDataTypeFromProto(tensorProto.dataType);
          const dims = ProtoUtil.tensorDimsFromProto(tensorProto.dims);
          const value = new _Tensor(dims, type);
          if (type === "string") {
            tensorProto.stringData.forEach((str, i) => {
              value.data[i] = decodeUtf8String(str);
            });
          } else if (tensorProto.rawData && typeof tensorProto.rawData.byteLength === "number" && tensorProto.rawData.byteLength > 0) {
            const dataDest = value.data;
            const dataSource = new DataView(
              tensorProto.rawData.buffer,
              tensorProto.rawData.byteOffset,
              tensorProto.rawData.byteLength
            );
            const elementSize = sizeofProto(tensorProto.dataType);
            const length = tensorProto.rawData.byteLength / elementSize;
            if (tensorProto.rawData.byteLength % elementSize !== 0) {
              throw new Error("invalid buffer length");
            }
            if (dataDest.length !== length) {
              throw new Error("buffer length mismatch");
            }
            for (let i = 0; i < length; i++) {
              const n = readProto(dataSource, tensorProto.dataType, i * elementSize);
              dataDest[i] = n;
            }
          } else {
            let array;
            switch (tensorProto.dataType) {
              case import_onnx2.onnx.TensorProto.DataType.FLOAT:
                array = tensorProto.floatData;
                break;
              case import_onnx2.onnx.TensorProto.DataType.INT32:
              case import_onnx2.onnx.TensorProto.DataType.INT16:
              case import_onnx2.onnx.TensorProto.DataType.UINT16:
              case import_onnx2.onnx.TensorProto.DataType.INT8:
              case import_onnx2.onnx.TensorProto.DataType.UINT8:
              case import_onnx2.onnx.TensorProto.DataType.BOOL:
                array = tensorProto.int32Data;
                break;
              case import_onnx2.onnx.TensorProto.DataType.INT64:
                array = tensorProto.int64Data;
                break;
              case import_onnx2.onnx.TensorProto.DataType.DOUBLE:
                array = tensorProto.doubleData;
                break;
              case import_onnx2.onnx.TensorProto.DataType.UINT32:
              case import_onnx2.onnx.TensorProto.DataType.UINT64:
                array = tensorProto.uint64Data;
                break;
              default:
                throw new Error("unspecific error");
            }
            if (array === null || array === void 0) {
              throw new Error("failed to populate data from a tensorproto value");
            }
            const data = value.data;
            if (data.length !== array.length) {
              throw new Error("array length mismatch");
            }
            for (let i = 0; i < array.length; i++) {
              const element = array[i];
              if (long_default.isLong(element)) {
                data[i] = longToNumber(element, tensorProto.dataType);
              } else {
                data[i] = element;
              }
            }
          }
          return value;
        }
        /**
         * Construct new Tensor from raw data
         * @param data the raw data object. Should be a string array for 'string' tensor, and the corresponding typed array
         * for other types of tensor.
         * @param dims the dimensions of the tensor
         * @param type the type of the tensor
         */
        static fromData(data, dims, type) {
          return new _Tensor(dims, type, void 0, void 0, data);
        }
        static fromOrtTensor(ortTensor) {
          if (!ortTensor) {
            throw new Error("cannot construct Value from an empty tensor");
          }
          const dims = ProtoUtil.tensorDimsFromORTFormat(ortTensor);
          const type = ProtoUtil.tensorDataTypeFromProto(ortTensor.dataType());
          const value = new _Tensor(dims, type);
          if (type === "string") {
            for (let i = 0; i < ortTensor.stringDataLength(); i++) {
              value.data[i] = ortTensor.stringData(i);
            }
          } else if (ortTensor.rawDataArray() && typeof ortTensor.rawDataLength() === "number" && ortTensor.rawDataLength() > 0) {
            const dataDest = value.data;
            const dataSource = new DataView(
              ortTensor.rawDataArray().buffer,
              ortTensor.rawDataArray().byteOffset,
              ortTensor.rawDataLength()
            );
            const elementSize = sizeofProto(ortTensor.dataType());
            const length = ortTensor.rawDataLength() / elementSize;
            if (ortTensor.rawDataLength() % elementSize !== 0) {
              throw new Error("invalid buffer length");
            }
            if (dataDest.length !== length) {
              throw new Error("buffer length mismatch");
            }
            for (let i = 0; i < length; i++) {
              const n = readProto(dataSource, ortTensor.dataType(), i * elementSize);
              dataDest[i] = n;
            }
          }
          return value;
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/glsl-source.ts
  function getGlsl(version3) {
    return version3 === 1 ? GLSL_ES_2_0 : GLSL_ES_3_0;
  }
  function getVertexShaderSource(version3) {
    const glsl = getGlsl(version3);
    return `${glsl.version}
      precision highp float;
      ${glsl.attribute} vec3 position;
      ${glsl.attribute} vec2 textureCoord;

      ${glsl.varyingVertex} vec2 TexCoords;

      void main()
      {
          gl_Position = vec4(position, 1.0);
          TexCoords = textureCoord;
      }`;
  }
  function getFragShaderPreamble(version3) {
    const glsl = getGlsl(version3);
    return `${glsl.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${glsl.varyingFrag} vec2 TexCoords;
    ${glsl.outputDeclaration}
    const vec2 halfCR = vec2(0.5, 0.5);

    // Custom vector types to handle higher dimenalities.
    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    `;
  }
  function getDefaultFragShaderMain(version3, outputShapeLength) {
    const glsl = getGlsl(version3);
    return `
  void main() {
    int indices[${outputShapeLength}];
    toVec(TexCoords, indices);
    vec4 result = vec4(process(indices));
    ${glsl.output} = result;
  }
  `;
  }
  var GLSL_ES_2_0, GLSL_ES_3_0;
  var init_glsl_source = __esm({
    "web/lib/onnxjs/backends/webgl/glsl-source.ts"() {
      "use strict";
      GLSL_ES_2_0 = {
        version: "",
        attribute: "attribute",
        varyingVertex: "varying",
        varyingFrag: "varying",
        texture2D: "texture2D",
        output: "gl_FragColor",
        outputDeclaration: ""
      };
      GLSL_ES_3_0 = {
        version: "#version 300 es",
        attribute: "in",
        varyingVertex: "out",
        varyingFrag: "in",
        texture2D: "texture",
        output: "outputColor",
        outputDeclaration: "out vec4 outputColor;"
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/types.ts
  var init_types = __esm({
    "web/lib/onnxjs/backends/webgl/types.ts"() {
      "use strict";
    }
  });

  // web/lib/onnxjs/backends/webgl/utils.ts
  async function repeatedTry(checkFn, delayFn = (_counter) => 0, maxCounter) {
    return new Promise((resolve, reject) => {
      let tryCount = 0;
      const tryFn = () => {
        if (checkFn()) {
          resolve();
          return;
        }
        tryCount++;
        const nextBackoff = delayFn(tryCount);
        if (maxCounter != null && tryCount >= maxCounter) {
          reject();
          return;
        }
        setTimeout(tryFn, nextBackoff);
      };
      tryFn();
    });
  }
  function generateShaderFuncNameFromInputSamplerName(samplerName) {
    assert(typeof samplerName !== "undefined" && samplerName.length !== 0, () => "empty string found for sampler name");
    return "get" + samplerName.charAt(0).toUpperCase() + samplerName.slice(1);
  }
  function generateShaderFuncNameFromInputSamplerNameAtOutCoords(samplerName) {
    assert(typeof samplerName !== "undefined" && samplerName.length !== 0, () => "empty string found for sampler name");
    return "get" + samplerName.charAt(0).toUpperCase() + samplerName.slice(1) + "AtOutCoords";
  }
  function squeezeInputShape(inputShape, squeezedShape) {
    let newInputShape = JSON.parse(JSON.stringify(inputShape));
    newInputShape = squeezedShape;
    return newInputShape;
  }
  function getSqueezedParams(params, keptDims) {
    return keptDims.map((d) => params[d]).join(", ");
  }
  function getCoordsDataType(rank) {
    if (rank <= 1) {
      return "int";
    } else if (rank === 2) {
      return "ivec2";
    } else if (rank === 3) {
      return "ivec3";
    } else if (rank === 4) {
      return "ivec4";
    } else if (rank === 5) {
      return "ivec5";
    } else if (rank === 6) {
      return "ivec6";
    } else {
      throw Error(`GPU for rank ${rank} is not yet supported`);
    }
  }
  function getGlChannels(rank = 6) {
    return ["x", "y", "z", "w", "u", "v"].slice(0, rank);
  }
  var init_utils = __esm({
    "web/lib/onnxjs/backends/webgl/utils.ts"() {
      "use strict";
      init_util();
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/packing-utils.ts
  function getVecChannels(name2, rank) {
    return getGlChannels(rank).map((d) => `${name2}.${d}`);
  }
  function getChannels(name2, rank) {
    if (rank === 1) {
      return [name2];
    }
    return getVecChannels(name2, rank);
  }
  function unpackFromChannel() {
    return `
    float getChannel(vec4 frag, int dim) {
      int modCoord = imod(dim, 2);
      return modCoord == 0 ? frag.r : frag.g;
    }

    float getChannel(vec4 frag, vec2 innerDims) {
      vec2 modCoord = mod(innerDims, 2.);
      return modCoord.x == 0. ?
        (modCoord.y == 0. ? frag.r : frag.g) :
        (modCoord.y == 0. ? frag.b : frag.a);
    }
  `;
  }
  var init_packing_utils = __esm({
    "web/lib/onnxjs/backends/webgl/ops/packing-utils.ts"() {
      "use strict";
      init_utils();
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/pack.ts
  function getOutOfBoundsCondition(rank, shape2, dims) {
    if (rank === 0) {
      return "false";
    }
    if (rank === 1) {
      return `rc > ${shape2[0]}`;
    }
    let cond = "";
    for (let i = rank - 2; i < rank; i++) {
      cond += `${dims[i]} >= ${shape2[i - rank + 2]}`;
      if (i < rank - 1) {
        cond += "||";
      }
    }
    return cond;
  }
  function getOutput(shape2, dims) {
    const rank = shape2.length;
    if (rank === 0) {
      return "getA(), 0, 0, 0";
    }
    if (rank === 1) {
      return `getA(rc),
            rc + 1 >= ${shape2[0]} ? 0. : getA(rc + 1),
            0, 0`;
    }
    const coord00 = "r, c";
    const coord01 = "r, cp1";
    const coord10 = "rp1, c";
    const coord11 = "rp1, cp1";
    let D = "";
    if (rank > 2) {
      for (let i = 0; i < rank - 2; ++i) {
        D = D + `${dims[i]},`;
      }
    }
    return `getA(${D}${coord00}),
          rEdge ? 0. : getA(${D}${coord10}),
          cEdge ? 0. : getA(${D}${coord01}),
          rEdge || cEdge ? 0. : getA(${D}${coord11})`;
  }
  function getSetup(rank, dims, rows, cols) {
    if (rank === 0 || rank === 1) {
      return "";
    } else {
      const setup = `
    int r = ${dims[rank - 2]};
    int c = ${dims[rank - 1]};
    int rp1 = ${dims[rank - 2]} + 1;
    int cp1 = ${dims[rank - 1]} + 1;
    bool rEdge = rp1 >= ${cols};
    bool cEdge = cp1 >= ${rows};
    `;
      return setup;
    }
  }
  var packProgramMetadata, createPackProgramInfo, createPackProgramInfoLoader;
  var init_pack = __esm({
    "web/lib/onnxjs/backends/webgl/ops/pack.ts"() {
      "use strict";
      init_glsl_source();
      init_types();
      init_utils();
      init_packing_utils();
      packProgramMetadata = {
        name: "pack",
        inputNames: ["A"],
        inputTypes: [1 /* unpackedReversed */]
      };
      createPackProgramInfo = (handler, input) => {
        const glsl = getGlsl(handler.session.backend.glContext.version);
        const inputShape = input.dims;
        const inputRank = inputShape.length;
        const outputRank = input.dims.length;
        const coordsDataType = getCoordsDataType(outputRank);
        const channels = getChannels("rc", outputRank);
        const setup = getSetup(outputRank, channels, inputShape[inputShape.length - 2], inputShape[inputShape.length - 1]);
        let reversedInputWH;
        if (inputRank === 0) {
          reversedInputWH = [1, 1];
        } else if (inputRank === 1) {
          reversedInputWH = [inputShape[0], 1];
        } else {
          reversedInputWH = [inputShape[outputRank - 1], inputShape[outputRank - 2]];
        }
        const outOfBoundsCondition = getOutOfBoundsCondition(outputRank, reversedInputWH, channels);
        const output = getOutput(inputShape, channels);
        const shaderSource = `
        void main() {
          ${coordsDataType} rc = getOutputCoords();

          if(${outOfBoundsCondition}) {
            ${glsl.output} = vec4(0);
          } else {
            ${setup}

            ${glsl.output} = vec4(${output});
          }
        }
      `;
        return {
          ...packProgramMetadata,
          hasMain: true,
          output: { dims: input.dims, type: input.type, textureType: 2 /* packed */ },
          shaderSource
        };
      };
      createPackProgramInfoLoader = (handler, input) => ({
        ...packProgramMetadata,
        get: () => createPackProgramInfo(handler, input)
      });
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/reshape-packed.ts
  function processDims3D(shape2) {
    if (shape2.length === 0) {
      return [1, 1, 1];
    }
    let batch = 1;
    for (let i = 0; i < shape2.length - 2; ++i) {
      batch *= shape2[i];
    }
    return [batch, shape2.length > 1 ? shape2[shape2.length - 2] : 1, shape2[shape2.length - 1]];
  }
  function isReshapeCheap(dims, reshapedDims) {
    let isCheapReshape = false;
    if (dims.length === 0 || reshapedDims.length === 0) {
      isCheapReshape = true;
    } else if (dims.length < 2 || reshapedDims.length < 2) {
      isCheapReshape = dims[dims.length - 1] === reshapedDims[reshapedDims.length - 1];
    } else {
      isCheapReshape = dims[dims.length - 1] === reshapedDims[reshapedDims.length - 1] && dims[dims.length - 2] === reshapedDims[reshapedDims.length - 2];
    }
    return isCheapReshape;
  }
  function getReshapedInputCoords(shape2) {
    const strides = ShapeUtil.computeStrides(shape2);
    const coords = ["b", "r", "c"];
    const index = "index";
    const coordsFromIndexSnippet = strides.map((stride, i) => {
      const line1 = `int ${coords[i]} = ${index} / ${stride}`;
      const line2 = i === strides.length - 1 ? `int ${coords[i + 1]} = ${index} - ${coords[i]} * ${stride}` : `index -= ${coords[i]} * ${stride}`;
      return `${line1}; ${line2};`;
    }).join("");
    return `
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${coordsFromIndexSnippet}
      return ivec3(b, r, c);
    }
  `;
  }
  function getFlattenedIndexFrom3D(shape2) {
    const strides = ShapeUtil.computeStrides(shape2);
    return `
  int getFlattenedIndex(ivec3 coords) {
    // reverse y, z order
    return coords.x * ${strides[0]} + coords.z * ${strides[1]} + coords.y;
  }
`;
  }
  var createPackedReshape3DProgramMetadata, createPackedReshape3DProgramInfo, createPackedReshape3DProgramInfoLoader;
  var init_reshape_packed = __esm({
    "web/lib/onnxjs/backends/webgl/ops/reshape-packed.ts"() {
      "use strict";
      init_util();
      init_glsl_source();
      init_types();
      init_packing_utils();
      createPackedReshape3DProgramMetadata = (outputShape3D) => ({
        name: "Reshape (packed)",
        inputTypes: [2 /* packed */],
        inputNames: ["A"],
        cacheHint: `${outputShape3D}`
      });
      createPackedReshape3DProgramInfo = (handler, input3D, metadata, outputShape3D) => {
        const inputShape3D = input3D.dims;
        const squeezedOutputShape = outputShape3D;
        let mainLoop = "";
        for (let i = 0; i < 4; i++) {
          let outputCoords = "";
          switch (i) {
            case 0:
              outputCoords = "outputCoords = rc;";
              break;
            case 1:
              outputCoords = "outputCoords = ivec3(rc.x, rc.y+1, rc.z);";
              break;
            case 2:
              outputCoords = "outputCoords = ivec3(rc.x, rc.y, rc.z+1);";
              break;
            case 3:
              outputCoords = "outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";
              break;
            default:
              throw new Error();
          }
          mainLoop += `
        ${outputCoords}
        ${i > 0 ? "if(outputCoords.y < rows && outputCoords.z < cols){" : ""}
          int flattenedIndex = getFlattenedIndex(outputCoords);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);
          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${i}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);

        ${i > 0 ? "}" : ""}
      `;
        }
        const glsl = getGlsl(handler.session.backend.glContext.version);
        const shaderSource = `
      ${getReshapedInputCoords(inputShape3D)}
      ${getFlattenedIndexFrom3D(squeezedOutputShape)}
      ${unpackFromChannel()}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.0);

        ivec3 outputCoords;
        int rows = ${squeezedOutputShape[2]};
        int cols = ${squeezedOutputShape[1]};

        ${mainLoop}
        ${glsl.output} = result;
      }
    `;
        return {
          ...metadata,
          output: { dims: squeezedOutputShape, type: input3D.type, textureType: 2 /* packed */ },
          shaderSource,
          hasMain: true
        };
      };
      createPackedReshape3DProgramInfoLoader = (handler, input3D, outputShape3D) => {
        const metadata = createPackedReshape3DProgramMetadata(outputShape3D);
        return { ...metadata, get: () => createPackedReshape3DProgramInfo(handler, input3D, metadata, outputShape3D) };
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/uint8-encode.ts
  var encodeAsUint8;
  var init_uint8_encode = __esm({
    "web/lib/onnxjs/backends/webgl/ops/uint8-encode.ts"() {
      "use strict";
      init_glsl_source();
      init_types();
      encodeAsUint8 = (inferenceHandler, input) => {
        const outputShape = input.shape;
        const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);
        const shaderSource = `
    const float FLOAT_MAX = 1.70141184e38;
    const float FLOAT_MIN = 1.17549435e-38;

    bool isNaN(float val) {
      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;
    }

    highp vec4 encodeAsUint8(highp float v) {
      if (isNaN(v)) {
        return vec4(255, 255, 255, 255);
      }

      highp float av = abs(v);

      if(av < FLOAT_MIN) {
        return vec4(0.0, 0.0, 0.0, 0.0);
      } else if(v > FLOAT_MAX) {
        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
      } else if(v < -FLOAT_MAX) {
        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
      }

      highp vec4 c = vec4(0,0,0,0);

      highp float e = floor(log2(av));
      highp float m = exp2(fract(log2(av))) - 1.0;

      c[2] = floor(128.0 * m);
      m -= c[2] / 128.0;
      c[1] = floor(32768.0 * m);
      m -= c[1] / 32768.0;
      c[0] = floor(8388608.0 * m);

      highp float ebias = e + 127.0;
      c[3] = floor(ebias / 2.0);
      ebias -= c[3] * 2.0;
      c[2] += floor(ebias) * 128.0;

      c[3] += 128.0 * step(0.0, -v);

      return c / 255.0;
    }

    void main() {
      float value = ${glsl.texture2D}(X,TexCoords).r;
      ${glsl.output} = encodeAsUint8(value);
    }`;
        const programInfo = {
          name: "Uint8Encode",
          inputTypes: [0 /* unpacked */],
          inputNames: ["X"],
          output: { dims: outputShape, type: input.tensor.type, textureType: 3 /* downloadUint8AsFloat */ },
          shaderSource,
          hasMain: true
        };
        return inferenceHandler.executeProgram(programInfo, [input.tensor]);
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/unpack.ts
  function getSourceCoords(rank, dims) {
    if (rank === 1) {
      return "rc";
    }
    let coords = "";
    for (let i = 0; i < rank; i++) {
      coords += dims[i];
      if (i < rank - 1) {
        coords += ",";
      }
    }
    return coords;
  }
  var unpackProgramMetadata, createUnpackProgramInfo, createUnpackProgramInfoLoader;
  var init_unpack = __esm({
    "web/lib/onnxjs/backends/webgl/ops/unpack.ts"() {
      "use strict";
      init_glsl_source();
      init_types();
      init_utils();
      init_packing_utils();
      unpackProgramMetadata = {
        name: "unpack",
        inputNames: ["A"],
        inputTypes: [2 /* packed */]
      };
      createUnpackProgramInfo = (handler, input) => {
        const rank = input.dims.length;
        const channels = getChannels("rc", rank);
        const innerDims = channels.slice(-2);
        const coordsDataType = getCoordsDataType(rank);
        const unpackChannel = unpackFromChannel();
        const isScalar = input.dims.length === 0;
        const sourceCoords = isScalar ? "" : getSourceCoords(rank, channels);
        const coords = rank <= 1 ? "rc" : `vec2(${innerDims.join(",")})`;
        const glsl = getGlsl(handler.session.backend.glContext.version);
        const shaderSource = `
    ${unpackChannel}
    void main() {
      ${coordsDataType} rc = getOutputCoords();

       // Sample the texture with the coords to get the rgba channel value.
       vec4 packedInput = getA(${sourceCoords});

       ${glsl.output} = vec4(getChannel(packedInput, ${coords}), 0, 0, 0);
     }
   `;
        return {
          ...unpackProgramMetadata,
          hasMain: true,
          output: { dims: input.dims, type: input.type, textureType: 0 /* unpacked */ },
          shaderSource
        };
      };
      createUnpackProgramInfoLoader = (handler, input) => ({
        ...unpackProgramMetadata,
        get: () => createUnpackProgramInfo(handler, input)
      });
    }
  });

  // web/lib/onnxjs/backends/webgl/texture-data-encoder.ts
  var RedFloat32DataEncoder, RGBAFloatDataEncoder, Uint8DataEncoder;
  var init_texture_data_encoder = __esm({
    "web/lib/onnxjs/backends/webgl/texture-data-encoder.ts"() {
      "use strict";
      init_instrument();
      RedFloat32DataEncoder = class {
        constructor(gl, channels = 1) {
          if (channels === 1) {
            this.internalFormat = gl.R32F;
            this.format = gl.RED;
            this.textureType = gl.FLOAT;
            this.channelSize = channels;
          } else if (channels === 4) {
            this.internalFormat = gl.RGBA32F;
            this.format = gl.RGBA;
            this.textureType = gl.FLOAT;
            this.channelSize = channels;
          } else {
            throw new Error(`Invalid number of channels: ${channels}`);
          }
        }
        encode(src, textureSize) {
          let result;
          let source;
          if (src.constructor !== Float32Array) {
            Logger.warning("Encoder", "data was not of type Float32; creating new Float32Array");
            source = new Float32Array(src);
          }
          if (textureSize * this.channelSize > src.length) {
            Logger.warning("Encoder", "Source data too small. Allocating larger array");
            source = src;
            result = this.allocate(textureSize * this.channelSize);
            source.forEach((v, i) => result[i] = v);
          } else {
            source = src;
            result = source;
          }
          return result;
        }
        allocate(size) {
          return new Float32Array(size * 4);
        }
        decode(buffer, dataSize) {
          if (this.channelSize === 1) {
            const filteredData = buffer.filter((_value, index) => index % 4 === 0).subarray(0, dataSize);
            return filteredData;
          }
          return buffer.subarray(0, dataSize);
        }
      };
      RGBAFloatDataEncoder = class {
        constructor(gl, channels = 1, textureType) {
          if (channels !== 1 && channels !== 4) {
            throw new Error(`Invalid number of channels: ${channels}`);
          }
          this.internalFormat = gl.RGBA;
          this.format = gl.RGBA;
          this.channelSize = channels;
          this.textureType = textureType || gl.FLOAT;
        }
        encode(src, textureSize) {
          let dest = src;
          if (this.channelSize === 1) {
            Logger.verbose("Encoder", "Exploding into a larger array");
            dest = this.allocate(textureSize);
            src.forEach((v, i) => dest[i * 4] = v);
          }
          return dest;
        }
        allocate(size) {
          return new Float32Array(size * 4);
        }
        decode(buffer, dataSize) {
          if (this.channelSize === 1) {
            const filteredData = buffer.filter((_value, index) => index % 4 === 0).subarray(0, dataSize);
            return filteredData;
          }
          return buffer.subarray(0, dataSize);
        }
      };
      Uint8DataEncoder = class {
        constructor(gl, channels = 1) {
          this.channelSize = 4;
          if (channels === 1) {
            this.internalFormat = gl.ALPHA;
            this.format = gl.ALPHA;
            this.textureType = gl.UNSIGNED_BYTE;
            this.channelSize = channels;
          } else if (channels === 4) {
            this.internalFormat = gl.RGBA;
            this.format = gl.RGBA;
            this.textureType = gl.UNSIGNED_BYTE;
            this.channelSize = channels;
          } else {
            throw new Error(`Invalid number of channels: ${channels}`);
          }
        }
        encode(src, _textureSize) {
          return new Uint8Array(src.buffer, src.byteOffset, src.byteLength);
        }
        allocate(size) {
          return new Uint8Array(size * this.channelSize);
        }
        decode(buffer, dataSize) {
          if (buffer instanceof Uint8Array) {
            return buffer.subarray(0, dataSize);
          }
          throw new Error(`Invalid array type: ${buffer.constructor}`);
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/texture-layout.ts
  var createTextureLayoutFromTextureType, calculateTextureWidthAndHeight, createTextureLayoutFromShape;
  var init_texture_layout = __esm({
    "web/lib/onnxjs/backends/webgl/texture-layout.ts"() {
      "use strict";
      init_util();
      init_types();
      createTextureLayoutFromTextureType = (textureLayoutStrategy, shape2, textureType) => {
        const channel = textureType === 0 /* unpacked */ || textureType === 1 /* unpackedReversed */ ? 1 : 4;
        const isPacked = textureType === 2 /* packed */;
        const reverseWH = textureType === 1 /* unpackedReversed */ || textureType === 2 /* packed */;
        const breakAxis = textureType === 4 /* packedLastDimension */ ? shape2.length - 1 : void 0;
        const unpackedShape = textureType === 4 /* packedLastDimension */ ? shape2.map((d, i) => i === shape2.length - 1 ? d * 4 : d) : void 0;
        return createTextureLayoutFromShape(textureLayoutStrategy, shape2, channel, unpackedShape, {
          isPacked,
          reverseWH,
          breakAxis
        });
      };
      calculateTextureWidthAndHeight = (textureLayoutStrategy, shape2, textureType) => {
        const layout = createTextureLayoutFromTextureType(textureLayoutStrategy, shape2, textureType);
        return [layout.width, layout.height];
      };
      createTextureLayoutFromShape = (textureLayoutStrategy, shape2, channels = 1, unpackedShape, prefs) => {
        const isPacked = !!(prefs && prefs.isPacked);
        const [width, height] = textureLayoutStrategy.computeTextureWH(isPacked ? unpackedShape || shape2 : shape2, prefs);
        const rank = shape2.length;
        let inferredDims = shape2.slice(0);
        if (rank === 0) {
          inferredDims = [1];
        }
        if (channels === 1) {
          unpackedShape = shape2;
        } else if (isPacked) {
          if (channels !== 4) {
            throw new Error("a packed texture must be 4-channel");
          }
          unpackedShape = shape2;
          if (rank > 0) {
            inferredDims[rank - 1] = Math.ceil(inferredDims[rank - 1] / 2);
          }
          if (rank > 1) {
            inferredDims[rank - 2] = Math.ceil(inferredDims[rank - 2] / 2);
          }
        } else if (!unpackedShape) {
          throw new Error("Unpacked shape is needed when using channels > 1");
        }
        return {
          width,
          height,
          channels,
          isPacked,
          shape: inferredDims,
          strides: ShapeUtil.computeStrides(inferredDims),
          unpackedShape,
          reversedWH: prefs && prefs.reverseWH
        };
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/inference-handler.ts
  var getProgramInfoUniqueKey, WebGLInferenceHandler;
  var init_inference_handler = __esm({
    "web/lib/onnxjs/backends/webgl/inference-handler.ts"() {
      "use strict";
      init_instrument();
      init_tensor2();
      init_util();
      init_pack();
      init_reshape_packed();
      init_uint8_encode();
      init_unpack();
      init_texture_data_encoder();
      init_texture_layout();
      init_types();
      getProgramInfoUniqueKey = (programInfo, inputTextureDatas) => {
        const inputs = inputTextureDatas.map((texture) => `${texture.unpackedShape.join(",")};${texture.width}x${texture.height}`).join("_");
        let key = programInfo.name;
        if (programInfo.cacheHint) {
          key += "[" + programInfo.cacheHint + "]";
        }
        key += ":" + inputs;
        return key;
      };
      WebGLInferenceHandler = class {
        constructor(session) {
          this.session = session;
          this.packedTextureDataCache = /* @__PURE__ */ new Map();
          this.unpackedTextureDataCache = /* @__PURE__ */ new Map();
        }
        /**
         * @returns [width, height]
         */
        calculateTextureWidthAndHeight(shape2, textureType) {
          return calculateTextureWidthAndHeight(this.session.layoutStrategy, shape2, textureType);
        }
        executeProgram(program, inputs) {
          if (inputs.length < program.inputNames.length) {
            throw new Error(`Input size mustn't be less than ${program.inputNames.length}.`);
          }
          if (program.inputNames.length !== program.inputTypes.length) {
            throw new Error("input names size does not match input types");
          }
          const inputTextureDatas = [];
          for (let i = 0; i < program.inputNames.length; ++i) {
            inputTextureDatas[i] = this.getOrCreateTextureData(inputs[i], program.inputTypes[i]);
          }
          const key = getProgramInfoUniqueKey(program, inputTextureDatas);
          let artifact = this.session.programManager.getArtifact(key);
          const programInfo = artifact ? artifact.programInfo : typeof program.get === "function" ? program.get() : program;
          const outputTextureLayout = createTextureLayoutFromTextureType(
            this.session.layoutStrategy,
            programInfo.output.dims,
            programInfo.output.textureType
          );
          const outputTextureData = this.createTextureData(outputTextureLayout, programInfo.output.type);
          if (!artifact) {
            artifact = this.session.programManager.build(programInfo, inputTextureDatas, outputTextureData);
            this.session.programManager.setArtifact(key, artifact);
          }
          this.runProgram(artifact, inputTextureDatas, outputTextureData);
          return outputTextureData;
        }
        run(program, inputs) {
          const outputTextureData = this.executeProgram(program, inputs);
          return outputTextureData.tensor;
        }
        runProgram(artifact, inputs, output) {
          for (let i = 0; i < inputs.length; ++i) {
            if (!!inputs[i].isPacked !== (artifact.programInfo.inputTypes[i] === 2 /* packed */)) {
              throw new Error(`input[${i}] property packed inconsistent`);
            }
          }
          if (!!output.isPacked !== (artifact.programInfo.output.textureType === 2 /* packed */)) {
            throw new Error("output property packed inconsistent");
          }
          this.session.programManager.run(artifact, inputs, output);
        }
        /**
         * Create a TextureData object from a tensor.
         * Usage = EncoderUsage.UploadOnly.
         * If a related texture data is found in cache, returns it;
         * Otherwise:
         *   Creates a new texture layout if not provided;
         *   Creates WebGLTexture with the layout;
         *   Upload tensor data to the texture;
         *   Creates a texture data object associated with the given tensor.
         * @param tensor the tensor with data to upload
         */
        getOrCreateTextureData(tensor, textureType) {
          let td = this.getTextureData(tensor.dataId, textureType === 2 /* packed */);
          if (!td) {
            td = this.getTextureData(tensor.dataId, textureType !== 2 /* packed */);
            if (td) {
              if (textureType === 2 /* packed */) {
                return this.pack(td);
              } else {
                return this.unpack(td);
              }
            }
          }
          if (!td) {
            const layout = createTextureLayoutFromTextureType(this.session.layoutStrategy, tensor.dims, textureType);
            if (textureType === 4 /* packedLastDimension */) {
              const group = 1;
              const channels = 4;
              const shape2 = tensor.dims;
              if (shape2.length === 4) {
                const adjustedKernelShape = [shape2[0], Math.ceil(shape2[1] * shape2[2] * shape2[3] / channels)];
                const adjustedLayout = createTextureLayoutFromTextureType(
                  this.session.layoutStrategy,
                  adjustedKernelShape,
                  textureType
                );
                let buffer = tensor.numberData;
                if (shape2[1] * shape2[2] * shape2[3] % channels !== 0) {
                  const numFeatureMaps = shape2[0];
                  const oldRowSize = shape2[1] * shape2[2] * shape2[3];
                  const newRowSize = Math.ceil(oldRowSize * group / channels) * channels;
                  const newSize = numFeatureMaps * newRowSize;
                  buffer = new Float32Array(newSize);
                  for (let f = 0; f < numFeatureMaps; ++f) {
                    const oldOffset = f * oldRowSize;
                    const newOffset = f * newRowSize + f % group * oldRowSize;
                    buffer.set(tensor.numberData.subarray(oldOffset, oldOffset + oldRowSize), newOffset);
                  }
                }
                return this.createTextureData(adjustedLayout, tensor.type, buffer, tensor, 1 /* UploadOnly */);
              }
            }
            if (textureType === 2 /* packed */) {
              const unpackedTextureLayout = createTextureLayoutFromShape(this.session.layoutStrategy, tensor.dims, 1, [], {
                reverseWH: true
              });
              const unpackedTextureData = this.createTextureData(
                unpackedTextureLayout,
                tensor.type,
                tensor.numberData,
                tensor,
                1 /* UploadOnly */
              );
              td = this.pack(unpackedTextureData);
            } else {
              td = this.createTextureData(layout, tensor.type, tensor.numberData, tensor, 1 /* UploadOnly */);
            }
          }
          return td;
        }
        /**
         * Create a TextureData object using the given data and bind to the given tensor.
         * Usage = EncoderUsage.UploadOnly.
         * NOTE: this function is a hack for Conv implementation. should remove this function, after rewriting Conv
         * implementation by Graph.Transformer
         * @param dataType the tensor data type
         * @param data the actual data to upload
         * @param tensor the tensor to bind. tensor's data is ignored.
         */
        createTextureDataFromLayoutBindTensor(layout, dataType, data, tensor) {
          return this.createTextureData(layout, dataType, data, tensor, 1 /* UploadOnly */);
        }
        createTextureData(layout, dataType, data, tensor, usage) {
          Logger.verbose("InferenceHandler", `Creating TextureData: layout:[${JSON.stringify(layout)}]`);
          const texture = this.session.textureManager.createTextureFromLayout(dataType, layout, data, usage);
          return this.createTextureDataFromTexture(layout, dataType, texture, tensor);
        }
        reshapeUnpacked(input, reshapedDims) {
          const inputTD = this.getOrCreateTextureData(input, 0 /* unpacked */);
          const newTextureLayout = {
            channels: inputTD.channels,
            height: inputTD.height,
            width: inputTD.width,
            // handle reshaping into scalar Tensors
            shape: reshapedDims.length !== 0 ? reshapedDims : [1],
            strides: ShapeUtil.computeStrides(reshapedDims),
            unpackedShape: reshapedDims
          };
          const newTextureData = this.createTextureDataFromTexture(newTextureLayout, input.type, inputTD.texture);
          return newTextureData.tensor;
        }
        reshapePacked(input, reshapedDims) {
          const inputTD = this.getOrCreateTextureData(input, 2 /* packed */);
          if (isReshapeCheap(input.dims, reshapedDims)) {
            const newTextureLayout = {
              channels: inputTD.channels,
              height: inputTD.height,
              width: inputTD.width,
              // handle reshaping into scalar Tensors
              shape: reshapedDims.length !== 0 ? reshapedDims : [1],
              strides: ShapeUtil.computeStrides(reshapedDims),
              unpackedShape: reshapedDims,
              isPacked: true
            };
            const newTextureData = this.createTextureDataFromTexture(newTextureLayout, input.type, inputTD.texture);
            return newTextureData.tensor;
          }
          const squeezedInputShape = processDims3D(input.dims);
          const squeezedOutputShape = processDims3D(reshapedDims);
          const squeezedInputTensor = this.reshapePacked(input, squeezedInputShape);
          const squeezedOutputTensor = this.run(
            createPackedReshape3DProgramInfoLoader(this, squeezedInputTensor, squeezedOutputShape),
            [squeezedInputTensor]
          );
          const outputTensor = this.reshapePacked(squeezedOutputTensor, reshapedDims);
          return outputTensor;
        }
        cast(input, type) {
          const inputTD = this.getOrCreateTextureData(input, 0 /* unpacked */);
          const newTextureData = this.createTextureDataFromTexture(inputTD, type, inputTD.texture);
          return newTextureData.tensor;
        }
        createTextureDataFromTexture(layout, dataType, texture, tensor, tensorId) {
          const textureData = {
            ...layout,
            tensor: tensor || new Tensor3(
              layout.unpackedShape,
              dataType,
              (_id) => this.readTexture(textureData),
              async (_id) => this.readTextureAsync(textureData),
              void 0,
              tensorId
            ),
            texture
          };
          this.setTextureData(textureData.tensor.dataId, textureData, layout.isPacked);
          return textureData;
        }
        getTextureData(tensorId, isPacked = false) {
          return this.session.isInitializer(tensorId) ? this.session.getTextureData(tensorId, isPacked) : isPacked ? this.packedTextureDataCache.get(tensorId) : this.unpackedTextureDataCache.get(tensorId);
        }
        setTextureData(tensorId, td, isPacked = false) {
          if (this.session.isInitializer(tensorId)) {
            this.session.setTextureData(tensorId, td, isPacked);
          } else {
            (isPacked ? this.packedTextureDataCache : this.unpackedTextureDataCache).set(tensorId, td);
          }
        }
        isTextureLayoutCached(tensor, isPacked = false) {
          return !!this.getTextureData(tensor.dataId, isPacked);
        }
        dispose() {
          this.session.textureManager.clearActiveTextures();
          this.packedTextureDataCache.forEach((td) => this.session.textureManager.releaseTexture(td));
          this.packedTextureDataCache = /* @__PURE__ */ new Map();
          this.unpackedTextureDataCache.forEach((td) => this.session.textureManager.releaseTexture(td));
          this.unpackedTextureDataCache = /* @__PURE__ */ new Map();
        }
        readTexture(textureData) {
          if (textureData.isPacked) {
            return this.readTexture(this.unpack(textureData));
          }
          if (!this.session.backend.glContext.isFloat32DownloadSupported) {
            return this.session.textureManager.readUint8TextureAsFloat(encodeAsUint8(this, textureData));
          }
          return this.session.textureManager.readTexture(textureData, textureData.tensor.type, textureData.channels);
        }
        async readTextureAsync(textureData) {
          if (textureData.isPacked) {
            return this.readTextureAsync(this.unpack(textureData));
          }
          if (!this.session.backend.glContext.isFloat32DownloadSupported) {
            return this.session.textureManager.readUint8TextureAsFloat(encodeAsUint8(this, textureData));
          }
          return this.session.textureManager.readTextureAsync(textureData, textureData.tensor.type, textureData.channels);
        }
        pack(input) {
          const outputTextureData = this.executeProgram(createPackProgramInfoLoader(this, input.tensor), [input.tensor]);
          return outputTextureData;
        }
        unpack(input) {
          const outputTextureData = this.executeProgram(createUnpackProgramInfoLoader(this, input.tensor), [input.tensor]);
          return outputTextureData;
        }
      };
    }
  });

  // web/lib/onnxjs/attribute-with-cache-key.ts
  var AttributeWithCacheKeyImpl, createAttributeWithCacheKey;
  var init_attribute_with_cache_key = __esm({
    "web/lib/onnxjs/attribute-with-cache-key.ts"() {
      "use strict";
      AttributeWithCacheKeyImpl = class {
        constructor(attribute) {
          Object.assign(this, attribute);
        }
        get cacheKey() {
          if (!this.key) {
            this.key = Object.getOwnPropertyNames(this).sort().map((name2) => `${this[name2]}`).join(";");
          }
          return this.key;
        }
      };
      createAttributeWithCacheKey = (attribute) => new AttributeWithCacheKeyImpl(attribute);
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/batch-normalization.ts
  var batchNormalizationProgramMetadata, batchNormalization, parseBatchNormalizationAttributes, createBatchNormalizationProgramInfo, validateInputs;
  var init_batch_normalization = __esm({
    "web/lib/onnxjs/backends/webgl/ops/batch-normalization.ts"() {
      "use strict";
      init_attribute_with_cache_key();
      init_glsl_source();
      init_types();
      batchNormalizationProgramMetadata = {
        name: "BatchNormalization",
        inputNames: ["A", "Scale", "B", "Mean", "Variance"],
        inputTypes: [
          0 /* unpacked */,
          0 /* unpacked */,
          0 /* unpacked */,
          0 /* unpacked */,
          0 /* unpacked */
        ]
      };
      batchNormalization = (inferenceHandler, inputs, attributes) => {
        validateInputs(inputs);
        const output = inferenceHandler.run(
          {
            ...batchNormalizationProgramMetadata,
            cacheHint: attributes.cacheKey,
            get: () => createBatchNormalizationProgramInfo(inferenceHandler, inputs, attributes)
          },
          inputs
        );
        return [output];
      };
      parseBatchNormalizationAttributes = (node) => {
        const epsilon = node.attributes.getFloat("epsilon", 1e-5);
        const momentum = node.attributes.getFloat("momentum", 0.9);
        const spatial = node.attributes.getInt("spatial", 1);
        return createAttributeWithCacheKey({ epsilon, momentum, spatial });
      };
      createBatchNormalizationProgramInfo = (inferenceHandler, inputs, attributes) => {
        const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);
        const rank = inputs[0].dims.length;
        const [scaleWidth, scaleHeight] = inferenceHandler.calculateTextureWidthAndHeight(
          inputs[1].dims,
          0 /* unpacked */
        );
        const shaderSource = `
  float process(int[${rank}] indices) {
    vec2 position = offsetToCoords(indices[1], ${scaleWidth}, ${scaleHeight});
    float scale = getColorAsFloat(${glsl.texture2D}(Scale, position));
    float mean = getColorAsFloat(${glsl.texture2D}(Mean, position));
    float variance = getColorAsFloat(${glsl.texture2D}(Variance, position));
    float b = getColorAsFloat(${glsl.texture2D}(B, position));

    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${attributes.epsilon})) ) + b;
  }`;
        return {
          ...batchNormalizationProgramMetadata,
          output: { dims: inputs[0].dims, type: inputs[0].type, textureType: 0 /* unpacked */ },
          shaderSource
        };
      };
      validateInputs = (inputs) => {
        if (!inputs || inputs.length !== 5) {
          throw new Error("BatchNormalization requires 5 inputs.");
        }
        const X = inputs[0];
        const scale = inputs[1];
        const B = inputs[2];
        const mean = inputs[3];
        const var_ = inputs[4];
        if (X.dims.length < 3 || scale.dims.length !== 1 || B.dims.length !== 1 || mean.dims.length !== 1 || var_.dims.length !== 1) {
          throw new Error("invalid input shape.");
        }
        if (scale.dims[0] !== X.dims[1] || B.dims[0] !== X.dims[1] || mean.dims[0] !== X.dims[1] || var_.dims[0] !== X.dims[1]) {
          throw new Error("invalid input shape.");
        }
        if (X.type !== "float32" && X.type !== "float64" || scale.type !== "float32" && scale.type !== "float64" || B.type !== "float32" && B.type !== "float64" || mean.type !== "float32" && mean.type !== "float64" || var_.type !== "float32" && var_.type !== "float64") {
          throw new Error("invalid input tensor types.");
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/glsl-definitions.ts
  var GlslContext, GlslLib, GlslLibRoutine, GlslLibRoutineNode, TopologicalSortGlslRoutines;
  var init_glsl_definitions = __esm({
    "web/lib/onnxjs/backends/webgl/glsl-definitions.ts"() {
      "use strict";
      GlslContext = class {
        constructor(glContext, programInfo, inputTextureLayouts, outputTextureLayout) {
          this.glContext = glContext;
          this.programInfo = programInfo;
          this.inputTextureLayouts = inputTextureLayouts;
          this.outputTextureLayout = outputTextureLayout;
        }
      };
      GlslLib = class {
        constructor(context) {
          this.context = context;
        }
      };
      GlslLibRoutine = class {
        constructor(routineBody, dependencies) {
          this.routineBody = routineBody;
          this.dependencies = dependencies;
        }
      };
      GlslLibRoutineNode = class {
        constructor(name2, routineBody, dependencies) {
          this.name = name2;
          if (dependencies) {
            this.dependencies = dependencies;
          } else {
            this.dependencies = [];
          }
          if (routineBody) {
            this.routineBody = routineBody;
          }
        }
        addDependency(node) {
          if (node) {
            this.dependencies.push(node);
          }
        }
      };
      TopologicalSortGlslRoutines = class {
        static returnOrderedNodes(nodes) {
          if (!nodes || nodes.length === 0) {
            return [];
          }
          if (nodes.length === 1) {
            return nodes;
          }
          const cycleCheck = /* @__PURE__ */ new Set();
          const alreadyTraversed = /* @__PURE__ */ new Set();
          const result = new Array();
          this.createOrderedNodes(nodes, cycleCheck, alreadyTraversed, result);
          return result;
        }
        static createOrderedNodes(graphNodes, cycleCheck, alreadyTraversed, result) {
          for (let i = 0; i < graphNodes.length; ++i) {
            this.dfsTraverse(graphNodes[i], cycleCheck, alreadyTraversed, result);
          }
        }
        static dfsTraverse(root, cycleCheck, alreadyTraversed, result) {
          if (!root || alreadyTraversed.has(root.name)) {
            return;
          }
          if (cycleCheck.has(root.name)) {
            throw new Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");
          }
          cycleCheck.add(root.name);
          const dependencies = root.dependencies;
          if (dependencies && dependencies.length > 0) {
            for (let i = 0; i < dependencies.length; ++i) {
              this.dfsTraverse(dependencies[i], cycleCheck, alreadyTraversed, result);
            }
          }
          result.push(root);
          alreadyTraversed.add(root.name);
          cycleCheck.delete(root.name);
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/binary-op.ts
  function glslAdd() {
    const name2 = "add_";
    const body = `
  float ${name2}(float a, float b) {
    return a + b;
  }
  vec4 ${name2}(vec4 v1, vec4 v2) {
    return v1 + v2;
  }
  `;
    return { body, name: name2, type: 0 /* ValueBased */ };
  }
  function glslDiv() {
    const name2 = "div_";
    const body = `
  float ${name2}(float a, float b) {
    return a / b;
  }
  vec4 ${name2}(vec4 v1, vec4 v2) {
    return v1 / v2;
  }
  `;
    return { body, name: name2, type: 0 /* ValueBased */ };
  }
  function glslMul() {
    const name2 = "mul_";
    const body = `
  float ${name2}(float a, float b) {
    return a * b;
  }
  vec4 ${name2}(vec4 v1, vec4 v2) {
    return v1 * v2;
  }
  `;
    return { body, name: name2, type: 0 /* ValueBased */ };
  }
  function glslSub() {
    const name2 = "sub_";
    const body = `
  float ${name2}(float a, float b) {
    return a - b;
  }
  vec4 ${name2}(vec4 v1, vec4 v2) {
    return v1 - v2;
  }
  `;
    return { body, name: name2, type: 0 /* ValueBased */ };
  }
  function glslEqual() {
    const name2 = "equal_";
    const body = `
  float ${name2}(float a, float b) {
    return float(a == b);
  }
  vec4 ${name2}(vec4 v1, vec4 v2) {
    return vec4(equal(v1, v2));
  }
  `;
    return { body, name: name2, type: 0 /* ValueBased */ };
  }
  function glslGreater() {
    const name2 = "greater_";
    const body = `
  float ${name2}(float a, float b) {
    return float(a > b);
  }
  vec4 ${name2}(vec4 v1, vec4 v2) {
    return vec4( v1.r > v2.r ,
      v1.g > v2.g,
      v1.b > v2.b,
      v1.a > v2.a );
  }
  `;
    return { body, name: name2, type: 0 /* ValueBased */ };
  }
  function glslLess() {
    const name2 = "less_";
    const body = `
  float ${name2}(float a, float b) {
    return float(a < b);
  }
  vec4 ${name2}(vec4 v1, vec4 v2) {
    return vec4( v1.r < v2.r ,
                v1.g < v2.g,
                v1.b < v2.b,
                v1.a < v2.a );
  }
  `;
    return { body, name: name2, type: 0 /* ValueBased */ };
  }
  function glslAnd() {
    const name2 = "and_";
    const body = `
  float ${name2}(float a, float b) {
    return float( bool(a) && bool(b) );
  }
  vec4 ${name2}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r && b2.r ,
                b1.g && b2.g,
                b1.b && b2.b,
                b1.a && b2.a );
  }
  `;
    return { body, name: name2, type: 0 /* ValueBased */ };
  }
  function glslOr() {
    const name2 = "or_";
    const body = `
  float ${name2}(float a, float b) {
    return float( bool(a) || bool(b) );
  }
  vec4 ${name2}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r || b2.r ,
                b1.g || b2.g,
                b1.b || b2.b,
                b1.a || b2.a );
  }
  `;
    return { body, name: name2, type: 0 /* ValueBased */ };
  }
  function glslXor() {
    const name2 = "xor_";
    const body = `
  float ${name2}(float a, float b) {
    return float( bool(a) ^^ bool(b) );
  }
  vec4 ${name2}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r ^^ b2.r ,
                b1.g ^^ b2.g,
                b1.b ^^ b2.b,
                b1.a ^^ b2.a );
  }
  `;
    return { body, name: name2, type: 0 /* ValueBased */ };
  }
  function glslPow() {
    return glslBuiltinBinary("pow");
  }
  function glslPRelu() {
    const name2 = "prelu_";
    const body = `
  float ${name2}(float a, float b) {
    return a < 0.0 ? a * b: a;
  }
  vec4 ${name2}(vec4 v1, vec4 v2) {
    return vec4(
      v1.r < 0.0 ? v1.r * v2.r: v1.r,
      v1.g < 0.0 ? v1.g * v2.g: v1.g,
      v1.b < 0.0 ? v1.b * v2.b: v1.b,
      v1.a < 0.0 ? v1.a * v2.a: v1.a
      );
  }
  `;
    return { body, name: name2, type: 0 /* ValueBased */ };
  }
  function glslBuiltinBinary(fname) {
    const name2 = `${fname}_`;
    const body = `
  float ${name2}(float a, float b) {
    return ${fname}(a, b);
  }
  vec4 ${name2}(vec4 v1, vec4 v2) {
    return ${fname}(v1, v2);
  }
  `;
    return { body, name: name2, type: 0 /* ValueBased */ };
  }
  var createBinaryProgramInfoLoader, createBinaryProgramInfo, add2, and2, div, equal, greater, less, mul, or2, pow, pRelu, sub, xor2;
  var init_binary_op = __esm({
    "web/lib/onnxjs/backends/webgl/ops/binary-op.ts"() {
      "use strict";
      init_util();
      init_glsl_definitions();
      init_glsl_source();
      init_types();
      createBinaryProgramInfoLoader = (handler, inputs, glslFunc, outputTensorType = inputs[0].type, cacheKey) => {
        const textureType = handler.session.pack ? 2 /* packed */ : 0 /* unpacked */;
        return {
          name: glslFunc.name,
          inputNames: ["A", "B"],
          inputTypes: [textureType, textureType],
          cacheHint: cacheKey,
          get: () => createBinaryProgramInfo(handler, inputs, glslFunc, outputTensorType)
        };
      };
      createBinaryProgramInfo = (handler, inputs, glslFunc, outputTensorType = inputs[0].type) => {
        const textureType = handler.session.pack ? 2 /* packed */ : 0 /* unpacked */;
        const isBroadcast = !ShapeUtil.areEqual(inputs[0].dims, inputs[1].dims);
        let outputShape = inputs[0].dims;
        const usePackedTexture = handler.session.pack;
        if (isBroadcast) {
          const calculatedShape = BroadcastUtil.calcShape(inputs[0].dims, inputs[1].dims, false);
          if (!calculatedShape) {
            throw new Error("Can't perform binary op on the given tensors");
          }
          outputShape = calculatedShape;
          const outputRank = outputShape.length;
          const aRank = inputs[0].dims.length !== 0 ? inputs[0].dims.length : 1;
          const bRank = inputs[1].dims.length !== 0 ? inputs[1].dims.length : 1;
          const aBcast = inputs[0].dims.length !== 0 ? "bcastIndices_A(indices, aindices);" : "aindices[0] = 0;";
          const bBcast = inputs[1].dims.length !== 0 ? "bcastIndices_B(indices, bindices);" : "bindices[0] = 0;";
          const glsl2 = getGlsl(handler.session.backend.glContext.version);
          const shaderSource2 = usePackedTexture ? `
      ${glslFunc.body}
      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();
        vec4 result = ${glslFunc.name}(a, b);
        ${glsl2.output} = result;
      }` : `
      ${glslFunc.body}
      float process(int indices[${outputRank}]) {
        int aindices[${aRank}];
        int bindices[${bRank}];
        ${aBcast}
        ${bBcast}
        return ${glslFunc.name}(_A(aindices), _B(bindices));
      }`;
          return {
            name: glslFunc.name,
            inputNames: ["A", "B"],
            inputTypes: [textureType, textureType],
            output: { dims: outputShape, type: outputTensorType, textureType },
            shaderSource: shaderSource2,
            hasMain: usePackedTexture
          };
        }
        const glsl = getGlsl(handler.session.backend.glContext.version);
        const shaderSource = `
    ${glslFunc.body}
    void main() {
      vec4 v1 = ${glsl.texture2D}(A, TexCoords);
      vec4 v2 = ${glsl.texture2D}(B, TexCoords);
      vec4 result = ${glslFunc.name}(v1, v2);
      ${glsl.output} = result;
    }
    `;
        return {
          name: glslFunc.name,
          inputNames: ["A", "B"],
          inputTypes: [textureType, textureType],
          output: { dims: inputs[0].dims, type: outputTensorType, textureType },
          shaderSource,
          hasMain: true
        };
      };
      add2 = (handler, inputs) => [
        handler.run(createBinaryProgramInfoLoader(handler, inputs, glslAdd()), inputs)
      ];
      and2 = (handler, inputs) => [
        handler.run(createBinaryProgramInfoLoader(handler, inputs, glslAnd(), "bool"), inputs)
      ];
      div = (handler, inputs) => [
        handler.run(createBinaryProgramInfoLoader(handler, inputs, glslDiv()), inputs)
      ];
      equal = (handler, inputs) => [
        handler.run(createBinaryProgramInfoLoader(handler, inputs, glslEqual(), "bool"), inputs)
      ];
      greater = (handler, inputs) => [
        handler.run(createBinaryProgramInfoLoader(handler, inputs, glslGreater(), "bool"), inputs)
      ];
      less = (handler, inputs) => [
        handler.run(createBinaryProgramInfoLoader(handler, inputs, glslLess(), "bool"), inputs)
      ];
      mul = (handler, inputs) => [
        handler.run(createBinaryProgramInfoLoader(handler, inputs, glslMul()), inputs)
      ];
      or2 = (handler, inputs) => [
        handler.run(createBinaryProgramInfoLoader(handler, inputs, glslOr(), "bool"), inputs)
      ];
      pow = (handler, inputs) => [
        handler.run(createBinaryProgramInfoLoader(handler, inputs, glslPow()), inputs)
      ];
      pRelu = (handler, inputs) => [
        handler.run(createBinaryProgramInfoLoader(handler, inputs, glslPRelu()), inputs)
      ];
      sub = (handler, inputs) => [
        handler.run(createBinaryProgramInfoLoader(handler, inputs, glslSub()), inputs)
      ];
      xor2 = (handler, inputs) => [
        handler.run(createBinaryProgramInfoLoader(handler, inputs, glslXor(), "bool"), inputs)
      ];
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/cast.ts
  var cast, parseCastAttributes, validateInputs2;
  var init_cast = __esm({
    "web/lib/onnxjs/backends/webgl/ops/cast.ts"() {
      "use strict";
      init_util();
      cast = (handler, inputs, to) => {
        validateInputs2(inputs);
        return [handler.cast(inputs[0], to)];
      };
      parseCastAttributes = (node) => ProtoUtil.tensorDataTypeFromProto(node.attributes.getInt("to"));
      validateInputs2 = (inputs) => {
        if (!inputs || inputs.length !== 1) {
          throw new Error("Cast requires 1 input.");
        }
        if (inputs[0].type === "string") {
          throw new Error("Invalid input type.");
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/concat-packed.ts
  var createPackedConcatProgramMetadata, createPackedConcatProgramInfo, createPackedConcatProgramInfoLoader, getShiftedChannelsSnippet;
  var init_concat_packed = __esm({
    "web/lib/onnxjs/backends/webgl/ops/concat-packed.ts"() {
      "use strict";
      init_glsl_source();
      init_types();
      init_utils();
      init_packing_utils();
      createPackedConcatProgramMetadata = (inputCount, cacheHint) => ({
        name: "Concat (packed)",
        inputNames: Array.from({ length: inputCount }, (_v, i) => `X${i}`),
        inputTypes: Array(inputCount).fill(2 /* packed */),
        cacheHint
      });
      createPackedConcatProgramInfo = (handler, metadata, inputs, axis) => {
        const inputShape = inputs[0].dims.slice();
        if (axis >= inputShape.length || axis < -1 * inputShape.length) {
          throw new Error("axis specified for concat doesn't match input dimensionality");
        }
        if (axis < 0) {
          axis = inputShape.length + axis;
        }
        const outputShape = inputShape.slice(0);
        for (let i = 1; i < inputs.length; i++) {
          const dataNShape = inputs[i].dims.slice();
          for (let axisIndex = 0; axisIndex < inputShape.length; axisIndex++) {
            if (axisIndex === axis) {
              outputShape[axis] += dataNShape[axisIndex];
            } else if (inputShape[axisIndex] !== dataNShape[axisIndex]) {
              throw new Error("non concat dimensions must match");
            }
          }
        }
        const rank = outputShape.length;
        const coords = getChannels("coords", rank);
        const dtype = getCoordsDataType(rank);
        const unpackChannel = unpackFromChannel();
        const shapes = inputs.map((i) => i.dims);
        const channels = getGlChannels(rank);
        const offsets = new Array(shapes.length - 1);
        offsets[0] = shapes[0][axis];
        for (let i = 1; i < offsets.length; i++) {
          offsets[i] = offsets[i - 1] + shapes[i][axis];
        }
        const channel = channels[axis];
        const lastChannels = channels.slice(-2);
        const allChannels = channels.join();
        let getValueSnippet = `if (${channel} < ${offsets[0]}) {
        return getChannel(
            getX0(${allChannels}), vec2(${lastChannels.join()}));
        }`;
        for (let i = 1; i < offsets.length; i++) {
          const shift2 = offsets[i - 1];
          getValueSnippet += `
            if (${channel} < ${offsets[i]}  && ${channel} >= ${offsets[i - 1]}) {
              return getChannel(
                getX${i}(${getShiftedChannelsSnippet(channels, channel, shift2)}),
                vec2(${getShiftedChannelsSnippet(lastChannels, channel, shift2)}));
            }`;
        }
        const lastIndex = offsets.length;
        const shift = offsets[offsets.length - 1];
        getValueSnippet += `
            return getChannel(
              getX${lastIndex}(${getShiftedChannelsSnippet(channels, channel, shift)}),
              vec2(${getShiftedChannelsSnippet(lastChannels, channel, shift)}));`;
        const glsl = getGlsl(handler.session.backend.glContext.version);
        const shaderSource = `
          ${unpackChannel}
          float getValue(${channels.map((x) => "int " + x)}) {
            ${getValueSnippet}
          }

          void main() {
            ${dtype} coords = getOutputCoords();
            int lastDim = coords.${channels[rank - 1]};
            coords.${channels[rank - 1]} = coords.${channels[rank - 2]};
            coords.${channels[rank - 2]} = lastDim;

            vec4 result = vec4(getValue(${coords}), 0., 0., 0.);

            ${coords[rank - 1]} = ${coords[rank - 1]} + 1;
            if (${coords[rank - 1]} < ${outputShape[rank - 1]}) {
              result.g = getValue(${coords});
            }

            ${coords[rank - 2]} = ${coords[rank - 2]} + 1;
            if (${coords[rank - 2]} < ${outputShape[rank - 2]}) {
              result.a = getValue(${coords});
            }

            ${coords[rank - 1]} = ${coords[rank - 1]} - 1;
            if (${coords[rank - 2]} < ${outputShape[rank - 2]} &&
                ${coords[rank - 1]} < ${outputShape[rank - 1]}) {
              result.b = getValue(${coords});
            }
            ${glsl.output} = result;
          }
        `;
        return {
          ...metadata,
          output: { dims: outputShape, type: inputs[0].type, textureType: 2 /* packed */ },
          shaderSource,
          hasMain: true
        };
      };
      createPackedConcatProgramInfoLoader = (handler, inputs, attributes) => {
        const metadata = createPackedConcatProgramMetadata(inputs.length, attributes.cacheKey);
        return { ...metadata, get: () => createPackedConcatProgramInfo(handler, metadata, inputs, attributes.axis) };
      };
      getShiftedChannelsSnippet = (channels, channel, shift) => {
        const channelIdx = channels.indexOf(channel);
        const res = channels.map((c, idx) => {
          if (idx === channelIdx) {
            return `${c} - ${shift}`;
          } else {
            return c;
          }
        });
        return res.join();
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/concat.ts
  var concat, createUnpackedConcatProgramMetadata, createUnpackedConcatProgramInfo, createUnpackedConcatProgramInfoLoader, getTextureIndexWhereDataResidesLinearSearch, getTextureIndexWhereDataResidesBinarySearch, getFetchDataFromCorrectTextureMethod, getGetSizeInConcatAxisValueFromIndexMethod, parseConcatAttributes, validateInputs3;
  var init_concat = __esm({
    "web/lib/onnxjs/backends/webgl/ops/concat.ts"() {
      "use strict";
      init_attribute_with_cache_key();
      init_types();
      init_concat_packed();
      concat = (inferenceHandler, inputs, attributes) => {
        validateInputs3(inputs);
        if (inferenceHandler.session.pack && inputs[0].dims.length > 1) {
          const output = inferenceHandler.run(
            createPackedConcatProgramInfoLoader(inferenceHandler, inputs, attributes),
            inputs
          );
          return [output];
        } else {
          const output = inferenceHandler.run(
            createUnpackedConcatProgramInfoLoader(inferenceHandler, inputs, attributes),
            inputs
          );
          return [output];
        }
      };
      createUnpackedConcatProgramMetadata = (inputCount, cacheHint) => ({
        name: "Concat",
        inputNames: Array.from({ length: inputCount }, (_v, i) => `X${i}`),
        inputTypes: Array(inputCount).fill(0 /* unpacked */),
        cacheHint
      });
      createUnpackedConcatProgramInfo = (_handler, metadata, inputs, axis) => {
        const inputShape = inputs[0].dims.slice();
        if (axis >= inputShape.length || axis < -1 * inputShape.length) {
          throw new Error("axis specified for concat doesn't match input dimensionality");
        }
        if (axis < 0) {
          axis = inputShape.length + axis;
        }
        const outputShape = inputShape.slice(0);
        for (let i = 1; i < inputs.length; i++) {
          const dataNShape = inputs[i].dims.slice();
          for (let axisIndex = 0; axisIndex < inputShape.length; axisIndex++) {
            if (axisIndex === axis) {
              outputShape[axis] += dataNShape[axisIndex];
            } else if (inputShape[axisIndex] !== dataNShape[axisIndex]) {
              throw new Error("non concat dimensions must match");
            }
          }
        }
        const rank = outputShape.length;
        const sizeInConcatAxis = new Array(inputs.length);
        let previousSum = 0;
        for (let i = 0; i < sizeInConcatAxis.length; ++i) {
          previousSum += inputs[i].dims[axis];
          sizeInConcatAxis[i] = previousSum;
        }
        let getTextureIndexWhereDataResidesMethod = "";
        if (inputs.length < 5) {
          getTextureIndexWhereDataResidesMethod = getTextureIndexWhereDataResidesLinearSearch(sizeInConcatAxis);
        } else {
          getTextureIndexWhereDataResidesMethod = getTextureIndexWhereDataResidesBinarySearch(sizeInConcatAxis);
        }
        const fetchDataFromCorrectTextureMethod = getFetchDataFromCorrectTextureMethod(inputs.length, rank);
        const getSizeInConcatAxisValueFromIndexMethod = getGetSizeInConcatAxisValueFromIndexMethod(sizeInConcatAxis);
        const shaderSource = `
        ${fetchDataFromCorrectTextureMethod}
        ${getSizeInConcatAxisValueFromIndexMethod}
        ${getTextureIndexWhereDataResidesMethod}
        float process(int indices[${rank}]) {
          int textureIndex = getTextureWhereDataResides (indices[${axis}]);

          if(textureIndex != 0) {
            indices[${axis}] = indices[${axis}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));
          }

          return fetchDataFromCorrectTexture(textureIndex, indices);
        }`;
        return {
          ...metadata,
          output: { dims: outputShape, type: inputs[0].type, textureType: 0 /* unpacked */ },
          shaderSource
        };
      };
      createUnpackedConcatProgramInfoLoader = (handler, inputs, attributes) => {
        const metadata = createUnpackedConcatProgramMetadata(inputs.length, attributes.cacheKey);
        return { ...metadata, get: () => createUnpackedConcatProgramInfo(handler, metadata, inputs, attributes.axis) };
      };
      getTextureIndexWhereDataResidesLinearSearch = (sizeInConcatAxis) => {
        const searchAxis = sizeInConcatAxis.map(
          (size, i) => `if(index<${size}) {return ${i};}
`
        );
        return `int getTextureWhereDataResides(int index) {
      ${searchAxis.join("")}
    }`;
      };
      getTextureIndexWhereDataResidesBinarySearch = (sizeInConcatAxis) => getTextureIndexWhereDataResidesLinearSearch(sizeInConcatAxis);
      getFetchDataFromCorrectTextureMethod = (numberOfTensors, tensorRank) => {
        const codeLines = [`float fetchDataFromCorrectTexture(int textureIndex, int indices[${tensorRank}]) {`];
        for (let i = 0; i < numberOfTensors; ++i) {
          if (i === 0) {
            codeLines.push(`	if (textureIndex == ${i}) { return _X${i}(indices); }`);
          } else if (i === numberOfTensors - 1) {
            codeLines.push(`	else { return _X${i}(indices); }`);
          } else {
            codeLines.push(`	else if (textureIndex == ${i}) { return _X${i}(indices); }`);
          }
        }
        codeLines.push("	}");
        return codeLines.join("\n");
      };
      getGetSizeInConcatAxisValueFromIndexMethod = (sizeInConcatAxis) => {
        const codeLines = ["int getSizeInConcatAxisValueFromIndex(int index) {"];
        for (let i = 0; i < sizeInConcatAxis.length; ++i) {
          if (i === 0) {
            codeLines.push(`	if (index == ${i}) { return ${sizeInConcatAxis[i]}; }`);
          } else if (i === sizeInConcatAxis.length - 1) {
            codeLines.push(`	else { return ${sizeInConcatAxis[i]}; }`);
          } else {
            codeLines.push(`	else if (index == ${i}) { return ${sizeInConcatAxis[i]}; }`);
          }
        }
        codeLines.push("	}");
        return codeLines.join("\n");
      };
      parseConcatAttributes = (node) => createAttributeWithCacheKey({ axis: node.attributes.getInt("axis") });
      validateInputs3 = (inputs) => {
        if (!inputs || inputs.length < 1) {
          throw new Error("too few inputs");
        }
        const inputType = inputs[0].type;
        const inputDimensionality = inputs[0].dims.length;
        if (inputType === "string") {
          throw new Error("string tensor is not supported yet");
        }
        for (const input of inputs) {
          if (input.type !== inputType) {
            throw new Error("input tensors should be one type");
          }
          if (input.dims.length !== inputDimensionality) {
            throw new Error("input tensors should have the same shape");
          }
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/unary-op.ts
  function glslAbs() {
    return glslBuiltinUnary("abs");
  }
  function glslAcos() {
    return glslBuiltinUnary("acos");
  }
  function glslAsin() {
    return glslBuiltinUnary("asin");
  }
  function glslAtan() {
    return glslBuiltinUnary("atan");
  }
  function glslCeil() {
    return glslBuiltinUnary("ceil");
  }
  function glslCos() {
    return glslBuiltinUnary("cos");
  }
  function glslElu(alpha) {
    const name2 = "elu";
    const body = `
  const float alpha = float(${alpha});

  float ${name2}_(float a) {
    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;
  }
  vec4 ${name2}_(vec4 v) {
    return vec4(${name2}_(v.x), ${name2}_(v.y), ${name2}_(v.z), ${name2}_(v.w));
  }
  `;
    return { body, name: name2, type: 0 /* ValueBased */ };
  }
  function glslExp() {
    return glslBuiltinUnary("exp");
  }
  function glslFloor() {
    return glslBuiltinUnary("floor");
  }
  function glslClip(min, max) {
    const name2 = "clip";
    const body = `
  const float min = float(${min});
  const float max = float(${max});

  float ${name2}_(float a) {
    return clamp(a, min, max);
  }
  vec4 ${name2}_(vec4 v) {
    return clamp(v, min, max);
  }
  `;
    return { body, name: name2, type: 0 /* ValueBased */ };
  }
  function glslIdentity() {
    const name2 = "indentity";
    const body = `
  float ${name2}_(float a) {
    return a;
  }
  vec4 ${name2}_(vec4 v) {
    return v;
  }
  `;
    return { body, name: name2, type: 0 /* ValueBased */ };
  }
  function glslLeakyRelu(alpha) {
    const name2 = "leakyRelu";
    const body = `
  const float alpha = float(${alpha});

  float ${name2}_(float a) {
    return a < 0.0 ? a * alpha : a;
  }
  vec4 ${name2}_(vec4 v) {
    return vec4(${name2}_(v.x), ${name2}_(v.y), ${name2}_(v.z), ${name2}_(v.w));
  }
  `;
    return { body, name: name2, type: 0 /* ValueBased */ };
  }
  function glslLog() {
    return glslBuiltinUnary("log");
  }
  function glslNeg() {
    const name2 = "neg";
    const body = `
  float ${name2}_(float a) {
    return -a;
  }
  vec4 ${name2}_(vec4 v) {
    return -v;
  }
  `;
    return { body, name: name2, type: 0 /* ValueBased */ };
  }
  function glslNot() {
    const name2 = "not";
    const body = `
  float ${name2}_(float a) {
    return float( ! bool(a) );
  }
  bool ${name2}_(bool a) {
    return !a;
  }
  vec4 ${name2}_(vec4 v) {
    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));
  }
  bvec4 ${name2}_(bvec4 v) {
    return bvec4(!v.x, !v.y, !v.z, !v.w);
  }
  `;
    return { body, name: name2, type: 0 /* ValueBased */ };
  }
  function glslSin() {
    return glslBuiltinUnary("sin");
  }
  function glslRelu() {
    const name2 = "relu";
    const body = `
  float ${name2}_(float a) {
    return max( a, 0.0 );
  }
  vec4 ${name2}_(vec4 v) {
    return max( v, 0.0 );
  }
  `;
    return { body, name: name2, type: 0 /* ValueBased */ };
  }
  function glslSigmoid() {
    const name2 = "sigmoid";
    const body = `
  float ${name2}_(float a) {
    return 1.0 / (1.0 + exp(-a));
  }
  vec4 ${name2}_(vec4 v) {
    return 1.0 / (1.0 + exp(-v));
  }
  `;
    return { body, name: name2, type: 0 /* ValueBased */ };
  }
  function glslSqrt() {
    return glslBuiltinUnary("sqrt");
  }
  function glslTan() {
    return glslBuiltinUnary("tan");
  }
  function glslTanh() {
    const name2 = "tanh";
    const body = `
  float ${name2}_(float a) {
    a = clamp(a, -10., 10.);
    a = exp(2.*a);
    return (a - 1.) / (a + 1.);
  }
  vec4 ${name2}_(vec4 v) {
    v = clamp(v, -10., 10.);
    v = exp(2.*v);
    return (v - 1.) / (v + 1.);
  }
  `;
    return { body, name: name2, type: 0 /* ValueBased */ };
  }
  function glslBuiltinUnary(name2) {
    const body = `
  float ${name2}_(float a) {
    return ${name2}(a);
  }
  vec4 ${name2}_(vec4 v) {
    return ${name2}(v);
  }
  `;
    return { body, name: name2, type: 0 /* ValueBased */ };
  }
  var createElementwiseProgramInfo, createElementwiseProgramInfoLoader, abs, acos, asin, atan, clip, parseClipAttributes, clipV11, generateClipAttributesFromInputs, ceil, cos, elu, parseEluAttributes, exp, floor, identity, leakyRelu, parseLeakyReluAttributes, log2, neg, not2, relu, sigmoid, sin, sqrt, tan, tanh;
  var init_unary_op = __esm({
    "web/lib/onnxjs/backends/webgl/ops/unary-op.ts"() {
      "use strict";
      init_attribute_with_cache_key();
      init_util();
      init_glsl_definitions();
      init_glsl_source();
      init_types();
      createElementwiseProgramInfo = (handler, metadata, input, glslFunc) => {
        const textureType = handler.session.pack ? 2 /* packed */ : 0 /* unpacked */;
        const glsl = getGlsl(handler.session.backend.glContext.version);
        return {
          ...metadata,
          output: { dims: input.dims, type: input.type, textureType },
          shaderSource: `
     ${glslFunc.body}
     void main() {
       vec4 v = ${glsl.texture2D}(A, TexCoords);
       v = ${glslFunc.name}_(v);
       ${glsl.output} = v;
     }
     `,
          hasMain: true
        };
      };
      createElementwiseProgramInfoLoader = (handler, input, glslFunc, cacheKey) => {
        const textureType = handler.session.pack ? 2 /* packed */ : 0 /* unpacked */;
        const metadata = { name: glslFunc.name, inputTypes: [textureType], inputNames: ["A"], cacheHint: cacheKey };
        return { ...metadata, get: () => createElementwiseProgramInfo(handler, metadata, input, glslFunc) };
      };
      abs = (handler, inputs) => [
        handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslAbs()), inputs)
      ];
      acos = (handler, inputs) => [
        handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslAcos()), inputs)
      ];
      asin = (handler, inputs) => [
        handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslAsin()), inputs)
      ];
      atan = (handler, inputs) => [
        handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslAtan()), inputs)
      ];
      clip = (handler, inputs, attributes) => [
        handler.run(
          createElementwiseProgramInfoLoader(
            handler,
            inputs[0],
            glslClip(attributes.min, attributes.max),
            attributes.cacheKey
          ),
          inputs
        )
      ];
      parseClipAttributes = (node) => createAttributeWithCacheKey({
        min: node.attributes.getFloat("min", MIN_CLIP),
        max: node.attributes.getFloat("max", MAX_CLIP)
      });
      clipV11 = (handler, inputs) => {
        const attributes = generateClipAttributesFromInputs(handler, inputs);
        return clip(handler, [inputs[0]], attributes);
      };
      generateClipAttributesFromInputs = (handler, inputs) => {
        if (inputs.length >= 3 && (!handler.session.isInitializer(inputs[1].dataId) || !handler.session.isInitializer(inputs[2].dataId))) {
          throw new Error("dynamic clip attributes are not allowed");
        }
        const min = inputs.length >= 3 ? inputs[1].numberData[0] : MIN_CLIP;
        const max = inputs.length >= 3 ? inputs[2].numberData[0] : MAX_CLIP;
        return createAttributeWithCacheKey({ min, max });
      };
      ceil = (handler, inputs) => [
        handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslCeil()), inputs)
      ];
      cos = (handler, inputs) => [
        handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslCos()), inputs)
      ];
      elu = (handler, inputs, attributes) => [
        handler.run(
          createElementwiseProgramInfoLoader(handler, inputs[0], glslElu(attributes.alpha), attributes.cacheKey),
          inputs
        )
      ];
      parseEluAttributes = (node) => createAttributeWithCacheKey({ alpha: node.attributes.getFloat("alpha", 1) });
      exp = (handler, inputs) => [
        handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslExp()), inputs)
      ];
      floor = (handler, inputs) => [
        handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslFloor()), inputs)
      ];
      identity = (handler, inputs) => [
        handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslIdentity()), inputs)
      ];
      leakyRelu = (handler, inputs, attributes) => [
        handler.run(
          createElementwiseProgramInfoLoader(handler, inputs[0], glslLeakyRelu(attributes.alpha), attributes.cacheKey),
          inputs
        )
      ];
      parseLeakyReluAttributes = (node) => createAttributeWithCacheKey({ alpha: node.attributes.getFloat("alpha", 0.01) });
      log2 = (handler, inputs) => [
        handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslLog()), inputs)
      ];
      neg = (handler, inputs) => [
        handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslNeg()), inputs)
      ];
      not2 = (handler, inputs) => [
        handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslNot()), inputs)
      ];
      relu = (handler, inputs) => [
        handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslRelu()), inputs)
      ];
      sigmoid = (handler, inputs) => [
        handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslSigmoid()), inputs)
      ];
      sin = (handler, inputs) => [
        handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslSin()), inputs)
      ];
      sqrt = (handler, inputs) => [
        handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslSqrt()), inputs)
      ];
      tan = (handler, inputs) => [
        handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslTan()), inputs)
      ];
      tanh = (handler, inputs) => [
        handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslTanh()), inputs)
      ];
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/fuse-utils.ts
  function getActivationSnippet(attributes) {
    let func;
    switch (attributes.activation) {
      case "Relu":
        func = glslRelu();
        break;
      case "Sigmoid":
        func = glslSigmoid();
        break;
      case "Clip":
        func = glslClip(attributes.clipMin, attributes.clipMax);
        break;
      default:
        return { activationFunction: "", applyActivation: "" };
    }
    const activationName = func.name;
    const activationFunction = func.body;
    const applyActivation = `value = ${activationName}_(value);`;
    return { activationFunction, applyActivation };
  }
  var parseInternalActivationAttributes;
  var init_fuse_utils = __esm({
    "web/lib/onnxjs/backends/webgl/ops/fuse-utils.ts"() {
      "use strict";
      init_util();
      init_unary_op();
      parseInternalActivationAttributes = (attributes) => {
        const activation = attributes.getString("activation", "");
        if (activation === "Clip") {
          const [clipMin, clipMax] = attributes.getFloats("activation_params", [MIN_CLIP, MAX_CLIP]);
          return { activation, clipMax, clipMin, activationCacheKey: `${activation}:${clipMin},${clipMax}` };
        }
        return { activation, activationCacheKey: activation };
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/conv-grouped.ts
  var createUnpackedGroupedConvProgramMetadata, createUnpackedGroupedConvProgramInfo, createUnpackedGroupedConvProgramInfoLoader;
  var init_conv_grouped = __esm({
    "web/lib/onnxjs/backends/webgl/ops/conv-grouped.ts"() {
      "use strict";
      init_instrument();
      init_glsl_source();
      init_types();
      init_conv();
      init_fuse_utils();
      createUnpackedGroupedConvProgramMetadata = (hasBias, cacheHint) => ({
        name: "GroupedConv",
        inputNames: hasBias ? ["X", "W", "Bias"] : ["X", "W"],
        inputTypes: hasBias ? [0 /* unpacked */, 0 /* unpacked */, 0 /* unpacked */] : [0 /* unpacked */, 0 /* unpacked */],
        cacheHint
      });
      createUnpackedGroupedConvProgramInfo = (inferenceHandler, inputs, metadata, attributes) => {
        const hasBias = inputs.length > 2;
        const processBias = hasBias ? "value += getBias(output_channel);" : "";
        const xShape = inputs[0].dims.slice();
        const wShape = inputs[1].dims.slice();
        const outputChannelsPerGroup = wShape[0] / attributes.group;
        Logger.verbose(
          "GroupedConv",
          `autpPad:${attributes.autoPad}, dilations:${attributes.dilations}, group:${attributes.group}, kernelShape:${attributes.kernelShape}, pads:${attributes.pads}, strides:${attributes.strides}`
        );
        const outputShape = calculateOutputShape(xShape, wShape, attributes.dilations, attributes.pads, attributes.strides);
        const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);
        const { activationFunction, applyActivation } = getActivationSnippet(attributes);
        const shaderSource = `
  const ivec2 strides = ivec2(${attributes.strides[0]}, ${attributes.strides[1]});
  const ivec2 pads = ivec2(${attributes.pads[0]}, ${attributes.pads[1]});
  ${activationFunction}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;
    ivec2 xRCCorner = coords.zw * strides - pads;
    int group_id = output_channel / ${outputChannelsPerGroup};

    float value = 0.0;
    for (int wInChannel = 0; wInChannel < ${wShape[1]}; wInChannel++) {
      int input_channel = group_id * ${wShape[1]} + wInChannel;
      for (int wHeight = 0; wHeight < ${wShape[2]}; wHeight++) {
        int xHeight = xRCCorner.x + wHeight * ${attributes.dilations[0]};

        if (xHeight < 0 || xHeight >= ${xShape[2]}) {
          continue;
        }

        for (int wWidth = 0; wWidth < ${wShape[3]}; wWidth++) {
          int xWidth = xRCCorner.y + wWidth * ${attributes.dilations[1]};
          if (xWidth < 0 || xWidth >= ${xShape[3]}) {
            continue;
          }

          float xVal = getX(batch, input_channel, xWidth, xHeight);
          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);
          value += xVal*wVal;
        }
      }
    }
    ${processBias}
    ${applyActivation}
    ${glsl.output} = vec4(value, .0, .0, .0);
  }
`;
        return {
          ...metadata,
          output: { dims: outputShape, type: inputs[0].type, textureType: 0 /* unpacked */ },
          shaderSource,
          hasMain: true
        };
      };
      createUnpackedGroupedConvProgramInfoLoader = (inferenceHandler, inputs, attributes) => {
        const metadata = createUnpackedGroupedConvProgramMetadata(inputs.length > 2, attributes.cacheKey);
        return {
          ...metadata,
          get: () => createUnpackedGroupedConvProgramInfo(inferenceHandler, inputs, metadata, attributes)
        };
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/im2col-pack.ts
  var createPackedIm2ColProgramMetadata, createPackedIm2ColProgramInfo, createPackedIm2ColProgramInfoLoader;
  var init_im2col_pack = __esm({
    "web/lib/onnxjs/backends/webgl/ops/im2col-pack.ts"() {
      "use strict";
      init_glsl_source();
      init_types();
      init_packing_utils();
      createPackedIm2ColProgramMetadata = (cacheHint) => ({
        name: "Im2Col (packed)",
        inputNames: ["A"],
        inputTypes: [2 /* packed */],
        cacheHint
      });
      createPackedIm2ColProgramInfo = (inferenceHandler, metadata, x, w, outputShape, attributes) => {
        const xshape = x.dims;
        const wshape = w.dims;
        const rowDim = 2;
        const colDim = 3;
        const rank = outputShape.length;
        const im2colShape = [wshape[1] * wshape[2] * wshape[3], outputShape[2] * outputShape[3]];
        const kernelSize = wshape[2] * wshape[3];
        const unpackChannel = unpackFromChannel();
        const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);
        let unrolled = "";
        for (let row = 0; row <= 1; row++) {
          for (let col = 0; col <= 1; col++) {
            unrolled += `
            blockIndex = rc.x + ${col};
            pos = rc.y + ${row};

            if(blockIndex < ${im2colShape[1]} && pos < ${im2colShape[0]}) {
              offsetY = int(blockIndex / (${outputShape[rank - 1]})) * ${attributes.strides[0]} -
                ${attributes.pads[0]};
              d0 = offsetY + ${attributes.dilations[0]} * (imod(pos, ${kernelSize}) / ${wshape[2]});

              if(d0 < ${xshape[rowDim]} && d0 >= 0) {
                offsetX = imod(blockIndex, ${outputShape[rank - 1]}) * ${attributes.strides[1]} -
                  ${attributes.pads[1]};
                d1 = offsetX + ${attributes.dilations[1]} * imod(imod(pos, ${kernelSize}), ${wshape[2]});

                if(d1 < ${xshape[colDim]} && d1 >= 0) {

                  ch = int(float(pos)/ ${kernelSize}.);
                    innerDims = vec2(d0, d1);
                    result[${row * 2 + col}] = getChannel(
                      getA(0, ch, int(innerDims.x),
                      int(innerDims.y)), innerDims);
                }
              }
            }

          `;
          }
        }
        const shaderSource = `
      ${unpackChannel}

      void main() {
        ivec2 rc = getOutputCoords();
          vec4 result = vec4(0.0);
          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
          vec2 innerDims;
          ${unrolled}
          ${glsl.output} = result;
      }
            `;
        return {
          ...metadata,
          output: { dims: im2colShape, type: x.type, textureType: 2 /* packed */ },
          shaderSource,
          hasMain: true
        };
      };
      createPackedIm2ColProgramInfoLoader = (inferenceHandler, x, w, outputShape, attributes) => {
        const metadata = createPackedIm2ColProgramMetadata(attributes.cacheKey);
        return {
          ...metadata,
          get: () => createPackedIm2ColProgramInfo(inferenceHandler, metadata, x, w, outputShape, attributes)
        };
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/matmul.ts
  function createMatmulProgramInfo(metadata, inputs, activationAttributes) {
    const aShape = inputs[0].dims;
    const bShape = inputs[1].dims;
    const outputShape = BroadcastUtil.calcShape(aShape, bShape, true);
    if (!outputShape) {
      throw new Error("Can't use matmul on the given tensors");
    }
    const coordsDataType = getCoordsDataType(outputShape.length);
    const allGlChannels = getGlChannels();
    const { activationFunction, applyActivation } = getActivationSnippet(activationAttributes);
    const hasBias = inputs.length > 2;
    const processBias = hasBias ? "value += getBiasForMatmul();" : "";
    const getBiasForMatmulSnippet = hasBias ? `${getBiasForMatmul(coordsDataType, allGlChannels, inputs[2].dims, outputShape, false)}` : "";
    const rank = outputShape.length;
    const arank = aShape.length;
    const brank = bShape.length;
    const sharedDim = aShape[aShape.length - 1];
    const shaderSource = `
    ${activationFunction}
    ${getBiasForMatmulSnippet}
    float process(int indices[${rank}]) {
        int a[${arank}];
        int b[${brank}];
        bcastMatmulIndices_A(indices, a);
        bcastMatmulIndices_B(indices, b);

        float value;
        for (int k=0; k<${sharedDim}; ++k) {
            a[${arank - 1}] = k;
            b[${brank - 2}] = k;
            value += _A(a) * _B(b);
        }
        ${processBias}
        ${applyActivation}
        return value;
    }`;
    return {
      ...metadata,
      output: { dims: outputShape, type: inputs[0].type, textureType: 0 /* unpacked */ },
      shaderSource
    };
  }
  function createMatmulProgramInfoLoader(inputs, activationAttributes) {
    const metadata = createMatmulProgramMetadata(inputs.length > 2, activationAttributes.activationCacheKey);
    return { ...metadata, get: () => createMatmulProgramInfo(metadata, inputs, activationAttributes) };
  }
  function getBiasForMatmul(coordsDataType, allGlChannels, inShape, outShape, isPacked) {
    let unpackedCoordsSnippet = "";
    const inRank = inShape.length;
    const outRank = outShape.length;
    const rankDiff = outRank - inRank;
    if (outRank < 2 && inRank > 0) {
      unpackedCoordsSnippet = "coords";
    } else {
      unpackedCoordsSnippet = inShape.map((_s, i) => `coords.${allGlChannels[i + rankDiff]}`).join(", ");
    }
    const broadcastDims = BroadcastUtil.getBroadcastDims(inShape, outShape);
    const coordsSnippet = broadcastDims.map((d) => `coords.${allGlChannels[d + rankDiff]} = 0;`).join("\n");
    const inSize = ShapeUtil.size(inShape);
    const isInputScalar = inSize === 1;
    let output = "vec4(outputValue.xx, outputValue.yy)";
    if (isInputScalar) {
      output = "vec4(outputValue.x)";
    }
    const getBiasForMatmulSource = isPacked ? `
vec4 getBiasForMatmul() {
  ${coordsDataType} coords = getOutputCoords();
  ${coordsSnippet}
  vec4 outputValue = getBias(${unpackedCoordsSnippet});
  return ${output};
}` : `
float getBiasForMatmul() {
  ${coordsDataType} coords = getOutputCoords();
  ${coordsSnippet}
  return getBias(coords.x);
}`;
    return getBiasForMatmulSource;
  }
  var matMul, parseMatMulAttributes, createMatmulProgramMetadata, validateInputs4;
  var init_matmul = __esm({
    "web/lib/onnxjs/backends/webgl/ops/matmul.ts"() {
      "use strict";
      init_util();
      init_types();
      init_utils();
      init_fuse_utils();
      init_matmul_pack();
      matMul = (inferenceHandler, inputs, attributes) => {
        validateInputs4(inputs);
        if (inferenceHandler.session.pack) {
          return [inferenceHandler.run(createPackedMatmulProgramInfoLoader(inferenceHandler, inputs, attributes), inputs)];
        } else {
          return [inferenceHandler.run(createMatmulProgramInfoLoader(inputs, attributes), inputs)];
        }
      };
      parseMatMulAttributes = (node) => parseInternalActivationAttributes(node.attributes);
      createMatmulProgramMetadata = (hasBias, cacheHint) => ({
        name: "MatMul",
        inputNames: hasBias ? ["A", "B", "Bias"] : ["A", "B"],
        inputTypes: hasBias ? [0 /* unpacked */, 0 /* unpacked */, 0 /* unpacked */] : [0 /* unpacked */, 0 /* unpacked */],
        cacheHint
      });
      validateInputs4 = (inputs) => {
        if (!inputs || inputs.length !== 2) {
          throw new Error("MatMul requires 2 inputs.");
        }
        if (inputs[0].dims[inputs[0].dims.length - 1] !== inputs[1].dims[inputs[1].dims.length - 2]) {
          throw new Error("shared dimension does not match.");
        }
        if (inputs[0].type !== "float32" && inputs[0].type !== "float64" || inputs[1].type !== "float32" && inputs[1].type !== "float64") {
          throw new Error("inputs should be float type");
        }
        if (inputs[0].type !== inputs[1].type) {
          throw new Error("inputs types should match");
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/matmul-pack.ts
  function getBcastSamplerForMatmul(coordsDataType, allGlChannels, inputs, outShape) {
    let unpackedACoordsSnippet = [];
    let unpackedBCoordsSnippet = [];
    const inAShape = inputs[0].dims;
    const inBShape = inputs[1].dims;
    const inARank = inAShape.length;
    const inBRank = inBShape.length;
    const outRank = outShape.length;
    const rankADiff = outRank - inARank;
    const rankBDiff = outRank - inBRank;
    unpackedACoordsSnippet = inAShape.map((_s, i) => `coords.${allGlChannels[i + rankADiff]}`);
    unpackedACoordsSnippet[inARank - 1] = "i*2";
    unpackedACoordsSnippet.join(", ");
    unpackedBCoordsSnippet = inBShape.map((_s, i) => `coords.${allGlChannels[i + rankBDiff]}`);
    unpackedBCoordsSnippet[inBRank - 2] = "i*2";
    unpackedBCoordsSnippet.join(", ");
    const broadcastADims = BroadcastUtil.getBroadcastDims(inAShape, outShape);
    const broadcastBDims = BroadcastUtil.getBroadcastDims(inBShape, outShape);
    const coordsASnippet = broadcastADims.map((d) => `coords.${allGlChannels[d + rankADiff]} = 0;`).join("\n");
    const coordsBSnippet = broadcastBDims.map((d) => `coords.${allGlChannels[d + rankBDiff]} = 0;`).join("\n");
    const swapDimSnippet = `int lastDim = coords.${allGlChannels[outRank - 1]};
  coords.${allGlChannels[outRank - 1]} = coords.${allGlChannels[outRank - 2]};
  coords.${allGlChannels[outRank - 2]} = lastDim;`;
    const getBcastSamplerMatmulSource = `
vec4 getAAtOutCoordsMatmul(int i) {
  ${coordsDataType} coords = getOutputCoords();
  ${swapDimSnippet}
  ${coordsASnippet}
  vec4 outputValue = getA(${unpackedACoordsSnippet});
  return outputValue;
}

vec4 getBAtOutCoordsMatmul(int i) {
  ${coordsDataType} coords = getOutputCoords();
  ${swapDimSnippet}
  ${coordsBSnippet}
  vec4 outputValue = getB(${unpackedBCoordsSnippet});
  return outputValue;
}`;
    return getBcastSamplerMatmulSource;
  }
  function getA(allGlChannels, rank) {
    let res = "";
    for (let i = 0; i < rank - 2; i++) {
      res += `rc.${allGlChannels[i]}, `;
    }
    res += `rc.${allGlChannels[rank - 2]}, i*2`;
    return res;
  }
  function getB(allGlChannels, rank) {
    let res = "";
    for (let i = 0; i < rank - 2; i++) {
      res += `rc.${allGlChannels[i]}, `;
    }
    res += `i*2, rc.${allGlChannels[rank - 1]}`;
    return res;
  }
  var createPackedMatmulProgramMetadata, createPackedMatmulProgramInfo, createPackedMatmulProgramInfoLoader;
  var init_matmul_pack = __esm({
    "web/lib/onnxjs/backends/webgl/ops/matmul-pack.ts"() {
      "use strict";
      init_util();
      init_glsl_source();
      init_types();
      init_utils();
      init_fuse_utils();
      init_matmul();
      createPackedMatmulProgramMetadata = (hasBias, cacheHint) => ({
        name: "MatMul (packed)",
        inputNames: hasBias ? ["A", "B", "Bias"] : ["A", "B"],
        inputTypes: hasBias ? [2 /* packed */, 2 /* packed */, 2 /* packed */] : [2 /* packed */, 2 /* packed */],
        cacheHint
      });
      createPackedMatmulProgramInfo = (inferenceHandler, metadata, inputs, activationAttributes) => {
        const hasBias = inputs.length > 2;
        const processBias = hasBias ? "value += getBiasForMatmul();" : "";
        const aShape = inputs[0].dims;
        const bShape = inputs[1].dims;
        const outputShape = BroadcastUtil.calcShape(aShape, bShape, true);
        const isBroadcast = !ShapeUtil.areEqual(inputs[0].dims, inputs[1].dims);
        if (!outputShape) {
          throw new Error("Can't use matmul on the given tensors");
        }
        const sharedDim = aShape[aShape.length - 1];
        const sharedDimIndex = Math.ceil(sharedDim / 2);
        const aRank = aShape.length;
        const bRank = bShape.length;
        const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);
        const coordsDataType = getCoordsDataType(outputShape.length);
        const outRank = outputShape.length;
        const allGlChannels = getGlChannels();
        const { activationFunction, applyActivation } = getActivationSnippet(activationAttributes);
        const getBiasForMatmulSnippet = hasBias ? `${getBiasForMatmul(coordsDataType, allGlChannels, inputs[2].dims, outputShape, true)}` : "";
        const getBcastedSamplerForMatmulSnippet = isBroadcast ? `${getBcastSamplerForMatmul(coordsDataType, allGlChannels, inputs, outputShape)}` : "";
        const getSamplerAInLoopSnippet = isBroadcast ? "getAAtOutCoordsMatmul(i)" : `getA(${getA(allGlChannels, aRank)})`;
        const getSamplerBInLoopSnippet = isBroadcast ? "getBAtOutCoordsMatmul(i)" : `getB(${getB(allGlChannels, bRank)})`;
        const getOutputCoordsSnippet = isBroadcast ? "" : `${coordsDataType} rc =
          getOutputCoords(); int lastDim = rc.${allGlChannels[outRank - 1]}; rc.${allGlChannels[outRank - 1]} =
          rc.${allGlChannels[outRank - 2]}; rc.${allGlChannels[outRank - 2]} = lastDim;
      `;
        const shaderSource = `
            ${getBcastedSamplerForMatmulSnippet}
            ${getBiasForMatmulSnippet}
            ${activationFunction}
            void main() {
              ${getOutputCoordsSnippet}

              vec4 value = vec4(0);
              for (int i = 0; i < ${sharedDimIndex}; i++) {
                vec4 a = ${getSamplerAInLoopSnippet};
                vec4 b = ${getSamplerBInLoopSnippet};

                value += (a.rrbb * b.rgrg);
                value += (a.ggaa * b.baba);
              }
              ${processBias}
              ${applyActivation}
              ${glsl.output} = value;
            }`;
        return {
          ...metadata,
          output: { dims: outputShape, type: inputs[0].type, textureType: 2 /* packed */ },
          shaderSource,
          hasMain: true
        };
      };
      createPackedMatmulProgramInfoLoader = (inferenceHandler, inputs, activationAttributes) => {
        const metadata = createPackedMatmulProgramMetadata(inputs.length > 2, activationAttributes.activationCacheKey);
        return {
          ...metadata,
          get: () => createPackedMatmulProgramInfo(inferenceHandler, metadata, inputs, activationAttributes)
        };
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/conv-pack.ts
  var conv2DPacked;
  var init_conv_pack = __esm({
    "web/lib/onnxjs/backends/webgl/ops/conv-pack.ts"() {
      "use strict";
      init_conv();
      init_im2col_pack();
      init_matmul_pack();
      conv2DPacked = (inferenceHandler, inputs, attributes) => {
        const xshape = inputs[0].dims;
        const kshape = inputs[1].dims;
        const outputShape = calculateOutputShape(xshape, kshape, attributes.dilations, attributes.pads, attributes.strides);
        const im2colOutput = inferenceHandler.run(
          createPackedIm2ColProgramInfoLoader(inferenceHandler, inputs[0], inputs[1], outputShape, attributes),
          [inputs[0]]
        );
        const kernelReshaped = inferenceHandler.reshapePacked(inputs[1], [kshape[0], kshape[1] * kshape[2] * kshape[3]]);
        const matmulInputs = inputs.length === 3 ? [kernelReshaped, im2colOutput, inputs[2]] : [kernelReshaped, im2colOutput];
        const matmulOutput = inferenceHandler.run(
          createPackedMatmulProgramInfoLoader(inferenceHandler, matmulInputs, attributes),
          matmulInputs
        );
        const outputReshaped = inferenceHandler.reshapePacked(matmulOutput, outputShape);
        return outputReshaped;
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/im2col.ts
  var createIm2ColProgramMetadata, createIm2ColProgramInfo, createIm2ColProgramInfoLoader, calculateIm2ColDims;
  var init_im2col = __esm({
    "web/lib/onnxjs/backends/webgl/ops/im2col.ts"() {
      "use strict";
      init_types();
      createIm2ColProgramMetadata = (cacheHint) => ({
        name: "Im2Col",
        inputNames: ["X"],
        inputTypes: [0 /* unpacked */],
        cacheHint
      });
      createIm2ColProgramInfo = (_inferenceHandler, metadata, x, w, outputShape, attributes) => {
        const xshape = x.dims;
        const wshape = w.dims;
        const rank = outputShape.length;
        const im2colDims = calculateIm2ColDims(xshape, wshape, outputShape, 4);
        const shaderSource = `
        const int XC = ${xshape[1]};
        const int XH = ${xshape[2]};
        const int XW = ${xshape[3]};
        const int KH = ${attributes.kernelShape[0]};
        const int KW = ${attributes.kernelShape[1]};
        const int dilationH = ${attributes.dilations[0]};
        const int dilationW = ${attributes.dilations[1]};
        const int strideH = ${attributes.strides[0]};
        const int strideW = ${attributes.strides[1]};
        const int padH = ${attributes.pads[0]};
        const int padW = ${attributes.pads[1]};
        const int KHKW = KH*KW;
        const int XCKHKW = XC * KHKW;
        const int outputChannels = 4;
        vec4 process(int indices[${rank}]) {
          int b  = indices[0]; // batch size
          int oh = indices[1] * strideH - padH; //output height
          int ow = indices[2] * strideW - padW; //output width
          int p = indices[3] * outputChannels; //patch
          vec4 value = vec4(0.0);
          for(int i=0; i < outputChannels; ++i) {
            if(p < XCKHKW) {
              int patchC = p / KHKW;
              int patchH = (p - patchC*KHKW) / KW;
              int patchW = (p - patchC*KHKW) - patchH * KW;
              int xh2 = oh + patchH * dilationH;
              int xw2 = ow + patchW * dilationW;
              int x[${xshape.length}];
              x[0] = b;
              x[1] = patchC;
              x[2] = xh2;
              x[3] = xw2;
              if(xh2 >= 0 &&
                  xh2 < XH &&
                  xw2 >= 0 &&
                  xw2 < XW) {
                value[i] = _X(x);
              }
            }
            ++p;
          }
          return value;
        }
        `;
        return {
          ...metadata,
          output: { dims: im2colDims, type: x.type, textureType: 4 /* packedLastDimension */ },
          shaderSource
        };
      };
      createIm2ColProgramInfoLoader = (inferenceHandler, x, w, outputShape, attributes) => {
        const metadata = createIm2ColProgramMetadata(attributes.cacheKey);
        return {
          ...metadata,
          get: () => createIm2ColProgramInfo(inferenceHandler, metadata, x, w, outputShape, attributes)
        };
      };
      calculateIm2ColDims = (inputShape, kernelShape, outputShape, channels = 4) => [
        outputShape[0],
        outputShape[2],
        outputShape[3],
        Math.ceil(inputShape[1] * kernelShape[2] * kernelShape[3] / channels)
      ];
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/dot-product.ts
  var createDotProductProgramMetadata, createDotProductProgramInfo, createDotProductProgramInfoLoader;
  var init_dot_product = __esm({
    "web/lib/onnxjs/backends/webgl/ops/dot-product.ts"() {
      "use strict";
      init_util();
      init_glsl_source();
      init_types();
      init_fuse_utils();
      init_im2col();
      createDotProductProgramMetadata = (hasBias, attributes) => ({
        name: "ConvDotProduct",
        inputNames: hasBias ? ["Im2Col", "K", "B"] : ["Im2Col", "K"],
        inputTypes: hasBias ? [0 /* unpacked */, 4 /* packedLastDimension */, 0 /* unpacked */] : [0 /* unpacked */, 4 /* packedLastDimension */],
        cacheKey: attributes.activationCacheKey
      });
      createDotProductProgramInfo = (inferenceHandler, metadata, inputs, outputShape, attributes) => {
        const xshape = inputs[0].dims;
        const kshape = inputs[1].dims;
        const adjustedKernelShape = [kshape[0], Math.ceil(xshape[1] * kshape[2] * kshape[3] / 4)];
        const im2colShape = calculateIm2ColDims(xshape, kshape, outputShape);
        const [kWidth, kHeight] = inferenceHandler.calculateTextureWidthAndHeight(
          adjustedKernelShape,
          4 /* packedLastDimension */
        );
        const im2colStrides = ShapeUtil.computeStrides(im2colShape);
        const [im2colWidth, im2colHeight] = inferenceHandler.calculateTextureWidthAndHeight(
          im2colShape,
          4 /* packedLastDimension */
        );
        const rank = outputShape.length;
        const initValue = inputs.length < 3 ? "0.0" : "_B(b)";
        const sharedDim = Math.ceil(xshape[1] * kshape[2] * kshape[3] / 4);
        const { activationFunction, applyActivation } = getActivationSnippet(attributes);
        const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);
        const shaderSource = `
${activationFunction}
float process(int indices[${rank}]) {
  int b[1];
  b[0] = indices[1];
  int im2col[4];
  im2col[0] = indices[0];
  im2col[1] = indices[2];
  im2col[2] = indices[3];
  int im2colOffset = im2col[0] * ${im2colStrides[0]} + im2col[1] * ${im2colStrides[1]} + im2col[2] * ${im2colStrides[2]};
  int kernelOffset = indices[1] * ${adjustedKernelShape[1]};
  float value = ${initValue};
  for (int i = 0; i < ${sharedDim}; ++i) {
    vec2 im2colCoords = offsetToCoords(im2colOffset, ${im2colWidth}, ${im2colHeight});
    vec2 kernelCoords = offsetToCoords(kernelOffset, ${kWidth}, ${kHeight});
    value += dot(${glsl.texture2D}(Im2Col, im2colCoords), ${glsl.texture2D}(K, kernelCoords));
    ++im2colOffset;
    ++kernelOffset;
  }
  ${applyActivation}
  return value;
}`;
        return {
          ...metadata,
          output: { dims: outputShape, type: inputs[0].type, textureType: 0 /* unpacked */ },
          shaderSource
        };
      };
      createDotProductProgramInfoLoader = (inferenceHandler, inputs, outputShape, attributes) => {
        const metadata = createDotProductProgramMetadata(inputs.length > 2, attributes);
        return {
          ...metadata,
          get: () => createDotProductProgramInfo(inferenceHandler, metadata, inputs, outputShape, attributes)
        };
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/conv.ts
  var calculateOutputShape, conv, conv2d, conv2DUnpackedPointwise, conv2DUnpacked, getAdjustedConvAttributes, parseConvAttributes, validateInputs5;
  var init_conv = __esm({
    "web/lib/onnxjs/backends/webgl/ops/conv.ts"() {
      "use strict";
      init_attribute_with_cache_key();
      init_util();
      init_conv_grouped();
      init_conv_pack();
      init_dot_product();
      init_fuse_utils();
      init_im2col();
      init_matmul();
      calculateOutputShape = (inputShape, kernelShape, dilations, adjustPads, strides) => {
        const batchSize = inputShape[0];
        const inputSpatialShape = inputShape.slice(2);
        const spatialRank = inputSpatialShape.length;
        const outChannels = kernelShape[0];
        const kernelSpatialShape = kernelShape.slice(2);
        const dilatedKernelShape = kernelSpatialShape.map((v, i) => v + (v - 1) * (dilations[i] - 1));
        const inputSpatialShapeWithPad = inputSpatialShape.map((v, i) => v + adjustPads[i] + adjustPads[i + spatialRank]);
        const outputSpatialShape = inputSpatialShapeWithPad.map(
          (v, i) => Math.floor((v - dilatedKernelShape[i] + strides[i]) / strides[i])
        );
        const outputShape = [batchSize, outChannels].concat(...outputSpatialShape);
        return outputShape;
      };
      conv = (inferenceHandler, inputs, attributes) => {
        validateInputs5(inputs, attributes);
        return conv2d(inferenceHandler, inputs, attributes);
      };
      conv2d = (inferenceHandler, inputs, attributes) => {
        const adjustedAttributes = getAdjustedConvAttributes(attributes, inputs);
        const packMode = inferenceHandler.session.pack;
        const isPointwise = adjustedAttributes.kernelShape[0] === 1 && adjustedAttributes.kernelShape[1] === 1;
        if (adjustedAttributes.group > 1) {
          const result = inferenceHandler.run(
            createUnpackedGroupedConvProgramInfoLoader(inferenceHandler, inputs, adjustedAttributes),
            inputs
          );
          return [result];
        } else if (isPointwise && packMode) {
          return [conv2DUnpackedPointwise(inferenceHandler, inputs, adjustedAttributes)];
        } else if (packMode && inputs[0].dims.length === 4 && inputs[0].dims[0] === 1 && !isPointwise) {
          return [conv2DPacked(inferenceHandler, inputs, adjustedAttributes)];
        } else {
          return [conv2DUnpacked(inferenceHandler, inputs, adjustedAttributes)];
        }
      };
      conv2DUnpackedPointwise = (inferenceHandler, inputs, attributes) => {
        const xshape = inputs[0].dims;
        const kshape = inputs[1].dims;
        const outputShape = calculateOutputShape(xshape, kshape, attributes.dilations, attributes.pads, attributes.strides);
        const reshapedX = inferenceHandler.reshapeUnpacked(inputs[0], [xshape[1], xshape[2] * xshape[3]]);
        const reshapedK = inferenceHandler.reshapeUnpacked(inputs[1], [kshape[0], kshape[1]]);
        const matmulInputs = inputs.length > 2 ? [reshapedK, reshapedX, inputs[2]] : [reshapedK, reshapedX];
        const matmulOutput = inferenceHandler.run(createMatmulProgramInfoLoader(matmulInputs, attributes), matmulInputs);
        return inferenceHandler.reshapeUnpacked(matmulOutput, outputShape);
      };
      conv2DUnpacked = (inferenceHandler, inputs, attributes) => {
        const xshape = inputs[0].dims;
        const kshape = inputs[1].dims;
        const outputShape = calculateOutputShape(xshape, kshape, attributes.dilations, attributes.pads, attributes.strides);
        const xIm2Col = inferenceHandler.run(
          createIm2ColProgramInfoLoader(inferenceHandler, inputs[0], inputs[1], outputShape, attributes),
          [inputs[0]]
        );
        const dotProductInputs = inputs.length === 3 ? [xIm2Col, inputs[1], inputs[2]] : [xIm2Col, inputs[1]];
        const output = inferenceHandler.run(
          createDotProductProgramInfoLoader(inferenceHandler, inputs, outputShape, attributes),
          dotProductInputs
        );
        return output;
      };
      getAdjustedConvAttributes = (attributes, inputs) => {
        const kernelShape = attributes.kernelShape.slice();
        if (attributes.kernelShape.length === 0) {
          for (let i = 2; i < inputs[1].dims.length; ++i) {
            kernelShape.push(inputs[1].dims[i]);
          }
        }
        const pads = attributes.pads.slice();
        PoolConvUtil.adjustPadsBasedOnAutoPad(
          inputs[0].dims,
          attributes.strides,
          attributes.dilations,
          kernelShape,
          pads,
          attributes.autoPad
        );
        const newAttributes = Object.assign({}, attributes);
        Object.assign(newAttributes, { kernelShape, pads, cacheKey: attributes.cacheKey });
        return newAttributes;
      };
      parseConvAttributes = (node) => {
        const attributes = node.attributes;
        const activationAttributes = parseInternalActivationAttributes(attributes);
        const autoPad = attributes.getString("auto_pad", "NOTSET");
        const dilations = attributes.getInts("dilations", [1, 1]);
        const group = attributes.getInt("group", 1);
        const kernelShape = attributes.getInts("kernel_shape", []);
        const pads = attributes.getInts("pads", [0, 0, 0, 0]);
        const strides = attributes.getInts("strides", [1, 1]);
        return createAttributeWithCacheKey({
          autoPad,
          dilations,
          group,
          kernelShape,
          pads,
          strides,
          ...activationAttributes
        });
      };
      validateInputs5 = (inputs, attributes) => {
        if (!inputs || inputs.length !== 2 && inputs.length !== 3) {
          throw new Error("Conv requires 2 or 3 inputs");
        }
        if (inputs[0].dims.length !== 4 || inputs[1].dims.length !== 4) {
          throw new Error("currently only support 2-dimensional conv");
        }
        const dataChannel = inputs[0].dims[1];
        const filterInChannel = inputs[1].dims[1] * attributes.group;
        if (dataChannel !== filterInChannel) {
          throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");
        }
        if (inputs.length === 3 && (inputs[2].dims.length !== 1 || inputs[1].dims[0] !== inputs[2].dims[0])) {
          throw new Error("invalid bias");
        }
        const spatialRank = inputs[0].dims.length - 2;
        if (attributes.dilations.length !== spatialRank) {
          throw new Error(`dilations should be ${spatialRank}D`);
        }
        if (attributes.strides.length !== spatialRank) {
          throw new Error(`strides should be ${spatialRank}D`);
        }
        if (attributes.pads.length !== spatialRank * 2) {
          throw new Error(`pads should be ${spatialRank * 2}D`);
        }
        if (attributes.kernelShape.length !== 0 && attributes.kernelShape.length !== inputs[1].dims.length - 2) {
          throw new Error("invalid kernel shape");
        }
        if (inputs[0].type !== "float32" || inputs[1].type !== "float32") {
          throw new Error("Conv input(X,W) should be float tensor");
        }
        if (inputs.length === 3 && inputs[2].type !== "float32") {
          throw new Error("Conv input(bias) should be float tensor");
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/conv-transpose.ts
  var computeTotalPad, distributePadding, calculateOutputShapeAndPads, convTranspose, convTranspose2d, createConvTransposeProgramMetadata, createUnpackedConvTransposeProgramInfo, createUnpackedConvTransposeProgramInfoLoader, convTranspose2DUnpacked, getAdjustedConvTransposeAttributes, parseConvTransposeAttributes, validateInputs6;
  var init_conv_transpose = __esm({
    "web/lib/onnxjs/backends/webgl/ops/conv-transpose.ts"() {
      "use strict";
      init_attribute_with_cache_key();
      init_glsl_source();
      init_types();
      init_fuse_utils();
      computeTotalPad = (inDim, stride, adj, kernel, dilation, outSize) => (inDim - 1) * stride + adj + (kernel - 1) * dilation + 1 - outSize;
      distributePadding = (totalPad, autoPad, pads, head, tail) => {
        const smallPad = Math.floor(totalPad / 2);
        if (autoPad === "SAME_UPPER") {
          pads[head] = smallPad;
          pads[tail] = totalPad - smallPad;
        } else if (autoPad === "SAME_LOWER") {
          pads[head] = totalPad - smallPad;
          pads[tail] = smallPad;
        }
      };
      calculateOutputShapeAndPads = (inputShape, kernelShape, dilations, autoPad, pads, strides, outputPadding, outputShape) => {
        const spatialRank = inputShape.length - 2;
        const updateShape = outputShape.length === 0;
        for (let i = 0; i < spatialRank; ++i) {
          const outSize = updateShape ? inputShape[i + 2] * strides[i] : outputShape[i];
          const totalPad = computeTotalPad(inputShape[i + 2], strides[i], pads[i], kernelShape[i], dilations[i], outSize);
          distributePadding(totalPad, autoPad, pads, i, i + spatialRank);
          if (updateShape) {
            outputShape.push(
              strides[i] * (inputShape[i + 2] - 1) + outputPadding[i] + (kernelShape[i] - 1) * dilations[i] + 1 - pads[i] - pads[i + spatialRank]
            );
          }
        }
      };
      convTranspose = (inferenceHandler, inputs, attributes) => {
        validateInputs6(inputs, attributes);
        return convTranspose2d(inferenceHandler, inputs, attributes);
      };
      convTranspose2d = (inferenceHandler, inputs, attributes) => {
        const adjustedAttributes = getAdjustedConvTransposeAttributes(attributes, inputs);
        return [convTranspose2DUnpacked(inferenceHandler, inputs, adjustedAttributes)];
      };
      createConvTransposeProgramMetadata = (hasBias, cacheHint) => ({
        name: "ConvTranspose",
        inputNames: hasBias ? ["X", "W", "B"] : ["X", "W"],
        inputTypes: hasBias ? [0 /* unpacked */, 0 /* unpacked */, 0 /* unpacked */] : [0 /* unpacked */, 0 /* unpacked */],
        cacheHint
      });
      createUnpackedConvTransposeProgramInfo = (inferenceHandler, inputs, metadata, attributes) => {
        const hasBias = inputs.length > 2;
        const valueInit = hasBias ? "getB(output_channel)" : "0.0";
        const xShape = inputs[0].dims;
        const wShape = inputs[1].dims;
        const outputChannelsPerGroup = wShape[1];
        const inputChannelsPerGroup = wShape[0] / attributes.group;
        const outputShape = [inputs[0].dims[0], inputs[1].dims[1] * attributes.group, ...attributes.outputShape];
        const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);
        const { activationFunction, applyActivation } = getActivationSnippet(attributes);
        const shaderSource = `
  const ivec2 strides = ivec2(${attributes.strides[0]}, ${attributes.strides[1]});
  const ivec2 pads = ivec2(${attributes.pads[0]}, ${attributes.pads[1]});
  ${activationFunction}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;

    ivec2 loc = coords.zw + pads;

    int group_id = output_channel / ${outputChannelsPerGroup};
    int wOutChannel = output_channel - group_id * ${outputChannelsPerGroup};

    float value = ${valueInit};
    for (int inChannelOffset = 0; inChannelOffset < ${inputChannelsPerGroup}; inChannelOffset++) {
      int input_channel = group_id * ${inputChannelsPerGroup} + inChannelOffset;
      for (int wWOff = 0; wWOff < ${wShape[2]}; wWOff++) {
        for (int wHOff = 0; wHOff < ${wShape[3]}; wHOff++) {
          ivec2 wOff = ivec2(wWOff * ${attributes.dilations[0]}, wHOff * ${attributes.dilations[1]});
          ivec2 wLoc = loc - wOff;
          ivec2 wLocIn = wLoc / strides;
          if (
            wLocIn * strides == wLoc &&
            wLocIn.x >= 0 && wLocIn.x < ${xShape[2]} &&
            wLocIn.y >= 0 && wLocIn.y < ${xShape[3]}
          ) {
            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);
            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);
            value += xVal * wVal;
          }
        }
      }
    }
    ${applyActivation}
    ${glsl.output} = vec4(value, .0, .0, .0);
  }
`;
        return {
          ...metadata,
          output: { dims: outputShape, type: inputs[0].type, textureType: 0 /* unpacked */ },
          shaderSource,
          hasMain: true
        };
      };
      createUnpackedConvTransposeProgramInfoLoader = (inferenceHandler, inputs, attributes) => {
        const metadata = createConvTransposeProgramMetadata(inputs.length > 2, attributes.cacheKey);
        return {
          ...metadata,
          get: () => createUnpackedConvTransposeProgramInfo(inferenceHandler, inputs, metadata, attributes)
        };
      };
      convTranspose2DUnpacked = (inferenceHandler, inputs, attributes) => {
        const result = inferenceHandler.run(
          createUnpackedConvTransposeProgramInfoLoader(inferenceHandler, inputs, attributes),
          inputs
        );
        return result;
      };
      getAdjustedConvTransposeAttributes = (attributes, inputs) => {
        const kernelShape = attributes.kernelShape.slice();
        if (attributes.kernelShape.length === 0) {
          for (let i = 2; i < inputs[1].dims.length; ++i) {
            kernelShape.push(inputs[1].dims[i]);
          }
        }
        const pads = attributes.pads.slice();
        const outputShape = attributes.outputShape.slice();
        const inputShape = inputs[0].dims;
        calculateOutputShapeAndPads(
          inputShape,
          kernelShape,
          attributes.dilations,
          attributes.autoPad,
          pads,
          attributes.strides,
          attributes.outputPadding,
          outputShape
        );
        const newAttributes = Object.assign({}, attributes);
        Object.assign(newAttributes, { kernelShape, pads, outputShape, cacheKey: attributes.cacheKey });
        return newAttributes;
      };
      parseConvTransposeAttributes = (node) => {
        const attributes = node.attributes;
        const activationAttributes = parseInternalActivationAttributes(attributes);
        const autoPad = attributes.getString("auto_pad", "NOTSET");
        const dilations = attributes.getInts("dilations", [1, 1]);
        const group = attributes.getInt("group", 1);
        const kernelShape = attributes.getInts("kernel_shape", []);
        const outputPadding = attributes.getInts("output_padding", [0, 0]);
        const outputShape = attributes.getInts("output_shape", []);
        const pads = attributes.getInts("pads", [0, 0, 0, 0]);
        const strides = attributes.getInts("strides", [1, 1]);
        return createAttributeWithCacheKey({
          autoPad,
          dilations,
          group,
          kernelShape,
          outputPadding,
          outputShape,
          pads,
          strides,
          ...activationAttributes
        });
      };
      validateInputs6 = (inputs, attributes) => {
        if (!inputs || inputs.length !== 2 && inputs.length !== 3) {
          throw new Error("Conv requires 2 or 3 inputs");
        }
        if (inputs[0].dims.length !== 4 || inputs[1].dims.length !== 4) {
          throw new Error("currently only support 2-dimensional conv");
        }
        const dataChannel = inputs[0].dims[1];
        const filterInChannel = inputs[1].dims[0];
        if (dataChannel !== filterInChannel) {
          throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");
        }
        const featureMaps = inputs[1].dims[1] * attributes.group;
        if (inputs.length === 3 && (inputs[2].dims.length !== 1 || inputs[2].dims[0] !== featureMaps)) {
          throw new Error("invalid bias");
        }
        const spatialRank = inputs[0].dims.length - 2;
        if (attributes.dilations.length !== spatialRank) {
          throw new Error(`dilations should be ${spatialRank}D`);
        }
        if (attributes.strides.length !== spatialRank) {
          throw new Error(`strides should be ${spatialRank}D`);
        }
        if (attributes.pads.length !== spatialRank * 2) {
          throw new Error(`pads should be ${spatialRank * 2}D`);
        }
        if (attributes.outputPadding.length !== spatialRank) {
          throw new Error(`output_padding should be ${spatialRank}D`);
        }
        if (attributes.kernelShape.length !== 0 && attributes.kernelShape.length !== inputs[1].dims.length - 2) {
          throw new Error("invalid kernel shape");
        }
        if (attributes.outputShape.length !== 0 && attributes.outputShape.length !== inputs[0].dims.length - 2) {
          throw new Error("invalid output shape");
        }
        if (inputs[0].type !== "float32" || inputs[1].type !== "float32") {
          throw new Error("ConvTranspose input(X,W) should be float tensor");
        }
        if (inputs.length === 3 && inputs[2].type !== "float32") {
          throw new Error("ConvTranspose input(bias) should be float tensor");
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/transpose.ts
  var transposeProgramMetadata, transpose, parseTransposeAttributes, createTransposeProgramInfo, getAdjustedPerm, getOutputShape, getPermFunctionBody, validateInputs7;
  var init_transpose = __esm({
    "web/lib/onnxjs/backends/webgl/ops/transpose.ts"() {
      "use strict";
      init_attribute_with_cache_key();
      init_util();
      init_types();
      transposeProgramMetadata = {
        name: "Transpose",
        inputNames: ["A"],
        inputTypes: [0 /* unpacked */]
      };
      transpose = (inferenceHandler, inputs, attributes) => {
        validateInputs7(inputs);
        const output = inferenceHandler.run(
          {
            ...transposeProgramMetadata,
            cacheHint: attributes.cacheKey,
            get: () => createTransposeProgramInfo(inferenceHandler, inputs[0], attributes.perm)
          },
          inputs
        );
        return [output];
      };
      parseTransposeAttributes = (node) => createAttributeWithCacheKey({ perm: node.attributes.getInts("perm", []) });
      createTransposeProgramInfo = (_inferenceHandler, input, perm) => {
        const inputShape = input.dims;
        perm = getAdjustedPerm(inputShape, perm);
        const unpackedOutputShape = getOutputShape(inputShape, perm);
        const rank = inputShape.length;
        const shaderSource = `
      ${getPermFunctionBody("perm", perm, rank)}
      float process(int indices[${rank}]) {
        int a[${rank}];
        perm(a, indices);
        return _A(a);
      }`;
        return {
          ...transposeProgramMetadata,
          output: { dims: unpackedOutputShape, type: input.type, textureType: 0 /* unpacked */ },
          shaderSource
        };
      };
      getAdjustedPerm = (inputShape, perm) => {
        if (perm && perm.length !== inputShape.length) {
          perm = [...inputShape.keys()].reverse();
        }
        return perm;
      };
      getOutputShape = (inputShape, perm) => {
        perm = getAdjustedPerm(inputShape, perm);
        return ShapeUtil.sortBasedOnPerm(inputShape, perm);
      };
      getPermFunctionBody = (name2, perm, rank) => {
        const reverseFunc = [];
        reverseFunc.push(`void ${name2}(out int a[${rank}], int src[${rank}]) {`);
        for (let i = 0; i < rank; ++i) {
          reverseFunc.push(`	a[${perm[i]}]=src[${i}];`);
        }
        reverseFunc.push("	}");
        return reverseFunc.join("\n");
      };
      validateInputs7 = (inputs) => {
        if (!inputs || inputs.length !== 1) {
          throw new Error("Transpose requires 1 input.");
        }
        if (inputs[0].type !== "float32" && inputs[0].type !== "float64") {
          throw new Error("input should be float tensor");
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/depth-to-space.ts
  var depthToSpace, parseDepthToSpaceAttributes, validateInputs8;
  var init_depth_to_space = __esm({
    "web/lib/onnxjs/backends/webgl/ops/depth-to-space.ts"() {
      "use strict";
      init_transpose();
      depthToSpace = (inferenceHandler, inputs, attributes) => {
        validateInputs8(inputs);
        const blocksize = attributes.blocksize;
        const blocksizeSqr = blocksize * blocksize;
        const transposePerm = attributes.mode === "DCR" ? [0, 3, 4, 1, 5, 2] : [0, 1, 4, 2, 5, 3];
        const firstReshapeShape = attributes.mode === "DCR" ? [
          inputs[0].dims[0],
          blocksize,
          blocksize,
          inputs[0].dims[1] / blocksizeSqr,
          inputs[0].dims[2],
          inputs[0].dims[3]
        ] : [
          inputs[0].dims[0],
          inputs[0].dims[1] / blocksizeSqr,
          blocksize,
          blocksize,
          inputs[0].dims[2],
          inputs[0].dims[3]
        ];
        const firstReshapedTensor = inferenceHandler.reshapeUnpacked(inputs[0], firstReshapeShape);
        const transposeAttributes = { perm: transposePerm, cacheKey: `${transposePerm}` };
        const [transposeOutput] = transpose(inferenceHandler, [firstReshapedTensor], transposeAttributes);
        const secondReshapeShape = [
          inputs[0].dims[0],
          inputs[0].dims[1] / blocksizeSqr,
          inputs[0].dims[2] * blocksize,
          inputs[0].dims[3] * blocksize
        ];
        const result = inferenceHandler.reshapeUnpacked(transposeOutput, secondReshapeShape);
        return [result];
      };
      parseDepthToSpaceAttributes = (node) => {
        const blocksize = node.attributes.getInt("blocksize");
        if (blocksize < 1) {
          throw new Error(`blocksize must be >= 1, but got : ${blocksize} for DepthToSpace`);
        }
        const mode = node.attributes.getString("mode", "DCR");
        if (mode !== "DCR" && mode !== "CRD") {
          throw new Error(`unrecognized mode: ${mode} for DepthToSpace`);
        }
        return { mode, blocksize };
      };
      validateInputs8 = (inputs) => {
        if (inputs.length !== 1) {
          throw new Error(`DepthToSpace expect 1 inputs, but got ${inputs.length}`);
        }
        if (inputs[0].type === "string" || inputs[0].dims.length !== 4) {
          throw new TypeError("DepthToSpace input should be a 4-D numeric tensor");
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/flatten.ts
  var flatten, parseFlattenAttributes, validateInputs9;
  var init_flatten = __esm({
    "web/lib/onnxjs/backends/webgl/ops/flatten.ts"() {
      "use strict";
      init_util();
      flatten = (inferenceHandler, inputs, axis) => {
        validateInputs9(inputs, axis);
        const outputDims = ShapeUtil.flattenShape(inputs[0].dims, axis);
        return [inferenceHandler.reshapeUnpacked(inputs[0], outputDims)];
      };
      parseFlattenAttributes = (node) => node.attributes.getInt("axis", 1);
      validateInputs9 = (inputs, axis) => {
        if (!inputs || inputs.length !== 1) {
          throw new Error("Flatten requires 1 input.");
        }
        const r = inputs[0].dims.length;
        if (r === 0) {
          throw new Error("scalar tensor is not supported.");
        }
        if (axis < -r || axis > r) {
          throw new Error("Invalid axis");
        }
        if (inputs[0].type === "string") {
          throw new Error("string tensor is not supported.");
        }
      };
    }
  });

  // web/lib/onnxjs/operators.ts
  var NUMBER_TYPES;
  var init_operators = __esm({
    "web/lib/onnxjs/operators.ts"() {
      "use strict";
      NUMBER_TYPES = [
        "float32",
        "float64",
        "int32",
        "int16",
        "int8",
        "uint16",
        "uint32",
        "uint8"
      ];
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/gather.ts
  var gather, parseGatherAttributes, gatherProgramMetadata, createGatherProgramInfo, createGatherProgramInfoLoader, validateInputs10;
  var init_gather = __esm({
    "web/lib/onnxjs/backends/webgl/ops/gather.ts"() {
      "use strict";
      init_attribute_with_cache_key();
      init_operators();
      init_util();
      init_types();
      gather = (inferenceHandler, inputs, attributes) => {
        validateInputs10(inputs, attributes.axis);
        const output = inferenceHandler.run(createGatherProgramInfoLoader(inferenceHandler, inputs, attributes), inputs);
        return [output];
      };
      parseGatherAttributes = (node) => createAttributeWithCacheKey({ axis: node.attributes.getInt("axis", 0) });
      gatherProgramMetadata = {
        name: "Gather",
        inputNames: ["A", "B"],
        inputTypes: [0 /* unpacked */, 0 /* unpacked */]
      };
      createGatherProgramInfo = (_handler, metadata, inputs, axis) => {
        const inputShape = inputs[0].dims.slice();
        const indexDataShape = inputs[1].dims.slice();
        const outputShape = new Array(inputShape.length + indexDataShape.length - 1);
        axis = ShapeUtil.normalizeAxis(axis, inputShape.length);
        const indexCopyOps = [];
        for (let i = 0; i < outputShape.length; i++) {
          if (i < axis) {
            outputShape[i] = inputShape[i];
            indexCopyOps.push(`inputIdx[${i}] = outputIdx[${i}];`);
          } else {
            if (i < axis + indexDataShape.length) {
              outputShape[i] = indexDataShape[i - axis];
              indexCopyOps.push(`indexDataIdx[${i - axis}] = outputIdx[${i}];`);
            } else {
              outputShape[i] = inputShape[i - indexDataShape.length + 1];
              indexCopyOps.push(`inputIdx[${i - indexDataShape.length + 1}] = outputIdx[${i}];`);
            }
          }
        }
        const orank = outputShape.length || 1;
        const irank = inputShape.length;
        const iDrank = indexDataShape.length || 1;
        const shaderSource = `
      float process(int outputIdx[${orank}]) {
        int inputIdx[${irank}];
        int indexDataIdx[${iDrank}];
        indexDataIdx[0] = 0;
        ${indexCopyOps.join("\n        ")}
        int idx = int(_B(indexDataIdx));
        inputIdx[${axis}] = idx < 0 ? idx + ${inputShape[axis]} : idx;
        return _A(inputIdx);
      }`;
        return {
          ...metadata,
          output: { dims: outputShape, type: inputs[0].type, textureType: 0 /* unpacked */ },
          shaderSource
        };
      };
      createGatherProgramInfoLoader = (handler, inputs, attributes) => {
        const metadata = { ...gatherProgramMetadata, cacheHint: attributes.cacheKey };
        return { ...metadata, get: () => createGatherProgramInfo(handler, metadata, inputs, attributes.axis) };
      };
      validateInputs10 = (inputs, axis) => {
        if (!inputs || inputs.length !== 2) {
          throw new Error("Gather requires 2 inputs.");
        }
        const tensorRank = inputs[0].dims.length;
        if (tensorRank < 1) {
          throw new Error("Invalid input shape.");
        }
        if (axis < -tensorRank || axis > tensorRank - 1) {
          throw new Error("Invalid axis.");
        }
        if (NUMBER_TYPES.indexOf(inputs[0].type) === -1) {
          throw new Error("Invaid input type.");
        }
        if (inputs[1].type !== "int32" && inputs[1].type !== "int16") {
          throw new Error("Invaid input type.");
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/gemm.ts
  var gemm, parseGemmAttributes, parseGemmAttributesV7, parseGemmAttributesV11, createGemmProgramInfoLoader, createGemmProgramInfo, validateInputs11;
  var init_gemm = __esm({
    "web/lib/onnxjs/backends/webgl/ops/gemm.ts"() {
      "use strict";
      init_attribute_with_cache_key();
      init_util();
      init_types();
      gemm = (inferenceHandler, inputs, attributes) => {
        validateInputs11(inputs, attributes);
        const output = inferenceHandler.run(createGemmProgramInfoLoader(inputs, attributes), inputs);
        return [output];
      };
      parseGemmAttributes = (node, isOptionalC) => {
        const transA = node.attributes.getInt("transA", 0) !== 0;
        const transB = node.attributes.getInt("transB", 0) !== 0;
        const alpha = node.attributes.getFloat("alpha", 1);
        const beta = node.attributes.getFloat("beta", 1);
        return createAttributeWithCacheKey({ transA, transB, alpha, beta, isOptionalC });
      };
      parseGemmAttributesV7 = (node) => parseGemmAttributes(node, false);
      parseGemmAttributesV11 = (node) => parseGemmAttributes(node, true);
      createGemmProgramInfoLoader = (inputs, attributes) => {
        const metadata = {
          name: "Gemm",
          inputNames: inputs.length === 3 ? ["A", "B", "C"] : ["A", "B"],
          inputTypes: inputs.length === 3 ? [0 /* unpacked */, 0 /* unpacked */, 0 /* unpacked */] : [0 /* unpacked */, 0 /* unpacked */],
          key: attributes.cacheKey
        };
        return { ...metadata, get: () => createGemmProgramInfo(metadata, inputs, attributes) };
      };
      createGemmProgramInfo = (metadata, inputs, attributes) => {
        const aShape = inputs[0].dims.slice();
        const bShape = inputs[1].dims.slice();
        const [M, N] = GemmUtil.getShapeOfGemmResult(
          aShape,
          attributes.transA,
          bShape,
          attributes.transB,
          inputs.length === 3 ? inputs[2].dims : void 0
        );
        const outputShape = [M, N];
        if (!outputShape) {
          throw new Error("Can't use gemm on the given tensors");
        }
        let sharedDim = aShape[aShape.length - 1];
        let line = "";
        if (attributes.transA) {
          sharedDim = aShape[0];
        }
        if (attributes.transA && attributes.transB) {
          line = "value += _A_T(a) * _B_T(b);";
        } else if (attributes.transA && !attributes.transB) {
          line = "value += _A_T(a) * _B(b);";
        } else if (!attributes.transA && attributes.transB) {
          line = "value += _A(a) * _B_T(b);";
        } else if (!attributes.transA && !attributes.transB) {
          line = "value += _A(a) * _B(b);";
        }
        const rank = outputShape.length;
        const declareC = inputs.length === 3 ? `int c[${inputs[2].dims.length}];` : "";
        const broadcastC = inputs.length === 3 ? "bcastIndices_C(indices, c);" : "";
        const calculateC = inputs.length === 3 ? "value += beta * _C(c);" : "";
        const shaderSource = `
      float process(int indices[${rank}]) {
          int a[${rank}];
          int b[${rank}];
          ${declareC}

          copyVec(indices, a);
          copyVec(indices, b);
          ${broadcastC}

          float value = 0.0;
          for (int k=0; k<${sharedDim}; ++k) {
              a[${rank - 1}] = k;
              b[${rank - 2}] = k;
              ${line}
          }

          value = value * alpha;
          ${calculateC}
          return value;
      }`;
        return {
          ...metadata,
          output: { dims: outputShape, type: inputs[0].type, textureType: 0 /* unpacked */ },
          variables: [
            { name: "alpha", type: "float", data: attributes.alpha },
            { name: "beta", type: "float", data: attributes.beta }
          ],
          shaderSource
        };
      };
      validateInputs11 = (inputs, attributes) => {
        if (!inputs) {
          throw new Error("Input is missing");
        }
        if (attributes.isOptionalC && (inputs.length < 2 || inputs.length > 3)) {
          throw new Error("Invaid input shape.");
        }
        if (!attributes.isOptionalC && inputs.length !== 3) {
          throw new Error("Gemm requires 3 inputs");
        }
        if (inputs.length === 3 && inputs[2].dims.length !== 1 && inputs[2].dims.length !== 2) {
          throw new Error("Invalid input shape of C");
        }
        if (inputs[0].type !== "float32" && inputs[0].type !== "float64" || inputs[1].type !== "float32" && inputs[1].type !== "float64" || inputs.length === 3 && inputs[2].type !== "float32" && inputs[2].type !== "float64") {
          throw new Error("Invalid input type.");
        }
        if (inputs[0].type !== inputs[1].type || inputs.length === 3 && inputs[0].type !== inputs[2].type) {
          throw new Error("Input types are mismatched");
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/image-scaler.ts
  var imageScaler, parseImageScalerAttributes, imageScalerProgramMetadata, createImageScalerProgramInfo, createImageScalerProgramInfoLoader, createGetBiasMethod, validateInputs12;
  var init_image_scaler = __esm({
    "web/lib/onnxjs/backends/webgl/ops/image-scaler.ts"() {
      "use strict";
      init_attribute_with_cache_key();
      init_types();
      imageScaler = (inferenceHandler, inputs, attributes) => {
        validateInputs12(inputs);
        const output = inferenceHandler.run(createImageScalerProgramInfoLoader(inferenceHandler, inputs, attributes), inputs);
        return [output];
      };
      parseImageScalerAttributes = (node) => {
        const scale = node.attributes.getFloat("scale");
        const bias = node.attributes.getFloats("bias");
        return createAttributeWithCacheKey({ scale, bias });
      };
      imageScalerProgramMetadata = {
        name: "ImageScaler",
        inputNames: ["X"],
        inputTypes: [0 /* unpacked */]
      };
      createImageScalerProgramInfo = (_handler, metadata, inputs, attributes) => {
        const outputShape = inputs[0].dims.slice();
        const rank = outputShape.length;
        const getBiasMethod = createGetBiasMethod(attributes.bias.length);
        const shaderSource = `
      ${getBiasMethod}
      float process(int indices[${rank}]) {
        return _X(indices) * scale + getBias(bias, indices[1]);
      }`;
        return {
          ...metadata,
          output: { dims: outputShape, type: inputs[0].type, textureType: 0 /* unpacked */ },
          variables: [
            { name: "bias", type: "float", arrayLength: attributes.bias.length, data: attributes.bias },
            { name: "scale", type: "float", data: attributes.scale }
          ],
          shaderSource
        };
      };
      createImageScalerProgramInfoLoader = (handler, inputs, attributes) => {
        const metadata = { ...imageScalerProgramMetadata, cacheHint: attributes.cacheKey };
        return { ...metadata, get: () => createImageScalerProgramInfo(handler, metadata, inputs, attributes) };
      };
      createGetBiasMethod = (numChannels) => {
        const codeLines = [`float getBias(float bias[${numChannels}], int channel) {`];
        for (let i = 0; i < numChannels; ++i) {
          if (i === 0) {
            codeLines.push(`	if (channel == ${i}) { return bias[${i}]; }`);
          } else if (i === numChannels - 1) {
            codeLines.push(`	else { return bias[${i}]; }`);
          } else {
            codeLines.push(`	else if (channel == ${i}) { return bias[${i}]; }`);
          }
        }
        codeLines.push("	}");
        return codeLines.join("\n");
      };
      validateInputs12 = (inputs) => {
        if (!inputs || inputs.length !== 1) {
          throw new Error("ImageScaler requires 1 input.");
        }
        if (inputs[0].dims.length !== 4) {
          throw new Error("Invalid input shape.");
        }
        if (inputs[0].type !== "float32" && inputs[0].type !== "float64") {
          throw new Error("Invalid input type.");
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/instance-normalization.ts
  var instanceNormalization, parseInstanceNormalizationAttributes, meanAndVarianceProgramMetadata, createMeanAndVarianceProgramInfo, createMeanAndVarianceProgramInfoLoader, computeOutputProgramMetadata, createComputeOutputProgramInfo, createComputeOutputProgramInfoLoader, validateInputs13;
  var init_instance_normalization = __esm({
    "web/lib/onnxjs/backends/webgl/ops/instance-normalization.ts"() {
      "use strict";
      init_glsl_source();
      init_types();
      instanceNormalization = (inferenceHandler, inputs, epsilon) => {
        validateInputs13(inputs);
        const meanAndVariance = inferenceHandler.run(createMeanAndVarianceProgramInfoLoader(inputs[0]), inputs);
        const output = inferenceHandler.run(
          createComputeOutputProgramInfoLoader(inferenceHandler, inputs[0], epsilon, meanAndVariance.dims),
          [inputs[0], meanAndVariance, inputs[1], inputs[2]]
        );
        return [output];
      };
      parseInstanceNormalizationAttributes = (node) => node.attributes.getFloat("epsilon", 1e-5);
      meanAndVarianceProgramMetadata = {
        name: "InstanceNormalization_MeanAndVariance",
        inputNames: ["X"],
        inputTypes: [0 /* unpacked */]
      };
      createMeanAndVarianceProgramInfo = (metadata, input) => {
        const xDims = input.dims.slice();
        const channel = xDims[1];
        const channelSize = xDims[2] * xDims[3];
        const outputShape = [xDims[0], channel];
        const shaderSource = `
      vec4 process(int[2] indices) {
        vec4 v = vec4(0.0);
        int a[4];
        a[0] = indices[0];
        a[1] = indices[1];
        float temp = 0.0;
        for(int a2=0; a2<${xDims[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${xDims[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += x;
          }
        }
        float mean = temp / float(${channelSize});
        temp = 0.0;
        for(int a2=0; a2<${xDims[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${xDims[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += (x - mean) * (x - mean);
          }
        }
        v.r = mean;
        v.g = temp / float(${channelSize});

        return v;
      }`;
        return {
          ...metadata,
          output: { dims: outputShape, type: input.type, textureType: 4 /* packedLastDimension */ },
          shaderSource
        };
      };
      createMeanAndVarianceProgramInfoLoader = (input) => ({
        ...meanAndVarianceProgramMetadata,
        get: () => createMeanAndVarianceProgramInfo(meanAndVarianceProgramMetadata, input)
      });
      computeOutputProgramMetadata = {
        name: "InstanceNormalization_ComputeOutput",
        inputNames: ["X", "MeanAndVariance", "Scale", "B"],
        inputTypes: [0 /* unpacked */, 4 /* packedLastDimension */, 0 /* unpacked */, 0 /* unpacked */]
      };
      createComputeOutputProgramInfo = (inferenceHandler, metadata, input, epsilon, meanAndVarianceShape) => {
        const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);
        const [textureWidth, textureHeight] = inferenceHandler.calculateTextureWidthAndHeight(
          meanAndVarianceShape,
          4 /* packedLastDimension */
        );
        const [meanAndVarianceWidth, meanAndVarianceHeight] = [textureWidth / 4, textureHeight];
        const shaderSource = `
      vec4 get_MeanAndVariance(int[2] mv) {
        int offset = indicesToOffset_MeanAndVariance(mv);
        vec2 coords = offsetToCoords(offset, ${meanAndVarianceWidth}, ${meanAndVarianceHeight});
        return ${glsl.texture2D}(MeanAndVariance, coords);
      }

      float process(int[4] indices) {
        int mv[2];
        mv[0] = indices[0];
        mv[1] = indices[1];
        vec4 mean_and_variance = get_MeanAndVariance(mv);
        float mean = mean_and_variance.r;
        float variance = mean_and_variance.g;

        int sb[1];
        sb[0] = indices[1];
        float scale = _Scale(sb);
        float b = _B(sb);

        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;
      }`;
        return {
          ...metadata,
          output: { dims: input.dims, type: input.type, textureType: 0 /* unpacked */ },
          variables: [{ name: "epsilon", type: "float", data: epsilon }],
          shaderSource
        };
      };
      createComputeOutputProgramInfoLoader = (inferenceHandler, input, epsilon, meanAndVarianceShape) => {
        const metadata = { ...computeOutputProgramMetadata, cacheHint: `${epsilon}` };
        return {
          ...metadata,
          get: () => createComputeOutputProgramInfo(inferenceHandler, metadata, input, epsilon, meanAndVarianceShape)
        };
      };
      validateInputs13 = (inputs) => {
        if (!inputs || inputs.length !== 3) {
          throw new Error("InstanceNormalization requires 3 inputs.");
        }
        const X = inputs[0];
        const scale = inputs[1];
        const B = inputs[2];
        if (X.dims.length < 3 || scale.dims.length !== 1 || B.dims.length !== 1) {
          throw new Error("Invalid input shape.");
        }
        if (scale.dims[0] !== X.dims[1] || B.dims[0] !== X.dims[1]) {
          throw new Error("Input shapes are mismatched.");
        }
        if (X.type !== "float32" && X.type !== "float64" || scale.type !== "float32" && scale.type !== "float64" || B.type !== "float32" && B.type !== "float64") {
          throw new Error("Invalid input type.");
        }
        if (inputs[0].dims.length !== 4) {
          throw new Error("Only support 4-D input shape.");
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/lrn.ts
  function createLrnProgramInfo(inputs, attributes) {
    const C = inputs[0].dims[1];
    const rank = inputs[0].dims.length;
    const from = -Math.floor((attributes.size - 1) / 2);
    const to = Math.ceil((attributes.size - 1) / 2);
    const alpha = `float(${attributes.alpha}) / float(${attributes.size})`;
    const bias = `float(${attributes.bias})`;
    const beta = `float(${attributes.beta})`;
    const shaderSource = `
    float process(int indices[${rank}]) {
        int c = indices[1];
        float x = _X(indices);
        float square_sum = 0.0;

        for (int i = ${from}; i <= ${to}; i++) {
          int idx = c + i;
          if (c >= 0 && c < ${C}) {
            indices[1] = idx;
            float j = _X(indices);
            square_sum += j * j;
          }
        }
        return x / pow(${bias} + ${alpha} * square_sum, ${beta});
    }`;
    return {
      ...lrnProgramMetadata,
      cacheHint: attributes.cacheKey,
      output: { dims: inputs[0].dims, type: inputs[0].type, textureType: 0 /* unpacked */ },
      shaderSource
    };
  }
  function createLrnProgramInfoLoader(inputs, attributes) {
    return { ...lrnProgramMetadata, cacheHint: attributes.cacheKey, get: () => createLrnProgramInfo(inputs, attributes) };
  }
  var lrn, parseLrnAttributes, lrnProgramMetadata, validateInputs14;
  var init_lrn = __esm({
    "web/lib/onnxjs/backends/webgl/ops/lrn.ts"() {
      "use strict";
      init_attribute_with_cache_key();
      init_types();
      lrn = (inferenceHandler, inputs, attributes) => {
        validateInputs14(inputs);
        return [inferenceHandler.run(createLrnProgramInfoLoader(inputs, attributes), inputs)];
      };
      parseLrnAttributes = (node) => {
        const alpha = node.attributes.getFloat("alpha", 1e-4);
        const beta = node.attributes.getFloat("beta", 0.75);
        const bias = node.attributes.getFloat("bias", 1);
        const size = node.attributes.getInt("size");
        return createAttributeWithCacheKey({ alpha, beta, bias, size });
      };
      lrnProgramMetadata = {
        name: "LRN",
        inputNames: ["X"],
        inputTypes: [0 /* unpacked */]
      };
      validateInputs14 = (inputs) => {
        if (!inputs || inputs.length !== 1) {
          throw new Error("LRN requires 1 input.");
        }
        if (inputs[0].dims.length !== 4) {
          throw new Error('currently only support LRN for input with "NCHW" format');
        }
        if (inputs[0].type !== "float32") {
          throw new Error("input should be float type");
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/pad.ts
  var padProgramMetadata, padV2, parsePadAttributesV2, padV11, parsePadAttributesV11, generatePadAttributesFromInputs, createPadProgramInfo, validateInputsV2, validateInputsV11, getPadFunction, getPadConstant, getPadReflect, getPadEdge;
  var init_pad = __esm({
    "web/lib/onnxjs/backends/webgl/ops/pad.ts"() {
      "use strict";
      init_attribute_with_cache_key();
      init_util();
      init_glsl_source();
      init_types();
      padProgramMetadata = {
        name: "Pad",
        inputNames: ["A"],
        inputTypes: [0 /* unpacked */]
      };
      padV2 = (inferenceHandler, inputs, attributes) => {
        validateInputsV2(inputs);
        const output = inferenceHandler.run(
          {
            ...padProgramMetadata,
            cacheHint: attributes.cacheKey,
            get: () => createPadProgramInfo(inferenceHandler, inputs[0], attributes)
          },
          inputs
        );
        return [output];
      };
      parsePadAttributesV2 = (node) => {
        const mode = node.attributes.getString("mode", "constant");
        const value = node.attributes.getFloat("value", 0);
        const pads = node.attributes.getInts("pads");
        return createAttributeWithCacheKey({ mode, value, pads });
      };
      padV11 = (inferenceHandler, inputs, mode) => {
        validateInputsV11(inputs);
        const attrubutes = generatePadAttributesFromInputs(inferenceHandler, inputs, mode);
        return padV2(inferenceHandler, [inputs[0]], attrubutes);
      };
      parsePadAttributesV11 = (node) => node.attributes.getString("mode", "constant");
      generatePadAttributesFromInputs = (inferenceHandler, inputs, mode) => {
        if (!inferenceHandler.session.isInitializer(inputs[1].dataId) || inputs.length >= 3 && !inferenceHandler.session.isInitializer(inputs[2].dataId)) {
          throw new Error("dynamic pad attributes are not allowed");
        }
        const pads = Array.from(inputs[1].integerData);
        const value = inputs.length >= 3 ? inputs[2].floatData[0] : 0;
        return createAttributeWithCacheKey({ mode, pads, value });
      };
      createPadProgramInfo = (inferenceHandler, input, attributes) => {
        const outputShape = ShapeUtil.padShape(input.dims.slice(), attributes.pads);
        const rank = outputShape.length;
        const padFunction = getPadFunction(inferenceHandler, input, attributes);
        const shaderSource = `
      ${padFunction}
      float process(int[${rank}] indices) {
          return padA(indices);
      }`;
        return {
          name: "Pad",
          inputNames: ["A"],
          inputTypes: [0 /* unpacked */],
          output: { dims: outputShape, type: input.type, textureType: 0 /* unpacked */ },
          shaderSource
        };
      };
      validateInputsV2 = (inputs) => {
        if (!inputs || inputs.length !== 1) {
          throw new Error("Pad requires 1 input");
        }
        if (inputs[0].type !== "float32" && inputs[0].type !== "float64") {
          throw new Error("Invalid input type.");
        }
      };
      validateInputsV11 = (inputs) => {
        if (!inputs || inputs.length !== 2 && inputs.length !== 3) {
          throw new Error("Pad requires 2 or 3 inputs");
        }
        if (inputs[1].type !== "int32") {
          throw new Error("Invalid input type.");
        }
        if (inputs.length >= 3 && inputs[2].type === "string") {
          throw new Error("Invalid input type.");
        }
      };
      getPadFunction = (inferenceHandler, input, attributes) => {
        const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);
        const [width, height] = inferenceHandler.calculateTextureWidthAndHeight(input.dims, 0 /* unpacked */);
        const strides = ShapeUtil.computeStrides(input.dims);
        switch (attributes.mode) {
          case "constant":
            return getPadConstant(glsl, input.dims, strides, width, height, attributes.pads, attributes.value);
          case "reflect":
            return getPadReflect(glsl, input.dims, strides, width, height, attributes.pads);
          case "edge":
            return getPadEdge(glsl, input.dims, strides, width, height, attributes.pads);
          default:
            throw new Error("Invalid mode");
        }
      };
      getPadConstant = (glsl, shape2, strides, width, height, pads, value) => {
        const rank = shape2.length;
        let block = "";
        for (let i = rank - 1; i >= 0; --i) {
          block += `
        k = m[${i}] - ${pads[i]};
        if (k < 0)  return constant;
        if (k >= ${shape2[i]}) return constant;
        offset += k * ${strides[i]};
        `;
        }
        return `
      float padA(int m[${rank}]) {
        const float constant = float(${value});
        int offset = 0;
        int k = 0;
        ${block}
        vec2 coords = offsetToCoords(offset, ${width}, ${height});
        float value = getColorAsFloat(${glsl.texture2D}(A, coords));
        return value;
      }
      `;
      };
      getPadReflect = (glsl, shape2, strides, width, height, pads) => {
        const rank = shape2.length;
        let block = "";
        for (let i = rank - 1; i >= 0; --i) {
          block += `
        k = m[${i}] - ${pads[i]};
        if (k < 0) { k = -k; }
        {
          const int _2n_1 = ${2 * (shape2[i] - 1)};
          k = int( mod( float(k), float(_2n_1) ) ) ;
          if(k >= ${shape2[i]}) { k = _2n_1 - k; }
        }
        offset += k * ${strides[i]};
        `;
        }
        return `
      float padA(int m[${rank}]) {
        int offset = 0;
        int k = 0;
        ${block}
        vec2 coords = offsetToCoords(offset, ${width}, ${height});
        float value = getColorAsFloat(${glsl.texture2D}(A, coords));
        return value;
      }
      `;
      };
      getPadEdge = (glsl, shape2, strides, width, height, pads) => {
        const rank = shape2.length;
        let block = "";
        for (let i = rank - 1; i >= 0; --i) {
          block += `
        k = m[${i}] - ${pads[i]};
        if (k < 0)  k = 0;
        if (k >= ${shape2[i]}) k = ${shape2[i] - 1};
        offset += k * ${strides[i]};
      `;
        }
        return `
      float padA(int m[${rank}]) {
        int offset = 0;
        int k = 0;
        ${block}
        vec2 coords = offsetToCoords(offset, ${width}, ${height});
        float value = getColorAsFloat(${glsl.texture2D}(A, coords));
        return value;
      }
      `;
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/pool.ts
  var averagePool, parseAveragePoolAttributes, createAveragePoolProgramInfo, globalAveragePool, parseGlobalAveragePoolAttributes, maxPool, parseMaxPoolAttributes, createMaxPoolProgramInfo, getAdjustedPoolAttributesAndOutputShape, globalMaxPoolAttributes, globalMaxPoolMetadata, globalMaxPool, validateInputs15, generatePoolingCode, copyArray, offsetToIndices;
  var init_pool = __esm({
    "web/lib/onnxjs/backends/webgl/ops/pool.ts"() {
      "use strict";
      init_attribute_with_cache_key();
      init_util();
      init_types();
      averagePool = (inferenceHandler, inputs, attributes) => {
        validateInputs15(inputs);
        const metadata = {
          name: "AveragePool",
          inputNames: ["X"],
          inputTypes: [0 /* unpacked */],
          cacheHint: attributes.cacheKey
        };
        const output = inferenceHandler.run(
          { ...metadata, get: () => createAveragePoolProgramInfo(inputs, metadata, false, attributes) },
          inputs
        );
        return [output];
      };
      parseAveragePoolAttributes = (node) => {
        const autoPad = node.attributes.getString("auto_pad", "NOTSET");
        const ceilMode = node.attributes.getInt("ceil_mode", 0);
        const countIncludePad = node.attributes.getInt("count_include_pad", 0) === 0 ? false : true;
        const kernelShape = node.attributes.getInts("kernel_shape");
        const strides = node.attributes.getInts("strides", []);
        const pads = node.attributes.getInts("pads", []);
        if (ceilMode !== 0) {
          throw new Error("using ceil() in shape computation is not yet supported for AveragePool");
        }
        return createAttributeWithCacheKey({ autoPad, ceilMode, countIncludePad, kernelShape, strides, pads });
      };
      createAveragePoolProgramInfo = (inputs, metadata, isGlobalOperator, attributes) => {
        const [adjustedAttributes, outputShape] = getAdjustedPoolAttributesAndOutputShape(
          inputs,
          attributes,
          isGlobalOperator
        );
        const kernelSize = ShapeUtil.size(adjustedAttributes.kernelShape);
        const op1 = "value += _X(x);";
        let op2 = "";
        if (adjustedAttributes.countIncludePad) {
          op2 += `value /= float(${kernelSize});`;
        } else {
          op2 += `value /= float(${kernelSize} - pad);`;
        }
        const poolingCode = generatePoolingCode(inputs[0].dims, adjustedAttributes, op1, op2, "0.0");
        const shaderSource = `
        ${poolingCode}
      `;
        return {
          ...metadata,
          output: { dims: outputShape, type: inputs[0].type, textureType: 0 /* unpacked */ },
          shaderSource
        };
      };
      globalAveragePool = (inferenceHandler, inputs, attributes) => {
        validateInputs15(inputs);
        const metadata = {
          name: "GlobalAveragePool",
          inputNames: ["X"],
          inputTypes: [0 /* unpacked */],
          cacheHint: `${attributes.countIncludePad}`
        };
        const output = inferenceHandler.run(
          { ...metadata, get: () => createAveragePoolProgramInfo(inputs, metadata, true, attributes) },
          inputs
        );
        return [output];
      };
      parseGlobalAveragePoolAttributes = (node) => {
        const countIncludePad = node.attributes.getInt("count_include_pad", 0) === 0 ? false : true;
        return createAttributeWithCacheKey({
          autoPad: "",
          ceilMode: 0,
          countIncludePad,
          kernelShape: [],
          strides: [],
          pads: []
        });
      };
      maxPool = (inferenceHandler, inputs, attributes) => {
        validateInputs15(inputs);
        const metadata = {
          name: "MaxPool",
          inputNames: ["X"],
          inputTypes: [0 /* unpacked */],
          cacheHint: attributes.cacheKey
        };
        const output = inferenceHandler.run(
          { ...metadata, get: () => createMaxPoolProgramInfo(inputs, metadata, false, attributes) },
          inputs
        );
        return [output];
      };
      parseMaxPoolAttributes = (node) => {
        const autoPad = node.attributes.getString("auto_pad", "NOTSET");
        const ceilMode = node.attributes.getInt("ceil_mode", 0);
        const kernelShape = node.attributes.getInts("kernel_shape");
        const strides = node.attributes.getInts("strides", []);
        const pads = node.attributes.getInts("pads", []);
        const storageOrder = node.attributes.getInt("storage_order", 0);
        const dilations = node.attributes.getInts("dilations", []);
        if (storageOrder !== 0) {
          throw new Error("column major storage order is not yet supported for MaxPool");
        }
        if (ceilMode !== 0) {
          throw new Error("using ceil() in shape computation is not yet supported for MaxPool");
        }
        return createAttributeWithCacheKey({
          autoPad,
          ceilMode,
          countIncludePad: false,
          kernelShape,
          strides,
          pads,
          storageOrder,
          dilations
        });
      };
      createMaxPoolProgramInfo = (inputs, metadata, isGlobalOperator, attributes) => {
        const [adjustedAttributes, outputShape] = getAdjustedPoolAttributesAndOutputShape(
          inputs,
          attributes,
          isGlobalOperator
        );
        const op1 = `
      value = max(_X(x), value);
    `;
        const op2 = "";
        const poolingCode = generatePoolingCode(inputs[0].dims, adjustedAttributes, op1, op2, "-1e5");
        const shaderSource = `
      ${poolingCode}
    `;
        return {
          ...metadata,
          output: { dims: outputShape, type: inputs[0].type, textureType: 0 /* unpacked */ },
          shaderSource
        };
      };
      getAdjustedPoolAttributesAndOutputShape = (inputs, attributes, isGlobalOperator) => {
        const inputShape = inputs[0].dims.slice();
        const hasDilations = Object.hasOwnProperty.call(attributes, "dilations");
        const kernelShape = attributes.kernelShape.slice();
        const strides = attributes.strides.slice();
        const dilations = hasDilations ? attributes.dilations.slice() : [];
        const pads = attributes.pads.slice();
        PoolConvUtil.adjustPoolAttributes(isGlobalOperator, inputShape, kernelShape, strides, dilations, pads);
        const outputShape = PoolConvUtil.computePoolOutputShape(
          isGlobalOperator,
          inputShape,
          strides,
          dilations,
          kernelShape,
          pads,
          attributes.autoPad
        );
        const newAttributes = Object.assign({}, attributes);
        if (hasDilations) {
          Object.assign(newAttributes, { kernelShape, strides, pads, dilations, cacheKey: attributes.cacheKey });
        } else {
          Object.assign(newAttributes, { kernelShape, strides, pads, cacheKey: attributes.cacheKey });
        }
        return [newAttributes, outputShape];
      };
      globalMaxPoolAttributes = {
        autoPad: "",
        ceilMode: 0,
        countIncludePad: false,
        kernelShape: [],
        strides: [],
        pads: [],
        storageOrder: 0,
        dilations: [],
        cacheKey: ""
      };
      globalMaxPoolMetadata = {
        name: "GlobalMaxPool",
        inputNames: ["X"],
        inputTypes: [0 /* unpacked */]
      };
      globalMaxPool = (inferenceHandler, inputs) => {
        validateInputs15(inputs);
        const output = inferenceHandler.run(
          {
            ...globalMaxPoolMetadata,
            get: () => createMaxPoolProgramInfo(inputs, globalMaxPoolMetadata, true, globalMaxPoolAttributes)
          },
          inputs
        );
        return [output];
      };
      validateInputs15 = (inputs) => {
        if (!inputs || inputs.length !== 1) {
          throw new Error("Pool ops requires 1 input.");
        }
        if (inputs[0].type !== "float32" && inputs[0].type !== "float64") {
          throw new Error("Invalid input type.");
        }
      };
      generatePoolingCode = (inputDims, attributes, op1, op2, start) => {
        const rank = inputDims.length;
        if (attributes.kernelShape.length <= 2) {
          const kw = attributes.kernelShape[attributes.kernelShape.length - 1];
          const sw = attributes.strides[attributes.strides.length - 1];
          const pwStart = attributes.pads[attributes.pads.length / 2 - 1];
          const pwEnd = attributes.pads[attributes.pads.length - 1];
          const dimW = inputDims[rank - 1];
          let codeW = "";
          let codeH = "";
          let codeHEnd = "";
          if (pwStart + pwEnd !== 0) {
            codeW = `
          for (int i = 0; i < ${kw}; i++) {
            x[${rank} - 1] = indices[${rank} - 1] * ${sw} - ${pwStart} + i;
            if (x[${rank} - 1] < 0 || x[${rank} - 1] >= ${dimW}) {
              pad++;
              continue;
            }
            ${op1}
          }`;
          } else {
            codeW = `
          for (int i = 0; i < ${kw}; i++) {
            x[${rank} - 1] = indices[${rank} - 1] * ${sw} - ${pwStart} + i;
            ${op1}
          }`;
          }
          if (attributes.kernelShape.length === 2) {
            const kh = attributes.kernelShape[attributes.kernelShape.length - 2];
            const sh = attributes.strides[attributes.strides.length - 2];
            const phStart = attributes.pads[attributes.pads.length / 2 - 2];
            const phEnd = attributes.pads[attributes.pads.length - 2];
            const dimH = inputDims[rank - 2];
            if (phStart + phEnd !== 0) {
              codeH = `
            for (int j = 0; j < ${kh}; j++) {
              x[${rank} - 2] = indices[${rank} - 2] * ${sh} - ${phStart} + j;
              if (x[${rank} - 2] < 0 || x[${rank} - 2] >= ${dimH}) {
                pad+= ${kw};
                continue;
              }
          `;
            } else {
              codeH = `
            for (int j = 0; j < ${kh}; j++) {
              x[${rank} - 2] = indices[${rank} - 2] * ${sh} - ${phStart} + j;
            `;
            }
            codeHEnd = `
          }
        `;
          }
          const poolingCode = `
        float process(int indices[${rank}]) {
          int x[${rank}];
          copyVec(indices, x);

          float value = ${start};
          int pad = 0;
          ${codeH}
          ${codeW}
          ${codeHEnd}
          ${op2}
          return value;
        }
      `;
          return poolingCode;
        } else {
          const kernelSize = ShapeUtil.size(attributes.kernelShape);
          const kernelStrides = ShapeUtil.computeStrides(attributes.kernelShape);
          const stridesRank = kernelStrides.length;
          const padsRank = attributes.pads.length;
          const offsetToIndicesFunction = offsetToIndices(stridesRank);
          const copyInputDims = copyArray(inputDims, "inputDims");
          const copyPads = copyArray(attributes.pads, "pads");
          const copyKernelStrides = copyArray(kernelStrides, "kernelStrides");
          const copyStrides = copyArray(attributes.strides, "strides");
          const hasPads = attributes.pads.reduce((sum2, cur) => sum2 + cur);
          let padCode = "";
          if (hasPads) {
            padCode = `
            if (x[j] >= inputDims[j] || x[j] < 0) {
              pad++;
              isPad = true;
              break;
            }
          }
          if (!isPad) {
            ${op1}
          }`;
          } else {
            padCode = `
          }
          ${op1}
        `;
          }
          const poolingCode = `
        ${offsetToIndicesFunction}
        float process(int indices[${rank}]) {
          int x[${rank}];
          copyVec(indices, x);
          int offset[${stridesRank}];
          int pads[${padsRank}];
          int inputDims[${rank}];
          int kernelStrides[${stridesRank}];
          int strides[${stridesRank}];
          ${copyPads}
          ${copyInputDims}
          ${copyStrides}
          ${copyKernelStrides}

          float value = ${start};
          int pad = 0;
          bool isPad = false;
          for (int i = 0; i < ${kernelSize}; i++) {
            offsetToIndices(i, kernelStrides, offset);
            isPad = false;
            for (int j = ${rank} - ${stridesRank}; j < ${rank}; j++) {
              x[j] = indices[j] * strides[j - ${rank} + ${stridesRank}]
                + offset[j - ${rank} + ${stridesRank}] - pads[j - 2];
              ${padCode}
          }
          ${op2}

          return value;
        }
      `;
          return poolingCode;
        }
      };
      copyArray = (array, arrayName) => {
        let block = "";
        for (let i = 0; i < array.length; i++) {
          block += `
      ${arrayName}[${i}] = ${array[i]};
    `;
        }
        return block;
      };
      offsetToIndices = (rank) => `
  void offsetToIndices(int offset, int[${rank}] strides, out int[${rank}] indices) {
    if (${rank} == 0) {
      return;
    }
    for (int i = 0; i < ${rank} - 1; ++i) {
      indices[i] = offset / strides[i];
      offset -= indices[i] * strides[i];
    }
    indices[${rank} - 1] = offset;
  }`;
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/reduce.ts
  var reduce, parseReduceAttributes, createReduceProgramInfo, validateInputs16, reduceSum, reduceMean, reduceMax, reduceMin, reduceProd, reduceLogSum, reduceLogSumSquare;
  var init_reduce = __esm({
    "web/lib/onnxjs/backends/webgl/ops/reduce.ts"() {
      "use strict";
      init_attribute_with_cache_key();
      init_operators();
      init_util();
      init_types();
      reduce = (inferenceHandler, inputs, attributes, name2, reduceOp) => {
        validateInputs16(inputs);
        const reduceProgramMetadata = {
          name: name2,
          inputNames: ["A"],
          inputTypes: [0 /* unpacked */]
        };
        const output = inferenceHandler.run(
          {
            ...reduceProgramMetadata,
            cacheHint: attributes.cacheKey,
            get: () => createReduceProgramInfo(inferenceHandler, inputs, attributes, name2, reduceOp, reduceProgramMetadata)
          },
          inputs
        );
        return [output];
      };
      parseReduceAttributes = (node) => {
        const axes = node.attributes.getInts("axes", []);
        const keepDims = node.attributes.getInt("keepdims", 1) === 1;
        return createAttributeWithCacheKey({ axes, keepDims });
      };
      createReduceProgramInfo = (_handler, inputs, attributes, _name, reduceOp, reduceProgramMetadata) => {
        const outputShape = [];
        const iRank = inputs[0].dims.length || 1;
        const idxCopy = [];
        const axes = ShapeUtil.normalizeAxes(attributes.axes, inputs[0].dims.length);
        const ops = reduceOp(inputs, axes);
        let reduceOps = ops[1];
        for (let k = 0; k < inputs[0].dims.length; k++) {
          if (axes.indexOf(k) >= 0 || axes.length === 0) {
            if (attributes.keepDims) {
              outputShape.push(1);
            }
            reduceOps = `
          for(int j${k} = 0; j${k} < ${inputs[0].dims[k]}; j${k}++) {
            inputIdx[${k}] = j${k};
            ${reduceOps}
          }`;
          } else {
            idxCopy.push(`inputIdx[${k}] = outputIdx[${outputShape.length}];`);
            outputShape.push(inputs[0].dims[k]);
          }
        }
        const oRank = outputShape.length || 1;
        const shaderSource = `
      float process(int outputIdx[${oRank}]) {
        float value;                 // final result
        int inputIdx[${iRank}];      // addressing input data
        ${idxCopy.join("\n")}
        ${ops[0]}       // init ops for reduce max/min
        ${reduceOps}
        ${ops[2]}       // final computation for reduce mean
        return value;
      }`;
        return {
          ...reduceProgramMetadata,
          output: { dims: outputShape, type: inputs[0].type, textureType: 0 /* unpacked */ },
          shaderSource
        };
      };
      validateInputs16 = (inputs) => {
        if (!inputs || inputs.length !== 1) {
          throw new Error("Reduce op requires 1 input.");
        }
        if (NUMBER_TYPES.indexOf(inputs[0].type) === -1) {
          throw new Error("Invalid input type.");
        }
      };
      reduceSum = (inferenceHandler, inputs, attributes) => {
        const reduceOp = () => ["value = 0.0;", "value += _A(inputIdx);", ""];
        return reduce(inferenceHandler, inputs, attributes, "ReduceSum", reduceOp);
      };
      reduceMean = (inferenceHandler, inputs, attributes) => {
        const reduceOp = (inputs2, axes) => {
          let size = 1;
          for (let k = 0; k < inputs2[0].dims.length; k++) {
            if (axes.indexOf(k) >= 0 || axes.length === 0) {
              size *= inputs2[0].dims[k];
            }
          }
          return ["value = 0.0;", "value += _A(inputIdx);", `value /= ${size}.;`];
        };
        return reduce(inferenceHandler, inputs, attributes, "ReduceMean", reduceOp);
      };
      reduceMax = (inferenceHandler, inputs, attributes) => {
        const reduceOp = (inputs2, axes) => {
          const idxZero = [];
          for (let k = 0; k < inputs2[0].dims.length; k++) {
            if (axes.indexOf(k) >= 0 || axes.length === 0) {
              idxZero.push(`inputIdx[${k}] = 0;`);
            }
          }
          return [`${idxZero.join("\n")}
value = _A(inputIdx);`, "value = max(value, _A(inputIdx));", ""];
        };
        return reduce(inferenceHandler, inputs, attributes, "ReduceMax", reduceOp);
      };
      reduceMin = (inferenceHandler, inputs, attributes) => {
        const reduceOp = (inputs2, axes) => {
          const idxZero = [];
          for (let k = 0; k < inputs2[0].dims.length; k++) {
            if (axes.indexOf(k) >= 0 || axes.length === 0) {
              idxZero.push(`inputIdx[${k}] = 0;`);
            }
          }
          return [`${idxZero.join("\n")}
value = _A(inputIdx);`, "value = min(value, _A(inputIdx));", ""];
        };
        return reduce(inferenceHandler, inputs, attributes, "ReduceMin", reduceOp);
      };
      reduceProd = (inferenceHandler, inputs, attributes) => {
        const reduceOp = () => ["value = 1.0;", "value *= _A(inputIdx);", ""];
        return reduce(inferenceHandler, inputs, attributes, "ReduceProd", reduceOp);
      };
      reduceLogSum = (inferenceHandler, inputs, attributes) => {
        const reduceOp = () => ["value = 0.0;", "value += _A(inputIdx);", "value = log(value);"];
        return reduce(inferenceHandler, inputs, attributes, "ReduceLogSum", reduceOp);
      };
      reduceLogSumSquare = (inferenceHandler, inputs, attributes) => {
        const reduceOp = () => ["float t; value = 0.0;", "t = _A(inputIdx); value += t * t;", ""];
        return reduce(inferenceHandler, inputs, attributes, "ReduceLogSumSquare", reduceOp);
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/reshape.ts
  var reshape;
  var init_reshape = __esm({
    "web/lib/onnxjs/backends/webgl/ops/reshape.ts"() {
      "use strict";
      init_util();
      reshape = (handler, inputs) => {
        const reshapedDims = ShapeUtil.calculateReshapedDims(inputs[0].dims, inputs[1].integerData);
        if (handler.session.pack) {
          return [handler.reshapePacked(inputs[0], reshapedDims)];
        } else {
          return [handler.reshapeUnpacked(inputs[0], reshapedDims)];
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/upsample.ts
  var upsampleProgramMetadata, upsample, parseUpsampleAttributesV7, parseUpsampleAttributesV9, parseUpsampleAttributes, createUpsampleProgramInfo, validateInputs17, scalesValidation;
  var init_upsample = __esm({
    "web/lib/onnxjs/backends/webgl/ops/upsample.ts"() {
      "use strict";
      init_attribute_with_cache_key();
      init_glsl_source();
      init_types();
      upsampleProgramMetadata = {
        name: "Upsample",
        inputNames: ["X"],
        inputTypes: [0 /* unpacked */]
      };
      upsample = (inferenceHandler, inputs, attributes) => {
        validateInputs17(inputs, attributes);
        const output = inferenceHandler.run(
          {
            ...upsampleProgramMetadata,
            cacheHint: attributes.cacheKey,
            get: () => createUpsampleProgramInfo(inferenceHandler, inputs, attributes)
          },
          inputs
        );
        return [output];
      };
      parseUpsampleAttributesV7 = (node) => parseUpsampleAttributes(node, 7);
      parseUpsampleAttributesV9 = (node) => parseUpsampleAttributes(node, 9);
      parseUpsampleAttributes = (node, opset) => {
        const isResize = opset >= 10;
        const mode = node.attributes.getString("mode", "nearest");
        if (mode !== "nearest" && mode !== "linear" && (opset < 11 || mode !== "cubic")) {
          throw new Error(`unrecognized mode: ${mode}`);
        }
        let scales = [];
        if (opset < 9) {
          scales = node.attributes.getFloats("scales");
          scalesValidation(scales, mode, isResize);
        }
        const extrapolationValue = node.attributes.getFloat("extrapolation_value", 0);
        const coordinateTransformMode = opset > 10 ? node.attributes.getString("coordinate_transformation_mode", "half_pixel") : "asymmetric";
        if ([
          "asymmetric",
          "pytorch_half_pixel",
          "tf_half_pixel_for_nn",
          "align_corners",
          "tf_crop_and_resize",
          "half_pixel"
        ].indexOf(coordinateTransformMode) === -1) {
          throw new Error(`coordinate_transform_mode '${coordinateTransformMode}' is not supported`);
        }
        const needRoiInput = coordinateTransformMode === "tf_crop_and_resize";
        const useExtrapolation = needRoiInput;
        const nearestMode = mode === "nearest" && opset >= 11 ? node.attributes.getString("nearest_mode", "round_prefer_floor") : "";
        if (["round_prefer_floor", "round_prefer_ceil", "floor", "ceil", ""].indexOf(nearestMode) === -1) {
          throw new Error(`nearest_mode '${nearestMode}' is not supported`);
        }
        const cubicCoefficientA = node.attributes.getFloat("cubic_coeff_a", -0.75);
        const excludeOutside = node.attributes.getInt("exclude_outside", 0) !== 0;
        if (excludeOutside && mode !== "cubic") {
          throw new Error("exclude_outside can be set to 1 only when mode is CUBIC.");
        }
        const useNearest2xOptimization = opset < 11 ? true : mode === "nearest" && coordinateTransformMode === "asymmetric" && nearestMode === "floor";
        let roiInputIdx = 0;
        let scalesInputIdx = 0;
        let sizesInputIdx = 0;
        if (opset > 10) {
          if (node.inputs.length > 2) {
            roiInputIdx = 1;
            scalesInputIdx = 2;
            sizesInputIdx = 3;
          } else {
            scalesInputIdx = 1;
            sizesInputIdx = 2;
          }
        } else if (opset === 9) {
          scalesInputIdx = 1;
        }
        return createAttributeWithCacheKey({
          opset,
          isResize,
          mode,
          scales,
          extrapolationValue,
          coordinateTransformMode,
          useExtrapolation,
          needRoiInput,
          nearestMode,
          cubicCoefficientA,
          excludeOutside,
          useNearest2xOptimization,
          roiInputIdx,
          scalesInputIdx,
          sizesInputIdx
        });
      };
      createUpsampleProgramInfo = (inferenceHandler, inputs, attributes) => {
        const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);
        const [inputWidth, inputHeight] = inferenceHandler.calculateTextureWidthAndHeight(
          inputs[0].dims,
          0 /* unpacked */
        );
        const outputShape = inputs[0].dims.map((dim2, i) => Math.floor(dim2 * attributes.scales[i]));
        const [outputWidth, outputHeight] = inferenceHandler.calculateTextureWidthAndHeight(
          outputShape,
          0 /* unpacked */
        );
        const dim = outputShape.length;
        const outputPitches = new Array(dim);
        const inputPitches = new Array(dim);
        let precalculatedPitches = `
      int output_pitches[${dim}];
      int input_pitches[${dim}];
      `;
        for (let d = dim - 1; d >= 0; d--) {
          outputPitches[d] = d === dim - 1 ? 1 : outputPitches[d + 1] * outputShape[d + 1];
          inputPitches[d] = d === dim - 1 ? 1 : inputPitches[d + 1] * inputs[0].dims[d + 1];
          precalculatedPitches += `
        output_pitches[${d}] = ${outputPitches[d]};
        input_pitches[${d}] = ${inputPitches[d]};
        `;
        }
        const getInputFloatFunction = `
      float getInputFloat(int index) {
        vec2 coords = offsetToCoords(index, ${inputWidth}, ${inputHeight});
        float value = getColorAsFloat(${glsl.texture2D}(X, coords));
        return value;
      }
      `;
        const shaderSource = attributes.mode === "nearest" ? (
          // nearest
          `
    ${getInputFloatFunction}
    float process(int indices[${dim}]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${outputWidth}, ${outputHeight});

      ${precalculatedPitches}

      int d, m;
      for (int dim = 0; dim < ${dim}; ++dim) {
        d = output_index / output_pitches[dim];
        m = output_index - d * output_pitches[dim];
        output_index = m;

        if (scales[dim] != 1 && d > 0) {
          int d2 = d / scales[dim];
          m = d - d2 * scales[dim];
          d = d2;
        }
        input_index += input_pitches[dim] * d;
      }

      return getInputFloat(input_index);
    }`
        ) : dim === 4 ? (
          // bilinear 4D
          `
    ${getInputFloatFunction}
    float process(int indices[4]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${outputWidth}, ${outputHeight});

      ${precalculatedPitches}

      int m;
      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m / output_pitches[1];
      m = m - index_of_dim1 * output_pitches[1];
      index_of_dim2 = m / output_pitches[2];
      m = m - index_of_dim2 * output_pitches[2];
      index_of_dim3 = m;

      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;
      index_of_input_dim2 = index_of_dim2 / scales[2];
      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];
      index_of_input_dim3 = index_of_dim3 / scales[3];
      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];

      input_index = index_of_dim0 * input_pitches[0] +
            index_of_dim1 * input_pitches[1] +
            index_of_input_dim2 * input_pitches[2] +
            index_of_input_dim3;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim2 = false;
      if (index_of_input_dim2 == (${inputs[0].dims[2]} - 1)) {
        // It's the end in dimension 2
        x01 = x00;
        end_of_dim2 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[2]);
      }

      if (index_of_input_dim3 == (input_pitches[2] - 1)) {
        // It's the end in dimension 3
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);
    }`
        ) : (
          // bilinear 2D
          `
    ${getInputFloatFunction}
    float process(int indices[2]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${outputWidth}, ${outputHeight});

      ${precalculatedPitches}

      int m;
      int index_of_dim0, index_of_dim1;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m;

      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;
      index_of_input_dim0 = index_of_dim0 / scales[0];
      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];
      index_of_input_dim1 = index_of_dim1 / scales[1];
      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];

      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim0 = false;
      if (index_of_input_dim0 == (${inputs[0].dims[0]} - 1)) {
        // It's the end in dimension 0
        x01 = x00;
        end_of_dim0 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[0]);
      }

      if (index_of_input_dim1 == (input_pitches[0] - 1)) {
        // It's the end in dimension 1
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);
    }`
        );
        return {
          ...upsampleProgramMetadata,
          output: { dims: outputShape, type: inputs[0].type, textureType: 0 /* unpacked */ },
          shaderSource,
          variables: [
            {
              name: "scales",
              type: "int",
              arrayLength: attributes.scales.length,
              data: attributes.scales.map((x) => Math.ceil(x))
            }
          ]
        };
      };
      validateInputs17 = (inputs, attribute) => {
        if (!inputs || attribute.opset < 9 && inputs.length !== 1 || attribute.opset >= 9 && attribute.opset < 11 && inputs.length !== 2 || attribute.opset >= 11 && inputs.length < 2) {
          throw new Error("invalid inputs.");
        }
        if (attribute.scales.length > 0 && inputs[0].dims.length !== attribute.scales.length) {
          throw new Error("Invalid input shape.");
        }
        if (inputs[0].type === "string") {
          throw new Error("Invalid input tensor types.");
        }
      };
      scalesValidation = (scales, mode, isResize) => {
        if (!isResize) {
          for (const scale of scales) {
            if (scale < 1) {
              throw new Error("Scale value should be greater than or equal to 1.");
            }
          }
        } else {
          for (const scale of scales) {
            if (scale <= 0) {
              throw new Error("Scale value should be greater than 0.");
            }
          }
        }
        if (mode === "linear" || mode === "cubic") {
          if (scales.length !== 2 && (scales.length !== 4 || scales[0] !== 1 || scales[1] !== 1)) {
            throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${isResize ? "Resize" : "Upsample"} opeartor.`);
          }
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/resize-packed.ts
  var resizeProgramMetadata, resize, parseResizeAttributesV10, parseResizeAttributesV11, createPackedResizeProgramInfo, prepareInputs, parseScalesData, parseScalesDataFromOutputSize;
  var init_resize_packed = __esm({
    "web/lib/onnxjs/backends/webgl/ops/resize-packed.ts"() {
      "use strict";
      init_glsl_source();
      init_types();
      init_utils();
      init_packing_utils();
      init_upsample();
      resizeProgramMetadata = {
        name: "Resize",
        inputNames: ["A"],
        inputTypes: [2 /* packed */]
      };
      resize = (inferenceHandler, inputs, attributes) => {
        validateInputs17(inputs, attributes);
        const output = inferenceHandler.run(
          {
            ...resizeProgramMetadata,
            cacheHint: attributes.cacheKey,
            get: () => createPackedResizeProgramInfo(inferenceHandler, inputs, attributes)
          },
          inputs
        );
        return [output];
      };
      parseResizeAttributesV10 = (node) => parseUpsampleAttributes(node, 10);
      parseResizeAttributesV11 = (node) => parseUpsampleAttributes(node, 11);
      createPackedResizeProgramInfo = (inferenceHandler, inputs, attributes) => {
        const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);
        const [scales, outputShape] = prepareInputs(inputs, attributes);
        const isSame = scales.every((s) => s === 1) && attributes.coordinateTransformMode !== "tf_crop_and_resize";
        if (isSame) {
          return {
            ...resizeProgramMetadata,
            output: { dims: outputShape, type: inputs[0].type, textureType: 2 /* packed */ },
            hasMain: true,
            shaderSource: `void main() {
                    vec4 v = ${glsl.texture2D}(X, TexCoords);
                    ${glsl.output} = v;
                }`
          };
        }
        const dim = outputShape.length;
        if (dim < 2) {
          throw new Error(`output dimension should be at least 2, but got ${dim}`);
        }
        const outputHeight = outputShape[dim - 2];
        const outputWidth = outputShape[dim - 1];
        const inputShape = inputs[0].dims;
        if (dim !== inputShape.length) {
          throw new Error(`output dimension should match input ${inputShape.length}, but got ${dim}`);
        }
        const inputHeight = inputShape[dim - 2];
        const inputWidth = inputShape[dim - 1];
        const scalesHeight = scales[dim - 2];
        const scalesWidth = scales[dim - 1];
        let getSourceFracIndex = "";
        if (attributes.mode !== "linear") {
          throw new Error(`resize (packed) does not support mode: '${attributes.mode}'`);
        }
        switch (attributes.coordinateTransformMode) {
          case "asymmetric":
            getSourceFracIndex = `
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return vec4(coords) / scaleWHWH;
                    }
                `;
            break;
          case "half_pixel":
            getSourceFracIndex = `
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;
                    }
                `;
            break;
          case "pytorch_half_pixel":
            getSourceFracIndex = `
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 fcoords = vec4(coords);
                        return vec4(
                            ${outputWidth}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,
                            ${outputHeight}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,
                            ${outputWidth}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,
                            ${outputHeight}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0
                          );
                    }
                `;
            break;
          case "align_corners":
            getSourceFracIndex = `
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 resized = vec4(${outputWidth}.0 - 1.0, ${outputHeight}.0 - 1.0, ${outputWidth}.0 - 1.0,
                            ${outputHeight}.0 - 1.0);
                        vec4 original = vec4(${inputWidth}.0 - 1.0, ${inputHeight}.0 - 1.0, ${inputWidth}.0 - 1.0,
                            ${inputHeight}.0 - 1.0);
                        vec4 new_scale = original / resized;
                        return vec4(coords) * new_scale;
                    }
                `;
            break;
          default:
            throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${attributes.coordinateTransformMode}'`);
        }
        const coordsDataType = getCoordsDataType(dim);
        const unpackChannel = unpackFromChannel();
        const shaderSource = `
            const vec2 inputWH = vec2(${inputHeight}.0, ${inputWidth}.0);
            const vec4 scaleWHWH = vec4(float(${scalesHeight}), float(${scalesWidth}), float(${scalesHeight}), float(${scalesWidth}));
            ${unpackChannel}
            ${getSourceFracIndex}
            float getAValue(int x10, int r, int c, int d) {
                return getChannel(getA(x10, r, c, d), vec2(c, d));
            }
            void main() {
                ${coordsDataType} rc = getOutputCoords();

                int batch = rc[0];
                int depth = rc[1];

                // retrieve the 4 coordinates that is used in the 4 packed output values.
                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);

                // calculate the source index in fraction
                vec4 sourceFrac = getSourceFracIndex(coords);

                // get the lower and upper bound of the 4 values that will be packed into one texel.
                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));
                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));
                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));
                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));

                bool hasNextRow = rc.w < ${outputHeight - 1};
                bool hasNextCol = rc.z < ${outputWidth - 1};

                // pack x00, x01, x10, x11's top-left corner into one vec4 structure
                vec4 topLeft = vec4(
                    getAValue(batch, depth, x00.x, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);

                // pack x00, x01, x10, x11's top-right corner into one vec4 structure
                vec4 topRight = vec4(
                    getAValue(batch, depth, x00.x, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);

                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure
                vec4 bottomLeft = vec4(
                    getAValue(batch, depth, x00.z, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);

                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure
                vec4 bottomRight = vec4(
                    getAValue(batch, depth, x00.z, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);

                // calculate the interpolation fraction on u and v direction
                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);
                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));

                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);
                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);
                vec4 newValue = mix(top, bottom, clampFrac.xxzz);

                ${glsl.output} = vec4(newValue);
            }
        `;
        return {
          ...resizeProgramMetadata,
          output: { dims: outputShape, type: inputs[0].type, textureType: 2 /* packed */ },
          hasMain: true,
          shaderSource
        };
      };
      prepareInputs = (inputs, attributes) => {
        const x = inputs[0];
        const xDims = x.dims;
        let scales = attributes.scales;
        let outputSizes;
        if (scales.length === 0) {
          const scalesTensor = inputs[attributes.scalesInputIdx];
          if (scalesTensor && scalesTensor.size !== 0) {
            if (inputs[attributes.sizesInputIdx]) {
              throw new Error("Only one of scales or sizes must be provided as input.");
            }
            scales = parseScalesData(scalesTensor, attributes.mode, attributes.isResize);
          } else {
            const sizesTensor = inputs[attributes.sizesInputIdx];
            if (!sizesTensor || sizesTensor.size === 0) {
              throw new Error("Either scales or sizes MUST be provided as input.");
            }
            outputSizes = Array.from(sizesTensor.integerData);
            scales = parseScalesDataFromOutputSize(outputSizes, xDims, attributes.mode, attributes.isResize);
          }
        } else {
          if (inputs[attributes.sizesInputIdx]) {
            throw new Error("Only one of scales or sizes must be provided as input.");
          }
        }
        const yDims = outputSizes || xDims.map((dim, i) => Math.floor(dim * scales[i]));
        return [scales, yDims];
      };
      parseScalesData = (scale, mode, isResize) => {
        const scales = Array.from(scale.floatData);
        scalesValidation(scales, mode, isResize);
        return scales;
      };
      parseScalesDataFromOutputSize = (yDims, xDims, mode, isResize) => {
        const length = xDims.length;
        const scales = new Array(length);
        for (let i = 0, end = length; i < end; i++) {
          if (xDims[i] === 0) {
            if (yDims[i] !== 0) {
              throw new Error("Input dim is zero but required output dim is non-zero.");
            }
            scales[i] = 1;
          } else {
            scales[i] = yDims[i] / xDims[i];
          }
        }
        scalesValidation(scales, mode, isResize);
        return scales;
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/shape.ts
  var shape, validateInputs18;
  var init_shape = __esm({
    "web/lib/onnxjs/backends/webgl/ops/shape.ts"() {
      "use strict";
      init_tensor2();
      shape = (_inferenceHandler, inputs) => {
        validateInputs18(inputs);
        return [new Tensor3([inputs[0].dims.length], "int32", void 0, void 0, new Int32Array(inputs[0].dims))];
      };
      validateInputs18 = (inputs) => {
        if (!inputs || inputs.length !== 1) {
          throw new Error("Shape requires 1 input.");
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/slice.ts
  var sliceProgramMetadata, slice, parseSliceAttributes, createSliceProgramInfo, validateInputs19, sliceV10, generateSliceAttributesFromInputs, validateInputsV10;
  var init_slice = __esm({
    "web/lib/onnxjs/backends/webgl/ops/slice.ts"() {
      "use strict";
      init_attribute_with_cache_key();
      init_operators();
      init_util();
      init_types();
      sliceProgramMetadata = {
        name: "Slice",
        inputNames: ["A"],
        inputTypes: [0 /* unpacked */]
      };
      slice = (inferenceHandler, inputs, attributes) => {
        validateInputs19(inputs);
        const output = inferenceHandler.run(
          {
            ...sliceProgramMetadata,
            cacheHint: attributes.cacheKey,
            get: () => createSliceProgramInfo(inferenceHandler, inputs[0], attributes)
          },
          inputs
        );
        return [output];
      };
      parseSliceAttributes = (node) => {
        const starts = node.attributes.getInts("starts");
        const ends = node.attributes.getInts("ends");
        const axes = node.attributes.getInts("axes", []);
        return createAttributeWithCacheKey({ starts, ends, axes });
      };
      createSliceProgramInfo = (_inferenceHandler, input, attributes) => {
        const axes = attributes.axes.length === 0 ? input.dims.slice(0).map((_val, i) => i) : attributes.axes;
        const normalizedAxes = ShapeUtil.normalizeAxes(axes, input.dims.length);
        const starts = attributes.starts.map((start, i) => {
          if (start > input.dims[normalizedAxes[i]] - 1) {
            return input.dims[normalizedAxes[i]];
          }
          return ShapeUtil.normalizeAxis(start, input.dims[normalizedAxes[i]]);
        });
        const ends = attributes.ends.map((end, i) => {
          if (end > input.dims[normalizedAxes[i]] - 1) {
            return input.dims[normalizedAxes[i]];
          }
          return ShapeUtil.normalizeAxis(end, input.dims[normalizedAxes[i]]);
        });
        const outputShape = input.dims.slice();
        const sliceOps = [];
        for (let i = 0; i < normalizedAxes.length; i++) {
          outputShape[normalizedAxes[i]] = ends[i] - starts[i];
          if (starts[i] > 0) {
            sliceOps.push(`outputIdx[${normalizedAxes[i]}] += ${starts[i]};`);
          }
        }
        const rank = outputShape.length;
        const shaderSource = `
      float process(int outputIdx[${rank}]) {
        ${sliceOps.join("\n      ")}
        return _A(outputIdx);
      }`;
        return {
          ...sliceProgramMetadata,
          output: { dims: outputShape, type: input.type, textureType: 0 /* unpacked */ },
          shaderSource
        };
      };
      validateInputs19 = (inputs) => {
        if (!inputs || inputs.length !== 1) {
          throw new Error("Slice requires 1 input.");
        }
        if (NUMBER_TYPES.indexOf(inputs[0].type) === -1) {
          throw new Error("Invalid input type.");
        }
      };
      sliceV10 = (inferenceHandler, inputs) => {
        validateInputsV10(inputs);
        const attributes = generateSliceAttributesFromInputs(inferenceHandler, inputs);
        const output = inferenceHandler.run(
          {
            ...sliceProgramMetadata,
            cacheHint: attributes.cacheKey,
            get: () => createSliceProgramInfo(inferenceHandler, inputs[0], attributes)
          },
          [inputs[0]]
        );
        return [output];
      };
      generateSliceAttributesFromInputs = (inferenceHandler, inputs) => {
        if (!inferenceHandler.session.isInitializer(inputs[1].dataId) || !inferenceHandler.session.isInitializer(inputs[2].dataId) || inputs.length >= 4 && !inferenceHandler.session.isInitializer(inputs[3].dataId) || inputs.length >= 5 && !inferenceHandler.session.isInitializer(inputs[4].dataId)) {
          throw new Error("dynamic slice attributes are not allowed");
        }
        if (inputs.length >= 5 && inputs[4].integerData.some((i) => i !== 1)) {
          throw new Error("currently non-1 steps is not supported for Slice");
        }
        const starts = Array.from(inputs[1].integerData);
        const ends = Array.from(inputs[2].integerData);
        const axes = inputs.length >= 4 ? Array.from(inputs[3].integerData) : [];
        const cacheKey = `${axes};${starts};${ends}`;
        return { starts, ends, axes, cacheKey };
      };
      validateInputsV10 = (inputs) => {
        if (!inputs || inputs.length < 3 || inputs.length > 5) {
          throw new Error("Invalid input number.");
        }
        if (inputs[1].type !== "int32" || inputs[1].dims.length !== 1) {
          throw new Error("Invalid input type.");
        }
        if (inputs[2].type !== "int32" || inputs[2].dims.length !== 1) {
          throw new Error("Invalid input type.");
        }
        if (inputs.length >= 4 && (inputs[3].type !== "int32" || inputs[3].dims.length !== 1)) {
          throw new Error("Invalid input type.");
        }
        if (inputs.length >= 5 && (inputs[4].type !== "int32" || inputs[4].dims.length !== 1)) {
          throw new Error("Invalid input type.");
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/softmax.ts
  var softmaxComputeMaxProgramMetadata, softmaxComputeScaleProgramMetadata, softmaxProgramMetadata, softmax, parseSoftmaxAttributes, parseSoftmaxAttributesV13, softmaxV13, computeSoftmax, createComputeMaxProgramInfo, createComputScaleProgramInfo, createSoftMaxProgramInfo, validateInputs20;
  var init_softmax = __esm({
    "web/lib/onnxjs/backends/webgl/ops/softmax.ts"() {
      "use strict";
      init_attribute_with_cache_key();
      init_util();
      init_glsl_source();
      init_types();
      init_transpose();
      softmaxComputeMaxProgramMetadata = {
        name: "SoftmaxComputeMax",
        inputNames: ["A"],
        inputTypes: [0 /* unpacked */]
      };
      softmaxComputeScaleProgramMetadata = {
        name: "SoftmaxComputeScale",
        inputNames: ["A", "Max"],
        inputTypes: [0 /* unpacked */, 0 /* unpacked */]
      };
      softmaxProgramMetadata = {
        name: "SoftMax",
        inputNames: ["A", "Max", "Norm"],
        inputTypes: [0 /* unpacked */, 0 /* unpacked */, 0 /* unpacked */]
      };
      softmax = (inferenceHandler, inputs, attributes) => {
        validateInputs20(inputs);
        const inputShape = inputs[0].dims.slice();
        const axis = ShapeUtil.normalizeAxis(attributes.axis, inputShape.length);
        const logicalRowCount = ShapeUtil.sizeToDimension(inputShape, axis);
        const featureCount = ShapeUtil.sizeFromDimension(inputShape, axis);
        const output = computeSoftmax(inferenceHandler, inputs, attributes, logicalRowCount, featureCount);
        return output;
      };
      parseSoftmaxAttributes = (node) => createAttributeWithCacheKey({ axis: node.attributes.getInt("axis", 1) });
      parseSoftmaxAttributesV13 = (node) => createAttributeWithCacheKey({ axis: node.attributes.getInt("axis", -1) });
      softmaxV13 = (inferenceHandler, inputs, attributes) => {
        validateInputs20(inputs);
        const inputShape = inputs[0].dims.slice();
        const axis = ShapeUtil.normalizeAxis(attributes.axis, inputShape.length);
        const rank = inputShape.length;
        const isTransposeRequired = axis !== rank - 1 ? true : false;
        const transposedInputShape = [];
        let perm = [];
        let transposedInputs = [];
        let transposeAttribute;
        if (isTransposeRequired) {
          perm = Array.from({ length: rank }).map((_, i) => i);
          perm[axis] = rank - 1;
          perm[rank - 1] = axis;
          perm.map((p) => transposedInputShape.push(inputShape[p]));
          transposeAttribute = createAttributeWithCacheKey({ perm });
          transposedInputs = transpose(inferenceHandler, inputs, transposeAttribute);
        }
        const logicalRowCount = isTransposeRequired ? ShapeUtil.sizeToDimension(transposedInputShape, rank - 1) : ShapeUtil.sizeToDimension(inputShape, rank - 1);
        const featureCount = isTransposeRequired ? ShapeUtil.sizeFromDimension(transposedInputShape, rank - 1) : ShapeUtil.sizeFromDimension(inputShape, rank - 1);
        const output = computeSoftmax(
          inferenceHandler,
          isTransposeRequired ? transposedInputs : inputs,
          attributes,
          logicalRowCount,
          featureCount
        );
        if (isTransposeRequired) {
          const reversedOutput = transpose(inferenceHandler, output, transposeAttribute);
          return reversedOutput;
        } else {
          return output;
        }
      };
      computeSoftmax = (inferenceHandler, inputs, attributes, logicalRowCount, featureCount) => {
        const computeMaxProgramInfo = createComputeMaxProgramInfo(
          inferenceHandler,
          inputs[0],
          logicalRowCount,
          featureCount,
          [logicalRowCount]
        );
        const max = inferenceHandler.run(
          { ...softmaxComputeMaxProgramMetadata, cacheHint: attributes.cacheKey, get: () => computeMaxProgramInfo },
          inputs
        );
        const computeScaleProgramInfo = createComputScaleProgramInfo(
          inferenceHandler,
          inputs[0],
          logicalRowCount,
          featureCount,
          computeMaxProgramInfo.output.dims,
          [logicalRowCount]
        );
        const scale = inferenceHandler.run(
          { ...softmaxComputeScaleProgramMetadata, cacheHint: attributes.cacheKey, get: () => computeScaleProgramInfo },
          [inputs[0], max]
        );
        const softMaxProgramInfo = createSoftMaxProgramInfo(
          inferenceHandler,
          inputs[0],
          logicalRowCount,
          featureCount,
          computeMaxProgramInfo.output.dims,
          computeScaleProgramInfo.output.dims
        );
        const output = inferenceHandler.run(
          { ...softmaxProgramMetadata, cacheHint: attributes.cacheKey, get: () => softMaxProgramInfo },
          [inputs[0], max, scale]
        );
        return [output];
      };
      createComputeMaxProgramInfo = (inferenceHandler, input, logicalRowCount, featureCount, outputShape) => {
        const [textureWidth, textureHeight] = inferenceHandler.calculateTextureWidthAndHeight(
          input.dims,
          0 /* unpacked */
        );
        const rank = outputShape.length;
        if (logicalRowCount < 1 || featureCount < 1) {
          throw new Error("Logical row count N and feature count D must be greater than or equal to 1");
        }
        if (outputShape.length !== 1) {
          throw new Error("Dimensionality of the output should be 1");
        }
        if (outputShape[0] !== logicalRowCount) {
          throw new Error("Shape of the output should be equal to logical row count");
        }
        const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);
        const shaderSource = `
      float process(int[${rank}] indices) {
        int logical_row_start_offset = indices[0] * ${featureCount};

        float max = getColorAsFloat(${glsl.texture2D}(A, offsetToCoords(logical_row_start_offset, ${textureWidth},
        ${textureHeight} )));
        for(int i=1; i<${featureCount}; ++i)
        {
          float current = getColorAsFloat(${glsl.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${textureWidth}, ${textureHeight})));
          if(current > max)
          max = current;
        }

        return max;
      }`;
        return {
          ...softmaxComputeMaxProgramMetadata,
          output: { dims: outputShape, type: input.type, textureType: 0 /* unpacked */ },
          shaderSource
        };
      };
      createComputScaleProgramInfo = (inferenceHandler, input, logicalRowCount, featureCount, maxElementPerLogicalRow, outputShape) => {
        const [textureWidth, textureHeight] = inferenceHandler.calculateTextureWidthAndHeight(
          input.dims,
          0 /* unpacked */
        );
        const rank = outputShape.length;
        if (logicalRowCount < 1 || featureCount < 1) {
          throw new Error("Logical row count N and feature count D must be greater than or equal to 1");
        }
        if (outputShape.length !== 1) {
          throw new Error("Dimensionality of the output should be 1");
        }
        if (outputShape[0] !== logicalRowCount) {
          throw new Error("Shape of the output should be equal to logical row count");
        }
        if (maxElementPerLogicalRow.length !== 1) {
          throw new Error("Dimensionality of the intermediate results should be 1");
        }
        if (maxElementPerLogicalRow[0] !== logicalRowCount) {
          throw new Error("Shape of the intermediate results should be equal to logical row count");
        }
        const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);
        const shaderSource = `
      float process(int[${rank}] indices) {
        int logical_row_start_offset = indices[0] * ${featureCount};

        float norm_factor = 0.0;
        float max = _Max(indices);
        for(int i=0; i<${featureCount}; ++i)
        {
          norm_factor += exp(getColorAsFloat(${glsl.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${textureWidth}, ${textureHeight}))) - max);
        }

        return norm_factor;
      }`;
        return {
          ...softmaxComputeScaleProgramMetadata,
          output: { dims: outputShape, type: input.type, textureType: 0 /* unpacked */ },
          shaderSource
        };
      };
      createSoftMaxProgramInfo = (inferenceHandler, input, logicalRowCount, featureCount, maxElementPerLogicalRow, normalizationPerLogicalRow) => {
        const [textureWidth, textureHeight] = inferenceHandler.calculateTextureWidthAndHeight(
          input.dims,
          0 /* unpacked */
        );
        const rank = input.dims.length;
        if (logicalRowCount < 1 || featureCount < 1) {
          throw new Error("Logical row count N and feature count D must be greater than or equal to 1");
        }
        if (maxElementPerLogicalRow.length !== 1 || normalizationPerLogicalRow.length !== 1) {
          throw new Error("Dimensionality of the intermediate results should be 1");
        }
        if (maxElementPerLogicalRow[0] !== logicalRowCount || normalizationPerLogicalRow[0] !== logicalRowCount) {
          throw new Error("Shape of the intermediate results should be equal to logical row count");
        }
        const shaderSource = `
      float process(int[${rank}] indices) {

      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)
      int offset = coordsToOffset(TexCoords, ${textureWidth}, ${textureHeight});

      //determine the logical row for this index
      int logical_row_index[1];
      logical_row_index[0] = offset / ${featureCount};

      float norm_factor = _Norm(logical_row_index);

      // avoid possible division by 0
      // if norm_facor is 0, all elements are zero
      // if so, return 0
      if(norm_factor == 0.0)
        return 0.0;

      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;
    }`;
        return {
          ...softmaxProgramMetadata,
          output: { dims: input.dims, type: input.type, textureType: 0 /* unpacked */ },
          shaderSource
        };
      };
      validateInputs20 = (inputs) => {
        if (!inputs || inputs.length !== 1) {
          throw new Error("Softmax requires 1 input.");
        }
        if (inputs[0].type !== "float32" && inputs[0].type !== "float64") {
          throw new Error("Invalid input type");
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/split.ts
  var splitProgramMetadata, split, parseSplitAttributes, getProgramCount, createSplitProgramInfo, validateInputs21;
  var init_split = __esm({
    "web/lib/onnxjs/backends/webgl/ops/split.ts"() {
      "use strict";
      init_attribute_with_cache_key();
      init_util();
      init_types();
      splitProgramMetadata = {
        name: "Split",
        inputNames: ["A"],
        inputTypes: [0 /* unpacked */]
      };
      split = (inferenceHandler, inputs, attributes) => {
        validateInputs21(inputs);
        const axis = ShapeUtil.normalizeAxis(attributes.axis, inputs[0].dims.length);
        const count = getProgramCount(inferenceHandler, inputs, axis, attributes);
        const output = [];
        for (let i = 0; i < count; ++i) {
          output.push(
            inferenceHandler.run(
              {
                ...splitProgramMetadata,
                cacheHint: `${attributes.cacheKey};${i}`,
                get: () => createSplitProgramInfo(inferenceHandler, inputs[0], attributes, axis, i)
              },
              inputs
            )
          );
        }
        return output;
      };
      parseSplitAttributes = (node) => {
        const axis = node.attributes.getInt("axis", 0);
        const split2 = node.attributes.getInts("split", []);
        const numOutputs = node.outputs.length;
        return createAttributeWithCacheKey({ axis, split: split2, numOutputs });
      };
      getProgramCount = (_inferenceHandler, inputs, axis, attributes) => {
        const [, offsets] = SplitUtil.splitShape(inputs[0].dims, axis, attributes.split, attributes.numOutputs);
        return offsets.length;
      };
      createSplitProgramInfo = (_inferenceHandler, input, attributes, axis, index) => {
        const [shapes, offsets] = SplitUtil.splitShape(input.dims, axis, attributes.split, attributes.numOutputs);
        const offset = offsets[index];
        const outputShape = shapes[index];
        const rank = outputShape.length;
        const shaderSource = `
      float process(int indices[${rank}]) {
        indices[${axis}] += ${offset};
        return _A(indices);
      }
    `;
        return {
          ...splitProgramMetadata,
          cacheHint: `${attributes.cacheKey}:${index}`,
          output: { dims: outputShape, type: input.type, textureType: 0 /* unpacked */ },
          shaderSource
        };
      };
      validateInputs21 = (inputs) => {
        if (!inputs || inputs.length !== 1) {
          throw new Error("Split requires one input.");
        }
        if (inputs[0].type !== "int8" && inputs[0].type !== "uint8" && inputs[0].type !== "int16" && inputs[0].type !== "uint16" && inputs[0].type !== "int32" && inputs[0].type !== "uint32" && inputs[0].type !== "float32" && inputs[0].type !== "float64" && inputs[0].type !== "bool") {
          throw new Error("Invalid input type.");
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/squeeze.ts
  var squeeze, squeezeV13, parseSqueezeAttributes, validateInputs22, validateInputsV13;
  var init_squeeze = __esm({
    "web/lib/onnxjs/backends/webgl/ops/squeeze.ts"() {
      "use strict";
      init_util();
      squeeze = (inferenceHandler, inputs, axes) => {
        validateInputs22(inputs);
        const outputShape = ShapeUtil.squeezeShape(inputs[0].dims, axes);
        const output = inferenceHandler.reshapeUnpacked(inputs[0], outputShape);
        return [output];
      };
      squeezeV13 = (inferenceHandler, inputs) => {
        validateInputsV13(inputs);
        return squeeze(inferenceHandler, [inputs[0]], Array.from(inputs[1].integerData));
      };
      parseSqueezeAttributes = (node) => node.attributes.getInts("axes");
      validateInputs22 = (inputs) => {
        if (!inputs || inputs.length !== 1) {
          throw new Error("Squeeze requires 1 input.");
        }
        if (inputs[0].type === "string") {
          throw new Error("invalid input tensor types.");
        }
      };
      validateInputsV13 = (inputs) => {
        if (!inputs || inputs.length !== 2) {
          throw new Error("Squeeze requires 2 inputs.");
        }
        if (inputs[1].type !== "int32") {
          throw new Error("Invalid input type.");
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/sum.ts
  var sum, createSumProgramInfo, validateInputs23;
  var init_sum = __esm({
    "web/lib/onnxjs/backends/webgl/ops/sum.ts"() {
      "use strict";
      init_glsl_source();
      init_types();
      sum = (inferenceHandler, inputs) => {
        validateInputs23(inputs);
        const sumProgramMetadata = {
          name: "Sum",
          inputNames: inputs.map((_v, i) => `X${i}`),
          inputTypes: new Array(inputs.length).fill(0 /* unpacked */)
        };
        const output = inferenceHandler.run(
          { ...sumProgramMetadata, get: () => createSumProgramInfo(inferenceHandler, inputs, sumProgramMetadata) },
          inputs
        );
        return [output];
      };
      createSumProgramInfo = (inferenceHandler, inputs, sumProgramMetadata) => {
        const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);
        const outputShape = inputs[0].dims.slice();
        const sumLine = inputs.map((_v, i) => `${glsl.texture2D}(X${i},TexCoords)`).join(" + ");
        const shaderSource = `
      void main() {
        vec4 result = ${sumLine};
        ${glsl.output} = result;
      }
    `;
        return {
          ...sumProgramMetadata,
          output: { dims: outputShape, type: inputs[0].type, textureType: 0 /* unpacked */ },
          hasMain: true,
          shaderSource
        };
      };
      validateInputs23 = (inputs) => {
        if (!inputs || inputs.length === 0) {
          throw new Error("Sum requires inputs.");
        }
        const length = inputs[0].dims.length;
        for (let i = 1; i < inputs.length; i++) {
          if (length !== inputs[i].dims.length) {
            throw new Error("Input shapes are mismatched.");
          }
          for (let j = 0; j < length; j++) {
            if (inputs[0].dims[j] !== inputs[i].dims[j]) {
              throw new Error("Input shapes are not matched.");
            }
          }
        }
        if (inputs[0].type !== "float32" && inputs[0].type !== "float64") {
          throw new Error("Invalid input type.");
        }
        for (let i = 1; i < inputs.length; i++) {
          if (inputs[0].type !== inputs[i].type) {
            throw new Error("Input types are not matched.");
          }
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/tile.ts
  var tile, createTileProgramInfo, validateInputs24;
  var init_tile = __esm({
    "web/lib/onnxjs/backends/webgl/ops/tile.ts"() {
      "use strict";
      init_operators();
      init_types();
      tile = (inferenceHandler, inputs) => {
        validateInputs24(inputs);
        const tileProgramMetadata = {
          name: "Tile",
          inputNames: ["A"],
          inputTypes: [0 /* unpacked */]
        };
        const output = inferenceHandler.run(
          { ...tileProgramMetadata, get: () => createTileProgramInfo(inferenceHandler, inputs, tileProgramMetadata) },
          inputs
        );
        return [output];
      };
      createTileProgramInfo = (_handler, inputs, tileProgramMetadata) => {
        const inputShape = inputs[0].dims.slice();
        const outputShape = new Array(inputShape.length);
        const tileOps = [];
        for (let i = 0; i < inputShape.length; i++) {
          outputShape[i] = inputShape[i] * inputs[1].numberData[i];
          tileOps.push(`inputIdx[${i}] = int(mod(float(outputIdx[${i}]), ${inputShape[i]}.));`);
        }
        const rank = outputShape.length;
        const shaderSource = `
      float process(int outputIdx[${rank}]) {
        int inputIdx[${rank}];
        ${tileOps.join("\n")}
        return _A(inputIdx);
      }
    `;
        return {
          ...tileProgramMetadata,
          output: { dims: outputShape, type: inputs[0].type, textureType: 0 /* unpacked */ },
          shaderSource
        };
      };
      validateInputs24 = (inputs) => {
        if (!inputs || inputs.length !== 2) {
          throw new Error("Tile requires 2 input.");
        }
        if (inputs[1].dims.length !== 1) {
          throw new Error("The second input shape must 1 dimension.");
        }
        if (inputs[1].dims[0] !== inputs[0].dims.length) {
          throw new Error("Invalid input shape.");
        }
        if (NUMBER_TYPES.indexOf(inputs[0].type) === -1) {
          throw new Error("Invalid input type.");
        }
        if (inputs[1].type !== "int32" && inputs[1].type !== "int16") {
          throw new Error("Invalid repeat type.");
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/ops/unsqueeze.ts
  var unsqueeze, unsqueezeV13, parseUnsqueezeAttributes, validateInputs25, validateInputsV132;
  var init_unsqueeze = __esm({
    "web/lib/onnxjs/backends/webgl/ops/unsqueeze.ts"() {
      "use strict";
      init_util();
      unsqueeze = (inferenceHandler, inputs, axes) => {
        validateInputs25(inputs);
        const outputShape = ShapeUtil.unsqueezeShape(inputs[0].dims, axes);
        const output = inferenceHandler.reshapeUnpacked(inputs[0], outputShape);
        return [output];
      };
      unsqueezeV13 = (inferenceHandler, inputs) => {
        validateInputsV132(inputs);
        return unsqueeze(inferenceHandler, [inputs[0]], Array.from(inputs[1].integerData));
      };
      parseUnsqueezeAttributes = (node) => node.attributes.getInts("axes");
      validateInputs25 = (inputs) => {
        if (!inputs || inputs.length !== 1) {
          throw new Error("Unsqueeze requires 1 input.");
        }
        if (inputs[0].type === "string") {
          throw new Error("invalid input tensor types.");
        }
      };
      validateInputsV132 = (inputs) => {
        if (!inputs || inputs.length !== 2) {
          throw new Error("Unsqueeze requires 2 inputs.");
        }
        if (inputs[1].type !== "int32") {
          throw new Error("Invalid input type.");
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/op-resolve-rules.ts
  var WEBGL_OP_RESOLVE_RULES;
  var init_op_resolve_rules = __esm({
    "web/lib/onnxjs/backends/webgl/op-resolve-rules.ts"() {
      "use strict";
      init_batch_normalization();
      init_binary_op();
      init_cast();
      init_concat();
      init_conv();
      init_conv_transpose();
      init_depth_to_space();
      init_flatten();
      init_gather();
      init_gemm();
      init_image_scaler();
      init_instance_normalization();
      init_lrn();
      init_matmul();
      init_pad();
      init_pool();
      init_reduce();
      init_reshape();
      init_resize_packed();
      init_shape();
      init_slice();
      init_softmax();
      init_split();
      init_squeeze();
      init_sum();
      init_tile();
      init_transpose();
      init_unary_op();
      init_unsqueeze();
      init_upsample();
      WEBGL_OP_RESOLVE_RULES = [
        ["Abs", "", "6+", abs],
        ["Acos", "", "7+", acos],
        ["Add", "", "7+", add2],
        ["And", "", "7+", and2],
        ["Asin", "", "7+", asin],
        ["Atan", "", "7+", atan],
        // TODO: support new attributes for AveragePool-10
        ["AveragePool", "", "7+", averagePool, parseAveragePoolAttributes],
        ["BatchNormalization", "", "7+", batchNormalization, parseBatchNormalizationAttributes],
        ["Cast", "", "6+", cast, parseCastAttributes],
        ["Ceil", "", "6+", ceil],
        ["Clip", "", "6-10", clip, parseClipAttributes],
        ["Clip", "", "11+", clipV11],
        ["Concat", "", "4+", concat, parseConcatAttributes],
        ["Conv", "", "1+", conv, parseConvAttributes],
        ["ConvTranspose", "", "1+", convTranspose, parseConvTransposeAttributes],
        ["Cos", "", "7+", cos],
        ["Div", "", "7+", div],
        ["Dropout", "", "7+", identity],
        ["DepthToSpace", "", "1+", depthToSpace, parseDepthToSpaceAttributes],
        ["Equal", "", "7+", equal],
        ["Elu", "", "6+", elu, parseEluAttributes],
        ["Exp", "", "6+", exp],
        ["Flatten", "", "1+", flatten, parseFlattenAttributes],
        ["Floor", "", "6+", floor],
        ["FusedConv", "com.microsoft", "1+", conv, parseConvAttributes],
        ["Gather", "", "1+", gather, parseGatherAttributes],
        ["Gemm", "", "7-10", gemm, parseGemmAttributesV7],
        ["Gemm", "", "11+", gemm, parseGemmAttributesV11],
        ["GlobalAveragePool", "", "1+", globalAveragePool, parseGlobalAveragePoolAttributes],
        ["GlobalMaxPool", "", "1+", globalMaxPool],
        ["Greater", "", "7+", greater],
        ["Identity", "", "1+", identity],
        ["ImageScaler", "", "1+", imageScaler, parseImageScalerAttributes],
        ["InstanceNormalization", "", "6+", instanceNormalization, parseInstanceNormalizationAttributes],
        ["LeakyRelu", "", "6+", leakyRelu, parseLeakyReluAttributes],
        ["Less", "", "7+", less],
        ["LRN", "", "1+", lrn, parseLrnAttributes],
        ["Log", "", "6+", log2],
        ["MatMul", "", "1+", matMul, parseMatMulAttributes],
        // TODO: support new attributes for MaxPool-8 and MaxPool-10
        ["MaxPool", "", "1+", maxPool, parseMaxPoolAttributes],
        ["Mul", "", "7+", mul],
        ["Neg", "", "6+", neg],
        ["Not", "", "1+", not2],
        ["Or", "", "7+", or2],
        ["Pad", "", "2-10", padV2, parsePadAttributesV2],
        ["Pad", "", "11+", padV11, parsePadAttributesV11],
        ["Pow", "", "7+", pow],
        ["PRelu", "", "7+", pRelu],
        ["ReduceLogSum", "", "1+", reduceLogSum, parseReduceAttributes],
        ["ReduceMax", "", "1+", reduceMax, parseReduceAttributes],
        ["ReduceMean", "", "1+", reduceMean, parseReduceAttributes],
        ["ReduceMin", "", "1+", reduceMin, parseReduceAttributes],
        ["ReduceProd", "", "1+", reduceProd, parseReduceAttributes],
        ["ReduceSum", "", "1-12", reduceSum, parseReduceAttributes],
        ["ReduceSumSquare", "", "1+", reduceLogSumSquare, parseReduceAttributes],
        ["Relu", "", "6+", relu],
        ["Reshape", "", "5+", reshape],
        ["Resize", "", "10", resize, parseResizeAttributesV10],
        ["Resize", "", "11+", resize, parseResizeAttributesV11],
        ["Shape", "", "1+", shape],
        ["Sigmoid", "", "6+", sigmoid],
        ["Sin", "", "7+", sin],
        ["Slice", "", "10+", sliceV10],
        // TODO: support 'steps' for Slice-10
        ["Slice", "", "1-9", slice, parseSliceAttributes],
        // The "semantic" meaning of axis has changed in opset-13.
        ["Softmax", "", "1-12", softmax, parseSoftmaxAttributes],
        ["Softmax", "", "13+", softmaxV13, parseSoftmaxAttributesV13],
        // 'Split' operator has an optional attribute 'split'
        // this attribute determines how the specified axis of input data is split.
        // When the attribute is missing, we need the count of number of outputs
        // so that we can determine the 'split' attribute from the runtime input to the Operator
        ["Split", "", "2-12", split, parseSplitAttributes],
        ["Sqrt", "", "6+", sqrt],
        ["Squeeze", "", "1-12", squeeze, parseSqueezeAttributes],
        ["Squeeze", "", "13+", squeezeV13],
        ["Sub", "", "7+", sub],
        ["Sum", "", "6+", sum],
        ["Tan", "", "7+", tan],
        ["Tanh", "", "6+", tanh],
        ["Tile", "", "6+", tile],
        ["Transpose", "", "1+", transpose, parseTransposeAttributes],
        ["Upsample", "", "7-8", upsample, parseUpsampleAttributesV7],
        ["Upsample", "", "9", upsample, parseUpsampleAttributesV9],
        ["Unsqueeze", "", "1-12", unsqueeze, parseUnsqueezeAttributes],
        ["Unsqueeze", "", "13+", unsqueezeV13],
        ["Xor", "", "7+", xor2]
      ];
    }
  });

  // web/lib/onnxjs/backends/webgl/glsl-function-inliner.ts
  function replaceInlines(script) {
    const inlineDefs = {};
    let match;
    while ((match = INLINE_FUNC_DEF_REGEX.exec(script)) !== null) {
      const params = match[3].split(",").map((s) => {
        const tokens = s.trim().split(" ");
        if (tokens && tokens.length === 2) {
          return { type: tokens[0], name: tokens[1] };
        }
        return null;
      }).filter((v) => v !== null);
      inlineDefs[match[2]] = { params, body: match[4] };
    }
    for (const name2 in inlineDefs) {
      const regexString = FUNC_CALL_REGEX.replace("__FUNC__", name2);
      const regex = new RegExp(regexString, "gm");
      while ((match = regex.exec(script)) !== null) {
        const type = match[1];
        const variable = match[2];
        const params = match[3].split(",");
        const declLine = type ? `${type} ${variable};` : "";
        let newBody = inlineDefs[name2].body;
        let paramRedecLine = "";
        inlineDefs[name2].params.forEach((v, i) => {
          if (v) {
            paramRedecLine += `${v.type} ${v.name} = ${params[i]};
`;
          }
        });
        newBody = `${paramRedecLine}
 ${newBody}`;
        newBody = newBody.replace("return", `${variable} = `);
        const replacement = `
      ${declLine}
      {
        ${newBody}
      }
      `;
        script = script.replace(match[0], replacement);
      }
    }
    script = script.replace(INLINE_FUNC_DEF_REGEX, "");
    return script;
  }
  var INLINE_FUNC_DEF_REGEX, FUNC_CALL_REGEX;
  var init_glsl_function_inliner = __esm({
    "web/lib/onnxjs/backends/webgl/glsl-function-inliner.ts"() {
      "use strict";
      INLINE_FUNC_DEF_REGEX = /@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm;
      FUNC_CALL_REGEX = "(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;";
    }
  });

  // web/lib/onnxjs/backends/webgl/texture-layout-strategy.ts
  function squeezeShape(shape2, axis) {
    const newShape = [];
    const keptDims = [];
    const isEmptyArray = axis != null && Array.isArray(axis) && axis.length === 0;
    const axes = axis == null || isEmptyArray ? null : parseAxisParam(axis, shape2).sort();
    let j = 0;
    for (let i = 0; i < shape2.length; ++i) {
      if (axes != null) {
        if (axes[j] === i && shape2[i] !== 1) {
          throw new Error(`Can't squeeze axis ${i} since its dim '${shape2[i]}' is not 1`);
        }
        if ((axes[j] == null || axes[j] > i) && shape2[i] === 1) {
          newShape.push(shape2[i]);
          keptDims.push(i);
        }
        if (axes[j] <= i) {
          j++;
        }
      }
      if (shape2[i] !== 1) {
        newShape.push(shape2[i]);
        keptDims.push(i);
      }
    }
    return { newShape, keptDims };
  }
  function parseAxisParam(axis, shape2) {
    const rank = shape2.length;
    axis = axis == null ? shape2.map((_s, i) => i) : [].concat(axis);
    assert(
      axis.every((ax) => ax >= -rank && ax < rank),
      () => `All values in axis param must be in range [-${rank}, ${rank}) but got axis ${axis}`
    );
    assert(axis.every(isInt), () => `All values in axis param must be integers but got axis ${axis}`);
    return axis.map((a) => a < 0 ? rank + a : a);
  }
  function isInt(a) {
    return a % 1 === 0;
  }
  function sizeFromShape(shape2) {
    if (shape2.length === 0) {
      return 1;
    }
    let size = shape2[0];
    for (let i = 1; i < shape2.length; i++) {
      size *= shape2[i];
    }
    return size;
  }
  function sizeToSquarishShape(size) {
    const width = Math.ceil(Math.sqrt(size));
    return [width, Math.ceil(size / width)];
  }
  var PreferLogicalStrategy;
  var init_texture_layout_strategy = __esm({
    "web/lib/onnxjs/backends/webgl/texture-layout-strategy.ts"() {
      "use strict";
      init_instrument();
      init_util();
      PreferLogicalStrategy = class {
        constructor(maxTextureSize) {
          this.maxTextureSize = maxTextureSize;
        }
        computeTextureWH(shape2, prefs) {
          const wh = this.computeTexture(shape2, prefs);
          if (prefs && prefs.isPacked) {
            wh[0] /= 2;
            wh[1] /= 2;
          }
          if (prefs && prefs.reverseWH) {
            return [wh[1], wh[0]];
          }
          return wh;
        }
        computeTexture(shape2, prefs) {
          const isPacked = prefs && prefs.isPacked;
          if (shape2.length === 0) {
            return isPacked ? [2, 2] : [1, 1];
          }
          let maxTextureSize = this.maxTextureSize;
          if (prefs && prefs.breakAxis !== void 0) {
            const wsize = prefs.breakAxis >= shape2.length ? 1 : shape2.slice(prefs.breakAxis).reduce((a, b) => a * b);
            const hsize = prefs.breakAxis <= 0 ? 1 : shape2.slice(0, prefs.breakAxis).reduce((a, b) => a * b);
            if (wsize > maxTextureSize || hsize > maxTextureSize) {
              Logger.verbose(
                "TextureLayout",
                `Given width/height preferences were unattainable: shape:${shape2}, breakAxis:${prefs.breakAxis}`
              );
            } else {
              return [wsize, hsize];
            }
          }
          let logShape = shape2.slice(0);
          if (isPacked) {
            maxTextureSize = maxTextureSize * 2;
            logShape = logShape.map(
              (_d, i) => i >= logShape.length - 2 ? logShape[i] % 2 === 0 ? logShape[i] : logShape[i] + 1 : logShape[i]
            );
            if (logShape.length === 1) {
              logShape = [2, logShape[0]];
            }
          }
          if (logShape.length !== 2) {
            const squeezeResult = squeezeShape(logShape);
            logShape = squeezeResult.newShape;
          }
          const size = sizeFromShape(logShape);
          if (logShape.length <= 1 && size <= maxTextureSize) {
            return [1, size];
          } else if (logShape.length === 2 && logShape[0] <= maxTextureSize && logShape[1] <= maxTextureSize) {
            return logShape;
          } else if (logShape.length === 3 && logShape[0] * logShape[1] <= maxTextureSize && logShape[2] <= maxTextureSize) {
            return [logShape[0] * logShape[1], logShape[2]];
          } else if (logShape.length === 3 && logShape[0] <= maxTextureSize && logShape[1] * logShape[2] <= maxTextureSize) {
            return [logShape[0], logShape[1] * logShape[2]];
          } else if (logShape.length === 4 && logShape[0] * logShape[1] * logShape[2] <= maxTextureSize && logShape[3] <= maxTextureSize) {
            return [logShape[0] * logShape[1] * logShape[2], logShape[3]];
          } else if (logShape.length === 4 && logShape[0] <= maxTextureSize && logShape[1] * logShape[2] * logShape[3] <= maxTextureSize) {
            return [logShape[0], logShape[1] * logShape[2] * logShape[3]];
          } else {
            if (isPacked) {
              return sizeToSquarishShape(size / 4).map((d) => d * 2);
            }
            return sizeToSquarishShape(size);
          }
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/glsl-coordinate-lib.ts
  var CoordsGlslLib;
  var init_glsl_coordinate_lib = __esm({
    "web/lib/onnxjs/backends/webgl/glsl-coordinate-lib.ts"() {
      "use strict";
      init_util();
      init_glsl_definitions();
      init_glsl_source();
      init_texture_layout_strategy();
      init_utils();
      CoordsGlslLib = class extends GlslLib {
        constructor(context) {
          super(context);
        }
        getFunctions() {
          return {
            ...this.offsetToCoords(),
            ...this.coordsToOffset(),
            ...this.toVec(),
            ...this.valueFrom(),
            // TODO return these only when packing is enabled.
            ...this.getCommonUtilFuncs(),
            ...this.getInputsSamplingSnippets(),
            ...this.getOutputSamplingSnippet()
          };
        }
        getCustomTypes() {
          return {};
        }
        /**
         * Produces a function that can map from
         * 2D normalzied coordinates (s,t) to a flat offset
         */
        offsetToCoords() {
          const funcName = "offsetToCoords";
          return {
            offsetToCoords: new GlslLibRoutine(`
      vec2 ${funcName}(int offset, int width, int height) {
        int t = offset / width;
        int s = offset - t*width;
        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);
        return coords;
      }
      `)
          };
        }
        /**
         * Produces a function that can map from
         * 2D normalzied coordinates (s,t) to a flat offset
         */
        coordsToOffset() {
          const funcName = "coordsToOffset";
          return {
            coordsToOffset: new GlslLibRoutine(`
      int ${funcName}(vec2 coords, int width, int height) {
        float s = coords.s * float(width);
        float t = coords.t * float(height);
        int offset = int(t) * width + int(s);
        return offset;
      }
      `)
          };
        }
        /**
         * Generates code for output sampler.
         */
        getOutputSamplingSnippet() {
          const outputLayout = this.context.outputTextureLayout;
          if (outputLayout.isPacked) {
            return this.getPackedOutputSamplingSnippet(outputLayout);
          } else {
            return this.getUnpackedOutputSamplingSnippet(outputLayout);
          }
        }
        /**
         * Generates code for packed output sampler.
         */
        getPackedOutputSamplingSnippet(outputLayout) {
          const outShape = outputLayout.unpackedShape;
          const outTexShape = [outputLayout.width, outputLayout.height];
          const result = {};
          const funcName = "getOutputCoords";
          switch (outShape.length) {
            case 0:
              result[funcName] = this.getOutputScalarCoords();
              break;
            case 1:
              result[funcName] = this.getOutputPacked1DCoords(outShape, outTexShape);
              break;
            case 2:
              result[funcName] = this.getOutputPacked2DCoords(outShape, outTexShape);
              break;
            case 3:
              result[funcName] = this.getOutputPacked3DCoords(
                outShape,
                outTexShape
              );
              break;
            default:
              result[funcName] = this.getOutputPackedNDCoords(outShape, outTexShape);
          }
          const glsl = getGlsl(this.context.glContext.version);
          const floatTextureSetRGBASource = `
      void setOutput(vec4 val) {
        ${glsl.output} = val;
      }
    `;
          const floatTextureSetRGBAFuncName = "floatTextureSetRGBA";
          result[floatTextureSetRGBAFuncName] = new GlslLibRoutine(floatTextureSetRGBASource);
          return result;
        }
        /**
         * Generates code for unpacked output sampler.
         */
        getUnpackedOutputSamplingSnippet(outputLayout) {
          const outShape = outputLayout.unpackedShape;
          const outTexShape = [outputLayout.width, outputLayout.height];
          const result = {};
          const funcName = "getOutputCoords";
          switch (outShape.length) {
            case 0:
              result[funcName] = this.getOutputScalarCoords();
              break;
            case 1:
              result[funcName] = this.getOutputUnpacked1DCoords(outShape, outTexShape);
              break;
            case 2:
              result[funcName] = this.getOutputUnpacked2DCoords(
                outShape,
                outTexShape
              );
              break;
            case 3:
              result[funcName] = this.getOutputUnpacked3DCoords(
                outShape,
                outTexShape
              );
              break;
            case 4:
              result[funcName] = this.getOutputUnpacked4DCoords(
                outShape,
                outTexShape
              );
              break;
            case 5:
              result[funcName] = this.getOutputUnpacked5DCoords(
                outShape,
                outTexShape
              );
              break;
            case 6:
              result[funcName] = this.getOutputUnpacked6DCoords(
                outShape,
                outTexShape
              );
              break;
            default:
              throw new Error(`Unsupported output dimensionality: ${outShape.length}`);
          }
          const glsl = getGlsl(this.context.glContext.version);
          const floatTextureSetRSource = `
        void setOutput(float val) {
          ${glsl.output} = vec4(val, 0, 0, 0);
        }
    `;
          const floatTextureSetRFuncName = "floatTextureSetR";
          result[floatTextureSetRFuncName] = new GlslLibRoutine(floatTextureSetRSource);
          return result;
        }
        /**
         * Scalar output coordinates.
         */
        getOutputScalarCoords() {
          return new GlslLibRoutine(`
      int getOutputCoords() {
        return 0;
      }
    `);
        }
        /**
         * 1D packed output coordinates.
         */
        getOutputPacked1DCoords(_shape, texShape) {
          const packedTexShape = texShape;
          let source = "";
          if (packedTexShape[0] === 1) {
            source = `
          int getOutputCoords() {
            return 2 * int(TexCoords.y * ${packedTexShape[1]}.0);
          }
        `;
            return new GlslLibRoutine(source);
          }
          if (packedTexShape[1] === 1) {
            source = `
          int getOutputCoords() {
            return 2 * int(TexCoords.x * ${packedTexShape[0]}.0);
          }
        `;
            return new GlslLibRoutine(source);
          }
          source = `
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                 vec2(${packedTexShape[0]}, ${packedTexShape[1]}));
          return 2 * (resTexRC.y * ${packedTexShape[0]} + resTexRC.x);
        }
      `;
          return new GlslLibRoutine(source);
        }
        /**
         * 2D packed output coordinates.
         */
        getOutputPacked2DCoords(shape2, texShape) {
          let source = "";
          if (ArrayUtil.arraysEqual(shape2, texShape)) {
            source = `
        ivec2 getOutputCoords() {
          return 2 * ivec2(TexCoords.xy * vec2(${texShape[0]}, ${texShape[1]}));
        }
      `;
            return new GlslLibRoutine(source);
          }
          const packedTexShape = texShape;
          const texelsInLogicalRow = Math.ceil(shape2[1] / 2);
          source = `
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${packedTexShape[0]}, ${packedTexShape[1]}));

          int index = resTexRC.y * ${packedTexShape[0]} + resTexRC.x;

          // reverse r and c order for packed texture
          int r = imod(index, ${texelsInLogicalRow}) * 2;
          int c = 2 * (index / ${texelsInLogicalRow});

          return ivec2(r, c);
        }
      `;
          return new GlslLibRoutine(source);
        }
        /**
         * 3D packed output coordinates.
         */
        getOutputPacked3DCoords(shape2, texShape) {
          const packedTexShape = [texShape[0], texShape[1]];
          const texelsInLogicalRow = Math.ceil(shape2[2] / 2);
          const texelsInBatch = texelsInLogicalRow * Math.ceil(shape2[1] / 2);
          const source = `
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${packedTexShape[0]}, ${packedTexShape[1]}));
          int index = resTexRC.y * ${packedTexShape[0]} + resTexRC.x;

          int b = index / ${texelsInBatch};
          index -= b * ${texelsInBatch};

          // reverse r and c order for packed texture
          int r = imod(index, ${texelsInLogicalRow}) * 2;
          int c = 2 * (index / ${texelsInLogicalRow});

          return ivec3(b, r, c);
        }
      `;
          return new GlslLibRoutine(source);
        }
        /**
         * ND packed output coordinates.
         */
        getOutputPackedNDCoords(shape2, texShape) {
          const packedTexShape = [texShape[0], texShape[1]];
          const texelsInLogicalRow = Math.ceil(shape2[shape2.length - 1] / 2);
          const texelsInBatch = texelsInLogicalRow * Math.ceil(shape2[shape2.length - 2] / 2);
          let texelsInBatchN = texelsInBatch;
          let batches = "";
          let coords = "b, r, c";
          for (let b = 2; b < shape2.length - 1; b++) {
            texelsInBatchN *= shape2[shape2.length - b - 1];
            batches = `
      int b${b} = index / ${texelsInBatchN};
      index -= b${b} * ${texelsInBatchN};
    ` + batches;
            coords = `b${b}, ` + coords;
          }
          const source = `
      ivec${shape2.length} getOutputCoords() {
        ivec2 resTexRC = ivec2(TexCoords.xy *
                              vec2(${packedTexShape[0]}, ${packedTexShape[1]}));
        int index = resTexRC.y * ${packedTexShape[0]} + resTexRC.x;

        ${batches}

        int b = index / ${texelsInBatch};
        index -= b * ${texelsInBatch};

        // reverse r and c order for packed texture
        int r = imod(index, ${texelsInLogicalRow}) * 2;
        int c = 2 * (index / ${texelsInLogicalRow});

        return ivec${shape2.length}(${coords});
      }
    `;
          return new GlslLibRoutine(source);
        }
        /**
         * Unpacked 1D output coordinates.
         */
        getOutputUnpacked1DCoords(_shape, texShape) {
          const source = `
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${texShape[0]}, ${texShape[1]}));
          return resTexRC.y * ${texShape[0]} + resTexRC.x;
        }
      `;
          return new GlslLibRoutine(source);
        }
        /**
         * Unpacked 2D output coordinates.
         */
        getOutputUnpacked2DCoords(shape2, texShape) {
          const source = `
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${texShape[0]}, ${texShape[1]}));
          int index = resTexRC.y * ${texShape[0]} + resTexRC.x;
          int r = index / ${shape2[1]};
          int c = index - r * ${shape2[1]};
          return ivec2(r, c);
        }
      `;
          return new GlslLibRoutine(source);
        }
        /**
         * Unpacked 3D output coordinates.
         */
        getOutputUnpacked3DCoords(shape2, texShape) {
          let source = "";
          const rank = shape2.length;
          let strides = null;
          if (rank < 2) {
            strides = [];
          }
          strides = new Array(rank - 1);
          strides[rank - 2] = shape2[rank - 1];
          for (let i = rank - 3; i >= 0; --i) {
            strides[i] = strides[i + 1] * shape2[i + 1];
          }
          const coordsToCompute = ["r", "c", "d"];
          const coordsFromIndexSnippet = strides.map((stride, i) => {
            const line1 = `int ${coordsToCompute[i]} = index / ${stride}`;
            const line2 = i === strides.length - 1 ? `int ${coordsToCompute[i + 1]} = index - ${coordsToCompute[i]} * ${stride}` : `index -= ${coordsToCompute[i]} * ${stride}`;
            return `${line1}; ${line2};`;
          }).join("");
          source = `
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${texShape[0]}, ${texShape[1]}));
          int index = resTexRC.y * ${texShape[0]} + resTexRC.x;
          ${coordsFromIndexSnippet}
          return ivec3(r, c, d);
        }
      `;
          return new GlslLibRoutine(source);
        }
        /**
         * Unpacked 4D output coordinates.
         */
        getOutputUnpacked4DCoords(shape2, texShape) {
          let source = "";
          const rank = shape2.length;
          let strides = null;
          if (rank < 2) {
            strides = [];
          }
          strides = new Array(rank - 1);
          strides[rank - 2] = shape2[rank - 1];
          for (let i = rank - 3; i >= 0; --i) {
            strides[i] = strides[i + 1] * shape2[i + 1];
          }
          const coordsToCompute = ["r", "c", "d", "d2"];
          const coordsFromIndexSnippet = strides.map((stride, i) => {
            const line1 = `int ${coordsToCompute[i]} = index / ${stride}`;
            const line2 = i === strides.length - 1 ? `int ${coordsToCompute[i + 1]} = index - ${coordsToCompute[i]} * ${stride}` : `index -= ${coordsToCompute[i]} * ${stride}`;
            return `${line1}; ${line2};`;
          }).join("");
          source = `
      ivec4 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${texShape[0]}, ${texShape[1]}));
          int index = resTexRC.y * ${texShape[0]} + resTexRC.x;
          ${coordsFromIndexSnippet}
          return ivec4(r, c, d, d2);
        }
      `;
          return new GlslLibRoutine(source);
        }
        /**
         * Unpacked 5D output coordinates.
         */
        getOutputUnpacked5DCoords(shape2, texShape) {
          let source = "";
          const rank = shape2.length;
          let strides = null;
          if (rank < 2) {
            strides = [];
          }
          strides = new Array(rank - 1);
          strides[rank - 2] = shape2[rank - 1];
          for (let i = rank - 3; i >= 0; --i) {
            strides[i] = strides[i + 1] * shape2[i + 1];
          }
          const coordsToCompute = ["r", "c", "d", "d2", "d3"];
          const coordsFromIndexSnippet = strides.map((stride, i) => {
            const line1 = `int ${coordsToCompute[i]} = index / ${stride}`;
            const line2 = i === strides.length - 1 ? `int ${coordsToCompute[i + 1]} = index - ${coordsToCompute[i]} * ${stride}` : `index -= ${coordsToCompute[i]} * ${stride}`;
            return `${line1}; ${line2};`;
          }).join("");
          source = `
      ivec5 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${texShape[0]}, ${texShape[1]}));
          int index = resTexRC.y * ${texShape[0]} + resTexRC.x;
          ${coordsFromIndexSnippet}
          return ivec5(r, c, d, d2, d3);
        }
      `;
          return new GlslLibRoutine(source);
        }
        /**
         * Unpacked 6D output coordinates.
         */
        getOutputUnpacked6DCoords(shape2, texShape) {
          let source = "";
          const rank = shape2.length;
          let strides = null;
          if (rank < 2) {
            strides = [];
          }
          strides = new Array(rank - 1);
          strides[rank - 2] = shape2[rank - 1];
          for (let i = rank - 3; i >= 0; --i) {
            strides[i] = strides[i + 1] * shape2[i + 1];
          }
          const coordsToCompute = ["r", "c", "d", "d2", "d3", "d4"];
          const coordsFromIndexSnippet = strides.map((stride, i) => {
            const line1 = `int ${coordsToCompute[i]} = index / ${stride}`;
            const line2 = i === strides.length - 1 ? `int ${coordsToCompute[i + 1]} = index - ${coordsToCompute[i]} * ${stride}` : `index -= ${coordsToCompute[i]} * ${stride}`;
            return `${line1}; ${line2};`;
          }).join("");
          source = `
     ivec6 getOutputCoords() {
         ivec2 resTexRC = ivec2(TexCoords.xy *
                               vec2(${texShape[0]}, ${texShape[1]}));
         int index = resTexRC.y * ${texShape[0]} + resTexRC.x;
         ${coordsFromIndexSnippet}
         return ivec6(r, c, d, d2, d3, d4);
       }
     `;
          return new GlslLibRoutine(source);
        }
        /**
         * Generates code for common UV coords computation utility functions.
         */
        getCommonUtilFuncs() {
          const result = {};
          let funcName = "uvFromFlat";
          result[funcName] = new GlslLibRoutine(`
    vec2 uvFromFlat(int texNumR, int texNumC, int index) {
      int texC = index / texNumR;
      int texR = index - texC * texNumR;
      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to
      //       v.
      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);
    }
    `);
          funcName = "packedUVfrom1D";
          result[funcName] = new GlslLibRoutine(`
      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
        int texelIndex = index / 2;
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `);
          funcName = "packedUVfrom2D";
          result[funcName] = new GlslLibRoutine(`
      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {
        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `);
          funcName = "packedUVfrom3D";
          result[funcName] = new GlslLibRoutine(`
      vec2 packedUVfrom3D(int texNumR, int texNumC,
          int texelsInBatch, int texelsInLogicalRow, int b,
          int row, int col) {
        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = index / texNumC;
        int texC = index - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `);
          funcName = "sampleTexture";
          const glsl = getGlsl(this.context.glContext.version);
          result[funcName] = new GlslLibRoutine(`
        float sampleTexture(sampler2D textureSampler, vec2 uv) {
            return ${glsl.texture2D}(textureSampler, uv).r;
        }`);
          return result;
        }
        /**
         * Constructing snippets for inputs
         */
        getInputsSamplingSnippets() {
          const result = {};
          const outputLayout = this.context.outputTextureLayout;
          this.context.programInfo.inputNames.forEach((samplerName, i) => {
            const inputLayout = this.context.inputTextureLayouts[i];
            const funcName = generateShaderFuncNameFromInputSamplerName(samplerName);
            if (inputLayout.isPacked) {
              result[funcName] = this.getPackedSamplerFromInput(funcName, samplerName, inputLayout);
            } else {
              result[funcName] = this.getUnpackedSamplerFromInput(funcName, samplerName, inputLayout);
            }
            const outCoordFuncName = generateShaderFuncNameFromInputSamplerNameAtOutCoords(samplerName);
            if (inputLayout.unpackedShape.length <= outputLayout.unpackedShape.length) {
              if (inputLayout.isPacked) {
                result[outCoordFuncName] = this.getPackedSamplerAtOutputCoords(
                  outCoordFuncName,
                  inputLayout,
                  outputLayout,
                  samplerName
                );
              } else {
                result[outCoordFuncName] = this.getUnpackedSamplerAtOutputCoords(
                  outCoordFuncName,
                  inputLayout,
                  outputLayout,
                  samplerName
                );
              }
            }
          });
          return result;
        }
        /**
         * Constructing snippets for output coordinates of samplers
         */
        getPackedSamplerAtOutputCoords(funcName, inputLayout, outputLayout, name2) {
          const inShape = inputLayout.unpackedShape;
          const outShape = outputLayout.unpackedShape;
          const texName = name2;
          const texFuncSnippet = generateShaderFuncNameFromInputSamplerName(texName);
          const inRank = inShape.length;
          const outRank = outShape.length;
          const broadcastDims = BroadcastUtil.getBroadcastDims(inShape, outShape);
          const type = getCoordsDataType(outRank);
          const rankDiff = outRank - inRank;
          let coordsSnippet;
          const fields = getGlChannels();
          if (inRank === 0) {
            coordsSnippet = "";
          } else if (outRank < 2 && broadcastDims.length >= 1) {
            coordsSnippet = "coords = 0;";
          } else {
            coordsSnippet = broadcastDims.map((d) => `coords.${fields[d + rankDiff]} = 0;`).join("\n");
          }
          let unpackedCoordsSnippet = "";
          if (outRank < 2 && inRank > 0) {
            unpackedCoordsSnippet = "coords";
          } else {
            unpackedCoordsSnippet = inShape.map((_s, i) => `coords.${fields[i + rankDiff]}`).join(", ");
          }
          let output = "return outputValue;";
          const inSize = ShapeUtil.size(inShape);
          const isInputScalar = inSize === 1;
          const outSize = ShapeUtil.size(outShape);
          const isOutputScalar = outSize === 1;
          if (inRank === 1 && !isInputScalar && !isOutputScalar) {
            output = `
        return vec4(outputValue.xy, outputValue.xy);
      `;
          } else if (isInputScalar && !isOutputScalar) {
            if (outRank === 1) {
              output = `
          return vec4(outputValue.x, outputValue.x, 0., 0.);
        `;
            } else {
              output = `
          return vec4(outputValue.x);
        `;
            }
          } else if (broadcastDims.length) {
            const rows = inRank - 2;
            const cols = inRank - 1;
            if (broadcastDims.indexOf(rows) > -1 && broadcastDims.indexOf(cols) > -1) {
              output = "return vec4(outputValue.x);";
            } else if (broadcastDims.indexOf(rows) > -1) {
              output = "return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);";
            } else if (broadcastDims.indexOf(cols) > -1) {
              output = "return vec4(outputValue.xx, outputValue.zz);";
            }
          }
          const swapLastDimsSnippet = `
        int lastDim = coords.${fields[outRank - 1]};
        coords.${fields[outRank - 1]} = coords.${fields[outRank - 2]};
        coords.${fields[outRank - 2]} = lastDim;
      `;
          const source = `
      vec4 ${funcName}() {
        ${type} coords = getOutputCoords();
        ${swapLastDimsSnippet}
        ${coordsSnippet}
        vec4 outputValue = ${texFuncSnippet}(${unpackedCoordsSnippet});
        ${output}
      }
    `;
          return new GlslLibRoutine(source, ["coordinates.getOutputCoords"]);
        }
        /**
         * Constructing snippets for unpacked output coordinates of samplers
         */
        getUnpackedSamplerAtOutputCoords(funcName, inputLayout, outputLayout, name2) {
          const outTexShape = [outputLayout.width, outputLayout.height];
          const inTexShape = [inputLayout.width, inputLayout.height];
          const inRank = inputLayout.unpackedShape.length;
          const outRank = outputLayout.unpackedShape.length;
          const inShape = inputLayout.unpackedShape;
          const outShape = outputLayout.unpackedShape;
          const texFuncSnippet = generateShaderFuncNameFromInputSamplerName(name2);
          if (inRank === outRank && ArrayUtil.arraysEqual(inTexShape, outTexShape)) {
            const source2 = `
          float ${funcName}() {
            return sampleTexture(${name2}, TexCoords);
          }
        `;
            return new GlslLibRoutine(source2, ["coordinates.sampleTexture"]);
          }
          const type = getCoordsDataType(outRank);
          const broadcastDims = BroadcastUtil.getBroadcastDims(inShape, outShape);
          const rankDiff = outRank - inRank;
          let coordsSnippet;
          const fields = getGlChannels();
          if (inRank === 0) {
            coordsSnippet = "";
          } else if (outRank < 2 && broadcastDims.length >= 1) {
            coordsSnippet = "coords = 0;";
          } else {
            coordsSnippet = broadcastDims.map((d) => `coords.${fields[d + rankDiff]} = 0;`).join("\n");
          }
          let unpackedCoordsSnippet = "";
          if (outRank < 2 && inRank > 0) {
            unpackedCoordsSnippet = "coords";
          } else {
            unpackedCoordsSnippet = inputLayout.unpackedShape.map((_s, i) => `coords.${fields[i + rankDiff]}`).join(", ");
          }
          const source = `
        float ${funcName}() {
          ${type} coords = getOutputCoords();
          ${coordsSnippet}
          return ${texFuncSnippet}(${unpackedCoordsSnippet});
        }
      `;
          return new GlslLibRoutine(source, ["coordinates.getOutputCoords"]);
        }
        /**
         * Constructing snippets for packed operations.
         */
        getPackedSamplerFromInput(funcName, name2, inputLayout) {
          switch (inputLayout.unpackedShape.length) {
            case 0:
              return this.getPackedSamplerScalar(funcName, name2);
            case 1:
              return this.getPackedSampler1D(funcName, name2, inputLayout);
            case 2:
              return this.getPackedSampler2D(funcName, name2, inputLayout);
            case 3:
              return this.getPackedSampler3D(funcName, name2, inputLayout);
            default:
              return this.getPackedSamplerND(funcName, name2, inputLayout);
          }
        }
        /**
         * Constructing snippets for unpacked operations.
         */
        getUnpackedSamplerFromInput(funcName, name2, inputLayout) {
          const shape2 = inputLayout.unpackedShape;
          switch (shape2.length) {
            case 0:
              return this.getUnpackedSamplerScalar(funcName, name2, inputLayout);
            case 1:
              return this.getUnpackedSampler1D(funcName, name2, inputLayout);
            case 2:
              return this.getUnpackedSampler2D(funcName, name2, inputLayout);
            case 3:
              return this.getUnpackedSampler3D(funcName, name2, inputLayout);
            case 4:
              return this.getUnpackedSampler4D(funcName, name2, inputLayout);
            case 5:
              return this.getUnpackedSampler5D(funcName, name2, inputLayout);
            case 6:
              return this.getUnpackedSampler6D(funcName, name2, inputLayout);
            default:
              throw new Error(`Unsupported dimension ${shape2.length}-D`);
          }
        }
        /**
         * Packed scalar snippet.
         */
        getPackedSamplerScalar(funcName, name2) {
          const glsl = getGlsl(this.context.glContext.version);
          const source = `
          vec4 ${funcName}() {
            return ${glsl.texture2D}(${name2}, halfCR);
          }
        `;
          return new GlslLibRoutine(source);
        }
        /**
         * Packed 1D snippet.
         */
        getPackedSampler1D(funcName, name2, inputLayout) {
          const texShape = [inputLayout.width, inputLayout.height];
          const packedTexShape = [texShape[1], texShape[0]];
          const glsl = getGlsl(this.context.glContext.version);
          const packedSampler = `vec4 ${funcName}(int index) {
      vec2 uv = packedUVfrom1D(
      ${packedTexShape[0]}, ${packedTexShape[1]}, index);
      return ${glsl.texture2D}(${name2}, uv);
    }`;
          const source = packedSampler;
          return new GlslLibRoutine(source, ["coordinates.packedUVfrom1D"]);
        }
        /**
         * Packed 2D snippet.
         */
        getPackedSampler2D(funcName, name2, inputLayout) {
          const shape2 = inputLayout.unpackedShape;
          const texShape = [inputLayout.width, inputLayout.height];
          const glsl = getGlsl(this.context.glContext.version);
          const texNumR = texShape[0];
          const texNumC = texShape[1];
          if (texShape != null && ArrayUtil.arraysEqual(shape2, texShape)) {
            const packedSampler2 = `vec4 ${funcName}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${texNumC}.0, ${texNumR}.0);
        return ${glsl.texture2D}(${name2}, uv);
      }`;
            return new GlslLibRoutine(packedSampler2);
          }
          const packedTexShape = texShape;
          const valuesPerRow = Math.ceil(shape2[1] / 2);
          const packedSampler = `vec4 ${funcName}(int row, int col) {
      vec2 uv = packedUVfrom2D(${packedTexShape[1]}, ${packedTexShape[0]}, ${valuesPerRow}, row, col);
      return ${glsl.texture2D}(${name2}, uv);
    }`;
          const source = packedSampler;
          return new GlslLibRoutine(source, ["coordinates.packedUVfrom2D"]);
        }
        /**
         * Packed 3D snippet.
         */
        getPackedSampler3D(funcName, name2, inputLayout) {
          const shape2 = inputLayout.unpackedShape;
          const texShape = [inputLayout.width, inputLayout.height];
          const packedTexShape = [texShape[0], texShape[1]];
          const glsl = getGlsl(this.context.glContext.version);
          if (shape2[0] === 1) {
            const squeezedShape = shape2.slice(1);
            const keptDims = [1, 2];
            const newInputShape = squeezeInputShape(shape2, squeezedShape);
            const params = ["b", "row", "col"];
            const newInputLayout = JSON.parse(JSON.stringify(inputLayout));
            newInputLayout.unpackedShape = newInputShape;
            const samplerRoutine = this.getPackedSamplerFromInput(funcName, name2, newInputLayout);
            const packedSampler2 = `${samplerRoutine.routineBody}
      vec4 ${funcName}(int b, int row, int col) {
        return ${funcName}(${getSqueezedParams(params, keptDims)});
      } `;
            const source2 = packedSampler2;
            return new GlslLibRoutine(source2, samplerRoutine.dependencies);
          }
          const texNumR = packedTexShape[0];
          const texNumC = packedTexShape[1];
          const valuesPerRow = Math.ceil(shape2[2] / 2);
          const texelsInBatch = valuesPerRow * Math.ceil(shape2[1] / 2);
          const packedSampler = `vec4 ${funcName}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${texNumC}, ${texNumR}, ${texelsInBatch}, ${valuesPerRow}, b, row, col);
      return ${glsl.texture2D}(${name2}, uv);}`;
          const source = packedSampler;
          return new GlslLibRoutine(source, ["coordinates.packedUVfrom3D"]);
        }
        /*
         * Packed ND snippet.
         */
        getPackedSamplerND(funcName, name2, inputLayout) {
          const shape2 = inputLayout.unpackedShape;
          const rank = shape2.length;
          const texShape = [inputLayout.width, inputLayout.height];
          const glsl = getGlsl(this.context.glContext.version);
          const packedTexShape = [texShape[0], texShape[1]];
          const texNumR = packedTexShape[1];
          const texNumC = packedTexShape[0];
          const valuesPerRow = Math.ceil(shape2[rank - 1] / 2);
          let texelsInBatch = valuesPerRow * Math.ceil(shape2[rank - 2] / 2);
          let params = "int b, int row, int col";
          let index = `b * ${texelsInBatch} + (row / 2) * ${valuesPerRow} + (col / 2)`;
          for (let b = 2; b < rank - 1; b++) {
            params = `int b${b}, ` + params;
            texelsInBatch *= shape2[rank - b - 1];
            index = `b${b} * ${texelsInBatch} + ` + index;
          }
          const packedSampler = `vec4 ${funcName}(${params}) {
      int index = ${index};
      int texR = index / ${texNumC};
      int texC = index - texR * ${texNumC};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${texNumC}, ${texNumR});
      return ${glsl.texture2D}(${name2}, uv);
    }`;
          const source = packedSampler;
          return new GlslLibRoutine(source);
        }
        /**
         * Unpacked scalar snippet.
         */
        getUnpackedSamplerScalar(funcName, name2, inputLayout) {
          const [texNumR, texNumC] = [inputLayout.width, inputLayout.height];
          if (texNumR === 1 && texNumC === 1) {
            const source2 = `
          float ${funcName}() {
            return sampleTexture(${name2}, halfCR);
          }
        `;
            return new GlslLibRoutine(source2, ["coordinates.sampleTexture"]);
          }
          const source = `
        float ${funcName}() {
          int offset_${name2} = coordsToOffset(TexCoords, ${texNumR}, ${texNumC});
          vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, offset_${name2});
          return sampleTexture(${name2}, uv);
        }
      `;
          return new GlslLibRoutine(source, [
            "coordinates.uvFromFlat",
            "coordinates.sampleTexture",
            "coordinates.coordsToOffset"
          ]);
        }
        /**
         * Unpacked 1D snippet.
         */
        getUnpackedSampler1D(funcName, name2, inputLayout) {
          const tNumR = inputLayout.width;
          const tNumC = inputLayout.height;
          if (tNumC === 1 && tNumR === 1) {
            const source2 = `
        float ${funcName}(int index) {
          return sampleTexture(${name2}, halfCR);
        }
      `;
            return new GlslLibRoutine(source2, ["coordinates.sampleTexture"]);
          }
          if (tNumC === 1) {
            const source2 = `
          float ${funcName}(int index) {
            vec2 uv = vec2((float(index) + 0.5) / ${tNumR}.0, 0.5);
            return sampleTexture(${name2}, uv);
          }
        `;
            return new GlslLibRoutine(source2, ["coordinates.sampleTexture"]);
          }
          if (tNumR === 1) {
            const source2 = `
          float ${funcName}(int index) {
            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${tNumC}.0);
            return sampleTexture(${name2}, uv);
          }
        `;
            return new GlslLibRoutine(source2, ["coordinates.sampleTexture"]);
          }
          const source = `
        float ${funcName}(int index) {
          vec2 uv = uvFromFlat(${tNumR}, ${tNumC}, index);
          return sampleTexture(${name2}, uv);
        }
      `;
          return new GlslLibRoutine(source, ["coordinates.uvFromFlat", "coordinates.sampleTexture"]);
        }
        /**
         * Unpacked 2D snippet.
         */
        getUnpackedSampler2D(funcName, name2, inputLayout) {
          const shape2 = inputLayout.unpackedShape;
          const texShape = [inputLayout.height, inputLayout.width];
          if (texShape != null && ArrayUtil.arraysEqual(shape2, texShape)) {
            const texNumR2 = texShape[1];
            const texNumC2 = texShape[0];
            const source2 = `
          float ${funcName}(int row, int col) {
            vec2 uv = (vec2(row, col) + halfCR) / vec2(${texNumR2}.0, ${texNumC2}.0);
            return sampleTexture(${name2}, uv);
          }
        `;
            return new GlslLibRoutine(source2, ["coordinates.sampleTexture"]);
          }
          const { newShape, keptDims } = squeezeShape(shape2);
          const squeezedShape = newShape;
          if (squeezedShape.length < shape2.length) {
            const newInputShape = squeezeInputShape(shape2, squeezedShape);
            const newInputLayout = JSON.parse(JSON.stringify(inputLayout));
            newInputLayout.unpackedShape = newInputShape;
            const params = ["col", "row"];
            const source2 = `
          ${this.getUnpackedSamplerFromInput(funcName, name2, newInputLayout).routineBody}
          float ${funcName}(int row, int col) {
            return ${funcName}(${getSqueezedParams(params, keptDims)});
          }
        `;
            return new GlslLibRoutine(source2, ["coordinates.sampleTexture"]);
          }
          const texNumR = texShape[1];
          const texNumC = texShape[0];
          if (texNumC === 1) {
            const source2 = `
          float ${funcName}(int row, int col) {
            int offset_${name2} = coordsToOffset(TexCoords, ${texNumR}, ${texNumC});
            float index = dot(vec3(row, col, offset_${name2}), vec3(${shape2[1]}, 1, 1));
            vec2 uv = vec2(0.5, (index + 0.5) / ${texNumR}.0);
            return sampleTexture(${name2}, uv);
          }
        `;
            return new GlslLibRoutine(source2, ["coordinates.sampleTexture", "coordinates.coordsToOffset"]);
          }
          if (texNumR === 1) {
            const source2 = `
          float ${funcName}(int row, int col) {
            int offset_${name2} = coordsToOffset(TexCoords, ${texNumR}, ${texNumC});
            float index = dot(vec3(row, col, offset_${name2}), vec3(${shape2[1]}, 1, 1));
            vec2 uv = vec2((index + 0.5) / ${texNumC}.0, 0.5);
            return sampleTexture(${name2}, uv);
          }
        `;
            return new GlslLibRoutine(source2, ["coordinates.sampleTexture", "coordinates.coordsToOffset"]);
          }
          const source = `
        float ${funcName}(int row, int col) {
          int index = col * ${shape2[1]} + row;
          vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
          return sampleTexture(${name2}, uv);
        }
      `;
          return new GlslLibRoutine(source, [
            "coordinates.uvFromFlat",
            "coordinates.sampleTexture",
            "coordinates.coordsToOffset"
          ]);
        }
        /**
         * Unpacked 3D snippet.
         */
        getUnpackedSampler3D(funcName, name2, inputLayout) {
          const shape2 = inputLayout.unpackedShape;
          const stride0 = shape2[1] * shape2[2];
          const stride1 = shape2[2];
          const { newShape, keptDims } = squeezeShape(shape2);
          const squeezedShape = newShape;
          if (squeezedShape.length < shape2.length) {
            const newInputShape = squeezeInputShape(shape2, squeezedShape);
            const params = ["batch", "col", "row"];
            const newInputLayout = JSON.parse(JSON.stringify(inputLayout));
            newInputLayout.unpackedShape = newInputShape;
            const routine = this.getUnpackedSamplerFromInput(funcName, name2, newInputLayout);
            const revDims = keptDims.reverse();
            const source2 = `
          ${routine.routineBody}
          float ${funcName}(int batch, int row, int col) {
            return ${funcName}(${getSqueezedParams(params, revDims)});
          }
        `;
            return new GlslLibRoutine(source2, routine.dependencies);
          }
          const texNumR = inputLayout.width;
          const texNumC = inputLayout.height;
          const source = `
          float ${funcName}(int depth, int row, int col) {
            // Explicitly use integer operations as dot() only works on floats.
            int index = depth * ${stride0} + col * ${stride1} + row;
            vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
            return sampleTexture(${name2}, uv);
          }
      `;
          return new GlslLibRoutine(source, [
            "coordinates.uvFromFlat",
            "coordinates.sampleTexture",
            "coordinates.coordsToOffset"
          ]);
        }
        /**
         * Unpacked 4D snippet.
         */
        getUnpackedSampler4D(funcName, name2, inputLayout) {
          const shape2 = inputLayout.unpackedShape;
          const stride2 = shape2[3];
          const stride1 = shape2[2] * stride2;
          const stride0 = shape2[1] * stride1;
          const texNumR = inputLayout.width;
          const texNumC = inputLayout.height;
          const source = `
        float ${funcName}(int row, int col, int depth, int depth2) {
          int index = row * ${stride0} + col * ${stride1} +
              depth2 * ${stride2} + depth;
          vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
          return sampleTexture(${name2}, uv);
        }
      `;
          return new GlslLibRoutine(source, ["coordinates.uvFromFlat", "coordinates.sampleTexture"]);
        }
        /**
         * Unpacked 5D snippet.
         */
        getUnpackedSampler5D(funcName, name2, inputLayout) {
          const shape2 = inputLayout.unpackedShape;
          const stride3 = shape2[4];
          const stride2 = shape2[3] * stride3;
          const stride1 = shape2[2] * stride2;
          const stride0 = shape2[1] * stride1;
          const { newShape, keptDims } = squeezeShape(shape2);
          if (newShape.length < shape2.length) {
            const newInputShape = squeezeInputShape(shape2, newShape);
            const params = ["row", "col", "depth", "depth2", "depth3"];
            const newInputLayout = JSON.parse(JSON.stringify(inputLayout));
            newInputLayout.unpackedShape = newInputShape;
            const source2 = `
          ${this.getUnpackedSamplerFromInput(funcName, name2, newInputLayout).routineBody}
          float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
            return ${funcName}(${getSqueezedParams(params, keptDims)});
          }
        `;
            return new GlslLibRoutine(source2, ["coordinates.sampleTexture", "coordinates.uvFromFlat"]);
          }
          const texNumR = inputLayout.width;
          const texNumC = inputLayout.height;
          const source = `
        float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
          int index = row * ${stride0} + col * ${stride1} + depth * ${stride2} +
          depth3 * ${stride3} + depth2;
          vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
          return sampleTexture(${name2}, uv);
        }
      `;
          return new GlslLibRoutine(source, ["coordinates.sampleTexture", "coordinates.uvFromFlat"]);
        }
        /**
         * Unpacked 6D snippet.
         */
        getUnpackedSampler6D(funcName, name2, inputLayout) {
          const shape2 = inputLayout.unpackedShape;
          const stride4 = shape2[5];
          const stride3 = shape2[4] * stride4;
          const stride2 = shape2[3] * stride3;
          const stride1 = shape2[2] * stride2;
          const stride0 = shape2[1] * stride1;
          const { newShape, keptDims } = squeezeShape(shape2);
          if (newShape.length < shape2.length) {
            const newInputShape = squeezeInputShape(shape2, newShape);
            const params = ["row", "col", "depth", "depth2", "depth3", "depth4"];
            const newInputLayout = JSON.parse(JSON.stringify(inputLayout));
            newInputLayout.unpackedShape = newInputShape;
            const source2 = `
            ${this.getUnpackedSamplerFromInput(funcName, name2, newInputLayout).routineBody}
            float ${funcName}(int row, int col, int depth,
              int depth2, int depth3, int depth4) {
              return ${funcName}(${getSqueezedParams(params, keptDims)});
            }
          `;
            return new GlslLibRoutine(source2, ["coordinates.sampleTexture", "coordinates.uvFromFlat"]);
          }
          const texNumR = inputLayout.width;
          const texNumC = inputLayout.height;
          const source = `
          float ${funcName}(int row, int col, int depth,
            int depth2, int depth3, int depth4) {
            int index = row * ${stride0} + col * ${stride1} + depth * ${stride2} +
            depth2 * ${stride3} + depth3 * ${stride4} + depth4;
            vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
            return sampleTexture(${name2}, uv);
          }
        `;
          return new GlslLibRoutine(source, [
            "coordinates.uvFromFlat",
            "coordinates.sampleTexture",
            "coordinates.coordsToOffset"
          ]);
        }
        /**
         * This is the main function to map from the given texture coordinates (s,t)
         * to logical indices for the output
         * There will only be one single variation of this
         * Also see coordsToOffset and offsetToIndices for input-specific versions
         */
        toVec() {
          const output = this.context.outputTextureLayout;
          const rank = output.shape.length;
          const strides = output.strides;
          const xScale = output.width;
          const yScale = output.height;
          const stridesBlock = [];
          for (let i = 0; i < rank - 1; ++i) {
            stridesBlock.push(`
        c[${i}] = offset / ${strides[i]};`);
            stridesBlock.push(`
        offset -= c[${i}] * ${strides[i]};`);
          }
          stridesBlock.push(`
        c[${rank - 1}] = offset;`);
          const body = `
      void toVec(vec2 texCoords, out int c[${rank}]) {
        int offset = coordsToOffset(texCoords, ${xScale}, ${yScale});
        ${stridesBlock.join("")}
      }
      void toVec(int offset, out int c[${rank}]) {
        ${stridesBlock.join("")}
      }
    `;
          return { toVec: new GlslLibRoutine(body, ["coordinates.coordsToOffset"]) };
        }
        /**
         * These are value getter functions generated for each input
         * Each function is hardwired to the name and dimensions of the input
         * An '_T' variation is also produced which accesses values as if the
         * input was transposed
         */
        valueFrom() {
          const result = {};
          this.context.programInfo.inputNames.forEach((name2, i) => {
            const layout = this.context.inputTextureLayouts[i];
            const shape2 = layout.unpackedShape.length > 0 ? layout.unpackedShape : layout.shape;
            const rank = shape2.length;
            let funcName = `_${name2}`;
            result[funcName] = new GlslLibRoutine(this.getValueFromSingle(name2, rank, layout.width, layout.height, false), [
              `shapeUtils.indicesToOffset${funcName}`,
              "coordinates.offsetToCoords",
              "fragcolor.getColorAsFloat"
            ]);
            funcName = funcName + "_T";
            result[funcName] = new GlslLibRoutine(this.getValueFromSingle(name2, rank, layout.width, layout.height, true), [
              `shapeUtils.indicesToOffset${funcName}`,
              "coordinates.offsetToCoords",
              "fragcolor.getColorAsFloat"
            ]);
          });
          return result;
        }
        /**
         * Produces one value getter function for the name and rank given
         * If a transpose is set proper offsetToCoords mapping will be used
         * @param name name of the function
         * @param rank rank of the input
         * @param transpose whether or not should generate a transpose variation
         */
        getValueFromSingle(varName, rank, width, height, transpose2) {
          let name2 = `_${varName}`;
          if (transpose2) {
            name2 = name2 + "_T";
          }
          const glsl = getGlsl(this.context.glContext.version);
          return `
        float ${name2}(int m[${rank}]) {
          int offset = indicesToOffset${name2}(m);
          vec2 coords = offsetToCoords(offset, ${width}, ${height});
          float value = getColorAsFloat(${glsl.texture2D}(${varName}, coords));
          return value;
        }
        `;
        }
        /**
         * Produces a packed value getter function for the name and rank given
         * If a transpose is set proper offsetToCoords mapping will be used
         * @param name name of the function
         * @param rank rank of the input
         * @param transpose whether or not should generate a transpose variation
         */
        getPackedValueFrom(varName, rank, width, height, transpose2) {
          let name2 = `_${varName}_Pack`;
          if (transpose2) {
            name2 = name2 + "_T";
          }
          const glsl = getGlsl(this.context.glContext.version);
          return `
        vec4 ${name2}(int m[${rank}]) {
          int offset = indicesToOffset_${varName}(m);
          vec2 coords = offsetToCoords(offset, ${width}, ${height});
          return ${glsl.texture2D}(${varName}, coords);
        }
        `;
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/glsl-encoding-lib.ts
  var EncodingGlslLib;
  var init_glsl_encoding_lib = __esm({
    "web/lib/onnxjs/backends/webgl/glsl-encoding-lib.ts"() {
      "use strict";
      init_glsl_definitions();
      EncodingGlslLib = class _EncodingGlslLib extends GlslLib {
        constructor(context) {
          super(context);
        }
        getFunctions() {
          return { ...this.encodeFloat32(), ...this.decodeFloat32() };
        }
        getCustomTypes() {
          return {};
        }
        encodeFloat32() {
          return {
            encode: new GlslLibRoutine(`highp vec4 encode(highp float f) {
        return vec4(f, 0.0, 0.0, 0.0);
      }
        `)
          };
        }
        decodeFloat32() {
          return {
            decode: new GlslLibRoutine(`highp float decode(highp vec4 rgba) {
        return rgba.r;
      }
        `)
          };
        }
        /**
         * returns the routine to encode encode a 32bit float to a vec4 (of unsigned bytes)
         * @credit: https://stackoverflow.com/questions/7059962/how-do-i-convert-a-vec4-rgba-value-to-a-float
         */
        encodeUint8() {
          const endianness = _EncodingGlslLib.isLittleEndian() ? "rgba.rgba=rgba.abgr;" : "";
          return {
            encode: new GlslLibRoutine(`
      highp vec4 encode(highp float f) {
        highp float F = abs(f);
        highp float Sign = step(0.0,-f);
        highp float Exponent = floor(log2(F));
        highp float Mantissa = (exp2(- Exponent) * F);
        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));
        highp vec4 rgba;
        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));
        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);
        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));
        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));
        ${endianness}
        rgba = rgba / 255.0; // values need to be normalized to [0,1]
        return rgba;
    }
        `)
          };
        }
        /**
         * returns the routine to encode a vec4 of unsigned bytes to float32
         * @credit: https://stackoverflow.com/questions/7059962/how-do-i-convert-a-vec4-rgba-value-to-a-float
         */
        decodeUint8() {
          const endianness = _EncodingGlslLib.isLittleEndian() ? "rgba.rgba=rgba.abgr;" : "";
          return {
            decode: new GlslLibRoutine(`
        highp float decode(highp vec4 rgba) {
          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]
          ${endianness}
          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;
          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;
          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);
          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));
          return Result;
      }
        `)
          };
        }
        /**
         * Determines if the machine is little endian or not
         * @credit: https://gist.github.com/TooTallNate/4750953
         */
        static isLittleEndian() {
          const b = new ArrayBuffer(4);
          const a = new Uint32Array(b);
          const c = new Uint8Array(b);
          a[0] = 3735928559;
          if (c[0] === 239) {
            return true;
          }
          if (c[0] === 222) {
            return false;
          }
          throw new Error("unknown endianness");
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/glsl-fragcolor-lib.ts
  var FragColorGlslLib;
  var init_glsl_fragcolor_lib = __esm({
    "web/lib/onnxjs/backends/webgl/glsl-fragcolor-lib.ts"() {
      "use strict";
      init_glsl_definitions();
      init_glsl_source();
      FragColorGlslLib = class extends GlslLib {
        constructor(context) {
          super(context);
        }
        getFunctions() {
          return { ...this.setFragColor(), ...this.getColorAsFloat() };
        }
        getCustomTypes() {
          return {};
        }
        setFragColor() {
          const glsl = getGlsl(this.context.glContext.version);
          return {
            setFragColor: new GlslLibRoutine(
              `
        void setFragColor(float value) {
            ${glsl.output} = encode(value);
        }
        `,
              ["encoding.encode"]
            )
          };
        }
        getColorAsFloat() {
          return {
            getColorAsFloat: new GlslLibRoutine(
              `
        float getColorAsFloat(vec4 color) {
            return decode(color);
        }
        `,
              ["encoding.decode"]
            )
          };
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/glsl-shape-utils-lib.ts
  var ShapeUtilsGlslLib;
  var init_glsl_shape_utils_lib = __esm({
    "web/lib/onnxjs/backends/webgl/glsl-shape-utils-lib.ts"() {
      "use strict";
      init_glsl_definitions();
      ShapeUtilsGlslLib = class _ShapeUtilsGlslLib extends GlslLib {
        constructor(context) {
          super(context);
        }
        getFunctions() {
          return {
            ...this.bcastIndex(),
            ...this.bcastMatmulIndex(),
            ...this.offsetToIndices(),
            ...this.indicesToOffset(),
            ...this.incrementIndices()
          };
        }
        getCustomTypes() {
          return {};
        }
        bcastIndex() {
          const outputRank = this.context.outputTextureLayout.shape.length;
          const result = {};
          this.context.programInfo.inputNames.forEach((name2, i) => {
            const shape2 = this.context.inputTextureLayouts[i].unpackedShape;
            if (shape2.length <= outputRank) {
              const rank = shape2.length;
              const dimOffset = outputRank - rank;
              const funcName = `bcastIndices_${name2}`;
              let block = "";
              for (let i2 = 0; i2 < rank; ++i2) {
                block += `
          realIndices[${i2}] = int( mod(float(bcastedIndices[${dimOffset + i2}]), ${shape2[i2]}.0) );
          `;
              }
              const body = `
        void ${funcName} (int bcastedIndices[${outputRank}], out int realIndices[${rank}]) {
          ${block}
        }
        `;
              result[funcName] = new GlslLibRoutine(body);
            }
          });
          return result;
        }
        bcastMatmulIndex() {
          const outputRank = this.context.outputTextureLayout.shape.length;
          const result = {};
          this.context.programInfo.inputNames.forEach((name2, i) => {
            const shape2 = this.context.inputTextureLayouts[i].shape;
            if (!(shape2.length < 2 || shape2.length > outputRank)) {
              const rank = shape2.length;
              const dimOffset = outputRank - rank;
              const funcName = `bcastMatmulIndices_${name2}`;
              let block = "";
              for (let i2 = 0; i2 < rank - 2; ++i2) {
                block += `
          realIndices[${i2}] = int( mod(float(bcastedIndices[${dimOffset + i2}]), ${shape2[i2]}.0) );
          `;
              }
              const body = `
        void ${funcName}(int bcastedIndices[${outputRank}], out int realIndices[${rank}]) {
          ${block}
          realIndices[${rank - 1}] = bcastedIndices[${outputRank - 1}];
          realIndices[${rank - 2}] = bcastedIndices[${outputRank - 2}];
        }
        `;
              result[funcName] = new GlslLibRoutine(body);
            }
          });
          return result;
        }
        indicesToOffset() {
          const result = {};
          this.context.programInfo.inputNames.forEach((name2, i) => {
            const shape2 = this.context.inputTextureLayouts[i].shape;
            const strides = this.context.inputTextureLayouts[i].strides;
            const rank = shape2.length;
            let funcName = `indicesToOffset_${name2}`;
            result[funcName] = new GlslLibRoutine(_ShapeUtilsGlslLib.indexToOffsetSingle(funcName, rank, strides));
            funcName = `indicesToOffset_${name2}_T`;
            result[funcName] = new GlslLibRoutine(
              _ShapeUtilsGlslLib.indexToOffsetSingle(funcName, rank, strides.slice().reverse())
            );
          });
          return result;
        }
        static indexToOffsetSingle(name2, rank, strides) {
          let block = "";
          for (let i = rank - 1; i >= 0; --i) {
            block += `
        offset += indices[${i}] * ${strides[i]};
        `;
          }
          return `
      int ${name2}(int indices[${rank}]) {
        int offset = 0;
        ${block}
        return offset;
      }
      `;
        }
        offsetToIndices() {
          const result = {};
          this.context.programInfo.inputNames.forEach((name2, i) => {
            const shape2 = this.context.inputTextureLayouts[i].shape;
            const strides = this.context.inputTextureLayouts[i].strides;
            const rank = shape2.length;
            let funcName = `offsetToIndices_${name2}`;
            result[funcName] = new GlslLibRoutine(_ShapeUtilsGlslLib.offsetToIndicesSingle(funcName, rank, strides));
            funcName = `offsetToIndices_${name2}_T`;
            result[funcName] = new GlslLibRoutine(
              _ShapeUtilsGlslLib.offsetToIndicesSingle(funcName, rank, strides.slice().reverse())
            );
          });
          return result;
        }
        static offsetToIndicesSingle(name2, rank, strides) {
          const stridesBlock = [];
          for (let i = 0; i < rank - 1; ++i) {
            stridesBlock.push(`
      indices[${i}] = offset / ${strides[i]};`);
            stridesBlock.push(`
        offset -= indices[${i}] * ${strides[i]};`);
          }
          stridesBlock.push(`
      indices[${rank - 1}] = offset;`);
          return `
      void ${name2}(int offset, out int indices[${rank}]) {
        ${stridesBlock.join("")}
      }
      `;
        }
        incrementIndices() {
          const result = {};
          this.context.programInfo.inputNames.forEach((name2, i) => {
            const shape2 = this.context.inputTextureLayouts[i].shape;
            const rank = shape2.length;
            const funcName = `incrementIndices_${name2}`;
            let shapeInit = "";
            for (let i2 = 0; i2 < rank; ++i2) {
              shapeInit += `
        shape[${i2}] = ${shape2[i2]};`;
            }
            const body = `
        void ${funcName}(int axis, out int indices[${rank}]) {
          int shape[${rank}];
          ${shapeInit};
          for(int i = ${rank} -1 ; i >= 0; --i) {
            if(i > axis) continue;
            indices[i] += 1;
            if(indices[i] < shape[i]) {
              break;
            }
            indices[i] = 0;
          }
        }
        `;
            result[funcName] = new GlslLibRoutine(body);
          });
          return result;
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/glsl-vec-lib.ts
  var VecGlslLib;
  var init_glsl_vec_lib = __esm({
    "web/lib/onnxjs/backends/webgl/glsl-vec-lib.ts"() {
      "use strict";
      init_glsl_definitions();
      VecGlslLib = class extends GlslLib {
        constructor(context) {
          super(context);
        }
        getCustomTypes() {
          return {};
        }
        getFunctions() {
          return { ...this.binaryVecFunctions(), ...this.copyVec(), ...this.setVecItem(), ...this.getVecItem() };
        }
        binaryVecFunctions() {
          const outputLayout = this.context.outputTextureLayout;
          const rank = outputLayout.shape.length;
          const nameOp = { add: "+=", sub: "-=", mul: "*=", div: "/=" };
          const result = {};
          for (const name2 in nameOp) {
            const fname = `${name2}Vec`;
            let assignmentBlock = "";
            for (let i = 0; i < rank; ++i) {
              assignmentBlock += `
          dest[${i}] ${nameOp[name2]} src[${i}];
          `;
            }
            const body = `
        void ${fname}(int src[${rank}], out int dest[${rank}]) {
          ${assignmentBlock}
        }
        `;
            result[fname] = new GlslLibRoutine(body);
          }
          return result;
        }
        copyVec() {
          const outputLayout = this.context.outputTextureLayout;
          const rank = outputLayout.shape.length;
          let assignmentBlock = "";
          for (let i = 0; i < rank; ++i) {
            assignmentBlock += `
        dest[${i}] = src[${i}];
        `;
          }
          const body = `
      void copyVec(int src[${rank}], out int dest[${rank}]) {
        ${assignmentBlock}
      }
      `;
          return { copyVec: new GlslLibRoutine(body) };
        }
        setVecItem() {
          const outputLayout = this.context.outputTextureLayout;
          const rank = outputLayout.shape.length;
          let block = `
        if(index < 0)
            index =${rank} + index;
        if (index == 0)
            m[0] = value;
        `;
          for (let i = 1; i < rank - 1; ++i) {
            block += `
        else if (index == ${i})
            m[${i}] = value;
            `;
          }
          block += `
        else
            m[${rank - 1}] = value;
        `;
          const body = `
      void setVecItem(out int m[${rank}], int index, int value) {
        ${block}
      }
        `;
          return { setVecItem: new GlslLibRoutine(body) };
        }
        getVecItem() {
          const outputLayout = this.context.outputTextureLayout;
          const rank = outputLayout.shape.length;
          let block = `
        if(index < 0)
            index = ${rank} + index;
        if (index == 0)
            return m[0];
      `;
          for (let i = 1; i < rank - 1; ++i) {
            block += `
        else if (index == ${i})
            return m[${i}];
      `;
          }
          block += `
        else
            return m[${rank - 1}];
        `;
          const body = `
      int getVecItem(int m[${rank}], int index) {
        ${block}
      }
    `;
          return { getVecItem: new GlslLibRoutine(body) };
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/glsl-registered-libs.ts
  var glslRegistry;
  var init_glsl_registered_libs = __esm({
    "web/lib/onnxjs/backends/webgl/glsl-registered-libs.ts"() {
      "use strict";
      init_glsl_coordinate_lib();
      init_glsl_encoding_lib();
      init_glsl_fragcolor_lib();
      init_glsl_shape_utils_lib();
      init_glsl_vec_lib();
      glslRegistry = {
        encoding: EncodingGlslLib,
        fragcolor: FragColorGlslLib,
        vec: VecGlslLib,
        shapeUtils: ShapeUtilsGlslLib,
        coordinates: CoordsGlslLib
        //  'arrays': ArrayGlslSLib
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/glsl-preprocessor.ts
  var GlslPreprocessor;
  var init_glsl_preprocessor = __esm({
    "web/lib/onnxjs/backends/webgl/glsl-preprocessor.ts"() {
      "use strict";
      init_glsl_definitions();
      init_glsl_function_inliner();
      init_glsl_registered_libs();
      init_glsl_source();
      GlslPreprocessor = class {
        constructor(glContext, programInfo, inputTextureLayouts, outputTextureLayout) {
          this.libs = {};
          this.glslLibRoutineDependencyGraph = {};
          this.context = new GlslContext(glContext, programInfo, inputTextureLayouts, outputTextureLayout);
          Object.keys(glslRegistry).forEach((name2) => {
            const lib = new glslRegistry[name2](this.context);
            this.libs[name2] = lib;
          });
          const map = this.glslLibRoutineDependencyGraph;
          for (const libName in this.libs) {
            const lib = this.libs[libName];
            const routinesInLib = lib.getFunctions();
            for (const routine in routinesInLib) {
              const key = libName + "." + routine;
              let currentNode;
              if (map[key]) {
                currentNode = map[key];
                currentNode.routineBody = routinesInLib[routine].routineBody;
              } else {
                currentNode = new GlslLibRoutineNode(key, routinesInLib[routine].routineBody);
                map[key] = currentNode;
              }
              const dependencies = routinesInLib[routine].dependencies;
              if (dependencies) {
                for (let i = 0; i < dependencies.length; ++i) {
                  if (!map[dependencies[i]]) {
                    const node = new GlslLibRoutineNode(dependencies[i]);
                    map[dependencies[i]] = node;
                    currentNode.addDependency(node);
                  } else {
                    currentNode.addDependency(map[dependencies[i]]);
                  }
                }
              }
            }
          }
        }
        preprocess() {
          const programInfo = this.context.programInfo;
          let source = programInfo.shaderSource;
          if (!this.context.programInfo.hasMain) {
            source = `${source}
      ${getDefaultFragShaderMain(this.context.glContext.version, this.context.outputTextureLayout.shape.length)}`;
          }
          source = replaceInlines(source);
          return `${getFragShaderPreamble(this.context.glContext.version)}
    ${this.getUniforms(programInfo.inputNames, programInfo.variables)}
    ${this.getImports(source)}
    ${source}`;
        }
        getImports(script) {
          const routinesIncluded = this.selectGlslLibRoutinesToBeIncluded(script);
          if (routinesIncluded.length === 0) {
            return "";
          }
          let routines = "";
          for (let i = 0; i < routinesIncluded.length; ++i) {
            if (routinesIncluded[i].routineBody) {
              routines += routinesIncluded[i].routineBody + "\n";
            } else {
              throw new Error(`Missing body for the Glsl Library routine: ${routinesIncluded[i].name}`);
            }
          }
          return routines;
        }
        selectGlslLibRoutinesToBeIncluded(script) {
          const nodes = [];
          Object.keys(this.glslLibRoutineDependencyGraph).forEach((classAndRoutine) => {
            const routine = classAndRoutine.split(".")[1];
            if (script.indexOf(routine) !== -1) {
              nodes.push(this.glslLibRoutineDependencyGraph[classAndRoutine]);
            }
          });
          return TopologicalSortGlslRoutines.returnOrderedNodes(nodes);
        }
        getUniforms(samplers, variables) {
          const uniformLines = [];
          if (samplers) {
            for (const sampler of samplers) {
              uniformLines.push(`uniform sampler2D ${sampler};`);
            }
          }
          if (variables) {
            for (const variable of variables) {
              uniformLines.push(
                `uniform ${variable.type} ${variable.name}${variable.arrayLength ? `[${variable.arrayLength}]` : ""};`
              );
            }
          }
          return uniformLines.join("\n");
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/program-manager.ts
  var ProgramManager;
  var init_program_manager = __esm({
    "web/lib/onnxjs/backends/webgl/program-manager.ts"() {
      "use strict";
      init_esm();
      init_instrument();
      init_glsl_preprocessor();
      init_glsl_source();
      ProgramManager = class {
        constructor(profiler, glContext, textureLayoutStrategy) {
          this.profiler = profiler;
          this.glContext = glContext;
          this.textureLayoutStrategy = textureLayoutStrategy;
          this.repo = /* @__PURE__ */ new Map();
          this.attributesBound = false;
        }
        getArtifact(key) {
          return this.repo.get(key);
        }
        setArtifact(key, artifact) {
          this.repo.set(key, artifact);
        }
        run(buildArtifact, inputs, output) {
          this.profiler.event(
            "op",
            `ProgramManager.run ${buildArtifact.programInfo.name ?? "unknown kernel"}`,
            () => {
              const gl = this.glContext.gl;
              const program = buildArtifact.program;
              gl.useProgram(program);
              try {
                this.bindOutput(output);
                if (!this.attributesBound) {
                  this.bindAttributes(buildArtifact.attribLocations);
                }
                this.bindUniforms(buildArtifact.uniformLocations, buildArtifact.programInfo.variables ?? [], inputs);
              } catch (err) {
                Logger.error("ProgramManager", buildArtifact.programInfo.shaderSource);
                throw err;
              }
              this.profiler.event("backend", "GlContext.draw()", () => {
                this.glContext.draw();
              });
            },
            this.glContext
          );
        }
        dispose() {
          if (this.vertexShader) {
            this.glContext.deleteShader(this.vertexShader);
          }
          this.repo.forEach((a) => this.glContext.deleteProgram(a.program));
        }
        build(programInfo, inputTextureLayouts, outputTextureLayout) {
          return this.profiler.event("backend", "ProgramManager.build", () => {
            const preprocessor = new GlslPreprocessor(this.glContext, programInfo, inputTextureLayouts, outputTextureLayout);
            const fragScript = preprocessor.preprocess();
            const program = this.compile(fragScript);
            const artifact = {
              programInfo,
              program,
              uniformLocations: this.getUniformLocations(
                program,
                preprocessor.context.programInfo.inputNames,
                preprocessor.context.programInfo.variables
              ),
              attribLocations: this.getAttribLocations(program)
            };
            return artifact;
          });
        }
        compile(fragShaderScript) {
          if (!this.vertexShader) {
            Logger.verbose("ProrgramManager", "Compiling and caching Vertex shader for the first time");
            const vertexShaderScript = getVertexShaderSource(this.glContext.version);
            this.vertexShader = this.glContext.compileShader(vertexShaderScript, this.glContext.gl.VERTEX_SHADER);
          }
          if (env2.debug) {
            Logger.verbose(
              "ProrgramManager",
              `FragShader:
${fragShaderScript}
`
            );
          }
          const fragShader = this.glContext.compileShader(fragShaderScript, this.glContext.gl.FRAGMENT_SHADER);
          const program = this.glContext.createProgram(this.vertexShader, fragShader);
          this.glContext.deleteShader(fragShader);
          return program;
        }
        bindOutput(td) {
          const width = td.width;
          const height = td.height;
          Logger.verbose(
            "ProrgramManager",
            `Binding output texture to Framebuffer: w/h=${width}/${height}, shape=${td.shape}, type=${td.tensor.type}`
          );
          this.glContext.attachFramebuffer(td.texture, width, height);
        }
        bindAttributes(attribLocations) {
          const positionHandle = attribLocations.position;
          const textureCoordHandle = attribLocations.textureCoord;
          this.glContext.setVertexAttributes(positionHandle, textureCoordHandle);
          this.attributesBound = true;
        }
        bindUniforms(uniformLocations, variables, textures) {
          const gl = this.glContext.gl;
          let texturePosition = 0;
          for (const { name: name2, type, location: location2, arrayLength } of uniformLocations) {
            const value = variables.find((v) => v.name === name2)?.data;
            if (type !== "sampler2D" && !value) {
              throw new Error(`variable '${name2}' does not have data defined in program info`);
            }
            switch (type) {
              case "sampler2D":
                this.bindTexture(textures[texturePosition], location2, texturePosition);
                texturePosition++;
                break;
              case "float":
                if (arrayLength) {
                  gl.uniform1fv(location2, value);
                } else {
                  gl.uniform1f(location2, value);
                }
                break;
              case "int":
                if (arrayLength) {
                  gl.uniform1iv(location2, value);
                } else {
                  gl.uniform1i(location2, value);
                }
                break;
              default:
                throw new Error(`Uniform not implemented: ${type}`);
            }
          }
        }
        bindTexture(td, uniformHandle, position) {
          this.glContext.bindTextureToUniform(td.texture, position, uniformHandle);
        }
        getAttribLocations(program) {
          return {
            position: this.getAttribLocation(program, "position"),
            textureCoord: this.getAttribLocation(program, "textureCoord")
          };
        }
        getUniformLocations(program, samplers, variables) {
          const uniformLocations = [];
          if (samplers) {
            for (const sampler of samplers) {
              uniformLocations.push({
                name: sampler,
                type: "sampler2D",
                location: this.getUniformLocation(program, sampler)
              });
            }
          }
          if (variables) {
            for (const variable of variables) {
              uniformLocations.push({ ...variable, location: this.getUniformLocation(program, variable.name) });
            }
          }
          return uniformLocations;
        }
        getUniformLocation(program, name2) {
          const gl = this.glContext.gl;
          const reference = gl.getUniformLocation(program, name2);
          if (reference === null) {
            throw new Error(`Uniform ${name2} not found.`);
          }
          return reference;
        }
        getAttribLocation(program, name2) {
          const gl = this.glContext.gl;
          const attributeLocation = gl.getAttribLocation(program, name2);
          return attributeLocation;
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/texture-manager.ts
  var TextureManager;
  var init_texture_manager = __esm({
    "web/lib/onnxjs/backends/webgl/texture-manager.ts"() {
      "use strict";
      init_instrument();
      init_texture_data_encoder();
      TextureManager = class {
        constructor(glContext, layoutStrategy, profiler, config) {
          this.glContext = glContext;
          this.layoutStrategy = layoutStrategy;
          this.profiler = profiler;
          this.config = config;
          this.pendingRead = /* @__PURE__ */ new Map();
          if (config.reuseTextures) {
            this.inUseTextures = /* @__PURE__ */ new Map();
            this.idleTextures = /* @__PURE__ */ new Map();
            this.textureLookup = /* @__PURE__ */ new Map();
          }
        }
        createTextureFromLayout(dataType, layout, data, usage) {
          const textureDataType = this.toEncoderType(dataType);
          const encoder = this.glContext.getEncoder(textureDataType, layout.channels || 1, usage);
          if (layout.isPacked && usage === 1 /* UploadOnly */) {
            throw new Error("not implemented");
          }
          const width = layout.width;
          const height = layout.height;
          let key;
          let inUseTextures;
          if (this.config.reuseTextures) {
            key = `${width}x${height}_${encoder.format}_${encoder.internalFormat}_${encoder.textureType}`;
            inUseTextures = this.inUseTextures.get(key);
            if (!inUseTextures) {
              inUseTextures = [];
              this.inUseTextures.set(key, inUseTextures);
            }
            const idleTextures = this.idleTextures.get(key);
            if (idleTextures && idleTextures.length > 0) {
              const texture2 = idleTextures.pop();
              inUseTextures.push(texture2);
              if (usage === 1 /* UploadOnly */) {
                this.glContext.updateTexture(texture2, width, height, encoder, this.toTextureData(dataType, data));
              }
              return texture2;
            }
          }
          Logger.verbose("TextureManager", `Creating new texture of size ${layout.width}x${layout.height}`);
          const texture = this.glContext.allocateTexture(width, height, encoder, this.toTextureData(dataType, data));
          if (this.config.reuseTextures) {
            inUseTextures.push(texture);
            this.textureLookup.set(texture, key);
          }
          return texture;
        }
        readTexture(td, dataType, channels) {
          if (!channels) {
            channels = 1;
          }
          return this.profiler.event("backend", "TextureManager.readTexture", () => {
            const dataSize = td.shape.reduce((a, b) => a * b) * channels;
            const data = this.glContext.readTexture(
              td.texture,
              td.width,
              td.height,
              dataSize,
              this.toEncoderType(dataType),
              channels
            );
            return this.toTensorData(dataType, data);
          });
        }
        async readTextureAsync(td, dataType, channels) {
          const dataId = td.tensor.dataId;
          if (!channels) {
            channels = 1;
          }
          if (this.pendingRead.has(dataId)) {
            const subscribers = this.pendingRead.get(dataId);
            return new Promise((resolve) => subscribers?.push(resolve));
          }
          return this.profiler.event("backend", "TextureManager.readTextureAsync", async () => {
            this.pendingRead.set(dataId, []);
            const dataSize = td.shape.reduce((a, b) => a * b) * channels;
            await this.glContext.createAndWaitForFence();
            const data = this.glContext.readTexture(
              td.texture,
              td.width,
              td.height,
              dataSize,
              this.toEncoderType(dataType),
              channels
            );
            const tensorData = this.toTensorData(dataType, data);
            const subscribers = this.pendingRead.get(dataId);
            this.pendingRead.delete(dataId);
            subscribers?.forEach((resolve) => resolve(tensorData));
            return tensorData;
          });
        }
        readUint8TextureAsFloat(td) {
          return this.profiler.event("backend", "TextureManager.readUint8TextureAsFloat", () => {
            const dataSize = td.shape.reduce((a, b) => a * b);
            const data = this.glContext.readTexture(td.texture, td.width, td.height, dataSize * 4, "byte", 4);
            return new Float32Array(data.buffer, data.byteOffset, dataSize);
          });
        }
        releaseTexture(textureData, deleteTexture) {
          let key;
          if (this.config.reuseTextures) {
            key = this.textureLookup.get(textureData.texture);
            if (key) {
              if (deleteTexture) {
                this.textureLookup.delete(key);
              }
              const inUseTextures = this.inUseTextures.get(key);
              if (inUseTextures) {
                const index = inUseTextures.indexOf(textureData.texture);
                if (index !== -1) {
                  inUseTextures.splice(index, 1);
                  let idleTextures = this.idleTextures.get(key);
                  if (!idleTextures) {
                    idleTextures = [];
                    this.idleTextures.set(key, idleTextures);
                  }
                  idleTextures.push(textureData.texture);
                }
              }
            }
          }
          if (!key || deleteTexture) {
            Logger.verbose("TextureManager", `Deleting texture of size ${textureData.width}x${textureData.height}`);
            this.glContext.deleteTexture(textureData.texture);
          }
        }
        toTensorData(dataType, data) {
          switch (dataType) {
            case "int16":
              return data instanceof Int16Array ? data : Int16Array.from(data);
            case "int32":
              return data instanceof Int32Array ? data : Int32Array.from(data);
            case "int8":
              return data instanceof Int8Array ? data : Int8Array.from(data);
            case "uint16":
              return data instanceof Uint16Array ? data : Uint16Array.from(data);
            case "uint32":
              return data instanceof Uint32Array ? data : Uint32Array.from(data);
            case "uint8":
            case "bool":
              return data instanceof Uint8Array ? data : Uint8Array.from(data);
            case "float32":
              return data instanceof Float32Array ? data : Float32Array.from(data);
            case "float64":
              return data instanceof Float64Array ? data : Float64Array.from(data);
            default:
              throw new Error(`TensorData type ${dataType} is not supported`);
          }
        }
        toTextureData(_dataType, data) {
          if (!data) {
            return void 0;
          }
          return data instanceof Float32Array ? data : new Float32Array(data);
        }
        toEncoderType(_dataType) {
          return "float";
        }
        clearActiveTextures() {
          this.glContext.clearActiveTextures();
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/session-handler.ts
  var WebGLSessionHandler;
  var init_session_handler = __esm({
    "web/lib/onnxjs/backends/webgl/session-handler.ts"() {
      "use strict";
      init_instrument();
      init_opset();
      init_inference_handler();
      init_op_resolve_rules();
      init_program_manager();
      init_texture_layout_strategy();
      init_texture_manager();
      WebGLSessionHandler = class {
        constructor(backend2, context) {
          this.backend = backend2;
          this.context = context;
          this.layoutStrategy = new PreferLogicalStrategy(backend2.glContext.maxTextureSize);
          this.programManager = new ProgramManager(this.context.profiler, backend2.glContext, this.layoutStrategy);
          this.textureManager = new TextureManager(backend2.glContext, this.layoutStrategy, this.context.profiler, {
            reuseTextures: backend2.textureCacheMode === "full"
          });
          this.packedTextureDataCache = /* @__PURE__ */ new Map();
          this.unpackedTextureDataCache = /* @__PURE__ */ new Map();
          this.pack = backend2.pack;
          this.pack2unpackMap = /* @__PURE__ */ new Map();
          this.unpack2packMap = /* @__PURE__ */ new Map();
        }
        createInferenceHandler() {
          return new WebGLInferenceHandler(this);
        }
        onGraphInitialized(graph) {
          const initializers = graph.getValues().filter((v) => v.from === -1 && v.tensor).map((v) => v.tensor.dataId);
          this.initializers = new Set(initializers);
        }
        isInitializer(tensorId) {
          return this.initializers ? this.initializers.has(tensorId) : false;
        }
        addInitializer(tensorId) {
          this.initializers.add(tensorId);
        }
        getTextureData(tensorId, isPacked) {
          if (isPacked) {
            return this.packedTextureDataCache.get(tensorId);
          } else {
            return this.unpackedTextureDataCache.get(tensorId);
          }
        }
        setTextureData(tensorId, textureData, isPacked = false) {
          Logger.verbose("WebGLSessionHandler", "Storing Texture data in cache");
          if (isPacked) {
            this.packedTextureDataCache.set(tensorId, textureData);
          } else {
            this.unpackedTextureDataCache.set(tensorId, textureData);
          }
        }
        dispose() {
          this.programManager.dispose();
          this.textureManager.clearActiveTextures();
          this.packedTextureDataCache.forEach((td) => this.textureManager.releaseTexture(td, true));
          this.packedTextureDataCache = /* @__PURE__ */ new Map();
          this.unpackedTextureDataCache.forEach((td) => this.textureManager.releaseTexture(td, true));
          this.unpackedTextureDataCache = /* @__PURE__ */ new Map();
        }
        resolve(node, opsets, graph) {
          const op = resolveOperator(node, opsets, WEBGL_OP_RESOLVE_RULES);
          return { impl: op.opImpl, context: op.opInit ? op.opInit(node, graph) : node };
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/webgl-context.ts
  function linearSearchLastTrue(arr) {
    let i = 0;
    for (; i < arr.length; ++i) {
      const isDone = arr[i]();
      if (!isDone) {
        break;
      }
    }
    return i - 1;
  }
  var WebGLContext;
  var init_webgl_context = __esm({
    "web/lib/onnxjs/backends/webgl/webgl-context.ts"() {
      "use strict";
      init_esm();
      init_texture_data_encoder();
      init_texture_data_encoder();
      init_utils();
      WebGLContext = class {
        constructor(gl, version3) {
          this.frameBufferBound = false;
          this.itemsToPoll = [];
          this.gl = gl;
          this.version = version3;
          this.getExtensions();
          this.vertexbuffer = this.createVertexbuffer();
          this.framebuffer = this.createFramebuffer();
          this.queryVitalParameters();
        }
        allocateTexture(width, height, encoder, data) {
          const gl = this.gl;
          const texture = gl.createTexture();
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
          const buffer = data ? encoder.encode(data, width * height) : null;
          gl.texImage2D(
            gl.TEXTURE_2D,
            0,
            // Level of detail.
            encoder.internalFormat,
            width,
            height,
            0,
            // Always 0 in OpenGL ES.
            encoder.format,
            encoder.textureType,
            buffer
          );
          this.checkError();
          return texture;
        }
        updateTexture(texture, width, height, encoder, data) {
          const gl = this.gl;
          gl.bindTexture(gl.TEXTURE_2D, texture);
          const buffer = encoder.encode(data, width * height);
          gl.texSubImage2D(
            gl.TEXTURE_2D,
            0,
            // level
            0,
            // xoffset
            0,
            // yoffset
            width,
            height,
            encoder.format,
            encoder.textureType,
            buffer
          );
          this.checkError();
        }
        attachFramebuffer(texture, width, height) {
          const gl = this.gl;
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
          this.checkError();
          gl.viewport(0, 0, width, height);
          gl.scissor(0, 0, width, height);
        }
        readTexture(texture, width, height, dataSize, dataType, channels) {
          const gl = this.gl;
          if (!channels) {
            channels = 1;
          }
          if (!this.frameBufferBound) {
            this.attachFramebuffer(texture, width, height);
          }
          const encoder = this.getEncoder(dataType, channels);
          const buffer = encoder.allocate(width * height);
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
          gl.readPixels(0, 0, width, height, gl.RGBA, encoder.textureType, buffer);
          this.checkError();
          return encoder.decode(buffer, dataSize);
        }
        isFramebufferReady() {
          return true;
        }
        getActiveTexture() {
          const gl = this.gl;
          const n = gl.getParameter(this.gl.ACTIVE_TEXTURE);
          return `TEXTURE${n - gl.TEXTURE0}`;
        }
        getTextureBinding() {
          return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D);
        }
        getFramebufferBinding() {
          return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING);
        }
        setVertexAttributes(positionHandle, textureCoordHandle) {
          const gl = this.gl;
          gl.vertexAttribPointer(positionHandle, 3, gl.FLOAT, false, 20, 0);
          gl.enableVertexAttribArray(positionHandle);
          if (textureCoordHandle !== -1) {
            gl.vertexAttribPointer(textureCoordHandle, 2, gl.FLOAT, false, 20, 12);
            gl.enableVertexAttribArray(textureCoordHandle);
          }
          this.checkError();
        }
        createProgram(vertexShader, fragShader) {
          const gl = this.gl;
          const program = gl.createProgram();
          gl.attachShader(program, vertexShader);
          gl.attachShader(program, fragShader);
          gl.linkProgram(program);
          return program;
        }
        compileShader(shaderSource, shaderType) {
          const gl = this.gl;
          const shader = gl.createShader(shaderType);
          if (!shader) {
            throw new Error(`createShader() returned null with type ${shaderType}`);
          }
          gl.shaderSource(shader, shaderSource);
          gl.compileShader(shader);
          if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) === false) {
            throw new Error(`Failed to compile shader: ${gl.getShaderInfoLog(shader)}
Shader source:
${shaderSource}`);
          }
          return shader;
        }
        deleteShader(shader) {
          this.gl.deleteShader(shader);
        }
        bindTextureToUniform(texture, position, uniformHandle) {
          const gl = this.gl;
          gl.activeTexture(gl.TEXTURE0 + position);
          this.checkError();
          gl.bindTexture(gl.TEXTURE_2D, texture);
          this.checkError();
          gl.uniform1i(uniformHandle, position);
          this.checkError();
        }
        draw() {
          this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
          this.checkError();
        }
        checkError() {
          if (env2.debug) {
            const gl = this.gl;
            const error = gl.getError();
            let label = "";
            switch (error) {
              case gl.NO_ERROR:
                return;
              case gl.INVALID_ENUM:
                label = "INVALID_ENUM";
                break;
              case gl.INVALID_VALUE:
                label = "INVALID_VALUE";
                break;
              case gl.INVALID_OPERATION:
                label = "INVALID_OPERATION";
                break;
              case gl.INVALID_FRAMEBUFFER_OPERATION:
                label = "INVALID_FRAMEBUFFER_OPERATION";
                break;
              case gl.OUT_OF_MEMORY:
                label = "OUT_OF_MEMORY";
                break;
              case gl.CONTEXT_LOST_WEBGL:
                label = "CONTEXT_LOST_WEBGL";
                break;
              default:
                label = `Unknown WebGL Error: ${error.toString(16)}`;
            }
            throw new Error(label);
          }
        }
        deleteTexture(texture) {
          this.gl.deleteTexture(texture);
        }
        deleteProgram(program) {
          this.gl.deleteProgram(program);
        }
        getEncoder(dataType, channels, usage = 0 /* Default */) {
          if (this.version === 2) {
            return new RedFloat32DataEncoder(this.gl, channels);
          }
          switch (dataType) {
            case "float":
              if (usage === 1 /* UploadOnly */ || this.isRenderFloat32Supported) {
                return new RGBAFloatDataEncoder(this.gl, channels);
              } else {
                return new RGBAFloatDataEncoder(
                  this.gl,
                  channels,
                  this.textureHalfFloatExtension.HALF_FLOAT_OES
                );
              }
            case "int":
              throw new Error("not implemented");
            case "byte":
              return new Uint8DataEncoder(this.gl, channels);
            default:
              throw new Error(`Invalid dataType: ${dataType}`);
          }
        }
        clearActiveTextures() {
          const gl = this.gl;
          for (let unit = 0; unit < this.maxTextureImageUnits; ++unit) {
            gl.activeTexture(gl.TEXTURE0 + unit);
            gl.bindTexture(gl.TEXTURE_2D, null);
          }
        }
        dispose() {
          if (this.disposed) {
            return;
          }
          const gl = this.gl;
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
          gl.deleteFramebuffer(this.framebuffer);
          gl.bindBuffer(gl.ARRAY_BUFFER, null);
          gl.deleteBuffer(this.vertexbuffer);
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
          gl.finish();
          this.disposed = true;
        }
        createDefaultGeometry() {
          return new Float32Array([
            -1,
            1,
            0,
            0,
            1,
            // upper left
            -1,
            -1,
            0,
            0,
            0,
            // lower left
            1,
            1,
            0,
            1,
            1,
            // upper right
            1,
            -1,
            0,
            1,
            0
            // lower right
          ]);
        }
        createVertexbuffer() {
          const gl = this.gl;
          const buffer = gl.createBuffer();
          if (!buffer) {
            throw new Error("createBuffer() returned null");
          }
          const geometry = this.createDefaultGeometry();
          gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
          gl.bufferData(gl.ARRAY_BUFFER, geometry, gl.STATIC_DRAW);
          this.checkError();
          return buffer;
        }
        createFramebuffer() {
          const fb = this.gl.createFramebuffer();
          if (!fb) {
            throw new Error("createFramebuffer returned null");
          }
          return fb;
        }
        queryVitalParameters() {
          const gl = this.gl;
          this.isFloatTextureAttachableToFrameBuffer = this.checkFloatTextureAttachableToFrameBuffer();
          this.isRenderFloat32Supported = this.checkRenderFloat32();
          this.isFloat32DownloadSupported = this.checkFloat32Download();
          if (this.version === 1 && !this.textureHalfFloatExtension && !this.isRenderFloat32Supported) {
            throw new Error("both float32 and float16 TextureType are not supported");
          }
          this.isBlendSupported = !this.isRenderFloat32Supported || this.checkFloat32Blend();
          this.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
          this.maxTextureImageUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
          if (this.version === 2) {
          }
        }
        getExtensions() {
          if (this.version === 2) {
            this.colorBufferFloatExtension = this.gl.getExtension("EXT_color_buffer_float");
            this.disjointTimerQueryWebgl2Extension = this.gl.getExtension("EXT_disjoint_timer_query_webgl2");
          } else {
            this.textureFloatExtension = this.gl.getExtension("OES_texture_float");
            this.textureHalfFloatExtension = this.gl.getExtension("OES_texture_half_float");
          }
        }
        checkFloatTextureAttachableToFrameBuffer() {
          const gl = this.gl;
          const texture = gl.createTexture();
          gl.bindTexture(gl.TEXTURE_2D, texture);
          const internalFormat = this.version === 2 ? gl.RGBA32F : gl.RGBA;
          gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 1, 1, 0, gl.RGBA, gl.FLOAT, null);
          const frameBuffer = gl.createFramebuffer();
          gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
          const isComplete = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;
          gl.bindTexture(gl.TEXTURE_2D, null);
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
          gl.deleteTexture(texture);
          gl.deleteFramebuffer(frameBuffer);
          return isComplete;
        }
        checkRenderFloat32() {
          if (this.version === 2) {
            if (!this.colorBufferFloatExtension) {
              return false;
            }
          } else {
            if (!this.textureFloatExtension) {
              return false;
            }
          }
          return this.isFloatTextureAttachableToFrameBuffer;
        }
        checkFloat32Download() {
          if (this.version === 2) {
            if (!this.colorBufferFloatExtension) {
              return false;
            }
          } else {
            if (!this.textureFloatExtension) {
              return false;
            }
            if (!this.gl.getExtension("WEBGL_color_buffer_float")) {
              return false;
            }
          }
          return this.isFloatTextureAttachableToFrameBuffer;
        }
        /**
         * Check whether GL_BLEND is supported
         */
        checkFloat32Blend() {
          const gl = this.gl;
          let texture;
          let frameBuffer;
          let vertexShader;
          let fragmentShader;
          let program;
          try {
            texture = gl.createTexture();
            frameBuffer = gl.createFramebuffer();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            const internalFormat = this.version === 2 ? gl.RGBA32F : gl.RGBA;
            gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 1, 1, 0, gl.RGBA, gl.FLOAT, null);
            gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
            gl.enable(gl.BLEND);
            vertexShader = gl.createShader(gl.VERTEX_SHADER);
            if (!vertexShader) {
              return false;
            }
            gl.shaderSource(vertexShader, "void main(){}");
            gl.compileShader(vertexShader);
            fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            if (!fragmentShader) {
              return false;
            }
            gl.shaderSource(fragmentShader, "precision highp float;void main(){gl_FragColor=vec4(0.5);}");
            gl.compileShader(fragmentShader);
            program = gl.createProgram();
            if (!program) {
              return false;
            }
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            gl.useProgram(program);
            gl.drawArrays(gl.POINTS, 0, 1);
            return gl.getError() === gl.NO_ERROR;
          } finally {
            gl.disable(gl.BLEND);
            if (program) {
              gl.deleteProgram(program);
            }
            if (vertexShader) {
              gl.deleteShader(vertexShader);
            }
            if (fragmentShader) {
              gl.deleteShader(fragmentShader);
            }
            if (frameBuffer) {
              gl.bindFramebuffer(gl.FRAMEBUFFER, null);
              gl.deleteFramebuffer(frameBuffer);
            }
            if (texture) {
              gl.bindTexture(gl.TEXTURE_2D, null);
              gl.deleteTexture(texture);
            }
          }
        }
        beginTimer() {
          if (this.version === 2 && this.disjointTimerQueryWebgl2Extension) {
            const gl2 = this.gl;
            const ext = this.disjointTimerQueryWebgl2Extension;
            const query = gl2.createQuery();
            gl2.beginQuery(ext.TIME_ELAPSED_EXT, query);
            return query;
          } else {
            throw new Error("WebGL1 profiling currently not supported.");
          }
        }
        endTimer() {
          if (this.version === 2 && this.disjointTimerQueryWebgl2Extension) {
            const gl2 = this.gl;
            const ext = this.disjointTimerQueryWebgl2Extension;
            gl2.endQuery(ext.TIME_ELAPSED_EXT);
            return;
          } else {
            throw new Error("WebGL1 profiling currently not supported");
          }
        }
        isTimerResultAvailable(query) {
          let available = false, disjoint = false;
          if (this.version === 2 && this.disjointTimerQueryWebgl2Extension) {
            const gl2 = this.gl;
            const ext = this.disjointTimerQueryWebgl2Extension;
            available = gl2.getQueryParameter(query, gl2.QUERY_RESULT_AVAILABLE);
            disjoint = gl2.getParameter(ext.GPU_DISJOINT_EXT);
          } else {
            throw new Error("WebGL1 profiling currently not supported");
          }
          return available && !disjoint;
        }
        getTimerResult(query) {
          let timeElapsed = 0;
          if (this.version === 2) {
            const gl2 = this.gl;
            timeElapsed = gl2.getQueryParameter(query, gl2.QUERY_RESULT);
            gl2.deleteQuery(query);
          } else {
            throw new Error("WebGL1 profiling currently not supported");
          }
          return timeElapsed / 1e6;
        }
        async waitForQueryAndGetTime(query) {
          await repeatedTry(() => this.isTimerResultAvailable(query));
          return this.getTimerResult(query);
        }
        async createAndWaitForFence() {
          const fenceContext = this.createFence(this.gl);
          return this.pollFence(fenceContext);
        }
        createFence(gl) {
          let isFencePassed;
          const gl2 = gl;
          const query = gl2.fenceSync(gl2.SYNC_GPU_COMMANDS_COMPLETE, 0);
          gl.flush();
          if (query === null) {
            isFencePassed = () => true;
          } else {
            isFencePassed = () => {
              const status = gl2.clientWaitSync(query, 0, 0);
              return status === gl2.ALREADY_SIGNALED || status === gl2.CONDITION_SATISFIED;
            };
          }
          return { query, isFencePassed };
        }
        async pollFence(fenceContext) {
          return new Promise((resolve) => {
            void this.addItemToPoll(
              () => fenceContext.isFencePassed(),
              () => resolve()
            );
          });
        }
        pollItems() {
          const index = linearSearchLastTrue(this.itemsToPoll.map((x) => x.isDoneFn));
          for (let i = 0; i <= index; ++i) {
            const { resolveFn } = this.itemsToPoll[i];
            resolveFn();
          }
          this.itemsToPoll = this.itemsToPoll.slice(index + 1);
        }
        async addItemToPoll(isDoneFn, resolveFn) {
          this.itemsToPoll.push({ isDoneFn, resolveFn });
          if (this.itemsToPoll.length > 1) {
            return;
          }
          await repeatedTry(() => {
            this.pollItems();
            return this.itemsToPoll.length === 0;
          });
        }
      };
    }
  });

  // web/lib/onnxjs/backends/webgl/webgl-context-factory.ts
  function createWebGLContext(contextId) {
    let context;
    if ((!contextId || contextId === "webgl2") && "webgl2" in cache) {
      context = cache.webgl2;
    } else if ((!contextId || contextId === "webgl") && "webgl" in cache) {
      context = cache.webgl;
    }
    if (!context) {
      try {
        const offscreenCanvas = createOffscreenCanvas();
        context = createNewWebGLContext(offscreenCanvas, contextId);
      } catch (e) {
        const canvas = createCanvas();
        context = createNewWebGLContext(canvas, contextId);
      }
    }
    contextId = contextId || context.version === 1 ? "webgl" : "webgl2";
    const gl = context.gl;
    cache[contextId] = context;
    if (gl.isContextLost()) {
      delete cache[contextId];
      return createWebGLContext(contextId);
    }
    gl.disable(gl.DEPTH_TEST);
    gl.disable(gl.STENCIL_TEST);
    gl.disable(gl.BLEND);
    gl.disable(gl.DITHER);
    gl.disable(gl.POLYGON_OFFSET_FILL);
    gl.disable(gl.SAMPLE_COVERAGE);
    gl.enable(gl.SCISSOR_TEST);
    gl.enable(gl.CULL_FACE);
    gl.cullFace(gl.BACK);
    return context;
  }
  function createNewWebGLContext(canvas, contextId) {
    const contextAttributes = {
      alpha: false,
      depth: false,
      antialias: false,
      stencil: false,
      preserveDrawingBuffer: false,
      premultipliedAlpha: false,
      failIfMajorPerformanceCaveat: false
    };
    let gl;
    const ca = contextAttributes;
    if (!contextId || contextId === "webgl2") {
      gl = canvas.getContext("webgl2", ca);
      if (gl) {
        try {
          return new WebGLContext(gl, 2);
        } catch (err) {
          Logger.warning("GlContextFactory", `failed to create WebGLContext using contextId 'webgl2'. Error: ${err}`);
        }
      }
    }
    if (!contextId || contextId === "webgl") {
      gl = canvas.getContext("webgl", ca) || canvas.getContext("experimental-webgl", ca);
      if (gl) {
        try {
          return new WebGLContext(gl, 1);
        } catch (err) {
          Logger.warning(
            "GlContextFactory",
            `failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${err}`
          );
        }
      }
    }
    throw new Error("WebGL is not supported");
  }
  function createCanvas() {
    if (typeof document === "undefined") {
      throw new TypeError("failed to create canvas: document is not supported");
    }
    const canvas = document.createElement("canvas");
    canvas.width = 1;
    canvas.height = 1;
    return canvas;
  }
  function createOffscreenCanvas() {
    if (typeof OffscreenCanvas === "undefined") {
      throw new TypeError("failed to create offscreen canvas: OffscreenCanvas is not supported");
    }
    return new OffscreenCanvas(1, 1);
  }
  var cache;
  var init_webgl_context_factory = __esm({
    "web/lib/onnxjs/backends/webgl/webgl-context-factory.ts"() {
      "use strict";
      init_instrument();
      init_webgl_context();
      cache = {};
    }
  });

  // web/lib/onnxjs/backends/backend-webgl.ts
  var WebGLBackend;
  var init_backend_webgl = __esm({
    "web/lib/onnxjs/backends/backend-webgl.ts"() {
      "use strict";
      init_esm();
      init_instrument();
      init_session_handler();
      init_webgl_context_factory();
      WebGLBackend = class {
        get contextId() {
          return env2.webgl.contextId;
        }
        set contextId(value) {
          env2.webgl.contextId = value;
        }
        get matmulMaxBatchSize() {
          return env2.webgl.matmulMaxBatchSize;
        }
        set matmulMaxBatchSize(value) {
          env2.webgl.matmulMaxBatchSize = value;
        }
        get textureCacheMode() {
          return env2.webgl.textureCacheMode;
        }
        set textureCacheMode(value) {
          env2.webgl.textureCacheMode = value;
        }
        get pack() {
          return env2.webgl.pack;
        }
        set pack(value) {
          env2.webgl.pack = value;
        }
        get async() {
          return env2.webgl.async;
        }
        set async(value) {
          env2.webgl.async = value;
        }
        initialize() {
          try {
            this.glContext = createWebGLContext(this.contextId);
            if (typeof this.matmulMaxBatchSize !== "number") {
              this.matmulMaxBatchSize = 16;
            }
            if (typeof this.textureCacheMode !== "string") {
              this.textureCacheMode = "full";
            }
            if (typeof this.pack !== "boolean") {
              this.pack = false;
            }
            if (typeof this.async !== "boolean") {
              this.async = false;
            }
            Logger.setWithEnv(env2);
            if (!env2.webgl.context) {
              Object.defineProperty(env2.webgl, "context", { value: this.glContext.gl });
            }
            Logger.verbose(
              "WebGLBackend",
              `Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`
            );
            return true;
          } catch (e) {
            Logger.warning("WebGLBackend", `Unable to initialize WebGLBackend. ${e}`);
            return false;
          }
        }
        createSessionHandler(context) {
          return new WebGLSessionHandler(this, context);
        }
        dispose() {
          this.glContext.dispose();
        }
      };
    }
  });

  // web/lib/onnxjs/backend.ts
  async function resolveBackend(hint) {
    if (!hint) {
      return resolveBackend(["webgl"]);
    } else {
      const hints = typeof hint === "string" ? [hint] : hint;
      for (const backendHint of hints) {
        const cache2 = backendsCache.get(backendHint);
        if (cache2) {
          return cache2;
        }
        const backend2 = await tryLoadBackend(backendHint);
        if (backend2) {
          return backend2;
        }
      }
    }
    throw new Error("no available backend to use");
  }
  async function tryLoadBackend(backendHint) {
    const backendObj = backend;
    if (typeof backendObj[backendHint] !== "undefined" && isBackend(backendObj[backendHint])) {
      const backend2 = backendObj[backendHint];
      let init = backend2.initialize();
      if (typeof init === "object" && "then" in init) {
        init = await init;
      }
      if (init) {
        backendsCache.set(backendHint, backend2);
        return backend2;
      }
    }
    return void 0;
  }
  function isBackend(obj) {
    const o = obj;
    if ("initialize" in o && typeof o.initialize === "function" && // initialize()
    "createSessionHandler" in o && typeof o.createSessionHandler === "function" && // createSessionHandler()
    "dispose" in o && typeof o.dispose === "function") {
      return true;
    }
    return false;
  }
  var backendsCache, backend;
  var init_backend2 = __esm({
    "web/lib/onnxjs/backend.ts"() {
      "use strict";
      init_backend_webgl();
      backendsCache = /* @__PURE__ */ new Map();
      backend = {
        webgl: new WebGLBackend()
      };
    }
  });

  // web/lib/onnxjs/execution-plan.ts
  var KernelOp, ExecutionPlan;
  var init_execution_plan = __esm({
    "web/lib/onnxjs/execution-plan.ts"() {
      "use strict";
      init_instrument();
      KernelOp = class {
        constructor(op, node) {
          this.op = op;
          this.node = node;
        }
      };
      ExecutionPlan = class {
        constructor(graph, ops, profiler) {
          this.graph = graph;
          this.profiler = profiler;
          this.initialize(ops);
        }
        initialize(ops) {
          this.profiler.event("session", "ExecutionPlan.initialize", () => {
            const graphNodes = this.graph.getNodes();
            if (graphNodes.length !== ops.length) {
              throw new Error("The size of nodes and OPs do not match.");
            }
            this._ops = ops.map((op, i) => new KernelOp(op, graphNodes[i]));
            this.reset();
            this._starter = [];
            this._ops.forEach((op, i) => {
              let resolved = true;
              for (const input of op.node.inputs) {
                if (!this._values[input] && // not an initialized input
                this.graph.getInputIndices().indexOf(input) === -1) {
                  resolved = false;
                  break;
                }
              }
              if (resolved) {
                this._starter.push(i);
              }
            });
          });
        }
        reset() {
          this._values = this.graph.getValues().map((i) => i.tensor);
        }
        async execute(sessionHandler, modelInputs) {
          return this.profiler.event("session", "ExecutionPlan.execute", async () => {
            this.reset();
            const inferenceHandler = sessionHandler.createInferenceHandler();
            const graphInputs = this.graph.getInputIndices();
            if (modelInputs.length !== graphInputs.length) {
              throw new Error(
                `number of input tensors don't match the number of inputs to the model: actual: ${modelInputs.length} expected: ${graphInputs.length}`
              );
            }
            modelInputs.forEach((input, i) => {
              const index = graphInputs[i];
              this._values[index] = input;
            });
            const sequence = this._starter.slice(0);
            const graphValues = this.graph.getValues();
            const graphNodes = this.graph.getNodes();
            let rear = 0;
            while (rear < sequence.length) {
              const thisOpIndex = sequence[rear++];
              const thisOp = this._ops[thisOpIndex];
              const inputList = thisOp.node.inputs.map((i) => this._values[i]);
              if (inputList.indexOf(void 0) !== -1) {
                throw new Error(`unresolved input detected: op: ${thisOp.node}`);
              }
              const inputTensors = inputList;
              Logger.verbose(
                "ExecPlan",
                `Running op:${thisOp.node.name} (${inputTensors.map((t, i) => `'${thisOp.node.inputs[i]}': ${t.type}[${t.dims.join(",")}]`).join(", ")})`
              );
              const outputList = await this.profiler.event(
                "node",
                thisOp.node.name,
                async () => thisOp.op.impl(inferenceHandler, inputTensors, thisOp.op.context)
              );
              if (outputList.length !== thisOp.node.outputs.length) {
                throw new Error("the size of output does not match model definition.");
              }
              outputList.forEach((output2, i) => {
                const j = thisOp.node.outputs[i];
                if (this._values[j]) {
                  throw new Error(`output [${j}] already has value: op:${thisOp.node.name}`);
                }
                this._values[j] = output2;
              });
              const downstreamNodes = /* @__PURE__ */ new Set();
              outputList.forEach((_output, i) => {
                const j = thisOp.node.outputs[i];
                for (const currentDownstreamNodeIndex of graphValues[j].to) {
                  const currentDownstreamNode = graphNodes[currentDownstreamNodeIndex];
                  let resolved = true;
                  for (const k of currentDownstreamNode.inputs) {
                    if (!this._values[k]) {
                      resolved = false;
                      break;
                    }
                  }
                  if (resolved) {
                    downstreamNodes.add(currentDownstreamNodeIndex);
                  }
                }
              });
              sequence.push(...downstreamNodes);
            }
            const output = [];
            for (let i = 0; i < this.graph.getOutputIndices().length; i++) {
              const outputIndex = this.graph.getOutputIndices()[i];
              const outputTensor = this._values[outputIndex];
              if (outputTensor === void 0) {
                throw new Error(`required output [${outputIndex}] does not have value`);
              }
              if (outputIndex === 0) {
                await outputTensor.getData();
              } else {
                outputTensor.data;
              }
              output.push(outputTensor);
            }
            Logger.verbose("ExecPlan", "disposing of inferenceHandler");
            inferenceHandler.dispose();
            return output;
          });
        }
      };
    }
  });

  // web/lib/onnxjs/attribute.ts
  var import_onnx3, ortFbs2, Attribute;
  var init_attribute = __esm({
    "web/lib/onnxjs/attribute.ts"() {
      "use strict";
      init_ort_generated();
      import_onnx3 = __toESM(require_onnx());
      init_tensor2();
      init_util();
      ortFbs2 = onnxruntime.experimental.fbs;
      Attribute = class _Attribute {
        constructor(attributes) {
          this._attributes = /* @__PURE__ */ new Map();
          if (attributes !== null && attributes !== void 0) {
            for (const attr of attributes) {
              if (attr instanceof import_onnx3.onnx.AttributeProto) {
                this._attributes.set(attr.name, [_Attribute.getValue(attr), _Attribute.getType(attr)]);
              } else if (attr instanceof ortFbs2.Attribute) {
                this._attributes.set(attr.name(), [_Attribute.getValue(attr), _Attribute.getType(attr)]);
              }
            }
            if (this._attributes.size < attributes.length) {
              throw new Error("duplicated attribute names");
            }
          }
        }
        set(key, type, value) {
          this._attributes.set(key, [value, type]);
        }
        delete(key) {
          this._attributes.delete(key);
        }
        getFloat(key, defaultValue) {
          return this.get(key, "float", defaultValue);
        }
        getInt(key, defaultValue) {
          return this.get(key, "int", defaultValue);
        }
        getString(key, defaultValue) {
          return this.get(key, "string", defaultValue);
        }
        getTensor(key, defaultValue) {
          return this.get(key, "tensor", defaultValue);
        }
        getFloats(key, defaultValue) {
          return this.get(key, "floats", defaultValue);
        }
        getInts(key, defaultValue) {
          return this.get(key, "ints", defaultValue);
        }
        getStrings(key, defaultValue) {
          return this.get(key, "strings", defaultValue);
        }
        getTensors(key, defaultValue) {
          return this.get(key, "tensors", defaultValue);
        }
        get(key, type, defaultValue) {
          const valueAndType = this._attributes.get(key);
          if (valueAndType === void 0) {
            if (defaultValue !== void 0) {
              return defaultValue;
            }
            throw new Error(`required attribute not found: ${key}`);
          }
          if (valueAndType[1] !== type) {
            throw new Error(`type mismatch: expected ${type} but got ${valueAndType[1]}`);
          }
          return valueAndType[0];
        }
        static getType(attr) {
          const type = attr instanceof import_onnx3.onnx.AttributeProto ? attr.type : attr.type();
          switch (type) {
            case import_onnx3.onnx.AttributeProto.AttributeType.FLOAT:
              return "float";
            case import_onnx3.onnx.AttributeProto.AttributeType.INT:
              return "int";
            case import_onnx3.onnx.AttributeProto.AttributeType.STRING:
              return "string";
            case import_onnx3.onnx.AttributeProto.AttributeType.TENSOR:
              return "tensor";
            case import_onnx3.onnx.AttributeProto.AttributeType.FLOATS:
              return "floats";
            case import_onnx3.onnx.AttributeProto.AttributeType.INTS:
              return "ints";
            case import_onnx3.onnx.AttributeProto.AttributeType.STRINGS:
              return "strings";
            case import_onnx3.onnx.AttributeProto.AttributeType.TENSORS:
              return "tensors";
            default:
              throw new Error(`attribute type is not supported yet: ${import_onnx3.onnx.AttributeProto.AttributeType[type]}`);
          }
        }
        static getValue(attr) {
          const attrType = attr instanceof import_onnx3.onnx.AttributeProto ? attr.type : attr.type();
          if (attrType === import_onnx3.onnx.AttributeProto.AttributeType.GRAPH || attrType === import_onnx3.onnx.AttributeProto.AttributeType.GRAPHS) {
            throw new Error("graph attribute is not supported yet");
          }
          const value = this.getValueNoCheck(attr);
          if (attrType === import_onnx3.onnx.AttributeProto.AttributeType.INT && LongUtil.isLong(value)) {
            return LongUtil.longToNumber(value);
          }
          if (attrType === import_onnx3.onnx.AttributeProto.AttributeType.INTS) {
            const arr = value;
            const numberValue = new Array(arr.length);
            for (let i = 0; i < arr.length; i++) {
              const maybeLong = arr[i];
              numberValue[i] = LongUtil.longToNumber(maybeLong);
            }
            return numberValue;
          }
          if (attrType === import_onnx3.onnx.AttributeProto.AttributeType.TENSOR) {
            return attr instanceof import_onnx3.onnx.AttributeProto ? Tensor3.fromProto(value) : Tensor3.fromOrtTensor(value);
          }
          if (attrType === import_onnx3.onnx.AttributeProto.AttributeType.TENSORS) {
            if (attr instanceof import_onnx3.onnx.AttributeProto) {
              const tensorProtos = value;
              return tensorProtos.map((value2) => Tensor3.fromProto(value2));
            } else if (attr instanceof ortFbs2.Attribute) {
              const tensorProtos = value;
              return tensorProtos.map((value2) => Tensor3.fromOrtTensor(value2));
            }
          }
          if (attrType === import_onnx3.onnx.AttributeProto.AttributeType.STRING) {
            if (attr instanceof import_onnx3.onnx.AttributeProto) {
              const utf8String = value;
              return decodeUtf8String(utf8String);
            }
          }
          if (attrType === import_onnx3.onnx.AttributeProto.AttributeType.STRINGS) {
            if (attr instanceof import_onnx3.onnx.AttributeProto) {
              const utf8Strings = value;
              return utf8Strings.map(decodeUtf8String);
            }
          }
          return value;
        }
        static getValueNoCheck(attr) {
          return attr instanceof import_onnx3.onnx.AttributeProto ? this.getValueNoCheckFromOnnxFormat(attr) : this.getValueNoCheckFromOrtFormat(attr);
        }
        static getValueNoCheckFromOnnxFormat(attr) {
          switch (attr.type) {
            case import_onnx3.onnx.AttributeProto.AttributeType.FLOAT:
              return attr.f;
            case import_onnx3.onnx.AttributeProto.AttributeType.INT:
              return attr.i;
            case import_onnx3.onnx.AttributeProto.AttributeType.STRING:
              return attr.s;
            case import_onnx3.onnx.AttributeProto.AttributeType.TENSOR:
              return attr.t;
            case import_onnx3.onnx.AttributeProto.AttributeType.GRAPH:
              return attr.g;
            case import_onnx3.onnx.AttributeProto.AttributeType.FLOATS:
              return attr.floats;
            case import_onnx3.onnx.AttributeProto.AttributeType.INTS:
              return attr.ints;
            case import_onnx3.onnx.AttributeProto.AttributeType.STRINGS:
              return attr.strings;
            case import_onnx3.onnx.AttributeProto.AttributeType.TENSORS:
              return attr.tensors;
            case import_onnx3.onnx.AttributeProto.AttributeType.GRAPHS:
              return attr.graphs;
            default:
              throw new Error(`unsupported attribute type: ${import_onnx3.onnx.AttributeProto.AttributeType[attr.type]}`);
          }
        }
        static getValueNoCheckFromOrtFormat(attr) {
          switch (attr.type()) {
            case ortFbs2.AttributeType.FLOAT:
              return attr.f();
            case ortFbs2.AttributeType.INT:
              return attr.i();
            case ortFbs2.AttributeType.STRING:
              return attr.s();
            case ortFbs2.AttributeType.TENSOR:
              return attr.t();
            case ortFbs2.AttributeType.GRAPH:
              return attr.g();
            case ortFbs2.AttributeType.FLOATS:
              return attr.floatsArray();
            case ortFbs2.AttributeType.INTS: {
              const ints = [];
              for (let i = 0; i < attr.intsLength(); i++) {
                ints.push(attr.ints(i));
              }
              return ints;
            }
            case ortFbs2.AttributeType.STRINGS: {
              const strings = [];
              for (let i = 0; i < attr.stringsLength(); i++) {
                strings.push(attr.strings(i));
              }
              return strings;
            }
            case ortFbs2.AttributeType.TENSORS: {
              const tensors = [];
              for (let i = 0; i < attr.tensorsLength(); i++) {
                tensors.push(attr.tensors(i));
              }
              return tensors;
            }
            default:
              throw new Error(`unsupported attribute type: ${ortFbs2.AttributeType[attr.type()]}`);
          }
        }
      };
    }
  });

  // web/lib/onnxjs/graph.ts
  var import_onnx4, ortFbs3, Graph, Value, Node, GraphImpl;
  var init_graph = __esm({
    "web/lib/onnxjs/graph.ts"() {
      "use strict";
      init_attribute();
      init_ort_generated();
      import_onnx4 = __toESM(require_onnx());
      init_tensor2();
      init_util();
      ortFbs3 = onnxruntime.experimental.fbs;
      Graph = {
        /**
         * construct a graph from a graph protobuf type
         */
        from: (graphProto, initializer) => new GraphImpl(graphProto, initializer)
      };
      Value = class {
        constructor(valueInfo) {
          this._from = void 0;
          this._to = [];
          this.tensor = void 0;
          this.type = void 0;
          if (valueInfo) {
            this.type = ProtoUtil.tensorValueTypeFromProto(valueInfo.type.tensorType);
          }
        }
        // -1 represent from initializer
        get from() {
          return this._from;
        }
        get to() {
          return this._to;
        }
      };
      Node = class {
        constructor(_nodeProto, name2) {
          if (_nodeProto instanceof import_onnx4.onnx.NodeProto) {
            this.name = _nodeProto.name;
            this.opType = _nodeProto.opType;
            this.attributes = new Attribute(_nodeProto.attribute);
          } else if (_nodeProto instanceof ortFbs3.Node) {
            this.name = name2 ?? _nodeProto.name();
            this.opType = _nodeProto.opType();
            this.attributes = new Attribute(ProtoUtil.tensorAttributesFromORTFormat(_nodeProto));
          }
          this.inputs = [];
          this.outputs = [];
          this.executeNode = true;
        }
      };
      GraphImpl = class {
        constructor(graph, graphInitializer) {
          if (!graph) {
            throw new TypeError("graph is empty");
          }
          this.buildGraph(graph);
          this.transformGraph(graphInitializer);
          this.checkIsAcyclic();
        }
        getInputIndices() {
          return this._allInputIndices;
        }
        getInputNames() {
          return this._allInputNames;
        }
        getOutputIndices() {
          return this._allOutputIndices;
        }
        getOutputNames() {
          return this._allOutputNames;
        }
        getValues() {
          return this._allData;
        }
        getNodes() {
          return this._nodes;
        }
        buildGraph(graph) {
          if (graph instanceof import_onnx4.onnx.GraphProto) {
            this.buildGraphFromOnnxFormat(graph);
          } else if (graph instanceof ortFbs3.Graph) {
            this.buildGraphFromOrtFormat(graph);
          } else {
            throw new TypeError("Graph type is not supported.");
          }
        }
        buildGraphFromOnnxFormat(graph) {
          const dataIndices = /* @__PURE__ */ new Map();
          this._allData = [];
          this._allInputIndices = [];
          this._allInputNames = [];
          this._allOutputIndices = [];
          this._allOutputNames = [];
          this._nodes = [];
          const nodesIndices = /* @__PURE__ */ new Map();
          if (!graph.input) {
            throw new Error("missing information in graph: input");
          }
          const inputValueNames = [];
          for (const i of graph.input) {
            if (dataIndices.has(i.name)) {
              throw new Error(`duplicated input name: ${i.name}`);
            }
            const currentIndex = this._allData.push(new Value(i)) - 1;
            dataIndices.set(i.name, currentIndex);
            inputValueNames.push(i.name);
          }
          if (!graph.initializer) {
            throw new Error("missing information in graph: initializer");
          }
          for (const i of graph.initializer) {
            let index = dataIndices.get(i.name);
            if (index === void 0) {
              const value = new Value();
              value.type = {
                shape: { dims: ProtoUtil.tensorDimsFromProto(i.dims) },
                tensorType: ProtoUtil.tensorDataTypeFromProto(i.dataType)
              };
              index = this._allData.push(value) - 1;
              dataIndices.set(i.name, index);
            }
            this._allData[index]._from = -1;
            this._allData[index].tensor = Tensor3.fromProto(i);
          }
          for (let i = 0; i < this._allData.length; i++) {
            if (!this._allData[i].tensor) {
              this._allInputIndices.push(i);
              this._allInputNames.push(inputValueNames[i]);
            }
          }
          if (!graph.output) {
            throw new Error("missing information in graph: output");
          }
          for (const i of graph.output) {
            if (dataIndices.has(i.name)) {
              throw new Error(`duplicated output name: ${i.name}`);
            }
            const currentIndex = this._allData.push(new Value(i)) - 1;
            dataIndices.set(i.name, currentIndex);
            this._allOutputIndices.push(currentIndex);
            this._allOutputNames.push(i.name);
          }
          if (!graph.node) {
            throw new Error("missing information in graph: node");
          }
          for (const nodeProto of graph.node) {
            if (!nodeProto.name) {
              for (let pick = 0; ; pick++) {
                const name2 = `unnamed_${nodeProto.opType}_${pick}`;
                if (!nodesIndices.has(name2)) {
                  nodeProto.name = name2;
                  break;
                }
              }
            }
            if (nodesIndices.has(nodeProto.name)) {
              throw new Error(`duplicated node name: ${nodeProto.name}`);
            }
            const currentIndex = this._nodes.push(new Node(nodeProto)) - 1;
            nodesIndices.set(nodeProto.name, currentIndex);
          }
          for (let i = 0; i < this._nodes.length; i++) {
            const node = this._nodes[i];
            const nodeProto = graph.node[i];
            if (!nodeProto.output) {
              throw new Error(`missing output for node: ${nodeProto.name}`);
            }
            for (const output of nodeProto.output) {
              let dataIndex = dataIndices.get(output);
              if (typeof dataIndex === "undefined") {
                dataIndex = this._allData.push(new Value()) - 1;
                dataIndices.set(output, dataIndex);
              }
              node.outputs.push(dataIndex);
              if (this._allData[dataIndex]._from !== void 0) {
                throw new Error(`multiple nodes output to one data value: ${dataIndex}`);
              }
              this._allData[dataIndex]._from = i;
              if (nodeProto.opType === "Constant") {
                if (!nodeProto.attribute || nodeProto.attribute.length !== 1 || !nodeProto.attribute[0].t) {
                  throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");
                }
                if (!nodeProto.output || nodeProto.output.length !== 1) {
                  throw new Error("missing output or incorrect number of outputs for this Constant operator");
                }
                node.outputs.pop();
                node.executeNode = false;
                this._allData[dataIndex]._from = -1;
                this._allData[dataIndex].tensor = Tensor3.fromProto(nodeProto.attribute[0].t);
              }
            }
          }
          for (let i = 0; i < this._nodes.length; i++) {
            const node = this._nodes[i];
            const nodeProto = graph.node[i];
            if (!nodeProto.input) {
              throw new Error(`missing input for node: ${nodeProto.name}`);
            }
            for (const input of nodeProto.input) {
              const dataIndex = dataIndices.get(input);
              if (typeof dataIndex === "undefined") {
                if (input === "" && (nodeProto.input.length === 3 || nodeProto.input.length === 4) && nodeProto.opType === "Resize") {
                  continue;
                }
                throw new Error(`unrecognized input '${input}' for node: ${nodeProto.name}`);
              }
              node.inputs.push(dataIndex);
              this._allData[dataIndex]._to.push(i);
            }
          }
          return true;
        }
        buildGraphFromOrtFormat(graph) {
          const dataIndices = /* @__PURE__ */ new Map();
          this._allData = [];
          this._allInputIndices = [];
          this._allInputNames = [];
          this._allOutputIndices = [];
          this._allOutputNames = [];
          this._nodes = [];
          const nodesIndices = /* @__PURE__ */ new Map();
          const inputValueNames = [];
          for (let i = 0; i < graph.inputsLength(); i++) {
            const inputName = graph.inputs(i);
            if (dataIndices.has(inputName)) {
              throw new Error(`duplicated input name: ${inputName}`);
            }
            for (let j = 0; j < graph.nodeArgsLength(); j++) {
              if (graph.nodeArgs(j)?.name() === inputName) {
                const value = new Value();
                const valueType = graph.nodeArgs(j)?.type()?.valueType();
                if (valueType !== ortFbs3.TypeInfoValue.tensor_type) {
                  throw new Error("Unexpected value type for the nodeArg.");
                }
                const valueInfo = graph.nodeArgs(j).type().value(new ortFbs3.TensorTypeAndShape());
                const type = ProtoUtil.tensorDataTypeFromProto(valueInfo.elemType());
                const shape2 = valueInfo.shape();
                const dims = [];
                for (let k = 0; k < shape2.dimLength(); k++) {
                  dims.push(LongUtil.longToNumber(shape2.dim(k).value().dimValue()));
                }
                value.type = { shape: { dims }, tensorType: type };
                const currentIndex = this._allData.push(value) - 1;
                dataIndices.set(inputName, currentIndex);
                inputValueNames.push(inputName);
              }
            }
          }
          for (let i = 0; i < graph.initializersLength(); i++) {
            const initializer = graph.initializers(i);
            let index = dataIndices.get(initializer.name());
            if (index === void 0) {
              const value = new Value();
              const dims = ProtoUtil.tensorDimsFromORTFormat(initializer);
              const type = ProtoUtil.tensorDataTypeFromProto(initializer.dataType());
              value.type = { shape: { dims }, tensorType: type };
              index = this._allData.push(value) - 1;
              dataIndices.set(initializer.name(), index);
            }
            this._allData[index]._from = -1;
            this._allData[index].tensor = Tensor3.fromOrtTensor(initializer);
          }
          for (let i = 0; i < this._allData.length; i++) {
            if (!this._allData[i].tensor) {
              this._allInputIndices.push(i);
              this._allInputNames.push(inputValueNames[i]);
            }
          }
          for (let i = 0; i < graph.outputsLength(); i++) {
            const outputName = graph.outputs(i);
            if (dataIndices.has(outputName)) {
              throw new Error(`duplicated output name: ${outputName}`);
            }
            const currentIndex = this._allData.push(new Value()) - 1;
            dataIndices.set(outputName, currentIndex);
            this._allOutputIndices.push(currentIndex);
            this._allOutputNames.push(outputName);
          }
          if (!graph.nodes) {
            throw new Error("missing information in graph: node");
          }
          for (let i = 0; i < graph.nodesLength(); i++) {
            const nodeProto = graph.nodes(i);
            let name2 = nodeProto.name();
            if (!name2) {
              for (let pick = 0; ; pick++) {
                name2 = `unnamed_${nodeProto.opType()}_${pick}`;
                if (!nodesIndices.has(name2)) {
                  break;
                }
              }
            }
            if (nodesIndices.has(name2)) {
              throw new Error(`duplicated node name: ${name2}`);
            }
            const currentIndex = this._nodes.push(new Node(nodeProto, name2)) - 1;
            nodesIndices.set(name2, currentIndex);
          }
          for (let i = 0; i < this._nodes.length; i++) {
            const node = this._nodes[i];
            const nodeProto = graph.nodes(i);
            if (nodeProto == null) {
              throw new Error(`No node exists at index ${i}`);
            }
            if (nodeProto?.outputsLength() === 0) {
              throw new Error(`missing output for node: ${nodeProto.name}`);
            }
            for (let j = 0; j < nodeProto?.outputsLength(); j++) {
              const output = nodeProto?.outputs(j);
              let dataIndex = dataIndices.get(output);
              if (typeof dataIndex === "undefined") {
                dataIndex = this._allData.push(new Value()) - 1;
                dataIndices.set(output, dataIndex);
              }
              node.outputs.push(dataIndex);
              if (this._allData[dataIndex]._from !== void 0) {
                throw new Error(`multiple nodes output to one data value: ${dataIndex}`);
              }
              this._allData[dataIndex]._from = i;
              if (nodeProto.opType() === "Constant") {
                if (nodeProto.attributesLength() !== 1 || !nodeProto.attributes(0).t()) {
                  throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");
                }
                if (nodeProto.outputsLength() !== 1) {
                  throw new Error("missing output or incorrect number of outputs for this Constant operator");
                }
                node.outputs.pop();
                node.executeNode = false;
                this._allData[dataIndex]._from = -1;
                this._allData[dataIndex].tensor = Tensor3.fromOrtTensor(nodeProto.attributes(0).t());
              }
            }
          }
          for (let i = 0; i < this._nodes.length; i++) {
            const node = this._nodes[i];
            const nodeProto = graph.nodes(i);
            if (nodeProto.inputsLength() === 0) {
              throw new Error(`missing input for node: ${nodeProto.name}`);
            }
            for (let j = 0; j < nodeProto.inputsLength(); j++) {
              const input = nodeProto.inputs(j);
              const dataIndex = dataIndices.get(input);
              if (typeof dataIndex === "undefined") {
                throw new Error(`unrecognized input '${input}' for node: ${nodeProto.name()}`);
              }
              node.inputs.push(dataIndex);
              this._allData[dataIndex]._to.push(i);
            }
          }
        }
        checkIsAcyclic() {
          const starters = /* @__PURE__ */ new Set();
          this._allInputIndices.forEach((i) => {
            const data = this._allData[i];
            data._to.forEach((j) => {
              starters.add(j);
            });
          });
          const nodesStack = Array.from(starters);
          const nodesState = new Array(this._nodes.length).fill("white");
          while (nodesStack.length > 0) {
            const nodeIndex = nodesStack.pop();
            if (nodesState[nodeIndex] === "gray") {
              nodesState[nodeIndex] = "black";
            } else {
              nodesStack.push(nodeIndex);
              nodesState[nodeIndex] = "gray";
              this._nodes[nodeIndex].outputs.forEach((outgoingEdgeIndex) => {
                const data = this._allData[outgoingEdgeIndex];
                if (typeof data.tensor !== "undefined") {
                  throw new Error("node outputs should not be initialized");
                }
                if (data._from !== nodeIndex) {
                  throw new Error("from property of the Value object doesn't match index of Node being processed");
                }
                data._to.forEach((downstreamNodeIndex) => {
                  if (nodesState[downstreamNodeIndex] === "gray") {
                    throw new Error("model graph is cyclic");
                  } else if (nodesState[downstreamNodeIndex] === "white") {
                    nodesStack.push(downstreamNodeIndex);
                  }
                });
              });
            }
          }
        }
        transformGraph(graphInitializer) {
          this.removeAllIdentityNodes();
          this.removeAllDropoutNodes();
          this.fuseConvActivationNodes();
          if (graphInitializer) {
            graphInitializer.transformGraph(this);
          }
          this.finalizeGraph();
        }
        /**
         * finalize the graph.
         *
         * this function should be called after all the transformation completed.
         * this function removes all unnecessary nodes and values from the graph
         */
        finalizeGraph() {
          let offset = 0;
          const newIndices = new Array(this._nodes.length, 0);
          let nodePossition = 0;
          for (let i = 0; i < this._nodes.length; i++) {
            newIndices[i] = nodePossition;
            if (this._nodes[i].executeNode) {
              if (nodePossition !== i) {
                this._nodes[nodePossition] = this._nodes[i];
              }
              nodePossition++;
            } else {
              this._nodes[i].outputs.forEach((ind) => {
                this._allData[ind]._from = -2;
              });
            }
          }
          this._nodes.splice(nodePossition, this._nodes.length - nodePossition);
          for (let i = 0; i < this._allData.length; i++) {
            const currentData = this._allData[i];
            if (currentData._from !== void 0 && currentData._from !== -1 && currentData._from !== -2) {
              currentData._from = newIndices[currentData._from];
            }
            for (let j = 0; j < currentData._to.length; j++) {
              if (currentData._to[j] >= 0) {
                currentData._to[j] = newIndices[currentData._to[j]];
              } else {
                throw new Error("Trying to update a removed node");
              }
            }
          }
          offset = 0;
          for (let i = 0; i < this._allData.length; i++) {
            if (this._allData[i].from === -2 && this._allOutputIndices.indexOf(i + offset) === -1) {
              offset++;
              this._allData.splice(i, 1);
              i--;
              continue;
            }
            if (offset > 0) {
              let ind = -1;
              if (this._allData[i].from !== void 0 && this._allData[i].from !== -1) {
                ind = this._nodes[this._allData[i].from].outputs.indexOf(i + offset);
                if (ind !== -1) {
                  this._nodes[this._allData[i].from].outputs[ind] = i;
                }
              } else {
                ind = this._allInputIndices.indexOf(i + offset);
                if (ind !== -1) {
                  this._allInputIndices[ind] = i;
                }
              }
              this._allData[i].to.forEach((node) => {
                ind = this._nodes[node].inputs.indexOf(i + offset);
                if (ind !== -1) {
                  this._nodes[node].inputs[ind] = i;
                }
              });
              if (this._allData[i].to.length === 0) {
                ind = this._allOutputIndices.indexOf(i + offset);
                if (ind !== -1) {
                  this._allOutputIndices[ind] = i;
                }
              }
            }
          }
        }
        /**
         * Delete the specified node. Assume the node has one incoming input and the first output connected to other nodes.
         * An input validation must be done before calling this function.
         * @param nodeIndex The index of node to be deleted
         */
        deleteNode(nodeIndex) {
          const node = this._nodes[nodeIndex];
          if (node.outputs.length > 1) {
            for (let i = 1; i < node.outputs.length; i++) {
              if (this._allData[node.outputs[i]].to.length > 0) {
                throw new Error("Node deletion with more than one output connected to other nodes is not supported. ");
              }
            }
          }
          node.executeNode = false;
          const inputValueIndex = node.inputs[0];
          const outputValueIndex = node.outputs[0];
          const nodesConsumingOutput = this._allData[outputValueIndex].to;
          for (let i = 0; i < node.inputs.length; i++) {
            const delIndex = this._allData[node.inputs[i]].to.indexOf(nodeIndex);
            if (delIndex === -1) {
              throw new Error("The Value object doesn't have the current Node in it's 'to' property ");
            }
            this._allData[node.inputs[i]].to.splice(delIndex, 1);
          }
          this._allData[outputValueIndex]._to = [];
          const index = this._allOutputIndices.indexOf(outputValueIndex);
          if (index !== -1) {
            this._allOutputIndices[index] = inputValueIndex;
          }
          if (nodesConsumingOutput && nodesConsumingOutput.length > 0) {
            for (const nodeIndex2 of nodesConsumingOutput) {
              const replaceIndex = this._nodes[nodeIndex2].inputs.indexOf(outputValueIndex);
              if (replaceIndex === -1) {
                throw new Error("The Node object doesn't have the output Value in it's 'inputs' property ");
              }
              this._nodes[nodeIndex2].inputs[replaceIndex] = inputValueIndex;
              this._allData[inputValueIndex].to.push(nodeIndex2);
            }
          }
        }
        removeAllDropoutNodes() {
          let nodeIndex = 0;
          for (const node of this._nodes) {
            if (node.opType === "Dropout") {
              if (node.inputs.length !== 1) {
                throw new Error("Dropout nodes should only contain one input. ");
              }
              if (node.outputs.length !== 1 && node.outputs.length !== 2) {
                throw new Error("Dropout nodes should contain either 1 or 2 output(s)");
              }
              if (node.outputs.length === 2 && this._allData[node.outputs[1]]._to.length !== 0) {
                throw new Error("Dropout nodes's second output should not be referenced by other nodes");
              }
              this.deleteNode(nodeIndex);
            }
            nodeIndex++;
          }
        }
        removeAllIdentityNodes() {
          let nodeIndex = 0;
          for (const node of this._nodes) {
            if (node.opType === "Identity") {
              this.deleteNode(nodeIndex);
            }
            nodeIndex++;
          }
        }
        isActivation(n) {
          switch (n.opType) {
            case "Relu":
            case "Sigmoid":
            case "Clip":
              return true;
            default:
              return false;
          }
        }
        fuseConvActivationNodes() {
          for (const node of this._nodes) {
            if (node.opType === "Conv") {
              const next = this._allData[node.outputs[0]]._to;
              if (next.length === 1 && this.isActivation(this._nodes[next[0]])) {
                const child = this._nodes[next[0]];
                if (child.opType === "Clip") {
                  if (child.inputs.length === 1) {
                    try {
                      node.attributes.set("activation_params", "floats", [
                        child.attributes.getFloat("min"),
                        child.attributes.getFloat("max")
                      ]);
                    } catch (e) {
                      node.attributes.set("activation_params", "floats", [MIN_CLIP, MAX_CLIP]);
                    }
                  } else if (child.inputs.length >= 3 && this._allData[child.inputs[1]].tensor !== void 0 && this._allData[child.inputs[2]].tensor !== void 0) {
                    node.attributes.set("activation_params", "floats", [
                      this._allData[child.inputs[1]].tensor.floatData[0],
                      this._allData[child.inputs[2]].tensor.floatData[0]
                    ]);
                  } else {
                    continue;
                  }
                }
                node.attributes.set("activation", "string", child.opType);
                this.deleteNode(next[0]);
              }
            }
          }
        }
      };
    }
  });

  // web/lib/onnxjs/model.ts
  var import_onnx5, ortFbs4, Model;
  var init_model = __esm({
    "web/lib/onnxjs/model.ts"() {
      "use strict";
      init_flatbuffers();
      init_graph();
      init_ort_generated();
      import_onnx5 = __toESM(require_onnx());
      init_util();
      ortFbs4 = onnxruntime.experimental.fbs;
      Model = class {
        // empty model
        constructor() {
        }
        load(buf, graphInitializer, isOrtFormat) {
          let onnxError;
          if (!isOrtFormat) {
            try {
              this.loadFromOnnxFormat(buf, graphInitializer);
              return;
            } catch (e) {
              if (isOrtFormat !== void 0) {
                throw e;
              }
              onnxError = e;
            }
          }
          try {
            this.loadFromOrtFormat(buf, graphInitializer);
          } catch (e) {
            if (isOrtFormat !== void 0) {
              throw e;
            }
            throw new Error(`Failed to load model as ONNX format: ${onnxError}
as ORT format: ${e}`);
          }
        }
        loadFromOnnxFormat(buf, graphInitializer) {
          const modelProto = import_onnx5.onnx.ModelProto.decode(buf);
          const irVersion = LongUtil.longToNumber(modelProto.irVersion);
          if (irVersion < 3) {
            throw new Error("only support ONNX model with IR_VERSION>=3");
          }
          this._opsets = modelProto.opsetImport.map((i) => ({
            domain: i.domain,
            version: LongUtil.longToNumber(i.version)
          }));
          this._graph = Graph.from(modelProto.graph, graphInitializer);
        }
        loadFromOrtFormat(buf, graphInitializer) {
          const fb = new flatbuffers.ByteBuffer(buf);
          const ortModel = ortFbs4.InferenceSession.getRootAsInferenceSession(fb).model();
          const irVersion = LongUtil.longToNumber(ortModel.irVersion());
          if (irVersion < 3) {
            throw new Error("only support ONNX model with IR_VERSION>=3");
          }
          this._opsets = [];
          for (let i = 0; i < ortModel.opsetImportLength(); i++) {
            const opsetId = ortModel.opsetImport(i);
            this._opsets.push({ domain: opsetId?.domain(), version: LongUtil.longToNumber(opsetId.version()) });
          }
          this._graph = Graph.from(ortModel.graph(), graphInitializer);
        }
        get graph() {
          return this._graph;
        }
        get opsets() {
          return this._opsets;
        }
      };
    }
  });

  // web/lib/onnxjs/session.ts
  var Session;
  var init_session = __esm({
    "web/lib/onnxjs/session.ts"() {
      "use strict";
      init_backend2();
      init_execution_plan();
      init_instrument();
      init_model();
      Session = class {
        constructor(config = {}) {
          this._initialized = false;
          this.backendHint = config.backendHint;
          this.profiler = Profiler.create(config.profiler);
          this.context = { profiler: this.profiler, graphInputTypes: [], graphInputDims: [] };
        }
        get inputNames() {
          return this._model.graph.getInputNames();
        }
        get outputNames() {
          return this._model.graph.getOutputNames();
        }
        startProfiling() {
          this.profiler.start();
        }
        endProfiling() {
          this.profiler.stop();
        }
        async loadModel(arg, byteOffset, length) {
          await this.profiler.event("session", "Session.loadModel", async () => {
            const backend2 = await resolveBackend(this.backendHint);
            this.sessionHandler = backend2.createSessionHandler(this.context);
            this._model = new Model();
            if (typeof arg === "string") {
              const isOrtFormat = arg.endsWith(".ort");
              if (false) {
                const { readFile } = null;
                const buf = await readFile(arg);
                this.initialize(buf, isOrtFormat);
              } else {
                const response = await fetch(arg);
                const buf = await response.arrayBuffer();
                this.initialize(new Uint8Array(buf), isOrtFormat);
              }
            } else if (!ArrayBuffer.isView(arg)) {
              const arr = new Uint8Array(arg, byteOffset || 0, length || arg.byteLength);
              this.initialize(arr);
            } else {
              this.initialize(arg);
            }
          });
        }
        initialize(modelProtoBlob, isOrtFormat) {
          if (this._initialized) {
            throw new Error("already initialized");
          }
          this.profiler.event("session", "Session.initialize", () => {
            const graphInitializer = this.sessionHandler.transformGraph ? this.sessionHandler : void 0;
            this._model.load(modelProtoBlob, graphInitializer, isOrtFormat);
            if (this.sessionHandler.onGraphInitialized) {
              this.sessionHandler.onGraphInitialized(this._model.graph);
            }
            this.initializeOps(this._model.graph);
            this._executionPlan = new ExecutionPlan(this._model.graph, this._ops, this.profiler);
          });
          this._initialized = true;
        }
        async run(inputs) {
          if (!this._initialized) {
            throw new Error("session not initialized yet");
          }
          return this.profiler.event("session", "Session.run", async () => {
            const inputTensors = this.normalizeAndValidateInputs(inputs);
            const outputTensors = await this._executionPlan.execute(this.sessionHandler, inputTensors);
            return this.createOutput(outputTensors);
          });
        }
        normalizeAndValidateInputs(inputs) {
          const modelInputNames = this._model.graph.getInputNames();
          if (Array.isArray(inputs)) {
            if (inputs.length !== modelInputNames.length) {
              throw new Error(`incorrect input array length: expected ${modelInputNames.length} but got ${inputs.length}`);
            }
          } else {
            if (inputs.size !== modelInputNames.length) {
              throw new Error(`incorrect input map size: expected ${modelInputNames.length} but got ${inputs.size}`);
            }
            const sortedInputs = new Array(inputs.size);
            let sortedInputsIndex = 0;
            for (let i = 0; i < modelInputNames.length; ++i) {
              const tensor = inputs.get(modelInputNames[i]);
              if (!tensor) {
                throw new Error(`missing input tensor for: '${name}'`);
              }
              sortedInputs[sortedInputsIndex++] = tensor;
            }
            inputs = sortedInputs;
          }
          if (!this.context.graphInputTypes || this.context.graphInputTypes.length === 0 || !this.context.graphInputDims || this.context.graphInputDims.length === 0) {
            const modelInputIndices = this._model.graph.getInputIndices();
            const modelValues = this._model.graph.getValues();
            const graphInputDims = new Array(modelInputIndices.length);
            for (let i = 0; i < modelInputIndices.length; ++i) {
              const graphInput = modelValues[modelInputIndices[i]];
              graphInputDims[i] = graphInput.type.shape.dims;
              this.context.graphInputTypes.push(graphInput.type.tensorType);
              this.context.graphInputDims.push(inputs[i].dims);
            }
            this.validateInputTensorDims(graphInputDims, inputs, true);
          } else {
            this.validateInputTensorDims(this.context.graphInputDims, inputs, false);
          }
          this.validateInputTensorTypes(this.context.graphInputTypes, inputs);
          return inputs;
        }
        validateInputTensorTypes(graphInputTypes, givenInputs) {
          for (let i = 0; i < givenInputs.length; i++) {
            const expectedType = graphInputTypes[i];
            const actualType = givenInputs[i].type;
            if (expectedType !== actualType) {
              throw new Error(`input tensor[${i}] check failed: expected type '${expectedType}' but got ${actualType}`);
            }
          }
        }
        validateInputTensorDims(graphInputDims, givenInputs, noneDimSupported) {
          for (let i = 0; i < givenInputs.length; i++) {
            const expectedDims = graphInputDims[i];
            const actualDims = givenInputs[i].dims;
            if (!this.compareTensorDims(expectedDims, actualDims, noneDimSupported)) {
              throw new Error(
                `input tensor[${i}] check failed: expected shape '[${expectedDims.join(",")}]' but got [${actualDims.join(
                  ","
                )}]`
              );
            }
          }
        }
        compareTensorDims(expectedDims, actualDims, noneDimSupported) {
          if (expectedDims.length !== actualDims.length) {
            return false;
          }
          for (let i = 0; i < expectedDims.length; ++i) {
            if (expectedDims[i] !== actualDims[i] && (!noneDimSupported || expectedDims[i] !== 0)) {
              return false;
            }
          }
          return true;
        }
        createOutput(outputTensors) {
          const modelOutputNames = this._model.graph.getOutputNames();
          if (outputTensors.length !== modelOutputNames.length) {
            throw new Error("expected number of outputs do not match number of generated outputs");
          }
          const output = /* @__PURE__ */ new Map();
          for (let i = 0; i < modelOutputNames.length; ++i) {
            output.set(modelOutputNames[i], outputTensors[i]);
          }
          return output;
        }
        initializeOps(graph) {
          const nodes = graph.getNodes();
          this._ops = new Array(nodes.length);
          for (let i = 0; i < nodes.length; i++) {
            this._ops[i] = this.sessionHandler.resolve(nodes[i], this._model.opsets, graph);
          }
        }
      };
    }
  });

  // web/lib/onnxjs/session-handler-inference.ts
  var OnnxjsSessionHandler;
  var init_session_handler_inference = __esm({
    "web/lib/onnxjs/session-handler-inference.ts"() {
      "use strict";
      init_esm();
      init_tensor2();
      OnnxjsSessionHandler = class {
        constructor(session) {
          this.session = session;
          this.inputNames = this.session.inputNames;
          this.outputNames = this.session.outputNames;
        }
        async dispose() {
        }
        async run(feeds, _fetches, _options) {
          const inputMap = /* @__PURE__ */ new Map();
          for (const name2 in feeds) {
            if (Object.hasOwnProperty.call(feeds, name2)) {
              const feed = feeds[name2];
              inputMap.set(
                name2,
                new Tensor3(
                  feed.dims,
                  feed.type,
                  void 0,
                  void 0,
                  feed.data
                )
              );
            }
          }
          const outputMap = await this.session.run(inputMap);
          const output = {};
          outputMap.forEach((tensor, name2) => {
            output[name2] = new Tensor2(tensor.type, tensor.data, tensor.dims);
          });
          return output;
        }
        startProfiling() {
          this.session.startProfiling();
        }
        endProfiling() {
          this.session.endProfiling();
        }
      };
    }
  });

  // web/lib/backend-onnxjs.ts
  var backend_onnxjs_exports = {};
  __export(backend_onnxjs_exports, {
    onnxjsBackend: () => onnxjsBackend
  });
  var OnnxjsBackend, onnxjsBackend;
  var init_backend_onnxjs = __esm({
    "web/lib/backend-onnxjs.ts"() {
      "use strict";
      init_session();
      init_session_handler_inference();
      OnnxjsBackend = class {
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        async init() {
        }
        async createInferenceSessionHandler(pathOrBuffer, options) {
          const session = new Session(options);
          if (typeof pathOrBuffer === "string") {
            await session.loadModel(pathOrBuffer);
          } else {
            await session.loadModel(pathOrBuffer);
          }
          return new OnnxjsSessionHandler(session);
        }
      };
      onnxjsBackend = new OnnxjsBackend();
    }
  });

  // web/lib/wasm/wasm-utils-env.ts
  var isNode;
  var init_wasm_utils_env = __esm({
    "web/lib/wasm/wasm-utils-env.ts"() {
      "use strict";
      isNode = false;
    }
  });

  // web/lib/wasm/proxy-worker/main.ts
  var main_exports = {};
  __export(main_exports, {
    default: () => main_default
  });
  var WORKER_NAME, isProxyWorker, main_default;
  var init_main = __esm({
    "web/lib/wasm/proxy-worker/main.ts"() {
      "use strict";
      init_wasm_core_impl();
      init_wasm_factory();
      init_wasm_utils_import();
      WORKER_NAME = "ort-wasm-proxy-worker";
      isProxyWorker = globalThis.self?.name === WORKER_NAME;
      if (isProxyWorker) {
        self.onmessage = (ev) => {
          const { type, in: message } = ev.data;
          try {
            switch (type) {
              case "init-wasm":
                initializeWebAssembly(message.wasm).then(
                  () => {
                    initRuntime(message).then(
                      () => {
                        postMessage({ type });
                      },
                      (err) => {
                        postMessage({ type, err });
                      }
                    );
                  },
                  (err) => {
                    postMessage({ type, err });
                  }
                );
                break;
              case "init-ep": {
                const { epName, env: env3 } = message;
                initEp(env3, epName).then(
                  () => {
                    postMessage({ type });
                  },
                  (err) => {
                    postMessage({ type, err });
                  }
                );
                break;
              }
              case "copy-from": {
                const { buffer } = message;
                const bufferData = copyFromExternalBuffer(buffer);
                postMessage({ type, out: bufferData });
                break;
              }
              case "create": {
                const { model, options } = message;
                createSession(model, options).then(
                  (sessionMetadata) => {
                    postMessage({ type, out: sessionMetadata });
                  },
                  (err) => {
                    postMessage({ type, err });
                  }
                );
                break;
              }
              case "release":
                releaseSession(message);
                postMessage({ type });
                break;
              case "run": {
                const { sessionId, inputIndices, inputs, outputIndices, options } = message;
                run(sessionId, inputIndices, inputs, outputIndices, new Array(outputIndices.length).fill(null), options).then(
                  (outputs) => {
                    if (outputs.some((o) => o[3] !== "cpu")) {
                      postMessage({ type, err: "Proxy does not support non-cpu tensor location." });
                    } else {
                      postMessage(
                        { type, out: outputs },
                        extractTransferableBuffers([...inputs, ...outputs])
                      );
                    }
                  },
                  (err) => {
                    postMessage({ type, err });
                  }
                );
                break;
              }
              case "end-profiling":
                endProfiling(message);
                postMessage({ type });
                break;
              default:
            }
          } catch (err) {
            postMessage({ type, err });
          }
        };
      }
      main_default = isProxyWorker ? null : (urlOverride) => new Worker(urlOverride ?? scriptSrc, { type: false ? "module" : "classic", name: WORKER_NAME });
    }
  });

  // web/lib/wasm/wasm-utils-import.ts
  var scriptSrc, origin, isSameOrigin, normalizeUrl, fallbackUrl, preload, dynamicImportDefault, createProxyWorker, importProxyWorker, embeddedWasmModule, importWasmModule;
  var init_wasm_utils_import = __esm({
    "web/lib/wasm/wasm-utils-import.ts"() {
      "use strict";
      init_wasm_utils_env();
      scriptSrc = // if Nodejs, return undefined
      isNode ? void 0 : (
        // use `document.currentScript.src` if available
        typeof document !== "undefined" ? document.currentScript?.src : (
          // use `self.location.href` if available
          typeof self !== "undefined" ? self.location?.href : void 0
        )
      );
      origin = isNode || typeof location === "undefined" ? void 0 : location.origin;
      isSameOrigin = (filename, prefixOverride) => {
        try {
          const baseUrl = prefixOverride ?? scriptSrc;
          const url = baseUrl ? new URL(filename, baseUrl) : new URL(filename);
          return url.origin === origin;
        } catch {
          return false;
        }
      };
      normalizeUrl = (filename, prefixOverride) => {
        const baseUrl = prefixOverride ?? scriptSrc;
        try {
          const url = baseUrl ? new URL(filename, baseUrl) : new URL(filename);
          return url.href;
        } catch {
          return void 0;
        }
      };
      fallbackUrl = (filename, prefixOverride) => `${prefixOverride ?? "./"}${filename}`;
      preload = async (absoluteUrl) => {
        const response = await fetch(absoluteUrl, { credentials: "same-origin" });
        const blob = await response.blob();
        return URL.createObjectURL(blob);
      };
      dynamicImportDefault = async (url) => (await import(
        /* webpackIgnore: true */
        url
      )).default;
      createProxyWorker = // eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires
      false ? void 0 : (init_main(), __toCommonJS(main_exports)).default;
      importProxyWorker = async () => {
        if (!scriptSrc) {
          throw new Error("Failed to load proxy worker: cannot determine the script source URL.");
        }
        if (isSameOrigin(scriptSrc)) {
          return [void 0, createProxyWorker()];
        }
        const url = await preload(scriptSrc);
        return [url, createProxyWorker(url)];
      };
      embeddedWasmModule = false ? (
        // eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires
        (false ? null : null).default
      ) : void 0;
      importWasmModule = async (urlOverride, prefixOverride, isMultiThreaded) => {
        if (false) {
          return [void 0, embeddedWasmModule];
        } else {
          const wasmModuleFilename = false ? "ort-wasm-simd-threaded.jsep.mjs" : "ort-wasm-simd-threaded.mjs";
          const wasmModuleUrl = urlOverride ?? normalizeUrl(wasmModuleFilename, prefixOverride);
          const needPreload = !isNode && isMultiThreaded && wasmModuleUrl && !isSameOrigin(wasmModuleUrl, prefixOverride);
          const url = needPreload ? await preload(wasmModuleUrl) : wasmModuleUrl ?? fallbackUrl(wasmModuleFilename, prefixOverride);
          return [needPreload ? url : void 0, await dynamicImportDefault(url)];
        }
      };
    }
  });

  // web/lib/wasm/wasm-factory.ts
  var wasm2, initialized, initializing, aborted, isMultiThreadSupported, isSimdSupported, initializeWebAssembly, getInstance;
  var init_wasm_factory = __esm({
    "web/lib/wasm/wasm-factory.ts"() {
      "use strict";
      init_wasm_utils_import();
      initialized = false;
      initializing = false;
      aborted = false;
      isMultiThreadSupported = () => {
        if (typeof SharedArrayBuffer === "undefined") {
          return false;
        }
        try {
          if (typeof MessageChannel !== "undefined") {
            new MessageChannel().port1.postMessage(new SharedArrayBuffer(1));
          }
          return WebAssembly.validate(
            new Uint8Array([
              0,
              97,
              115,
              109,
              1,
              0,
              0,
              0,
              1,
              4,
              1,
              96,
              0,
              0,
              3,
              2,
              1,
              0,
              5,
              4,
              1,
              3,
              1,
              1,
              10,
              11,
              1,
              9,
              0,
              65,
              0,
              254,
              16,
              2,
              0,
              26,
              11
            ])
          );
        } catch (e) {
          return false;
        }
      };
      isSimdSupported = () => {
        try {
          return WebAssembly.validate(
            new Uint8Array([
              0,
              97,
              115,
              109,
              1,
              0,
              0,
              0,
              1,
              4,
              1,
              96,
              0,
              0,
              3,
              2,
              1,
              0,
              10,
              30,
              1,
              28,
              0,
              65,
              0,
              253,
              15,
              253,
              12,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              253,
              186,
              1,
              26,
              11
            ])
          );
        } catch (e) {
          return false;
        }
      };
      initializeWebAssembly = async (flags) => {
        if (initialized) {
          return Promise.resolve();
        }
        if (initializing) {
          throw new Error("multiple calls to 'initializeWebAssembly()' detected.");
        }
        if (aborted) {
          throw new Error("previous call to 'initializeWebAssembly()' failed.");
        }
        initializing = true;
        const timeout = flags.initTimeout;
        let numThreads = flags.numThreads;
        if (!isSimdSupported()) {
          throw new Error("WebAssembly SIMD is not supported in the current environment.");
        }
        const multiThreadSupported = isMultiThreadSupported();
        if (numThreads > 1 && !multiThreadSupported) {
          if (typeof self !== "undefined" && !self.crossOriginIsolated) {
            console.warn(
              "env.wasm.numThreads is set to " + numThreads + ", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."
            );
          }
          console.warn(
            "WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."
          );
          flags.numThreads = numThreads = 1;
        }
        const wasmPaths = flags.wasmPaths;
        const wasmPrefixOverride = typeof wasmPaths === "string" ? wasmPaths : void 0;
        const mjsPathOverrideFlag = wasmPaths?.mjs;
        const mjsPathOverride = mjsPathOverrideFlag?.href ?? mjsPathOverrideFlag;
        const wasmPathOverrideFlag = wasmPaths?.wasm;
        const wasmPathOverride = wasmPathOverrideFlag?.href ?? wasmPathOverrideFlag;
        const wasmBinaryOverride = flags.wasmBinary;
        const [objectUrl, ortWasmFactory] = await importWasmModule(mjsPathOverride, wasmPrefixOverride, numThreads > 1);
        let isTimeout = false;
        const tasks = [];
        if (timeout > 0) {
          tasks.push(
            new Promise((resolve) => {
              setTimeout(() => {
                isTimeout = true;
                resolve();
              }, timeout);
            })
          );
        }
        tasks.push(
          new Promise((resolve, reject) => {
            const config = {
              /**
               * The number of threads. WebAssembly will create (Module.numThreads - 1) workers. If it is 1, no worker will be
               * created.
               */
              numThreads
            };
            if (wasmBinaryOverride) {
              config.wasmBinary = wasmBinaryOverride;
            } else if (wasmPathOverride || wasmPrefixOverride) {
              config.locateFile = (fileName, scriptDirectory) => wasmPathOverride ?? (wasmPrefixOverride ?? scriptDirectory) + fileName;
            }
            ortWasmFactory(config).then(
              // wasm module initialized successfully
              (module2) => {
                initializing = false;
                initialized = true;
                wasm2 = module2;
                resolve();
                if (objectUrl) {
                  URL.revokeObjectURL(objectUrl);
                }
              },
              // wasm module failed to initialize
              (what) => {
                initializing = false;
                aborted = true;
                reject(what);
              }
            );
          })
        );
        await Promise.race(tasks);
        if (isTimeout) {
          throw new Error(`WebAssembly backend initializing failed due to timeout: ${timeout}ms`);
        }
      };
      getInstance = () => {
        if (initialized && wasm2) {
          return wasm2;
        }
        throw new Error("WebAssembly is not initialized yet.");
      };
    }
  });

  // web/lib/wasm/wasm-utils.ts
  var allocWasmString, iterateExtraOptions, checkLastError;
  var init_wasm_utils = __esm({
    "web/lib/wasm/wasm-utils.ts"() {
      "use strict";
      init_wasm_factory();
      allocWasmString = (data, allocs) => {
        const wasm3 = getInstance();
        const dataLength = wasm3.lengthBytesUTF8(data) + 1;
        const dataOffset = wasm3._malloc(dataLength);
        wasm3.stringToUTF8(data, dataOffset, dataLength);
        allocs.push(dataOffset);
        return dataOffset;
      };
      iterateExtraOptions = (options, prefix, seen, handler) => {
        if (typeof options == "object" && options !== null) {
          if (seen.has(options)) {
            throw new Error("Circular reference in options");
          } else {
            seen.add(options);
          }
        }
        Object.entries(options).forEach(([key, value]) => {
          const name2 = prefix ? prefix + key : key;
          if (typeof value === "object") {
            iterateExtraOptions(value, name2 + ".", seen, handler);
          } else if (typeof value === "string" || typeof value === "number") {
            handler(name2, value.toString());
          } else if (typeof value === "boolean") {
            handler(name2, value ? "1" : "0");
          } else {
            throw new Error(`Can't handle extra config type: ${typeof value}`);
          }
        });
      };
      checkLastError = (message) => {
        const wasm3 = getInstance();
        const stack = wasm3.stackSave();
        try {
          const paramsOffset = wasm3.stackAlloc(8);
          wasm3._OrtGetLastError(paramsOffset, paramsOffset + 4);
          const errorCode = wasm3.HEAP32[paramsOffset / 4];
          const errorMessagePointer = wasm3.HEAPU32[paramsOffset / 4 + 1];
          const errorMessage = errorMessagePointer ? wasm3.UTF8ToString(errorMessagePointer) : "";
          throw new Error(`${message} ERROR_CODE: ${errorCode}, ERROR_MESSAGE: ${errorMessage}`);
        } finally {
          wasm3.stackRestore(stack);
        }
      };
    }
  });

  // web/lib/wasm/run-options.ts
  var setRunOptions;
  var init_run_options = __esm({
    "web/lib/wasm/run-options.ts"() {
      "use strict";
      init_wasm_factory();
      init_wasm_utils();
      setRunOptions = (options) => {
        const wasm3 = getInstance();
        let runOptionsHandle = 0;
        const allocs = [];
        const runOptions = options || {};
        try {
          if (options?.logSeverityLevel === void 0) {
            runOptions.logSeverityLevel = 2;
          } else if (typeof options.logSeverityLevel !== "number" || !Number.isInteger(options.logSeverityLevel) || options.logSeverityLevel < 0 || options.logSeverityLevel > 4) {
            throw new Error(`log serverity level is not valid: ${options.logSeverityLevel}`);
          }
          if (options?.logVerbosityLevel === void 0) {
            runOptions.logVerbosityLevel = 0;
          } else if (typeof options.logVerbosityLevel !== "number" || !Number.isInteger(options.logVerbosityLevel)) {
            throw new Error(`log verbosity level is not valid: ${options.logVerbosityLevel}`);
          }
          if (options?.terminate === void 0) {
            runOptions.terminate = false;
          }
          let tagDataOffset = 0;
          if (options?.tag !== void 0) {
            tagDataOffset = allocWasmString(options.tag, allocs);
          }
          runOptionsHandle = wasm3._OrtCreateRunOptions(
            runOptions.logSeverityLevel,
            runOptions.logVerbosityLevel,
            !!runOptions.terminate,
            tagDataOffset
          );
          if (runOptionsHandle === 0) {
            checkLastError("Can't create run options.");
          }
          if (options?.extra !== void 0) {
            iterateExtraOptions(options.extra, "", /* @__PURE__ */ new WeakSet(), (key, value) => {
              const keyDataOffset = allocWasmString(key, allocs);
              const valueDataOffset = allocWasmString(value, allocs);
              if (wasm3._OrtAddRunConfigEntry(runOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {
                checkLastError(`Can't set a run config entry: ${key} - ${value}.`);
              }
            });
          }
          return [runOptionsHandle, allocs];
        } catch (e) {
          if (runOptionsHandle !== 0) {
            wasm3._OrtReleaseRunOptions(runOptionsHandle);
          }
          allocs.forEach((alloc) => wasm3._free(alloc));
          throw e;
        }
      };
    }
  });

  // web/lib/wasm/session-options.ts
  var getGraphOptimzationLevel, getExecutionMode, appendDefaultOptions, setExecutionProviders, setSessionOptions;
  var init_session_options = __esm({
    "web/lib/wasm/session-options.ts"() {
      "use strict";
      init_wasm_factory();
      init_wasm_utils();
      getGraphOptimzationLevel = (graphOptimizationLevel) => {
        switch (graphOptimizationLevel) {
          case "disabled":
            return 0;
          case "basic":
            return 1;
          case "extended":
            return 2;
          case "all":
            return 99;
          default:
            throw new Error(`unsupported graph optimization level: ${graphOptimizationLevel}`);
        }
      };
      getExecutionMode = (executionMode) => {
        switch (executionMode) {
          case "sequential":
            return 0;
          case "parallel":
            return 1;
          default:
            throw new Error(`unsupported execution mode: ${executionMode}`);
        }
      };
      appendDefaultOptions = (options) => {
        if (!options.extra) {
          options.extra = {};
        }
        if (!options.extra.session) {
          options.extra.session = {};
        }
        const session = options.extra.session;
        if (!session.use_ort_model_bytes_directly) {
          session.use_ort_model_bytes_directly = "1";
        }
        if (options.executionProviders && options.executionProviders.some((ep) => (typeof ep === "string" ? ep : ep.name) === "webgpu")) {
          options.enableMemPattern = false;
        }
      };
      setExecutionProviders = (sessionOptionsHandle, executionProviders, allocs) => {
        for (const ep of executionProviders) {
          let epName = typeof ep === "string" ? ep : ep.name;
          switch (epName) {
            case "webnn":
              epName = "WEBNN";
              if (typeof ep !== "string") {
                const webnnOptions = ep;
                const deviceType = webnnOptions?.deviceType;
                if (deviceType) {
                  const keyDataOffset = allocWasmString("deviceType", allocs);
                  const valueDataOffset = allocWasmString(deviceType, allocs);
                  if (getInstance()._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {
                    checkLastError(`Can't set a session config entry: 'deviceType' - ${deviceType}.`);
                  }
                }
              }
              break;
            case "webgpu":
              epName = "JS";
              if (typeof ep !== "string") {
                const webgpuOptions = ep;
                if (webgpuOptions?.preferredLayout) {
                  if (webgpuOptions.preferredLayout !== "NCHW" && webgpuOptions.preferredLayout !== "NHWC") {
                    throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${webgpuOptions.preferredLayout}`);
                  }
                  const keyDataOffset = allocWasmString("preferredLayout", allocs);
                  const valueDataOffset = allocWasmString(webgpuOptions.preferredLayout, allocs);
                  if (getInstance()._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {
                    checkLastError(`Can't set a session config entry: 'preferredLayout' - ${webgpuOptions.preferredLayout}.`);
                  }
                }
              }
              break;
            case "wasm":
            case "cpu":
              continue;
            default:
              throw new Error(`not supported execution provider: ${epName}`);
          }
          const epNameDataOffset = allocWasmString(epName, allocs);
          if (getInstance()._OrtAppendExecutionProvider(sessionOptionsHandle, epNameDataOffset) !== 0) {
            checkLastError(`Can't append execution provider: ${epName}.`);
          }
        }
      };
      setSessionOptions = (options) => {
        const wasm3 = getInstance();
        let sessionOptionsHandle = 0;
        const allocs = [];
        const sessionOptions = options || {};
        appendDefaultOptions(sessionOptions);
        try {
          const graphOptimizationLevel = getGraphOptimzationLevel(sessionOptions.graphOptimizationLevel ?? "all");
          const executionMode = getExecutionMode(sessionOptions.executionMode ?? "sequential");
          const logIdDataOffset = typeof sessionOptions.logId === "string" ? allocWasmString(sessionOptions.logId, allocs) : 0;
          const logSeverityLevel = sessionOptions.logSeverityLevel ?? 2;
          if (!Number.isInteger(logSeverityLevel) || logSeverityLevel < 0 || logSeverityLevel > 4) {
            throw new Error(`log serverity level is not valid: ${logSeverityLevel}`);
          }
          const logVerbosityLevel = sessionOptions.logVerbosityLevel ?? 0;
          if (!Number.isInteger(logVerbosityLevel) || logVerbosityLevel < 0 || logVerbosityLevel > 4) {
            throw new Error(`log verbosity level is not valid: ${logVerbosityLevel}`);
          }
          const optimizedModelFilePathOffset = typeof sessionOptions.optimizedModelFilePath === "string" ? allocWasmString(sessionOptions.optimizedModelFilePath, allocs) : 0;
          sessionOptionsHandle = wasm3._OrtCreateSessionOptions(
            graphOptimizationLevel,
            !!sessionOptions.enableCpuMemArena,
            !!sessionOptions.enableMemPattern,
            executionMode,
            !!sessionOptions.enableProfiling,
            0,
            logIdDataOffset,
            logSeverityLevel,
            logVerbosityLevel,
            optimizedModelFilePathOffset
          );
          if (sessionOptionsHandle === 0) {
            checkLastError("Can't create session options.");
          }
          if (sessionOptions.executionProviders) {
            setExecutionProviders(sessionOptionsHandle, sessionOptions.executionProviders, allocs);
          }
          if (sessionOptions.enableGraphCapture !== void 0) {
            if (typeof sessionOptions.enableGraphCapture !== "boolean") {
              throw new Error(`enableGraphCapture must be a boolean value: ${sessionOptions.enableGraphCapture}`);
            }
            const keyDataOffset = allocWasmString("enableGraphCapture", allocs);
            const valueDataOffset = allocWasmString(sessionOptions.enableGraphCapture.toString(), allocs);
            if (wasm3._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {
              checkLastError(
                `Can't set a session config entry: 'enableGraphCapture' - ${sessionOptions.enableGraphCapture}.`
              );
            }
          }
          if (sessionOptions.freeDimensionOverrides) {
            for (const [name2, value] of Object.entries(sessionOptions.freeDimensionOverrides)) {
              if (typeof name2 !== "string") {
                throw new Error(`free dimension override name must be a string: ${name2}`);
              }
              if (typeof value !== "number" || !Number.isInteger(value) || value < 0) {
                throw new Error(`free dimension override value must be a non-negative integer: ${value}`);
              }
              const nameOffset = allocWasmString(name2, allocs);
              if (wasm3._OrtAddFreeDimensionOverride(sessionOptionsHandle, nameOffset, value) !== 0) {
                checkLastError(`Can't set a free dimension override: ${name2} - ${value}.`);
              }
            }
          }
          if (sessionOptions.extra !== void 0) {
            iterateExtraOptions(sessionOptions.extra, "", /* @__PURE__ */ new WeakSet(), (key, value) => {
              const keyDataOffset = allocWasmString(key, allocs);
              const valueDataOffset = allocWasmString(value, allocs);
              if (wasm3._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {
                checkLastError(`Can't set a session config entry: ${key} - ${value}.`);
              }
            });
          }
          return [sessionOptionsHandle, allocs];
        } catch (e) {
          if (sessionOptionsHandle !== 0) {
            wasm3._OrtReleaseSessionOptions(sessionOptionsHandle);
          }
          allocs.forEach((alloc) => wasm3._free(alloc));
          throw e;
        }
      };
    }
  });

  // web/lib/wasm/wasm-common.ts
  var tensorDataTypeStringToEnum, tensorDataTypeEnumToString, calculateTensorSizeInBytes, tensorTypeToTypedArrayConstructor, logLevelStringToEnum, isGpuBufferSupportedType, isMLTensorSupportedType, dataLocationStringToEnum;
  var init_wasm_common = __esm({
    "web/lib/wasm/wasm-common.ts"() {
      "use strict";
      tensorDataTypeStringToEnum = (type) => {
        switch (type) {
          case "int8":
            return 3 /* int8 */;
          case "uint8":
            return 2 /* uint8 */;
          case "bool":
            return 9 /* bool */;
          case "int16":
            return 5 /* int16 */;
          case "uint16":
            return 4 /* uint16 */;
          case "int32":
            return 6 /* int32 */;
          case "uint32":
            return 12 /* uint32 */;
          case "float16":
            return 10 /* float16 */;
          case "float32":
            return 1 /* float */;
          case "float64":
            return 11 /* double */;
          case "string":
            return 8 /* string */;
          case "int64":
            return 7 /* int64 */;
          case "uint64":
            return 13 /* uint64 */;
          case "int4":
            return 22 /* int4 */;
          case "uint4":
            return 21 /* uint4 */;
          default:
            throw new Error(`unsupported data type: ${type}`);
        }
      };
      tensorDataTypeEnumToString = (typeProto) => {
        switch (typeProto) {
          case 3 /* int8 */:
            return "int8";
          case 2 /* uint8 */:
            return "uint8";
          case 9 /* bool */:
            return "bool";
          case 5 /* int16 */:
            return "int16";
          case 4 /* uint16 */:
            return "uint16";
          case 6 /* int32 */:
            return "int32";
          case 12 /* uint32 */:
            return "uint32";
          case 10 /* float16 */:
            return "float16";
          case 1 /* float */:
            return "float32";
          case 11 /* double */:
            return "float64";
          case 8 /* string */:
            return "string";
          case 7 /* int64 */:
            return "int64";
          case 13 /* uint64 */:
            return "uint64";
          case 22 /* int4 */:
            return "int4";
          case 21 /* uint4 */:
            return "uint4";
          default:
            throw new Error(`unsupported data type: ${typeProto}`);
        }
      };
      calculateTensorSizeInBytes = (dateType, dimsOrSize) => {
        const elementSize = [
          -1,
          // undefined = 0
          4,
          // float = 1
          1,
          // uint8 = 2
          1,
          // int8 = 3
          2,
          // uint16 = 4
          2,
          // int16 = 5
          4,
          // int32 = 6
          8,
          // int64 = 7
          -1,
          // string = 8
          1,
          // bool = 9
          2,
          // float16 = 10
          8,
          // double = 11
          4,
          // uint32 = 12
          8,
          // uint64 = 13
          -1,
          // complex64 = 14
          -1,
          // complex128 = 15
          -1,
          // bfloat16 = 16
          -1,
          // FLOAT8E4M3FN = 17
          -1,
          // FLOAT8E4M3FNUZ = 18
          -1,
          // FLOAT8E5M2 = 19
          -1,
          // FLOAT8E5M2FNUZ = 20
          0.5,
          // uint4 = 21
          0.5
          // int4 = 22
        ][dateType];
        const size = typeof dimsOrSize === "number" ? dimsOrSize : dimsOrSize.reduce((a, b) => a * b, 1);
        return elementSize > 0 ? Math.ceil(size * elementSize) : void 0;
      };
      tensorTypeToTypedArrayConstructor = (type) => {
        switch (type) {
          case "float16":
            return typeof Float16Array !== "undefined" && Float16Array.from ? Float16Array : Uint16Array;
          case "float32":
            return Float32Array;
          case "uint8":
            return Uint8Array;
          case "int8":
            return Int8Array;
          case "uint16":
            return Uint16Array;
          case "int16":
            return Int16Array;
          case "int32":
            return Int32Array;
          case "bool":
            return Uint8Array;
          case "float64":
            return Float64Array;
          case "uint32":
            return Uint32Array;
          case "int64":
            return BigInt64Array;
          case "uint64":
            return BigUint64Array;
          default:
            throw new Error(`unsupported type: ${type}`);
        }
      };
      logLevelStringToEnum = (logLevel) => {
        switch (logLevel) {
          case "verbose":
            return 0;
          case "info":
            return 1;
          case "warning":
            return 2;
          case "error":
            return 3;
          case "fatal":
            return 4;
          default:
            throw new Error(`unsupported logging level: ${logLevel}`);
        }
      };
      isGpuBufferSupportedType = (type) => type === "float32" || type === "float16" || type === "int32" || type === "int64" || type === "uint32" || type === "uint8" || type === "bool" || type === "uint4" || type === "int4";
      isMLTensorSupportedType = (type) => type === "float32" || type === "float16" || type === "int32" || type === "int64" || type === "uint32" || type === "uint64" || type === "int8" || type === "uint8" || type === "bool" || type === "uint4" || type === "int4";
      dataLocationStringToEnum = (location2) => {
        switch (location2) {
          case "none":
            return 0;
          case "cpu":
            return 1;
          case "cpu-pinned":
            return 2;
          case "texture":
            return 3;
          case "gpu-buffer":
            return 4;
          case "ml-tensor":
            return 5;
          default:
            throw new Error(`unsupported data location: ${location2}`);
        }
      };
    }
  });

  // web/lib/wasm/wasm-utils-load-file.ts
  var loadFile;
  var init_wasm_utils_load_file = __esm({
    "web/lib/wasm/wasm-utils-load-file.ts"() {
      "use strict";
      init_wasm_utils_env();
      loadFile = async (file) => {
        if (typeof file === "string") {
          if (isNode) {
            try {
              const { readFile } = __require("node:fs/promises");
              return new Uint8Array(await readFile(file));
            } catch (e) {
              if (e.code === "ERR_FS_FILE_TOO_LARGE") {
                const { createReadStream } = __require("node:fs");
                const stream = createReadStream(file);
                const chunks = [];
                for await (const chunk of stream) {
                  chunks.push(chunk);
                }
                return new Uint8Array(Buffer.concat(chunks));
              }
              throw e;
            }
          } else {
            const response = await fetch(file);
            if (!response.ok) {
              throw new Error(`failed to load external data file: ${file}`);
            }
            const contentLengthHeader = response.headers.get("Content-Length");
            const fileSize = contentLengthHeader ? parseInt(contentLengthHeader, 10) : 0;
            if (fileSize < 1073741824) {
              return new Uint8Array(await response.arrayBuffer());
            } else {
              if (!response.body) {
                throw new Error(`failed to load external data file: ${file}, no response body.`);
              }
              const reader = response.body.getReader();
              let buffer;
              try {
                buffer = new ArrayBuffer(fileSize);
              } catch (e) {
                if (e instanceof RangeError) {
                  const pages = Math.ceil(fileSize / 65536);
                  buffer = new WebAssembly.Memory({ initial: pages, maximum: pages }).buffer;
                } else {
                  throw e;
                }
              }
              let offset = 0;
              while (true) {
                const { done, value } = await reader.read();
                if (done) {
                  break;
                }
                const chunkSize = value.byteLength;
                const chunk = new Uint8Array(buffer, offset, chunkSize);
                chunk.set(value);
                offset += chunkSize;
              }
              return new Uint8Array(buffer, 0, fileSize);
            }
          }
        } else if (file instanceof Blob) {
          return new Uint8Array(await file.arrayBuffer());
        } else if (file instanceof Uint8Array) {
          return file;
        } else {
          return new Uint8Array(file);
        }
      };
    }
  });

  // web/lib/wasm/wasm-core-impl.ts
  var initOrt, initRuntime, initEp, activeSessions, getSessionInputOutputCount, copyFromExternalBuffer, createSession, releaseSession, prepareInputOutputTensor, run, endProfiling, extractTransferableBuffers;
  var init_wasm_core_impl = __esm({
    "web/lib/wasm/wasm-core-impl.ts"() {
      "use strict";
      init_run_options();
      init_session_options();
      init_wasm_common();
      init_wasm_factory();
      init_wasm_utils();
      init_wasm_utils_load_file();
      initOrt = (numThreads, loggingLevel) => {
        const errorCode = getInstance()._OrtInit(numThreads, loggingLevel);
        if (errorCode !== 0) {
          checkLastError("Can't initialize onnxruntime.");
        }
      };
      initRuntime = async (env3) => {
        initOrt(env3.wasm.numThreads, logLevelStringToEnum(env3.logLevel));
      };
      initEp = async (env3, epName) => {
        if (false) {
          const initJsep = null.init;
          if (epName === "webgpu") {
            if (typeof navigator === "undefined" || !navigator.gpu) {
              throw new Error("WebGPU is not supported in current environment");
            }
            let adapter = env3.webgpu.adapter;
            if (!adapter) {
              const powerPreference = env3.webgpu.powerPreference;
              if (powerPreference !== void 0 && powerPreference !== "low-power" && powerPreference !== "high-performance") {
                throw new Error(`Invalid powerPreference setting: "${powerPreference}"`);
              }
              const forceFallbackAdapter = env3.webgpu.forceFallbackAdapter;
              if (forceFallbackAdapter !== void 0 && typeof forceFallbackAdapter !== "boolean") {
                throw new Error(`Invalid forceFallbackAdapter setting: "${forceFallbackAdapter}"`);
              }
              adapter = await navigator.gpu.requestAdapter({ powerPreference, forceFallbackAdapter });
              if (!adapter) {
                throw new Error(
                  'Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.'
                );
              }
            } else {
              if (typeof adapter.limits !== "object" || typeof adapter.features !== "object" || typeof adapter.requestDevice !== "function") {
                throw new Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.");
              }
            }
            await initJsep("webgpu", getInstance(), env3, adapter);
          }
          if (epName === "webnn") {
            if (typeof navigator === "undefined" || !navigator.ml) {
              throw new Error("WebNN is not supported in current environment");
            }
            await initJsep("webnn", getInstance(), env3);
          }
        }
      };
      activeSessions = /* @__PURE__ */ new Map();
      getSessionInputOutputCount = (sessionHandle) => {
        const wasm3 = getInstance();
        const stack = wasm3.stackSave();
        try {
          const dataOffset = wasm3.stackAlloc(8);
          const errorCode = wasm3._OrtGetInputOutputCount(sessionHandle, dataOffset, dataOffset + 4);
          if (errorCode !== 0) {
            checkLastError("Can't get session input/output count.");
          }
          return [wasm3.HEAP32[dataOffset / 4], wasm3.HEAP32[dataOffset / 4 + 1]];
        } finally {
          wasm3.stackRestore(stack);
        }
      };
      copyFromExternalBuffer = (model) => {
        const wasm3 = getInstance();
        const modelDataOffset = wasm3._malloc(model.byteLength);
        if (modelDataOffset === 0) {
          throw new Error(`Can't create a session. failed to allocate a buffer of size ${model.byteLength}.`);
        }
        wasm3.HEAPU8.set(model, modelDataOffset);
        return [modelDataOffset, model.byteLength];
      };
      createSession = async (modelData, options) => {
        let modelDataOffset, modelDataLength;
        const wasm3 = getInstance();
        if (Array.isArray(modelData)) {
          [modelDataOffset, modelDataLength] = modelData;
        } else if (modelData.buffer === wasm3.HEAPU8.buffer) {
          [modelDataOffset, modelDataLength] = [modelData.byteOffset, modelData.byteLength];
        } else {
          [modelDataOffset, modelDataLength] = copyFromExternalBuffer(modelData);
        }
        let sessionHandle = 0;
        let sessionOptionsHandle = 0;
        let ioBindingHandle = 0;
        let allocs = [];
        const inputNamesUTF8Encoded = [];
        const outputNamesUTF8Encoded = [];
        try {
          [sessionOptionsHandle, allocs] = setSessionOptions(options);
          if (options?.externalData && wasm3.mountExternalData) {
            const loadingPromises = [];
            for (const file of options.externalData) {
              const path = typeof file === "string" ? file : file.path;
              loadingPromises.push(
                loadFile(typeof file === "string" ? file : file.data).then((data) => {
                  wasm3.mountExternalData(path, data);
                })
              );
            }
            await Promise.all(loadingPromises);
          }
          for (const provider of options?.executionProviders ?? []) {
            const providerName = typeof provider === "string" ? provider : provider.name;
            if (providerName === "webnn") {
              wasm3.shouldTransferToMLTensor = false;
              if (wasm3.currentContext) {
                throw new Error("WebNN execution provider is already set.");
              }
              if (typeof provider !== "string") {
                const webnnOptions = provider;
                const context = webnnOptions?.context;
                const gpuDevice = webnnOptions?.gpuDevice;
                const deviceType = webnnOptions?.deviceType;
                const numThreads = webnnOptions?.numThreads;
                const powerPreference = webnnOptions?.powerPreference;
                if (context) {
                  wasm3.currentContext = context;
                } else if (gpuDevice) {
                  wasm3.currentContext = await navigator.ml.createContext(gpuDevice);
                } else {
                  wasm3.currentContext = await navigator.ml.createContext({ deviceType, numThreads, powerPreference });
                }
              } else {
                wasm3.currentContext = await navigator.ml.createContext();
              }
              break;
            }
          }
          sessionHandle = await wasm3._OrtCreateSession(modelDataOffset, modelDataLength, sessionOptionsHandle);
          if (sessionHandle === 0) {
            checkLastError("Can't create a session.");
          }
          if (wasm3.currentContext) {
            wasm3.jsepRegisterMLContext(sessionHandle, wasm3.currentContext);
            wasm3.currentContext = void 0;
            wasm3.shouldTransferToMLTensor = true;
          }
          const [inputCount, outputCount] = getSessionInputOutputCount(sessionHandle);
          const enableGraphCapture = !!options?.enableGraphCapture;
          const inputNames = [];
          const outputNames = [];
          const outputPreferredLocations = [];
          for (let i = 0; i < inputCount; i++) {
            const name2 = wasm3._OrtGetInputName(sessionHandle, i);
            if (name2 === 0) {
              checkLastError("Can't get an input name.");
            }
            inputNamesUTF8Encoded.push(name2);
            inputNames.push(wasm3.UTF8ToString(name2));
          }
          for (let i = 0; i < outputCount; i++) {
            const name2 = wasm3._OrtGetOutputName(sessionHandle, i);
            if (name2 === 0) {
              checkLastError("Can't get an output name.");
            }
            outputNamesUTF8Encoded.push(name2);
            const nameString = wasm3.UTF8ToString(name2);
            outputNames.push(nameString);
            if (false) {
              if (enableGraphCapture && options?.preferredOutputLocation === void 0) {
                outputPreferredLocations.push("gpu-buffer");
                continue;
              }
              const location2 = typeof options?.preferredOutputLocation === "string" ? options.preferredOutputLocation : options?.preferredOutputLocation?.[nameString] ?? "cpu";
              if (location2 !== "cpu" && location2 !== "cpu-pinned" && location2 !== "gpu-buffer" && location2 !== "ml-tensor") {
                throw new Error(`Not supported preferred output location: ${location2}.`);
              }
              if (enableGraphCapture && location2 !== "gpu-buffer") {
                throw new Error(
                  `Not supported preferred output location: ${location2}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`
                );
              }
              outputPreferredLocations.push(location2);
            }
          }
          let bindingState = null;
          if (false) {
            ioBindingHandle = wasm3._OrtCreateBinding(sessionHandle);
            if (ioBindingHandle === 0) {
              checkLastError("Can't create IO binding.");
            }
            bindingState = {
              handle: ioBindingHandle,
              outputPreferredLocations,
              outputPreferredLocationsEncoded: outputPreferredLocations.map((l) => dataLocationStringToEnum(l))
            };
          }
          activeSessions.set(sessionHandle, [
            sessionHandle,
            inputNamesUTF8Encoded,
            outputNamesUTF8Encoded,
            bindingState,
            enableGraphCapture,
            false
          ]);
          return [sessionHandle, inputNames, outputNames];
        } catch (e) {
          inputNamesUTF8Encoded.forEach((buf) => wasm3._OrtFree(buf));
          outputNamesUTF8Encoded.forEach((buf) => wasm3._OrtFree(buf));
          if (ioBindingHandle !== 0) {
            wasm3._OrtReleaseBinding(ioBindingHandle);
          }
          if (sessionHandle !== 0) {
            wasm3._OrtReleaseSession(sessionHandle);
          }
          throw e;
        } finally {
          wasm3._free(modelDataOffset);
          if (sessionOptionsHandle !== 0) {
            wasm3._OrtReleaseSessionOptions(sessionOptionsHandle);
          }
          allocs.forEach((alloc) => wasm3._free(alloc));
          wasm3.unmountExternalData?.();
        }
      };
      releaseSession = (sessionId) => {
        const wasm3 = getInstance();
        const session = activeSessions.get(sessionId);
        if (!session) {
          throw new Error(`cannot release session. invalid session id: ${sessionId}`);
        }
        const [sessionHandle, inputNamesUTF8Encoded, outputNamesUTF8Encoded, ioBindingState, enableGraphCapture] = session;
        if (ioBindingState) {
          if (enableGraphCapture) {
            wasm3._OrtClearBoundOutputs(ioBindingState.handle);
          }
          wasm3._OrtReleaseBinding(ioBindingState.handle);
        }
        wasm3.jsepOnReleaseSession?.(sessionId);
        inputNamesUTF8Encoded.forEach((buf) => wasm3._OrtFree(buf));
        outputNamesUTF8Encoded.forEach((buf) => wasm3._OrtFree(buf));
        wasm3._OrtReleaseSession(sessionHandle);
        activeSessions.delete(sessionId);
      };
      prepareInputOutputTensor = (tensor, tensorHandles, allocs, sessionId, index, enableGraphCapture = false) => {
        if (!tensor) {
          tensorHandles.push(0);
          return;
        }
        const wasm3 = getInstance();
        const dataType = tensor[0];
        const dims = tensor[1];
        const location2 = tensor[3];
        let rawData;
        let dataByteLength;
        if (dataType === "string" && (location2 === "gpu-buffer" || location2 === "ml-tensor")) {
          throw new Error("String tensor is not supported on GPU.");
        }
        if (enableGraphCapture && location2 !== "gpu-buffer") {
          throw new Error(
            `External buffer must be provided for input/output index ${index} when enableGraphCapture is true.`
          );
        }
        if (location2 === "gpu-buffer") {
          const gpuBuffer = tensor[2].gpuBuffer;
          dataByteLength = calculateTensorSizeInBytes(tensorDataTypeStringToEnum(dataType), dims);
          const registerBuffer = wasm3.jsepRegisterBuffer;
          if (!registerBuffer) {
            throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');
          }
          rawData = registerBuffer(sessionId, index, gpuBuffer, dataByteLength);
        } else if (location2 === "ml-tensor") {
          const mlTensor = tensor[2].mlTensor;
          dataByteLength = calculateTensorSizeInBytes(tensorDataTypeStringToEnum(dataType), dims);
          const registerMLTensor = wasm3.jsepRegisterMLTensor;
          if (!registerMLTensor) {
            throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');
          }
          rawData = registerMLTensor(mlTensor, tensorDataTypeStringToEnum(dataType), dims);
        } else {
          const data = tensor[2];
          if (Array.isArray(data)) {
            dataByteLength = 4 * data.length;
            rawData = wasm3._malloc(dataByteLength);
            allocs.push(rawData);
            let dataIndex = rawData / 4;
            for (let i = 0; i < data.length; i++) {
              if (typeof data[i] !== "string") {
                throw new TypeError(`tensor data at index ${i} is not a string`);
              }
              wasm3.HEAPU32[dataIndex++] = allocWasmString(data[i], allocs);
            }
          } else {
            dataByteLength = data.byteLength;
            rawData = wasm3._malloc(dataByteLength);
            allocs.push(rawData);
            wasm3.HEAPU8.set(new Uint8Array(data.buffer, data.byteOffset, dataByteLength), rawData);
          }
        }
        const stack = wasm3.stackSave();
        const dimsOffset = wasm3.stackAlloc(4 * dims.length);
        try {
          let dimIndex = dimsOffset / 4;
          dims.forEach((d) => wasm3.HEAP32[dimIndex++] = d);
          const tensor2 = wasm3._OrtCreateTensor(
            tensorDataTypeStringToEnum(dataType),
            rawData,
            dataByteLength,
            dimsOffset,
            dims.length,
            dataLocationStringToEnum(location2)
          );
          if (tensor2 === 0) {
            checkLastError(`Can't create tensor for input/output. session=${sessionId}, index=${index}.`);
          }
          tensorHandles.push(tensor2);
        } finally {
          wasm3.stackRestore(stack);
        }
      };
      run = async (sessionId, inputIndices, inputTensors, outputIndices, outputTensors, options) => {
        const wasm3 = getInstance();
        const session = activeSessions.get(sessionId);
        if (!session) {
          throw new Error(`cannot run inference. invalid session id: ${sessionId}`);
        }
        const sessionHandle = session[0];
        const inputNamesUTF8Encoded = session[1];
        const outputNamesUTF8Encoded = session[2];
        const ioBindingState = session[3];
        const enableGraphCapture = session[4];
        const inputOutputBound = session[5];
        const inputCount = inputIndices.length;
        const outputCount = outputIndices.length;
        let runOptionsHandle = 0;
        let runOptionsAllocs = [];
        const inputTensorHandles = [];
        const outputTensorHandles = [];
        const inputOutputAllocs = [];
        const beforeRunStack = wasm3.stackSave();
        const inputValuesOffset = wasm3.stackAlloc(inputCount * 4);
        const inputNamesOffset = wasm3.stackAlloc(inputCount * 4);
        const outputValuesOffset = wasm3.stackAlloc(outputCount * 4);
        const outputNamesOffset = wasm3.stackAlloc(outputCount * 4);
        try {
          wasm3.jsepOnRunStart?.(sessionHandle);
          [runOptionsHandle, runOptionsAllocs] = setRunOptions(options);
          for (let i = 0; i < inputCount; i++) {
            prepareInputOutputTensor(
              inputTensors[i],
              inputTensorHandles,
              inputOutputAllocs,
              sessionId,
              inputIndices[i],
              enableGraphCapture
            );
          }
          for (let i = 0; i < outputCount; i++) {
            prepareInputOutputTensor(
              outputTensors[i],
              outputTensorHandles,
              inputOutputAllocs,
              sessionId,
              inputCount + outputIndices[i],
              enableGraphCapture
            );
          }
          let inputValuesIndex = inputValuesOffset / 4;
          let inputNamesIndex = inputNamesOffset / 4;
          let outputValuesIndex = outputValuesOffset / 4;
          let outputNamesIndex = outputNamesOffset / 4;
          for (let i = 0; i < inputCount; i++) {
            wasm3.HEAPU32[inputValuesIndex++] = inputTensorHandles[i];
            wasm3.HEAPU32[inputNamesIndex++] = inputNamesUTF8Encoded[inputIndices[i]];
          }
          for (let i = 0; i < outputCount; i++) {
            wasm3.HEAPU32[outputValuesIndex++] = outputTensorHandles[i];
            wasm3.HEAPU32[outputNamesIndex++] = outputNamesUTF8Encoded[outputIndices[i]];
          }
          if (false) {
            const { handle, outputPreferredLocations, outputPreferredLocationsEncoded } = ioBindingState;
            if (inputNamesUTF8Encoded.length !== inputCount) {
              throw new Error(
                `input count from feeds (${inputCount}) is expected to be always equal to model's input count (${inputNamesUTF8Encoded.length}).`
              );
            }
            for (let i = 0; i < inputCount; i++) {
              const index = inputIndices[i];
              const errorCode2 = await wasm3._OrtBindInput(handle, inputNamesUTF8Encoded[index], inputTensorHandles[i]);
              if (errorCode2 !== 0) {
                checkLastError(`Can't bind input[${i}] for session=${sessionId}.`);
              }
            }
            for (let i = 0; i < outputCount; i++) {
              const index = outputIndices[i];
              const location2 = outputTensors[i]?.[3];
              if (location2) {
                const errorCode2 = wasm3._OrtBindOutput(handle, outputNamesUTF8Encoded[index], outputTensorHandles[i], 0);
                if (errorCode2 !== 0) {
                  checkLastError(`Can't bind pre-allocated output[${i}] for session=${sessionId}.`);
                }
              } else {
                const errorCode2 = wasm3._OrtBindOutput(
                  handle,
                  outputNamesUTF8Encoded[index],
                  0,
                  outputPreferredLocationsEncoded[index]
                );
                if (errorCode2 !== 0) {
                  checkLastError(`Can't bind output[${i}] to ${outputPreferredLocations[i]} for session=${sessionId}.`);
                }
              }
            }
            activeSessions.set(sessionId, [
              sessionHandle,
              inputNamesUTF8Encoded,
              outputNamesUTF8Encoded,
              ioBindingState,
              enableGraphCapture,
              true
            ]);
          }
          let errorCode;
          if (false) {
            errorCode = await wasm3._OrtRunWithBinding(
              sessionHandle,
              ioBindingState.handle,
              outputCount,
              outputValuesOffset,
              runOptionsHandle
            );
          } else {
            errorCode = await wasm3._OrtRun(
              sessionHandle,
              inputNamesOffset,
              inputValuesOffset,
              inputCount,
              outputNamesOffset,
              outputCount,
              outputValuesOffset,
              runOptionsHandle
            );
          }
          if (errorCode !== 0) {
            checkLastError("failed to call OrtRun().");
          }
          const output = [];
          for (let i = 0; i < outputCount; i++) {
            const tensor = wasm3.HEAPU32[outputValuesOffset / 4 + i];
            if (tensor === outputTensorHandles[i]) {
              output.push(outputTensors[i]);
              continue;
            }
            const beforeGetTensorDataStack = wasm3.stackSave();
            const tensorDataOffset = wasm3.stackAlloc(4 * 4);
            let keepOutputTensor = false;
            let type, dataOffset = 0;
            try {
              const errorCode2 = wasm3._OrtGetTensorData(
                tensor,
                tensorDataOffset,
                tensorDataOffset + 4,
                tensorDataOffset + 8,
                tensorDataOffset + 12
              );
              if (errorCode2 !== 0) {
                checkLastError(`Can't access output tensor data on index ${i}.`);
              }
              let tensorDataIndex = tensorDataOffset / 4;
              const dataType = wasm3.HEAPU32[tensorDataIndex++];
              dataOffset = wasm3.HEAPU32[tensorDataIndex++];
              const dimsOffset = wasm3.HEAPU32[tensorDataIndex++];
              const dimsLength = wasm3.HEAPU32[tensorDataIndex++];
              const dims = [];
              for (let i2 = 0; i2 < dimsLength; i2++) {
                dims.push(wasm3.HEAPU32[dimsOffset / 4 + i2]);
              }
              wasm3._OrtFree(dimsOffset);
              const size = dims.reduce((a, b) => a * b, 1);
              type = tensorDataTypeEnumToString(dataType);
              const preferredLocation = ioBindingState?.outputPreferredLocations[outputIndices[i]];
              if (type === "string") {
                if (preferredLocation === "gpu-buffer" || preferredLocation === "ml-tensor") {
                  throw new Error("String tensor is not supported on GPU.");
                }
                const stringData = [];
                let dataIndex = dataOffset / 4;
                for (let i2 = 0; i2 < size; i2++) {
                  const offset = wasm3.HEAPU32[dataIndex++];
                  const maxBytesToRead = i2 === size - 1 ? void 0 : wasm3.HEAPU32[dataIndex] - offset;
                  stringData.push(wasm3.UTF8ToString(offset, maxBytesToRead));
                }
                output.push([type, dims, stringData, "cpu"]);
              } else {
                if (preferredLocation === "gpu-buffer" && size > 0) {
                  const getBuffer = wasm3.jsepGetBuffer;
                  if (!getBuffer) {
                    throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');
                  }
                  const gpuBuffer = getBuffer(dataOffset);
                  const bufferSize = calculateTensorSizeInBytes(dataType, size);
                  if (bufferSize === void 0 || !isGpuBufferSupportedType(type)) {
                    throw new Error(`Unsupported data type: ${type}`);
                  }
                  keepOutputTensor = true;
                  output.push([
                    type,
                    dims,
                    {
                      gpuBuffer,
                      download: wasm3.jsepCreateDownloader(gpuBuffer, bufferSize, type),
                      dispose: () => {
                        wasm3._OrtReleaseTensor(tensor);
                      }
                    },
                    "gpu-buffer"
                  ]);
                } else if (preferredLocation === "ml-tensor" && size > 0) {
                  const ensureTensor = wasm3.jsepEnsureTensor;
                  if (!ensureTensor) {
                    throw new Error('preferredLocation "ml-tensor" is not supported without using WebNN.');
                  }
                  const tensorSize = calculateTensorSizeInBytes(dataType, size);
                  if (tensorSize === void 0 || !isMLTensorSupportedType(type)) {
                    throw new Error(`Unsupported data type: ${type}`);
                  }
                  const mlTensor = await ensureTensor(dataOffset, dataType, dims, false);
                  keepOutputTensor = true;
                  output.push([
                    type,
                    dims,
                    {
                      mlTensor,
                      download: wasm3.jsepCreateMLTensorDownloader(dataOffset, type),
                      dispose: () => {
                        wasm3.jsepReleaseTensorId(dataOffset);
                        wasm3._OrtReleaseTensor(tensor);
                      }
                    },
                    "ml-tensor"
                  ]);
                } else {
                  const typedArrayConstructor = tensorTypeToTypedArrayConstructor(type);
                  const data = new typedArrayConstructor(size);
                  new Uint8Array(data.buffer, data.byteOffset, data.byteLength).set(
                    wasm3.HEAPU8.subarray(dataOffset, dataOffset + data.byteLength)
                  );
                  output.push([type, dims, data, "cpu"]);
                }
              }
            } finally {
              wasm3.stackRestore(beforeGetTensorDataStack);
              if (type === "string" && dataOffset) {
                wasm3._free(dataOffset);
              }
              if (!keepOutputTensor) {
                wasm3._OrtReleaseTensor(tensor);
              }
            }
          }
          if (ioBindingState && !enableGraphCapture) {
            wasm3._OrtClearBoundOutputs(ioBindingState.handle);
            activeSessions.set(sessionId, [
              sessionHandle,
              inputNamesUTF8Encoded,
              outputNamesUTF8Encoded,
              ioBindingState,
              enableGraphCapture,
              false
            ]);
          }
          return output;
        } finally {
          wasm3.stackRestore(beforeRunStack);
          inputTensorHandles.forEach((v) => wasm3._OrtReleaseTensor(v));
          outputTensorHandles.forEach((v) => wasm3._OrtReleaseTensor(v));
          inputOutputAllocs.forEach((p) => wasm3._free(p));
          if (runOptionsHandle !== 0) {
            wasm3._OrtReleaseRunOptions(runOptionsHandle);
          }
          runOptionsAllocs.forEach((p) => wasm3._free(p));
        }
      };
      endProfiling = (sessionId) => {
        const wasm3 = getInstance();
        const session = activeSessions.get(sessionId);
        if (!session) {
          throw new Error("invalid session id");
        }
        const sessionHandle = session[0];
        const profileFileName = wasm3._OrtEndProfiling(sessionHandle);
        if (profileFileName === 0) {
          checkLastError("Can't get an profile file name.");
        }
        wasm3._OrtFree(profileFileName);
      };
      extractTransferableBuffers = (tensors) => {
        const buffers = [];
        for (const tensor of tensors) {
          const data = tensor[2];
          if (!Array.isArray(data) && "buffer" in data) {
            buffers.push(data.buffer);
          }
        }
        return buffers;
      };
    }
  });

  // web/lib/wasm/proxy-wrapper.ts
  var isProxy, proxyWorker, initializing2, initialized2, aborted2, temporaryObjectUrl, initWasmCallbacks, queuedCallbacks, enqueueCallbacks, ensureWorker, onProxyWorkerMessage, initializeWebAssemblyAndOrtRuntime, initializeOrtEp, copyFromExternalBuffer2, createSession2, releaseSession2, run2, endProfiling2;
  var init_proxy_wrapper = __esm({
    "web/lib/wasm/proxy-wrapper.ts"() {
      "use strict";
      init_esm();
      init_wasm_core_impl();
      init_wasm_factory();
      init_wasm_utils_import();
      isProxy = () => !!env2.wasm.proxy && typeof document !== "undefined";
      initializing2 = false;
      initialized2 = false;
      aborted2 = false;
      queuedCallbacks = /* @__PURE__ */ new Map();
      enqueueCallbacks = (type, callbacks) => {
        const queue = queuedCallbacks.get(type);
        if (queue) {
          queue.push(callbacks);
        } else {
          queuedCallbacks.set(type, [callbacks]);
        }
      };
      ensureWorker = () => {
        if (initializing2 || !initialized2 || aborted2 || !proxyWorker) {
          throw new Error("worker not ready");
        }
      };
      onProxyWorkerMessage = (ev) => {
        switch (ev.data.type) {
          case "init-wasm":
            initializing2 = false;
            if (ev.data.err) {
              aborted2 = true;
              initWasmCallbacks[1](ev.data.err);
            } else {
              initialized2 = true;
              initWasmCallbacks[0]();
            }
            if (temporaryObjectUrl) {
              URL.revokeObjectURL(temporaryObjectUrl);
              temporaryObjectUrl = void 0;
            }
            break;
          case "init-ep":
          case "copy-from":
          case "create":
          case "release":
          case "run":
          case "end-profiling": {
            const callbacks = queuedCallbacks.get(ev.data.type);
            if (ev.data.err) {
              callbacks.shift()[1](ev.data.err);
            } else {
              callbacks.shift()[0](ev.data.out);
            }
            break;
          }
          default:
        }
      };
      initializeWebAssemblyAndOrtRuntime = async () => {
        if (initialized2) {
          return;
        }
        if (initializing2) {
          throw new Error("multiple calls to 'initWasm()' detected.");
        }
        if (aborted2) {
          throw new Error("previous call to 'initWasm()' failed.");
        }
        initializing2 = true;
        if (isProxy()) {
          return new Promise((resolve, reject) => {
            proxyWorker?.terminate();
            void importProxyWorker().then(([objectUrl, worker]) => {
              try {
                proxyWorker = worker;
                proxyWorker.onerror = (ev) => reject(ev);
                proxyWorker.onmessage = onProxyWorkerMessage;
                initWasmCallbacks = [resolve, reject];
                const message = { type: "init-wasm", in: env2 };
                proxyWorker.postMessage(message);
                temporaryObjectUrl = objectUrl;
              } catch (e) {
                reject(e);
              }
            }, reject);
          });
        } else {
          try {
            await initializeWebAssembly(env2.wasm);
            await initRuntime(env2);
            initialized2 = true;
          } catch (e) {
            aborted2 = true;
            throw e;
          } finally {
            initializing2 = false;
          }
        }
      };
      initializeOrtEp = async (epName) => {
        if (isProxy()) {
          ensureWorker();
          return new Promise((resolve, reject) => {
            enqueueCallbacks("init-ep", [resolve, reject]);
            const message = { type: "init-ep", in: { epName, env: env2 } };
            proxyWorker.postMessage(message);
          });
        } else {
          await initEp(env2, epName);
        }
      };
      copyFromExternalBuffer2 = async (buffer) => {
        if (isProxy()) {
          ensureWorker();
          return new Promise((resolve, reject) => {
            enqueueCallbacks("copy-from", [resolve, reject]);
            const message = { type: "copy-from", in: { buffer } };
            proxyWorker.postMessage(message, [buffer.buffer]);
          });
        } else {
          return copyFromExternalBuffer(buffer);
        }
      };
      createSession2 = async (model, options) => {
        if (isProxy()) {
          if (options?.preferredOutputLocation) {
            throw new Error('session option "preferredOutputLocation" is not supported for proxy.');
          }
          ensureWorker();
          return new Promise((resolve, reject) => {
            enqueueCallbacks("create", [resolve, reject]);
            const message = { type: "create", in: { model, options: { ...options } } };
            const transferable = [];
            if (model instanceof Uint8Array) {
              transferable.push(model.buffer);
            }
            proxyWorker.postMessage(message, transferable);
          });
        } else {
          return createSession(model, options);
        }
      };
      releaseSession2 = async (sessionId) => {
        if (isProxy()) {
          ensureWorker();
          return new Promise((resolve, reject) => {
            enqueueCallbacks("release", [resolve, reject]);
            const message = { type: "release", in: sessionId };
            proxyWorker.postMessage(message);
          });
        } else {
          releaseSession(sessionId);
        }
      };
      run2 = async (sessionId, inputIndices, inputs, outputIndices, outputs, options) => {
        if (isProxy()) {
          if (inputs.some((t) => t[3] !== "cpu")) {
            throw new Error("input tensor on GPU is not supported for proxy.");
          }
          if (outputs.some((t) => t)) {
            throw new Error("pre-allocated output tensor is not supported for proxy.");
          }
          ensureWorker();
          return new Promise((resolve, reject) => {
            enqueueCallbacks("run", [resolve, reject]);
            const serializableInputs = inputs;
            const message = {
              type: "run",
              in: { sessionId, inputIndices, inputs: serializableInputs, outputIndices, options }
            };
            proxyWorker.postMessage(message, extractTransferableBuffers(serializableInputs));
          });
        } else {
          return run(sessionId, inputIndices, inputs, outputIndices, outputs, options);
        }
      };
      endProfiling2 = async (sessionId) => {
        if (isProxy()) {
          ensureWorker();
          return new Promise((resolve, reject) => {
            enqueueCallbacks("end-profiling", [resolve, reject]);
            const message = { type: "end-profiling", in: sessionId };
            proxyWorker.postMessage(message);
          });
        } else {
          endProfiling(sessionId);
        }
      };
    }
  });

  // web/lib/wasm/session-handler-inference.ts
  var encodeTensorMetadata, decodeTensorMetadata, OnnxruntimeWebAssemblySessionHandler;
  var init_session_handler_inference2 = __esm({
    "web/lib/wasm/session-handler-inference.ts"() {
      "use strict";
      init_esm();
      init_proxy_wrapper();
      init_wasm_common();
      init_wasm_utils_env();
      init_wasm_utils_load_file();
      encodeTensorMetadata = (tensor, getName) => {
        switch (tensor.location) {
          case "cpu":
            return [tensor.type, tensor.dims, tensor.data, "cpu"];
          case "gpu-buffer":
            return [tensor.type, tensor.dims, { gpuBuffer: tensor.gpuBuffer }, "gpu-buffer"];
          case "ml-tensor":
            return [tensor.type, tensor.dims, { mlTensor: tensor.mlTensor }, "ml-tensor"];
          default:
            throw new Error(`invalid data location: ${tensor.location} for ${getName()}`);
        }
      };
      decodeTensorMetadata = (tensor) => {
        switch (tensor[3]) {
          case "cpu":
            return new Tensor2(tensor[0], tensor[2], tensor[1]);
          case "gpu-buffer": {
            const dataType = tensor[0];
            if (!isGpuBufferSupportedType(dataType)) {
              throw new Error(`not supported data type: ${dataType} for deserializing GPU tensor`);
            }
            const { gpuBuffer, download, dispose } = tensor[2];
            return Tensor2.fromGpuBuffer(gpuBuffer, { dataType, dims: tensor[1], download, dispose });
          }
          case "ml-tensor": {
            const dataType = tensor[0];
            if (!isMLTensorSupportedType(dataType)) {
              throw new Error(`not supported data type: ${dataType} for deserializing MLTensor tensor`);
            }
            const { mlTensor, download, dispose } = tensor[2];
            return Tensor2.fromMLTensor(mlTensor, { dataType, dims: tensor[1], download, dispose });
          }
          default:
            throw new Error(`invalid data location: ${tensor[3]}`);
        }
      };
      OnnxruntimeWebAssemblySessionHandler = class {
        async fetchModelAndCopyToWasmMemory(path) {
          return copyFromExternalBuffer2(await loadFile(path));
        }
        async loadModel(pathOrBuffer, options) {
          TRACE_FUNC_BEGIN();
          let model;
          if (typeof pathOrBuffer === "string") {
            if (isNode) {
              model = await loadFile(pathOrBuffer);
            } else {
              model = await this.fetchModelAndCopyToWasmMemory(pathOrBuffer);
            }
          } else {
            model = pathOrBuffer;
          }
          [this.sessionId, this.inputNames, this.outputNames] = await createSession2(model, options);
          TRACE_FUNC_END();
        }
        async dispose() {
          return releaseSession2(this.sessionId);
        }
        async run(feeds, fetches, options) {
          TRACE_FUNC_BEGIN();
          const inputArray = [];
          const inputIndices = [];
          Object.entries(feeds).forEach((kvp) => {
            const name2 = kvp[0];
            const tensor = kvp[1];
            const index = this.inputNames.indexOf(name2);
            if (index === -1) {
              throw new Error(`invalid input '${name2}'`);
            }
            inputArray.push(tensor);
            inputIndices.push(index);
          });
          const outputArray = [];
          const outputIndices = [];
          Object.entries(fetches).forEach((kvp) => {
            const name2 = kvp[0];
            const tensor = kvp[1];
            const index = this.outputNames.indexOf(name2);
            if (index === -1) {
              throw new Error(`invalid output '${name2}'`);
            }
            outputArray.push(tensor);
            outputIndices.push(index);
          });
          const inputs = inputArray.map(
            (t, i) => encodeTensorMetadata(t, () => `input "${this.inputNames[inputIndices[i]]}"`)
          );
          const outputs = outputArray.map(
            (t, i) => t ? encodeTensorMetadata(t, () => `output "${this.outputNames[outputIndices[i]]}"`) : null
          );
          const results = await run2(this.sessionId, inputIndices, inputs, outputIndices, outputs, options);
          const resultMap = {};
          for (let i = 0; i < results.length; i++) {
            resultMap[this.outputNames[outputIndices[i]]] = outputArray[i] ?? decodeTensorMetadata(results[i]);
          }
          TRACE_FUNC_END();
          return resultMap;
        }
        startProfiling() {
        }
        endProfiling() {
          void endProfiling2(this.sessionId);
        }
      };
    }
  });

  // web/lib/backend-wasm.ts
  var backend_wasm_exports = {};
  __export(backend_wasm_exports, {
    OnnxruntimeWebAssemblyBackend: () => OnnxruntimeWebAssemblyBackend,
    initializeFlags: () => initializeFlags,
    wasmBackend: () => wasmBackend
  });
  var initializeFlags, OnnxruntimeWebAssemblyBackend, wasmBackend;
  var init_backend_wasm = __esm({
    "web/lib/backend-wasm.ts"() {
      "use strict";
      init_esm();
      init_proxy_wrapper();
      init_session_handler_inference2();
      init_wasm_utils_import();
      initializeFlags = () => {
        if (typeof env2.wasm.initTimeout !== "number" || env2.wasm.initTimeout < 0) {
          env2.wasm.initTimeout = 0;
        }
        if (env2.wasm.simd === false) {
          console.warn(
            'Deprecated property "env.wasm.simd" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'
          );
        }
        if (typeof env2.wasm.proxy !== "boolean") {
          env2.wasm.proxy = false;
        }
        if (typeof env2.wasm.trace !== "boolean") {
          env2.wasm.trace = false;
        }
        if (typeof env2.wasm.numThreads !== "number" || !Number.isInteger(env2.wasm.numThreads) || env2.wasm.numThreads <= 0) {
          if (typeof self !== "undefined" && !self.crossOriginIsolated) {
            env2.wasm.numThreads = 1;
          } else {
            const numCpuLogicalCores = typeof navigator === "undefined" ? __require("node:os").cpus().length : navigator.hardwareConcurrency;
            env2.wasm.numThreads = Math.min(4, Math.ceil((numCpuLogicalCores || 1) / 2));
          }
        }
        if (true) {
          if (env2.wasm.wasmPaths === void 0 && scriptSrc && scriptSrc.indexOf("blob:") !== 0) {
            env2.wasm.wasmPaths = scriptSrc.substring(0, scriptSrc.lastIndexOf("/") + 1);
          }
        }
      };
      OnnxruntimeWebAssemblyBackend = class {
        /**
         * This function initializes the WebAssembly backend.
         *
         * This function will be called only once for each backend name. It will be called the first time when
         * `ort.InferenceSession.create()` is called with a registered backend name.
         *
         * @param backendName - the registered backend name.
         */
        async init(backendName) {
          initializeFlags();
          await initializeWebAssemblyAndOrtRuntime();
          await initializeOrtEp(backendName);
        }
        async createInferenceSessionHandler(pathOrBuffer, options) {
          const handler = new OnnxruntimeWebAssemblySessionHandler();
          await handler.loadModel(pathOrBuffer, options);
          return Promise.resolve(handler);
        }
      };
      wasmBackend = new OnnxruntimeWebAssemblyBackend();
    }
  });

  // web/lib/index.ts
  var lib_exports = {};
  __export(lib_exports, {
    InferenceSession: () => InferenceSession2,
    TRACE: () => TRACE,
    TRACE_FUNC_BEGIN: () => TRACE_FUNC_BEGIN,
    TRACE_FUNC_END: () => TRACE_FUNC_END,
    Tensor: () => Tensor2,
    TrainingSession: () => TrainingSession2,
    default: () => lib_default,
    env: () => env2,
    registerBackend: () => registerBackend
  });
  init_esm();
  init_esm();
  init_esm();

  // web/lib/version.ts
  var version2 = "1.20.0";

  // web/lib/index.ts
  var lib_default = esm_exports;
  if (true) {
    const onnxjsBackend2 = (init_backend_onnxjs(), __toCommonJS(backend_onnxjs_exports)).onnxjsBackend;
    registerBackend("webgl", onnxjsBackend2, -10);
  }
  if (true) {
    const wasmBackend2 = (init_backend_wasm(), __toCommonJS(backend_wasm_exports)).wasmBackend;
    if (false) {
      registerBackend("webgpu", wasmBackend2, 5);
      registerBackend("webnn", wasmBackend2, 5);
    }
    registerBackend("cpu", wasmBackend2, 10);
    registerBackend("wasm", wasmBackend2, 10);
  }
  Object.defineProperty(env2.versions, "web", { value: version2, enumerable: true });
  return __toCommonJS(lib_exports);
})();
/*! Bundled license information:

long/index.js:
  (**
   * @license
   * Copyright 2009 The Closure Library Authors
   * Copyright 2020 Daniel Wirtz / The long.js Authors.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   *)
*/
typeof exports=="object"&&typeof module=="object"&&(module.exports=ort);
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vY29tbW9uL2xpYi9iYWNrZW5kLWltcGwudHMiLCAiLi4vLi4vY29tbW9uL2xpYi9iYWNrZW5kLnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvdmVyc2lvbi50cyIsICIuLi8uLi9jb21tb24vbGliL2Vudi1pbXBsLnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvZW52LnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvdGVuc29yLWNvbnZlcnNpb24taW1wbC50cyIsICIuLi8uLi9jb21tb24vbGliL3RlbnNvci1mYWN0b3J5LWltcGwudHMiLCAiLi4vLi4vY29tbW9uL2xpYi90ZW5zb3ItaW1wbC10eXBlLW1hcHBpbmcudHMiLCAiLi4vLi4vY29tbW9uL2xpYi90ZW5zb3ItdXRpbHMtaW1wbC50cyIsICIuLi8uLi9jb21tb24vbGliL3RlbnNvci1pbXBsLnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvdGVuc29yLnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvdHJhY2UudHMiLCAiLi4vLi4vY29tbW9uL2xpYi9pbmZlcmVuY2Utc2Vzc2lvbi1pbXBsLnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvaW5mZXJlbmNlLXNlc3Npb24udHMiLCAiLi4vLi4vY29tbW9uL2xpYi90ZW5zb3ItY29udmVyc2lvbi50cyIsICIuLi8uLi9jb21tb24vbGliL3RlbnNvci1mYWN0b3J5LnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvb25ueC1tb2RlbC50cyIsICIuLi8uLi9jb21tb24vbGliL29ubngtdmFsdWUudHMiLCAiLi4vLi4vY29tbW9uL2xpYi90cmFpbmluZy1zZXNzaW9uLWltcGwudHMiLCAiLi4vLi4vY29tbW9uL2xpYi90cmFpbmluZy1zZXNzaW9uLnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvaW5kZXgudHMiLCAiLi4vbGliL29ubnhqcy9pbnN0cnVtZW50LnRzIiwgIi4uL2xpYi9vbm54anMvb3BzZXQudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2d1aWQtdHlwZXNjcmlwdC9kaXN0L2d1aWQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2xvbmcvaW5kZXguanMiLCAiLi4vbm9kZV9tb2R1bGVzL2ZsYXRidWZmZXJzL2pzL2ZsYXRidWZmZXJzLm1qcyIsICIuLi9saWIvb25ueGpzL29ydC1zY2hlbWEvZmxhdGJ1ZmZlcnMvb3J0LWdlbmVyYXRlZC50cyIsICIuLi9ub2RlX21vZHVsZXMvQHByb3RvYnVmanMvYXNwcm9taXNlL2luZGV4LmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9iYXNlNjQvaW5kZXguanMiLCAiLi4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL2V2ZW50ZW1pdHRlci9pbmRleC5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHByb3RvYnVmanMvZmxvYXQvaW5kZXguanMiLCAiLi4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL2lucXVpcmUvaW5kZXguanMiLCAiLi4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL3V0ZjgvaW5kZXguanMiLCAiLi4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL3Bvb2wvaW5kZXguanMiLCAiLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3V0aWwvbG9uZ2JpdHMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3V0aWwvbWluaW1hbC5qcyIsICIuLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvd3JpdGVyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy93cml0ZXJfYnVmZmVyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9yZWFkZXIuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JlYWRlcl9idWZmZXIuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JwYy9zZXJ2aWNlLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9ycGMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3Jvb3RzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9pbmRleC1taW5pbWFsLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL21pbmltYWwuanMiLCAiLi4vbGliL29ubnhqcy9vcnQtc2NoZW1hL3Byb3RvYnVmL29ubnguanMiLCAiLi4vbGliL29ubnhqcy91dGlsLnRzIiwgIi4uL2xpYi9vbm54anMvdGVuc29yLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvZ2xzbC1zb3VyY2UudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC90eXBlcy50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL3V0aWxzLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL3BhY2tpbmctdXRpbHMudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvcGFjay50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9yZXNoYXBlLXBhY2tlZC50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy91aW50OC1lbmNvZGUudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvdW5wYWNrLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvdGV4dHVyZS1kYXRhLWVuY29kZXIudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC90ZXh0dXJlLWxheW91dC50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL2luZmVyZW5jZS1oYW5kbGVyLnRzIiwgIi4uL2xpYi9vbm54anMvYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5LnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL2JhdGNoLW5vcm1hbGl6YXRpb24udHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9nbHNsLWRlZmluaXRpb25zLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL2JpbmFyeS1vcC50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9jYXN0LnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL2NvbmNhdC1wYWNrZWQudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvY29uY2F0LnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL3VuYXJ5LW9wLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL2Z1c2UtdXRpbHMudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvY29udi1ncm91cGVkLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL2ltMmNvbC1wYWNrLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL21hdG11bC50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9tYXRtdWwtcGFjay50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9jb252LXBhY2sudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvaW0yY29sLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL2RvdC1wcm9kdWN0LnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL2NvbnYudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvY29udi10cmFuc3Bvc2UudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvdHJhbnNwb3NlLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL2RlcHRoLXRvLXNwYWNlLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL2ZsYXR0ZW4udHMiLCAiLi4vbGliL29ubnhqcy9vcGVyYXRvcnMudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvZ2F0aGVyLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL2dlbW0udHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvaW1hZ2Utc2NhbGVyLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL2luc3RhbmNlLW5vcm1hbGl6YXRpb24udHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvbHJuLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL3BhZC50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9wb29sLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL3JlZHVjZS50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9yZXNoYXBlLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL3Vwc2FtcGxlLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL3Jlc2l6ZS1wYWNrZWQudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvc2hhcGUudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvc2xpY2UudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvc29mdG1heC50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9zcGxpdC50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9zcXVlZXplLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL3N1bS50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy90aWxlLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL3Vuc3F1ZWV6ZS50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wLXJlc29sdmUtcnVsZXMudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9nbHNsLWZ1bmN0aW9uLWlubGluZXIudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC90ZXh0dXJlLWxheW91dC1zdHJhdGVneS50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL2dsc2wtY29vcmRpbmF0ZS1saWIudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9nbHNsLWVuY29kaW5nLWxpYi50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL2dsc2wtZnJhZ2NvbG9yLWxpYi50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL2dsc2wtc2hhcGUtdXRpbHMtbGliLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvZ2xzbC12ZWMtbGliLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvZ2xzbC1yZWdpc3RlcmVkLWxpYnMudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9nbHNsLXByZXByb2Nlc3Nvci50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL3Byb2dyYW0tbWFuYWdlci50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL3RleHR1cmUtbWFuYWdlci50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL3Nlc3Npb24taGFuZGxlci50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL3dlYmdsLWNvbnRleHQudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC93ZWJnbC1jb250ZXh0LWZhY3RvcnkudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy9iYWNrZW5kLXdlYmdsLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZC50cyIsICIuLi9saWIvb25ueGpzL2V4ZWN1dGlvbi1wbGFuLnRzIiwgIi4uL2xpYi9vbm54anMvYXR0cmlidXRlLnRzIiwgIi4uL2xpYi9vbm54anMvZ3JhcGgudHMiLCAiLi4vbGliL29ubnhqcy9tb2RlbC50cyIsICIuLi9saWIvb25ueGpzL3Nlc3Npb24udHMiLCAiLi4vbGliL29ubnhqcy9zZXNzaW9uLWhhbmRsZXItaW5mZXJlbmNlLnRzIiwgIi4uL2xpYi9iYWNrZW5kLW9ubnhqcy50cyIsICIuLi9saWIvd2FzbS93YXNtLXV0aWxzLWVudi50cyIsICIuLi9saWIvd2FzbS9wcm94eS13b3JrZXIvbWFpbi50cyIsICIuLi9saWIvd2FzbS93YXNtLXV0aWxzLWltcG9ydC50cyIsICIuLi9saWIvd2FzbS93YXNtLWZhY3RvcnkudHMiLCAiLi4vbGliL3dhc20vd2FzbS11dGlscy50cyIsICIuLi9saWIvd2FzbS9ydW4tb3B0aW9ucy50cyIsICIuLi9saWIvd2FzbS9zZXNzaW9uLW9wdGlvbnMudHMiLCAiLi4vbGliL3dhc20vd2FzbS1jb21tb24udHMiLCAiLi4vbGliL3dhc20vd2FzbS11dGlscy1sb2FkLWZpbGUudHMiLCAiLi4vbGliL3dhc20vd2FzbS1jb3JlLWltcGwudHMiLCAiLi4vbGliL3dhc20vcHJveHktd3JhcHBlci50cyIsICIuLi9saWIvd2FzbS9zZXNzaW9uLWhhbmRsZXItaW5mZXJlbmNlLnRzIiwgIi4uL2xpYi9iYWNrZW5kLXdhc20udHMiLCAiLi4vbGliL2luZGV4LnRzIiwgIi4uL2xpYi92ZXJzaW9uLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgQmFja2VuZCB9IGZyb20gJy4vYmFja2VuZC5qcyc7XG5pbXBvcnQgeyBJbmZlcmVuY2VTZXNzaW9uIH0gZnJvbSAnLi9pbmZlcmVuY2Utc2Vzc2lvbi5qcyc7XG5cbmludGVyZmFjZSBCYWNrZW5kSW5mbyB7XG4gIGJhY2tlbmQ6IEJhY2tlbmQ7XG4gIHByaW9yaXR5OiBudW1iZXI7XG5cbiAgaW5pdFByb21pc2U/OiBQcm9taXNlPHZvaWQ+O1xuICBpbml0aWFsaXplZD86IGJvb2xlYW47XG4gIGFib3J0ZWQ/OiBib29sZWFuO1xuICBlcnJvcj86IHN0cmluZztcbn1cblxuY29uc3QgYmFja2VuZHM6IE1hcDxzdHJpbmcsIEJhY2tlbmRJbmZvPiA9IG5ldyBNYXAoKTtcbmNvbnN0IGJhY2tlbmRzU29ydGVkQnlQcmlvcml0eTogc3RyaW5nW10gPSBbXTtcblxuLyoqXG4gKiBSZWdpc3RlciBhIGJhY2tlbmQuXG4gKlxuICogQHBhcmFtIG5hbWUgLSB0aGUgbmFtZSBhcyBhIGtleSB0byBsb29rdXAgYXMgYW4gZXhlY3V0aW9uIHByb3ZpZGVyLlxuICogQHBhcmFtIGJhY2tlbmQgLSB0aGUgYmFja2VuZCBvYmplY3QuXG4gKiBAcGFyYW0gcHJpb3JpdHkgLSBhbiBpbnRlZ2VyIGluZGljYXRpbmcgdGhlIHByaW9yaXR5IG9mIHRoZSBiYWNrZW5kLiBIaWdoZXIgbnVtYmVyIG1lYW5zIGhpZ2hlciBwcmlvcml0eS4gaWYgcHJpb3JpdHlcbiAqIDwgMCwgaXQgd2lsbCBiZSBjb25zaWRlcmVkIGFzIGEgJ2JldGEnIHZlcnNpb24gYW5kIHdpbGwgbm90IGJlIHVzZWQgYXMgYSBmYWxsYmFjayBiYWNrZW5kIGJ5IGRlZmF1bHQuXG4gKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgY29uc3QgcmVnaXN0ZXJCYWNrZW5kID0gKG5hbWU6IHN0cmluZywgYmFja2VuZDogQmFja2VuZCwgcHJpb3JpdHk6IG51bWJlcik6IHZvaWQgPT4ge1xuICBpZiAoYmFja2VuZCAmJiB0eXBlb2YgYmFja2VuZC5pbml0ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBiYWNrZW5kLmNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc3QgY3VycmVudEJhY2tlbmQgPSBiYWNrZW5kcy5nZXQobmFtZSk7XG4gICAgaWYgKGN1cnJlbnRCYWNrZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGJhY2tlbmRzLnNldChuYW1lLCB7IGJhY2tlbmQsIHByaW9yaXR5IH0pO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudEJhY2tlbmQucHJpb3JpdHkgPiBwcmlvcml0eSkge1xuICAgICAgLy8gc2FtZSBuYW1lIGlzIGFscmVhZHkgcmVnaXN0ZXJlZCB3aXRoIGEgaGlnaGVyIHByaW9yaXR5LiBza2lwIHJlZ2lzdGVyYXRpb24uXG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChjdXJyZW50QmFja2VuZC5wcmlvcml0eSA9PT0gcHJpb3JpdHkpIHtcbiAgICAgIGlmIChjdXJyZW50QmFja2VuZC5iYWNrZW5kICE9PSBiYWNrZW5kKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IHJlZ2lzdGVyIGJhY2tlbmQgXCIke25hbWV9XCIgdXNpbmcgcHJpb3JpdHkgJHtwcmlvcml0eX1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJpb3JpdHkgPj0gMCkge1xuICAgICAgY29uc3QgaSA9IGJhY2tlbmRzU29ydGVkQnlQcmlvcml0eS5pbmRleE9mKG5hbWUpO1xuICAgICAgaWYgKGkgIT09IC0xKSB7XG4gICAgICAgIGJhY2tlbmRzU29ydGVkQnlQcmlvcml0eS5zcGxpY2UoaSwgMSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChiYWNrZW5kcy5nZXQoYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5W2ldKSEucHJpb3JpdHkgPD0gcHJpb3JpdHkpIHtcbiAgICAgICAgICBiYWNrZW5kc1NvcnRlZEJ5UHJpb3JpdHkuc3BsaWNlKGksIDAsIG5hbWUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5LnB1c2gobmFtZSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ25vdCBhIHZhbGlkIGJhY2tlbmQnKTtcbn07XG5cbi8qKlxuICogVHJ5IHRvIHJlc29sdmUgYW5kIGluaXRpYWxpemUgYSBiYWNrZW5kLlxuICpcbiAqIEBwYXJhbSBiYWNrZW5kTmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBiYWNrZW5kLlxuICogQHJldHVybnMgdGhlIGJhY2tlbmQgaW5zdGFuY2UgaWYgcmVzb2x2ZWQgYW5kIGluaXRpYWxpemVkIHN1Y2Nlc3NmdWxseSwgb3IgYW4gZXJyb3IgbWVzc2FnZSBpZiBmYWlsZWQuXG4gKi9cbmNvbnN0IHRyeVJlc29sdmVBbmRJbml0aWFsaXplQmFja2VuZCA9IGFzeW5jIChiYWNrZW5kTmFtZTogc3RyaW5nKTogUHJvbWlzZTxCYWNrZW5kIHwgc3RyaW5nPiA9PiB7XG4gIGNvbnN0IGJhY2tlbmRJbmZvID0gYmFja2VuZHMuZ2V0KGJhY2tlbmROYW1lKTtcbiAgaWYgKCFiYWNrZW5kSW5mbykge1xuICAgIHJldHVybiAnYmFja2VuZCBub3QgZm91bmQuJztcbiAgfVxuXG4gIGlmIChiYWNrZW5kSW5mby5pbml0aWFsaXplZCkge1xuICAgIHJldHVybiBiYWNrZW5kSW5mby5iYWNrZW5kO1xuICB9IGVsc2UgaWYgKGJhY2tlbmRJbmZvLmFib3J0ZWQpIHtcbiAgICByZXR1cm4gYmFja2VuZEluZm8uZXJyb3IhO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGlzSW5pdGlhbGl6aW5nID0gISFiYWNrZW5kSW5mby5pbml0UHJvbWlzZTtcbiAgICB0cnkge1xuICAgICAgaWYgKCFpc0luaXRpYWxpemluZykge1xuICAgICAgICBiYWNrZW5kSW5mby5pbml0UHJvbWlzZSA9IGJhY2tlbmRJbmZvLmJhY2tlbmQuaW5pdChiYWNrZW5kTmFtZSk7XG4gICAgICB9XG4gICAgICBhd2FpdCBiYWNrZW5kSW5mby5pbml0UHJvbWlzZTtcbiAgICAgIGJhY2tlbmRJbmZvLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBiYWNrZW5kSW5mby5iYWNrZW5kO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmICghaXNJbml0aWFsaXppbmcpIHtcbiAgICAgICAgYmFja2VuZEluZm8uZXJyb3IgPSBgJHtlfWA7XG4gICAgICAgIGJhY2tlbmRJbmZvLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhY2tlbmRJbmZvLmVycm9yITtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZGVsZXRlIGJhY2tlbmRJbmZvLmluaXRQcm9taXNlO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBSZXNvbHZlIGV4ZWN1dGlvbiBwcm92aWRlcnMgZnJvbSB0aGUgc3BlY2lmaWMgc2Vzc2lvbiBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gdGhlIHNlc3Npb24gb3B0aW9ucyBvYmplY3QuXG4gKiBAcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIHR1cGxlIG9mIGFuIGluaXRpYWxpemVkIGJhY2tlbmQgaW5zdGFuY2UgYW5kIGEgc2Vzc2lvbiBvcHRpb25zIG9iamVjdCB3aXRoXG4gKiBmaWx0ZXJlZCBFUCBsaXN0LlxuICpcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0IGNvbnN0IHJlc29sdmVCYWNrZW5kQW5kRXhlY3V0aW9uUHJvdmlkZXJzID0gYXN5bmMgKFxuICBvcHRpb25zOiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zLFxuKTogUHJvbWlzZTxbYmFja2VuZDogQmFja2VuZCwgb3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9uc10+ID0+IHtcbiAgLy8gZXh0cmFjdCBiYWNrZW5kIGhpbnRzIGZyb20gc2Vzc2lvbiBvcHRpb25zXG4gIGNvbnN0IGVwcyA9IG9wdGlvbnMuZXhlY3V0aW9uUHJvdmlkZXJzIHx8IFtdO1xuICBjb25zdCBiYWNrZW5kSGludHMgPSBlcHMubWFwKChpKSA9PiAodHlwZW9mIGkgPT09ICdzdHJpbmcnID8gaSA6IGkubmFtZSkpO1xuICBjb25zdCBiYWNrZW5kTmFtZXMgPSBiYWNrZW5kSGludHMubGVuZ3RoID09PSAwID8gYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5IDogYmFja2VuZEhpbnRzO1xuXG4gIC8vIHRyeSB0byByZXNvbHZlIGFuZCBpbml0aWFsaXplIGFsbCByZXF1ZXN0ZWQgYmFja2VuZHNcbiAgbGV0IGJhY2tlbmQ6IEJhY2tlbmQgfCB1bmRlZmluZWQ7XG4gIGNvbnN0IGVycm9ycyA9IFtdO1xuICBjb25zdCBhdmFpbGFibGVCYWNrZW5kTmFtZXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgZm9yIChjb25zdCBiYWNrZW5kTmFtZSBvZiBiYWNrZW5kTmFtZXMpIHtcbiAgICBjb25zdCByZXNvbHZlUmVzdWx0ID0gYXdhaXQgdHJ5UmVzb2x2ZUFuZEluaXRpYWxpemVCYWNrZW5kKGJhY2tlbmROYW1lKTtcbiAgICBpZiAodHlwZW9mIHJlc29sdmVSZXN1bHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlcnJvcnMucHVzaCh7IG5hbWU6IGJhY2tlbmROYW1lLCBlcnI6IHJlc29sdmVSZXN1bHQgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghYmFja2VuZCkge1xuICAgICAgICBiYWNrZW5kID0gcmVzb2x2ZVJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGlmIChiYWNrZW5kID09PSByZXNvbHZlUmVzdWx0KSB7XG4gICAgICAgIGF2YWlsYWJsZUJhY2tlbmROYW1lcy5hZGQoYmFja2VuZE5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGlmIG5vIGJhY2tlbmQgaXMgYXZhaWxhYmxlLCB0aHJvdyBlcnJvci5cbiAgaWYgKCFiYWNrZW5kKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBubyBhdmFpbGFibGUgYmFja2VuZCBmb3VuZC4gRVJSOiAke2Vycm9ycy5tYXAoKGUpID0+IGBbJHtlLm5hbWV9XSAke2UuZXJyfWApLmpvaW4oJywgJyl9YCk7XG4gIH1cblxuICAvLyBmb3IgZWFjaCBleHBsaWNpdGx5IHJlcXVlc3RlZCBiYWNrZW5kLCBpZiBpdCdzIG5vdCBhdmFpbGFibGUsIG91dHB1dCB3YXJuaW5nIG1lc3NhZ2UuXG4gIGZvciAoY29uc3QgeyBuYW1lLCBlcnIgfSBvZiBlcnJvcnMpIHtcbiAgICBpZiAoYmFja2VuZEhpbnRzLmluY2x1ZGVzKG5hbWUpKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgcmVtb3ZpbmcgcmVxdWVzdGVkIGV4ZWN1dGlvbiBwcm92aWRlciBcIiR7bmFtZX1cIiBmcm9tIHNlc3Npb24gb3B0aW9ucyBiZWNhdXNlIGl0IGlzIG5vdCBhdmFpbGFibGU6ICR7ZXJyfWAsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGZpbHRlcmVkRXBzID0gZXBzLmZpbHRlcigoaSkgPT4gYXZhaWxhYmxlQmFja2VuZE5hbWVzLmhhcyh0eXBlb2YgaSA9PT0gJ3N0cmluZycgPyBpIDogaS5uYW1lKSk7XG5cbiAgcmV0dXJuIFtcbiAgICBiYWNrZW5kLFxuICAgIG5ldyBQcm94eShvcHRpb25zLCB7XG4gICAgICBnZXQ6ICh0YXJnZXQsIHByb3ApID0+IHtcbiAgICAgICAgaWYgKHByb3AgPT09ICdleGVjdXRpb25Qcm92aWRlcnMnKSB7XG4gICAgICAgICAgcmV0dXJuIGZpbHRlcmVkRXBzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3ApO1xuICAgICAgfSxcbiAgICB9KSxcbiAgXTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEluZmVyZW5jZVNlc3Npb24gfSBmcm9tICcuL2luZmVyZW5jZS1zZXNzaW9uLmpzJztcbmltcG9ydCB7IE9ubnhWYWx1ZSB9IGZyb20gJy4vb25ueC12YWx1ZS5qcyc7XG5pbXBvcnQgeyBUcmFpbmluZ1Nlc3Npb24gfSBmcm9tICcuL3RyYWluaW5nLXNlc3Npb24uanMnO1xuXG4vKipcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIFNlc3Npb25IYW5kbGVyIHtcbiAgdHlwZSBGZWVkc1R5cGUgPSB7IFtuYW1lOiBzdHJpbmddOiBPbm54VmFsdWUgfTtcbiAgdHlwZSBGZXRjaGVzVHlwZSA9IHsgW25hbWU6IHN0cmluZ106IE9ubnhWYWx1ZSB8IG51bGwgfTtcbiAgdHlwZSBSZXR1cm5UeXBlID0geyBbbmFtZTogc3RyaW5nXTogT25ueFZhbHVlIH07XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBzaGFyZWQgU2Vzc2lvbkhhbmRsZXIgZnVuY3Rpb25hbGl0eVxuICpcbiAqIEBpZ25vcmVcbiAqL1xuaW50ZXJmYWNlIFNlc3Npb25IYW5kbGVyIHtcbiAgZGlzcG9zZSgpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIHJlYWRvbmx5IGlucHV0TmFtZXM6IHJlYWRvbmx5IHN0cmluZ1tdO1xuICByZWFkb25seSBvdXRwdXROYW1lczogcmVhZG9ubHkgc3RyaW5nW107XG59XG5cbi8qKlxuICogUmVwcmVzZW50IGEgaGFuZGxlciBpbnN0YW5jZSBvZiBhbiBpbmZlcmVuY2Ugc2Vzc2lvbi5cbiAqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXIgZXh0ZW5kcyBTZXNzaW9uSGFuZGxlciB7XG4gIHN0YXJ0UHJvZmlsaW5nKCk6IHZvaWQ7XG4gIGVuZFByb2ZpbGluZygpOiB2b2lkO1xuXG4gIHJ1bihcbiAgICBmZWVkczogU2Vzc2lvbkhhbmRsZXIuRmVlZHNUeXBlLFxuICAgIGZldGNoZXM6IFNlc3Npb25IYW5kbGVyLkZldGNoZXNUeXBlLFxuICAgIG9wdGlvbnM6IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxTZXNzaW9uSGFuZGxlci5SZXR1cm5UeXBlPjtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgYSBoYW5kbGVyIGluc3RhbmNlIG9mIGEgdHJhaW5pbmcgaW5mZXJlbmNlIHNlc3Npb24uXG4gKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRyYWluaW5nU2Vzc2lvbkhhbmRsZXIgZXh0ZW5kcyBTZXNzaW9uSGFuZGxlciB7XG4gIHJlYWRvbmx5IGV2YWxJbnB1dE5hbWVzOiByZWFkb25seSBzdHJpbmdbXTtcbiAgcmVhZG9ubHkgZXZhbE91dHB1dE5hbWVzOiByZWFkb25seSBzdHJpbmdbXTtcblxuICBsYXp5UmVzZXRHcmFkKCk6IFByb21pc2U8dm9pZD47XG4gIHJ1blRyYWluU3RlcChcbiAgICBmZWVkczogU2Vzc2lvbkhhbmRsZXIuRmVlZHNUeXBlLFxuICAgIGZldGNoZXM6IFNlc3Npb25IYW5kbGVyLkZldGNoZXNUeXBlLFxuICAgIG9wdGlvbnM6IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxTZXNzaW9uSGFuZGxlci5SZXR1cm5UeXBlPjtcbiAgcnVuT3B0aW1pemVyU3RlcChvcHRpb25zOiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+O1xuICBydW5FdmFsU3RlcChcbiAgICBmZWVkczogU2Vzc2lvbkhhbmRsZXIuRmVlZHNUeXBlLFxuICAgIGZldGNoZXM6IFNlc3Npb25IYW5kbGVyLkZldGNoZXNUeXBlLFxuICAgIG9wdGlvbnM6IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxTZXNzaW9uSGFuZGxlci5SZXR1cm5UeXBlPjtcblxuICBnZXRQYXJhbWV0ZXJzU2l6ZSh0cmFpbmFibGVPbmx5OiBib29sZWFuKTogUHJvbWlzZTxudW1iZXI+O1xuICBsb2FkUGFyYW1ldGVyc0J1ZmZlcihidWZmZXI6IFVpbnQ4QXJyYXksIHRyYWluYWJsZU9ubHk6IGJvb2xlYW4pOiBQcm9taXNlPHZvaWQ+O1xuICBnZXRDb250aWd1b3VzUGFyYW1ldGVycyh0cmFpbmFibGVPbmx5OiBib29sZWFuKTogUHJvbWlzZTxPbm54VmFsdWU+O1xufVxuXG4vKipcbiAqIFJlcHJlc2VudCBhIGJhY2tlbmQgdGhhdCBwcm92aWRlcyBpbXBsZW1lbnRhdGlvbiBvZiBtb2RlbCBpbmZlcmVuY2luZy5cbiAqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQmFja2VuZCB7XG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBiYWNrZW5kIGFzeW5jaHJvbm91c2x5LiBTaG91bGQgdGhyb3cgd2hlbiBmYWlsZWQuXG4gICAqL1xuICBpbml0KGJhY2tlbmROYW1lOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIGNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyKFxuICAgIHVyaU9yQnVmZmVyOiBzdHJpbmcgfCBVaW50OEFycmF5LFxuICAgIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zLFxuICApOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb25IYW5kbGVyPjtcblxuICBjcmVhdGVUcmFpbmluZ1Nlc3Npb25IYW5kbGVyPyhcbiAgICBjaGVja3BvaW50U3RhdGVVcmlPckJ1ZmZlcjogVHJhaW5pbmdTZXNzaW9uLlVyaU9yQnVmZmVyLFxuICAgIHRyYWluTW9kZWxVcmlPckJ1ZmZlcjogVHJhaW5pbmdTZXNzaW9uLlVyaU9yQnVmZmVyLFxuICAgIGV2YWxNb2RlbFVyaU9yQnVmZmVyOiBUcmFpbmluZ1Nlc3Npb24uVXJpT3JCdWZmZXIsXG4gICAgb3B0aW1pemVyTW9kZWxVcmlPckJ1ZmZlcjogVHJhaW5pbmdTZXNzaW9uLlVyaU9yQnVmZmVyLFxuICAgIG9wdGlvbnM6IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMsXG4gICk6IFByb21pc2U8VHJhaW5pbmdTZXNzaW9uSGFuZGxlcj47XG59XG5cbmV4cG9ydCB7IHJlZ2lzdGVyQmFja2VuZCB9IGZyb20gJy4vYmFja2VuZC1pbXBsLmpzJztcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuLy8gVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBieSAvanMvc2NyaXB0cy91cGRhdGUtdmVyc2lvbi50c1xuLy8gRG8gbm90IG1vZGlmeSBmaWxlIGNvbnRlbnQgbWFudWFsbHkuXG5cbmV4cG9ydCBjb25zdCB2ZXJzaW9uID0gJzEuMjAuMCc7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEVudiB9IGZyb20gJy4vZW52LmpzJztcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuL3ZlcnNpb24uanMnO1xuXG50eXBlIExvZ0xldmVsVHlwZSA9IEVudlsnbG9nTGV2ZWwnXTtcblxubGV0IGxvZ0xldmVsVmFsdWU6IFJlcXVpcmVkPExvZ0xldmVsVHlwZT4gPSAnd2FybmluZyc7XG5cbmV4cG9ydCBjb25zdCBlbnY6IEVudiA9IHtcbiAgd2FzbToge30gYXMgRW52LldlYkFzc2VtYmx5RmxhZ3MsXG4gIHdlYmdsOiB7fSBhcyBFbnYuV2ViR0xGbGFncyxcbiAgd2ViZ3B1OiB7fSBhcyBFbnYuV2ViR3B1RmxhZ3MsXG4gIHZlcnNpb25zOiB7IGNvbW1vbjogdmVyc2lvbiB9LFxuXG4gIHNldCBsb2dMZXZlbCh2YWx1ZTogTG9nTGV2ZWxUeXBlKSB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgfHwgWyd2ZXJib3NlJywgJ2luZm8nLCAnd2FybmluZycsICdlcnJvcicsICdmYXRhbCddLmluZGV4T2YodmFsdWUpID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBsb2dnaW5nIGxldmVsOiAke3ZhbHVlfWApO1xuICAgIH1cbiAgICBsb2dMZXZlbFZhbHVlID0gdmFsdWU7XG4gIH0sXG4gIGdldCBsb2dMZXZlbCgpOiBSZXF1aXJlZDxMb2dMZXZlbFR5cGU+IHtcbiAgICByZXR1cm4gbG9nTGV2ZWxWYWx1ZTtcbiAgfSxcbn07XG5cbi8vIHNldCBwcm9wZXJ0eSAnbG9nTGV2ZWwnIHNvIHRoYXQgdGhleSBjYW4gYmUgY29ycmVjdGx5IHRyYW5zZmVycmVkIHRvIHdvcmtlciBieSBgcG9zdE1lc3NhZ2UoKWAuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZW52LCAnbG9nTGV2ZWwnLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IGVudiBhcyBlbnZJbXBsIH0gZnJvbSAnLi9lbnYtaW1wbC5qcyc7XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBFbnYge1xuICBleHBvcnQgdHlwZSBXYXNtUGF0aFByZWZpeCA9IHN0cmluZztcbiAgZXhwb3J0IGludGVyZmFjZSBXYXNtRmlsZVBhdGhzIHtcbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IHRoZSBvdmVycmlkZSBwYXRoIGZvciB0aGUgbWFpbiAud2FzbSBmaWxlLlxuICAgICAqXG4gICAgICogVGhpcyBwYXRoIHNob3VsZCBiZSBhbiBhYnNvbHV0ZSBwYXRoLlxuICAgICAqXG4gICAgICogSWYgbm90IG1vZGlmaWVkLCB0aGUgZmlsZW5hbWUgb2YgdGhlIC53YXNtIGZpbGUgaXM6XG4gICAgICogLSBgb3J0LXdhc20tc2ltZC10aHJlYWRlZC53YXNtYCBmb3IgZGVmYXVsdCBidWlsZFxuICAgICAqIC0gYG9ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC53YXNtYCBmb3IgSlNFUCBidWlsZCAod2l0aCBXZWJHUFUgYW5kIFdlYk5OKVxuICAgICAqIC0gYG9ydC10cmFpbmluZy13YXNtLXNpbWQtdGhyZWFkZWQud2FzbWAgZm9yIHRyYWluaW5nIGJ1aWxkXG4gICAgICovXG4gICAgd2FzbT86IFVSTCB8IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IHRoZSBvdmVycmlkZSBwYXRoIGZvciB0aGUgbWFpbiAubWpzIGZpbGUuXG4gICAgICpcbiAgICAgKiBUaGlzIHBhdGggc2hvdWxkIGJlIGFuIGFic29sdXRlIHBhdGguXG4gICAgICpcbiAgICAgKiBJZiBub3QgbW9kaWZpZWQsIHRoZSBmaWxlbmFtZSBvZiB0aGUgLm1qcyBmaWxlIGlzOlxuICAgICAqIC0gYG9ydC13YXNtLXNpbWQtdGhyZWFkZWQubWpzYCBmb3IgZGVmYXVsdCBidWlsZFxuICAgICAqIC0gYG9ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC5tanNgIGZvciBKU0VQIGJ1aWxkICh3aXRoIFdlYkdQVSBhbmQgV2ViTk4pXG4gICAgICogLSBgb3J0LXRyYWluaW5nLXdhc20tc2ltZC10aHJlYWRlZC5tanNgIGZvciB0cmFpbmluZyBidWlsZFxuICAgICAqL1xuICAgIG1qcz86IFVSTCB8IHN0cmluZztcbiAgfVxuICBleHBvcnQgdHlwZSBXYXNtUHJlZml4T3JGaWxlUGF0aHMgPSBXYXNtUGF0aFByZWZpeCB8IFdhc21GaWxlUGF0aHM7XG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViQXNzZW1ibHlGbGFncyB7XG4gICAgLyoqXG4gICAgICogc2V0IG9yIGdldCBudW1iZXIgb2YgdGhyZWFkKHMpLiBJZiBvbWl0dGVkIG9yIHNldCB0byAwLCBudW1iZXIgb2YgdGhyZWFkKHMpIHdpbGwgYmUgZGV0ZXJtaW5lZCBieSBzeXN0ZW0uIElmIHNldFxuICAgICAqIHRvIDEsIG5vIHdvcmtlciB0aHJlYWQgd2lsbCBiZSBzcGF3bmVkLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IHdoZW4gV2ViQXNzZW1ibHkgbXVsdGl0aHJlYWQgZmVhdHVyZSBpcyBhdmFpbGFibGUgaW4gY3VycmVudCBjb250ZXh0LlxuICAgICAqXG4gICAgICogQGRlZmF1bHRWYWx1ZSBgMGBcbiAgICAgKi9cbiAgICBudW1UaHJlYWRzPzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogc2V0IG9yIGdldCBhIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRvIGVuYWJsZSBTSU1ELiBJZiBzZXQgdG8gZmFsc2UsIFNJTUQgd2lsbCBiZSBmb3JjZWx5IGRpc2FibGVkLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IHdoZW4gV2ViQXNzZW1ibHkgU0lNRCBmZWF0dXJlIGlzIGF2YWlsYWJsZSBpbiBjdXJyZW50IGNvbnRleHQuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBUaGlzIHByb3BlcnR5IGlzIGRlcHJlY2F0ZWQuIFNpbmNlIFNJTUQgaXMgc3VwcG9ydGVkIGJ5IGFsbCBtYWpvciBKYXZhU2NyaXB0IGVuZ2luZXMsIG5vbi1TSU1EXG4gICAgICogYnVpbGQgaXMgbm8gbG9uZ2VyIHByb3ZpZGVkLiBUaGlzIHByb3BlcnR5IHdpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgcmVsZWFzZS5cbiAgICAgKiBAZGVmYXVsdFZhbHVlIGB0cnVlYFxuICAgICAqL1xuICAgIHNpbWQ/OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogc2V0IG9yIGdldCBhIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRvIGVuYWJsZSB0cmFjZS5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBgZW52LnRyYWNlYCBpbnN0ZWFkLiBJZiBgZW52LnRyYWNlYCBpcyBzZXQsIHRoaXMgcHJvcGVydHkgd2lsbCBiZSBpZ25vcmVkLlxuICAgICAqIEBkZWZhdWx0VmFsdWUgYGZhbHNlYFxuICAgICAqL1xuICAgIHRyYWNlPzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIFNldCBvciBnZXQgYSBudW1iZXIgc3BlY2lmeWluZyB0aGUgdGltZW91dCBmb3IgaW5pdGlhbGl6YXRpb24gb2YgV2ViQXNzZW1ibHkgYmFja2VuZCwgaW4gbWlsbGlzZWNvbmRzLiBBIHplcm9cbiAgICAgKiB2YWx1ZSBpbmRpY2F0ZXMgbm8gdGltZW91dCBpcyBzZXQuXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdFZhbHVlIGAwYFxuICAgICAqL1xuICAgIGluaXRUaW1lb3V0PzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogU2V0IGEgY3VzdG9tIFVSTCBwcmVmaXggdG8gdGhlIC53YXNtLy5tanMgZmlsZXMsIG9yIGFuIG9iamVjdCBvZiBvdmVycmlkZXMgZm9yIGJvdGggLndhc20vLm1qcyBmaWxlLiBUaGUgb3ZlcnJpZGVcbiAgICAgKiBwYXRoIHNob3VsZCBiZSBhbiBhYnNvbHV0ZSBwYXRoLlxuICAgICAqL1xuICAgIHdhc21QYXRocz86IFdhc21QcmVmaXhPckZpbGVQYXRocztcblxuICAgIC8qKlxuICAgICAqIFNldCBhIGN1c3RvbSBidWZmZXIgd2hpY2ggY29udGFpbnMgdGhlIFdlYkFzc2VtYmx5IGJpbmFyeS4gSWYgdGhpcyBwcm9wZXJ0eSBpcyBzZXQsIHRoZSBgd2FzbVBhdGhzYCBwcm9wZXJ0eSB3aWxsXG4gICAgICogYmUgaWdub3JlZC5cbiAgICAgKi9cbiAgICB3YXNtQmluYXJ5PzogQXJyYXlCdWZmZXJMaWtlIHwgVWludDhBcnJheTtcblxuICAgIC8qKlxuICAgICAqIFNldCBvciBnZXQgYSBib29sZWFuIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0byBwcm94eSB0aGUgZXhlY3V0aW9uIG9mIG1haW4gdGhyZWFkIHRvIGEgd29ya2VyIHRocmVhZC5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0VmFsdWUgYGZhbHNlYFxuICAgICAqL1xuICAgIHByb3h5PzogYm9vbGVhbjtcbiAgfVxuXG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViR0xGbGFncyB7XG4gICAgLyoqXG4gICAgICogU2V0IG9yIGdldCB0aGUgV2ViR0wgQ29udGV4dCBJRCAod2ViZ2wgb3Igd2ViZ2wyKS5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0VmFsdWUgYCd3ZWJnbDInYFxuICAgICAqL1xuICAgIGNvbnRleHRJZD86ICd3ZWJnbCcgfCAnd2ViZ2wyJztcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIFdlYkdMIHJlbmRlcmluZyBjb250ZXh0LlxuICAgICAqL1xuICAgIHJlYWRvbmx5IGNvbnRleHQ6IFdlYkdMUmVuZGVyaW5nQ29udGV4dDtcbiAgICAvKipcbiAgICAgKiBTZXQgb3IgZ2V0IHRoZSBtYXhpbXVtIGJhdGNoIHNpemUgZm9yIG1hdG11bC4gMCBtZWFucyB0byBkaXNhYmxlIGJhdGNoaW5nLlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBtYXRtdWxNYXhCYXRjaFNpemU/OiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogU2V0IG9yIGdldCB0aGUgdGV4dHVyZSBjYWNoZSBtb2RlLlxuICAgICAqXG4gICAgICogQGRlZmF1bHRWYWx1ZSBgJ2Z1bGwnYFxuICAgICAqL1xuICAgIHRleHR1cmVDYWNoZU1vZGU/OiAnaW5pdGlhbGl6ZXJPbmx5JyB8ICdmdWxsJztcbiAgICAvKipcbiAgICAgKiBTZXQgb3IgZ2V0IHRoZSBwYWNrZWQgdGV4dHVyZSBtb2RlXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdFZhbHVlIGBmYWxzZWBcbiAgICAgKi9cbiAgICBwYWNrPzogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBTZXQgb3IgZ2V0IHdoZXRoZXIgZW5hYmxlIGFzeW5jIGRvd25sb2FkLlxuICAgICAqXG4gICAgICogQGRlZmF1bHRWYWx1ZSBgZmFsc2VgXG4gICAgICovXG4gICAgYXN5bmM/OiBib29sZWFuO1xuICB9XG5cbiAgZXhwb3J0IGludGVyZmFjZSBXZWJHcHVQcm9maWxpbmdEYXRhVjFUZW5zb3JNZXRhZGF0YSB7XG4gICAgZGltczogcmVhZG9ubHkgbnVtYmVyW107XG4gICAgZGF0YVR5cGU6IHN0cmluZztcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIFdlYkdwdVByb2ZpbGluZ0RhdGFWMSB7XG4gICAgdmVyc2lvbjogMTtcbiAgICBpbnB1dHNNZXRhZGF0YTogcmVhZG9ubHkgV2ViR3B1UHJvZmlsaW5nRGF0YVYxVGVuc29yTWV0YWRhdGFbXTtcbiAgICBvdXRwdXRzTWV0YWRhdGE6IHJlYWRvbmx5IFdlYkdwdVByb2ZpbGluZ0RhdGFWMVRlbnNvck1ldGFkYXRhW107XG4gICAga2VybmVsSWQ6IG51bWJlcjtcbiAgICBrZXJuZWxUeXBlOiBzdHJpbmc7XG4gICAga2VybmVsTmFtZTogc3RyaW5nO1xuICAgIHByb2dyYW1OYW1lOiBzdHJpbmc7XG4gICAgc3RhcnRUaW1lOiBudW1iZXI7XG4gICAgZW5kVGltZTogbnVtYmVyO1xuICB9XG5cbiAgZXhwb3J0IHR5cGUgV2ViR3B1UHJvZmlsaW5nRGF0YSA9IFdlYkdwdVByb2ZpbGluZ0RhdGFWMTtcblxuICBleHBvcnQgaW50ZXJmYWNlIFdlYkdwdUZsYWdzIHtcbiAgICAvKipcbiAgICAgKiBTZXQgb3IgZ2V0IHRoZSBwcm9maWxpbmcgbW9kZS5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBgZW52LndlYmdwdS5wcm9maWxpbmcubW9kZWAgaW5zdGVhZC4gSWYgYGVudi53ZWJncHUucHJvZmlsaW5nLm1vZGVgIGlzIHNldCwgdGhpcyBwcm9wZXJ0eSB3aWxsIGJlXG4gICAgICogaWdub3JlZC5cbiAgICAgKi9cbiAgICBwcm9maWxpbmdNb2RlPzogJ29mZicgfCAnZGVmYXVsdCc7XG4gICAgLyoqXG4gICAgICogU2V0IG9yIGdldCB0aGUgcHJvZmlsaW5nIGNvbmZpZ3VyYXRpb24uXG4gICAgICovXG4gICAgcHJvZmlsaW5nPzoge1xuICAgICAgLyoqXG4gICAgICAgKiBTZXQgb3IgZ2V0IHRoZSBwcm9maWxpbmcgbW9kZS5cbiAgICAgICAqXG4gICAgICAgKiBAZGVmYXVsdFZhbHVlIGAnb2ZmJ2BcbiAgICAgICAqL1xuICAgICAgbW9kZT86ICdvZmYnIHwgJ2RlZmF1bHQnO1xuXG4gICAgICAvKipcbiAgICAgICAqIFNldCBvciBnZXQgYSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIGEgcHJvZmlsaW5nIGRhdGEgaXMgcmVjZWl2ZWQuIElmIG5vdCBzZXQsIHRoZSBwcm9maWxpbmcgZGF0YSB3aWxsIGJlXG4gICAgICAgKiBwcmludGVkIHRvIGNvbnNvbGUuXG4gICAgICAgKi9cbiAgICAgIG9uZGF0YT86IChkYXRhOiBXZWJHcHVQcm9maWxpbmdEYXRhKSA9PiB2b2lkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IG9yIGdldCB0aGUgcG93ZXIgcHJlZmVyZW5jZS5cbiAgICAgKlxuICAgICAqIFNldHRpbmcgdGhpcyBwcm9wZXJ0eSBvbmx5IGhhcyBlZmZlY3QgYmVmb3JlIHRoZSBmaXJzdCBXZWJHUFUgaW5mZXJlbmNlIHNlc3Npb24gaXMgY3JlYXRlZC4gVGhlIHZhbHVlIHdpbGwgYmVcbiAgICAgKiB1c2VkIGFzIG9wdGlvbnMgZm9yIGBuYXZpZ2F0b3IuZ3B1LnJlcXVlc3RBZGFwdGVyKClgLlxuICAgICAqXG4gICAgICogU2VlIHtAbGluayBodHRwczovL2dwdXdlYi5naXRodWIuaW8vZ3B1d2ViLyNkaWN0ZGVmLWdwdXJlcXVlc3RhZGFwdGVyb3B0aW9uc30gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0VmFsdWUgYHVuZGVmaW5lZGBcbiAgICAgKi9cbiAgICBwb3dlclByZWZlcmVuY2U/OiAnbG93LXBvd2VyJyB8ICdoaWdoLXBlcmZvcm1hbmNlJztcbiAgICAvKipcbiAgICAgKiBTZXQgb3IgZ2V0IHRoZSBmb3JjZSBmYWxsYmFjayBhZGFwdGVyIGZsYWcuXG4gICAgICpcbiAgICAgKiBTZXR0aW5nIHRoaXMgcHJvcGVydHkgb25seSBoYXMgZWZmZWN0IGJlZm9yZSB0aGUgZmlyc3QgV2ViR1BVIGluZmVyZW5jZSBzZXNzaW9uIGlzIGNyZWF0ZWQuIFRoZSB2YWx1ZSB3aWxsIGJlXG4gICAgICogdXNlZCBhcyBvcHRpb25zIGZvciBgbmF2aWdhdG9yLmdwdS5yZXF1ZXN0QWRhcHRlcigpYC5cbiAgICAgKlxuICAgICAqIFNlZSB7QGxpbmsgaHR0cHM6Ly9ncHV3ZWIuZ2l0aHViLmlvL2dwdXdlYi8jZGljdGRlZi1ncHVyZXF1ZXN0YWRhcHRlcm9wdGlvbnN9IGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdFZhbHVlIGB1bmRlZmluZWRgXG4gICAgICovXG4gICAgZm9yY2VGYWxsYmFja0FkYXB0ZXI/OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFNldCBvciBnZXQgdGhlIGFkYXB0ZXIgZm9yIFdlYkdQVS5cbiAgICAgKlxuICAgICAqIFNldHRpbmcgdGhpcyBwcm9wZXJ0eSBvbmx5IGhhcyBlZmZlY3QgYmVmb3JlIHRoZSBmaXJzdCBXZWJHUFUgaW5mZXJlbmNlIHNlc3Npb24gaXMgY3JlYXRlZC4gVGhlIHZhbHVlIHdpbGwgYmVcbiAgICAgKiB1c2VkIGFzIHRoZSBHUFUgYWRhcHRlciBmb3IgdGhlIHVuZGVybHlpbmcgV2ViR1BVIGJhY2tlbmQgdG8gY3JlYXRlIEdQVSBkZXZpY2UuXG4gICAgICpcbiAgICAgKiBJZiB0aGlzIHByb3BlcnR5IGlzIG5vdCBzZXQsIGl0IHdpbGwgYmUgYXZhaWxhYmxlIHRvIGdldCBhZnRlciB0aGUgZmlyc3QgV2ViR1BVIGluZmVyZW5jZSBzZXNzaW9uIGlzIGNyZWF0ZWQuIFRoZVxuICAgICAqIHZhbHVlIHdpbGwgYmUgdGhlIEdQVSBhZGFwdGVyIHRoYXQgY3JlYXRlZCBieSB0aGUgdW5kZXJseWluZyBXZWJHUFUgYmFja2VuZC5cbiAgICAgKlxuICAgICAqIFdoZW4gdXNlIHdpdGggVHlwZVNjcmlwdCwgdGhlIHR5cGUgb2YgdGhpcyBwcm9wZXJ0eSBpcyBgR1BVQWRhcHRlcmAgZGVmaW5lZCBpbiBcIkB3ZWJncHUvdHlwZXNcIi5cbiAgICAgKiBVc2UgYGNvbnN0IGFkYXB0ZXIgPSBlbnYud2ViZ3B1LmFkYXB0ZXIgYXMgR1BVQWRhcHRlcjtgIGluIFR5cGVTY3JpcHQgdG8gYWNjZXNzIHRoaXMgcHJvcGVydHkgd2l0aCBjb3JyZWN0IHR5cGUuXG4gICAgICpcbiAgICAgKiBzZWUgY29tbWVudHMgb24ge0BsaW5rIFRlbnNvci5HcHVCdWZmZXJUeXBlfVxuICAgICAqL1xuICAgIGFkYXB0ZXI6IHVua25vd247XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBkZXZpY2UgZm9yIFdlYkdQVS5cbiAgICAgKlxuICAgICAqIFRoaXMgcHJvcGVydHkgaXMgb25seSBhdmFpbGFibGUgYWZ0ZXIgdGhlIGZpcnN0IFdlYkdQVSBpbmZlcmVuY2Ugc2Vzc2lvbiBpcyBjcmVhdGVkLlxuICAgICAqXG4gICAgICogV2hlbiB1c2Ugd2l0aCBUeXBlU2NyaXB0LCB0aGUgdHlwZSBvZiB0aGlzIHByb3BlcnR5IGlzIGBHUFVEZXZpY2VgIGRlZmluZWQgaW4gXCJAd2ViZ3B1L3R5cGVzXCIuXG4gICAgICogVXNlIGBjb25zdCBkZXZpY2UgPSBlbnYud2ViZ3B1LmRldmljZSBhcyBHUFVEZXZpY2U7YCBpbiBUeXBlU2NyaXB0IHRvIGFjY2VzcyB0aGlzIHByb3BlcnR5IHdpdGggY29ycmVjdCB0eXBlLlxuICAgICAqXG4gICAgICogc2VlIGNvbW1lbnRzIG9uIHtAbGluayBUZW5zb3IuR3B1QnVmZmVyVHlwZX0gZm9yIG1vcmUgZGV0YWlscyBhYm91dCB3aHkgbm90IHVzZSB0eXBlcyBkZWZpbmVkIGluIFwiQHdlYmdwdS90eXBlc1wiLlxuICAgICAqL1xuICAgIHJlYWRvbmx5IGRldmljZTogdW5rbm93bjtcbiAgICAvKipcbiAgICAgKiBTZXQgb3IgZ2V0IHdoZXRoZXIgdmFsaWRhdGUgaW5wdXQgY29udGVudC5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0VmFsdWUgYGZhbHNlYFxuICAgICAqL1xuICAgIHZhbGlkYXRlSW5wdXRDb250ZW50PzogYm9vbGVhbjtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVudiB7XG4gIC8qKlxuICAgKiBzZXQgdGhlIHNldmVyaXR5IGxldmVsIGZvciBsb2dnaW5nLlxuICAgKlxuICAgKiBAZGVmYXVsdFZhbHVlIGAnd2FybmluZydgXG4gICAqL1xuICBsb2dMZXZlbD86ICd2ZXJib3NlJyB8ICdpbmZvJyB8ICd3YXJuaW5nJyB8ICdlcnJvcicgfCAnZmF0YWwnO1xuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZSB3aGV0aGVyIHJ1biBpbiBkZWJ1ZyBtb2RlLlxuICAgKlxuICAgKiBAZGVmYXVsdFZhbHVlIGBmYWxzZWBcbiAgICovXG4gIGRlYnVnPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogc2V0IG9yIGdldCBhIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRvIGVuYWJsZSB0cmFjZS5cbiAgICpcbiAgICogQGRlZmF1bHRWYWx1ZSBgZmFsc2VgXG4gICAqL1xuICB0cmFjZT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEdldCB2ZXJzaW9uIG9mIHRoZSBjdXJyZW50IHBhY2thZ2UuXG4gICAqL1xuICByZWFkb25seSB2ZXJzaW9uczoge1xuICAgIHJlYWRvbmx5IGNvbW1vbjogc3RyaW5nO1xuICAgIHJlYWRvbmx5IHdlYj86IHN0cmluZztcbiAgICByZWFkb25seSBub2RlPzogc3RyaW5nO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbiAgICByZWFkb25seSAncmVhY3QtbmF0aXZlJz86IHN0cmluZztcbiAgfTtcblxuICAvKipcbiAgICogUmVwcmVzZW50IGEgc2V0IG9mIGZsYWdzIGZvciBXZWJBc3NlbWJseVxuICAgKi9cbiAgcmVhZG9ubHkgd2FzbTogRW52LldlYkFzc2VtYmx5RmxhZ3M7XG5cbiAgLyoqXG4gICAqIFJlcHJlc2VudCBhIHNldCBvZiBmbGFncyBmb3IgV2ViR0xcbiAgICovXG4gIHJlYWRvbmx5IHdlYmdsOiBFbnYuV2ViR0xGbGFncztcblxuICAvKipcbiAgICogUmVwcmVzZW50IGEgc2V0IG9mIGZsYWdzIGZvciBXZWJHUFVcbiAgICovXG4gIHJlYWRvbmx5IHdlYmdwdTogRW52LldlYkdwdUZsYWdzO1xuXG4gIFtuYW1lOiBzdHJpbmddOiB1bmtub3duO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudCBhIHNldCBvZiBmbGFncyBhcyBhIGdsb2JhbCBzaW5nbGV0b24uXG4gKi9cbmV4cG9ydCBjb25zdCBlbnY6IEVudiA9IGVudkltcGw7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IFRlbnNvclRvRGF0YVVybE9wdGlvbnMsIFRlbnNvclRvSW1hZ2VEYXRhT3B0aW9ucyB9IGZyb20gJy4vdGVuc29yLWNvbnZlcnNpb24uanMnO1xuaW1wb3J0IHsgVGVuc29yIH0gZnJvbSAnLi90ZW5zb3IuanMnO1xuXG4vKipcbiAqIGltcGxlbWVudGF0aW9uIG9mIFRlbnNvci50b0RhdGFVUkwoKVxuICovXG5leHBvcnQgY29uc3QgdGVuc29yVG9EYXRhVVJMID0gKHRlbnNvcjogVGVuc29yLCBvcHRpb25zPzogVGVuc29yVG9EYXRhVXJsT3B0aW9ucyk6IHN0cmluZyA9PiB7XG4gIGNvbnN0IGNhbnZhcyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSA6IG5ldyBPZmZzY3JlZW5DYW52YXMoMSwgMSk7XG4gIGNhbnZhcy53aWR0aCA9IHRlbnNvci5kaW1zWzNdO1xuICBjYW52YXMuaGVpZ2h0ID0gdGVuc29yLmRpbXNbMl07XG4gIGNvbnN0IHBpeGVsczJEQ29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpIGFzXG4gICAgfCBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRcbiAgICB8IE9mZnNjcmVlbkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRFxuICAgIHwgbnVsbDtcblxuICBpZiAocGl4ZWxzMkRDb250ZXh0ICE9IG51bGwpIHtcbiAgICAvLyBEZWZhdWx0IHZhbHVlcyBmb3IgaGVpZ2h0IGFuZCB3aWR0aCAmIGZvcm1hdFxuICAgIGxldCB3aWR0aDogbnVtYmVyO1xuICAgIGxldCBoZWlnaHQ6IG51bWJlcjtcbiAgICBpZiAob3B0aW9ucz8udGVuc29yTGF5b3V0ICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy50ZW5zb3JMYXlvdXQgPT09ICdOSFdDJykge1xuICAgICAgd2lkdGggPSB0ZW5zb3IuZGltc1syXTtcbiAgICAgIGhlaWdodCA9IHRlbnNvci5kaW1zWzNdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEZWZhdWx0IGxheW91dCBpcyBOQ1dIXG4gICAgICB3aWR0aCA9IHRlbnNvci5kaW1zWzNdO1xuICAgICAgaGVpZ2h0ID0gdGVuc29yLmRpbXNbMl07XG4gICAgfVxuXG4gICAgY29uc3QgaW5wdXRmb3JtYXQgPSBvcHRpb25zPy5mb3JtYXQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZm9ybWF0IDogJ1JHQic7XG5cbiAgICBjb25zdCBub3JtID0gb3B0aW9ucz8ubm9ybTtcbiAgICBsZXQgbm9ybU1lYW46IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuICAgIGxldCBub3JtQmlhczogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG4gICAgaWYgKG5vcm0gPT09IHVuZGVmaW5lZCB8fCBub3JtLm1lYW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgbm9ybU1lYW4gPSBbMjU1LCAyNTUsIDI1NSwgMjU1XTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBub3JtLm1lYW4gPT09ICdudW1iZXInKSB7XG4gICAgICAgIG5vcm1NZWFuID0gW25vcm0ubWVhbiwgbm9ybS5tZWFuLCBub3JtLm1lYW4sIG5vcm0ubWVhbl07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub3JtTWVhbiA9IFtub3JtLm1lYW5bMF0sIG5vcm0ubWVhblsxXSwgbm9ybS5tZWFuWzJdLCAwXTtcbiAgICAgICAgaWYgKG5vcm0ubWVhblszXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbm9ybU1lYW5bM10gPSBub3JtLm1lYW5bM107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vcm0gPT09IHVuZGVmaW5lZCB8fCBub3JtLmJpYXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbm9ybUJpYXMgPSBbMCwgMCwgMCwgMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2Ygbm9ybS5iaWFzID09PSAnbnVtYmVyJykge1xuICAgICAgICBub3JtQmlhcyA9IFtub3JtLmJpYXMsIG5vcm0uYmlhcywgbm9ybS5iaWFzLCBub3JtLmJpYXNdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9ybUJpYXMgPSBbbm9ybS5iaWFzWzBdLCBub3JtLmJpYXNbMV0sIG5vcm0uYmlhc1syXSwgMF07XG4gICAgICAgIGlmIChub3JtLmJpYXNbM10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG5vcm1CaWFzWzNdID0gbm9ybS5iaWFzWzNdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc3RyaWRlID0gaGVpZ2h0ICogd2lkdGg7XG4gICAgLy8gRGVmYXVsdCBwb2ludGVyIGFzc2lnbm1lbnRzXG4gICAgbGV0IHJUZW5zb3JQb2ludGVyID0gMCxcbiAgICAgIGdUZW5zb3JQb2ludGVyID0gc3RyaWRlLFxuICAgICAgYlRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyLFxuICAgICAgYVRlbnNvclBvaW50ZXIgPSAtMTtcblxuICAgIC8vIFVwZGF0aW5nIHRoZSBwb2ludGVyIGFzc2lnbm1lbnRzIGJhc2VkIG9uIHRoZSBpbnB1dCBpbWFnZSBmb3JtYXRcbiAgICBpZiAoaW5wdXRmb3JtYXQgPT09ICdSR0JBJykge1xuICAgICAgclRlbnNvclBvaW50ZXIgPSAwO1xuICAgICAgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGU7XG4gICAgICBiVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDI7XG4gICAgICBhVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDM7XG4gICAgfSBlbHNlIGlmIChpbnB1dGZvcm1hdCA9PT0gJ1JHQicpIHtcbiAgICAgIHJUZW5zb3JQb2ludGVyID0gMDtcbiAgICAgIGdUZW5zb3JQb2ludGVyID0gc3RyaWRlO1xuICAgICAgYlRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyO1xuICAgIH0gZWxzZSBpZiAoaW5wdXRmb3JtYXQgPT09ICdSQkcnKSB7XG4gICAgICByVGVuc29yUG9pbnRlciA9IDA7XG4gICAgICBiVGVuc29yUG9pbnRlciA9IHN0cmlkZTtcbiAgICAgIGdUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMjtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhlaWdodDsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHdpZHRoOyBqKyspIHtcbiAgICAgICAgY29uc3QgUiA9ICgodGVuc29yLmRhdGFbclRlbnNvclBvaW50ZXIrK10gYXMgbnVtYmVyKSAtIG5vcm1CaWFzWzBdKSAqIG5vcm1NZWFuWzBdOyAvLyBSIHZhbHVlXG4gICAgICAgIGNvbnN0IEcgPSAoKHRlbnNvci5kYXRhW2dUZW5zb3JQb2ludGVyKytdIGFzIG51bWJlcikgLSBub3JtQmlhc1sxXSkgKiBub3JtTWVhblsxXTsgLy8gRyB2YWx1ZVxuICAgICAgICBjb25zdCBCID0gKCh0ZW5zb3IuZGF0YVtiVGVuc29yUG9pbnRlcisrXSBhcyBudW1iZXIpIC0gbm9ybUJpYXNbMl0pICogbm9ybU1lYW5bMl07IC8vIEIgdmFsdWVcbiAgICAgICAgY29uc3QgQSA9IGFUZW5zb3JQb2ludGVyID09PSAtMSA/IDI1NSA6ICgodGVuc29yLmRhdGFbYVRlbnNvclBvaW50ZXIrK10gYXMgbnVtYmVyKSAtIG5vcm1CaWFzWzNdKSAqIG5vcm1NZWFuWzNdOyAvLyBBIHZhbHVlXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtcGx1cy1vcGVyYW5kc1xuICAgICAgICBwaXhlbHMyRENvbnRleHQuZmlsbFN0eWxlID0gJ3JnYmEoJyArIFIgKyAnLCcgKyBHICsgJywnICsgQiArICcsJyArIEEgKyAnKSc7XG4gICAgICAgIHBpeGVsczJEQ29udGV4dC5maWxsUmVjdChqLCBpLCAxLCAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCd0b0RhdGFVUkwnIGluIGNhbnZhcykge1xuICAgICAgcmV0dXJuIGNhbnZhcy50b0RhdGFVUkwoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0b0RhdGFVUkwgaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgYWNjZXNzIGltYWdlIGRhdGEnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiBUZW5zb3IudG9JbWFnZURhdGEoKVxuICovXG5leHBvcnQgY29uc3QgdGVuc29yVG9JbWFnZURhdGEgPSAodGVuc29yOiBUZW5zb3IsIG9wdGlvbnM/OiBUZW5zb3JUb0ltYWdlRGF0YU9wdGlvbnMpOiBJbWFnZURhdGEgPT4ge1xuICBjb25zdCBwaXhlbHMyRENvbnRleHQgPVxuICAgIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dCgnMmQnKVxuICAgICAgOiAobmV3IE9mZnNjcmVlbkNhbnZhcygxLCAxKS5nZXRDb250ZXh0KCcyZCcpIGFzIE9mZnNjcmVlbkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCk7XG4gIGxldCBpbWFnZTogSW1hZ2VEYXRhO1xuICBpZiAocGl4ZWxzMkRDb250ZXh0ICE9IG51bGwpIHtcbiAgICAvLyBEZWZhdWx0IHZhbHVlcyBmb3IgaGVpZ2h0IGFuZCB3aWR0aCAmIGZvcm1hdFxuICAgIGxldCB3aWR0aDogbnVtYmVyO1xuICAgIGxldCBoZWlnaHQ6IG51bWJlcjtcbiAgICBsZXQgY2hhbm5lbHM6IG51bWJlcjtcbiAgICBpZiAob3B0aW9ucz8udGVuc29yTGF5b3V0ICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy50ZW5zb3JMYXlvdXQgPT09ICdOSFdDJykge1xuICAgICAgd2lkdGggPSB0ZW5zb3IuZGltc1syXTtcbiAgICAgIGhlaWdodCA9IHRlbnNvci5kaW1zWzFdO1xuICAgICAgY2hhbm5lbHMgPSB0ZW5zb3IuZGltc1szXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRGVmYXVsdCBsYXlvdXQgaXMgTkNXSFxuICAgICAgd2lkdGggPSB0ZW5zb3IuZGltc1szXTtcbiAgICAgIGhlaWdodCA9IHRlbnNvci5kaW1zWzJdO1xuICAgICAgY2hhbm5lbHMgPSB0ZW5zb3IuZGltc1sxXTtcbiAgICB9XG4gICAgY29uc3QgaW5wdXRmb3JtYXQgPSBvcHRpb25zICE9PSB1bmRlZmluZWQgPyAob3B0aW9ucy5mb3JtYXQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZm9ybWF0IDogJ1JHQicpIDogJ1JHQic7XG5cbiAgICBjb25zdCBub3JtID0gb3B0aW9ucz8ubm9ybTtcbiAgICBsZXQgbm9ybU1lYW46IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuICAgIGxldCBub3JtQmlhczogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG4gICAgaWYgKG5vcm0gPT09IHVuZGVmaW5lZCB8fCBub3JtLm1lYW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgbm9ybU1lYW4gPSBbMjU1LCAyNTUsIDI1NSwgMjU1XTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBub3JtLm1lYW4gPT09ICdudW1iZXInKSB7XG4gICAgICAgIG5vcm1NZWFuID0gW25vcm0ubWVhbiwgbm9ybS5tZWFuLCBub3JtLm1lYW4sIG5vcm0ubWVhbl07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub3JtTWVhbiA9IFtub3JtLm1lYW5bMF0sIG5vcm0ubWVhblsxXSwgbm9ybS5tZWFuWzJdLCAyNTVdO1xuICAgICAgICBpZiAobm9ybS5tZWFuWzNdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBub3JtTWVhblszXSA9IG5vcm0ubWVhblszXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9ybSA9PT0gdW5kZWZpbmVkIHx8IG5vcm0uYmlhcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBub3JtQmlhcyA9IFswLCAwLCAwLCAwXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBub3JtLmJpYXMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIG5vcm1CaWFzID0gW25vcm0uYmlhcywgbm9ybS5iaWFzLCBub3JtLmJpYXMsIG5vcm0uYmlhc107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub3JtQmlhcyA9IFtub3JtLmJpYXNbMF0sIG5vcm0uYmlhc1sxXSwgbm9ybS5iaWFzWzJdLCAwXTtcbiAgICAgICAgaWYgKG5vcm0uYmlhc1szXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbm9ybUJpYXNbM10gPSBub3JtLmJpYXNbM107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzdHJpZGUgPSBoZWlnaHQgKiB3aWR0aDtcbiAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoXG4gICAgICAgIChvcHRpb25zLmZvcm1hdCAhPT0gdW5kZWZpbmVkICYmIGNoYW5uZWxzID09PSA0ICYmIG9wdGlvbnMuZm9ybWF0ICE9PSAnUkdCQScpIHx8XG4gICAgICAgIChjaGFubmVscyA9PT0gMyAmJiBvcHRpb25zLmZvcm1hdCAhPT0gJ1JHQicgJiYgb3B0aW9ucy5mb3JtYXQgIT09ICdCR1InKVxuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRlbnNvciBmb3JtYXQgZG9lc24ndCBtYXRjaCBpbnB1dCB0ZW5zb3IgZGltc1wiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0IHBvaW50ZXIgYXNzaWdubWVudHNcbiAgICBjb25zdCBzdGVwID0gNDtcbiAgICBsZXQgckltYWdlUG9pbnRlciA9IDAsXG4gICAgICBnSW1hZ2VQb2ludGVyID0gMSxcbiAgICAgIGJJbWFnZVBvaW50ZXIgPSAyLFxuICAgICAgYUltYWdlUG9pbnRlciA9IDM7XG4gICAgbGV0IHJUZW5zb3JQb2ludGVyID0gMCxcbiAgICAgIGdUZW5zb3JQb2ludGVyID0gc3RyaWRlLFxuICAgICAgYlRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyLFxuICAgICAgYVRlbnNvclBvaW50ZXIgPSAtMTtcblxuICAgIC8vIFVwZGF0aW5nIHRoZSBwb2ludGVyIGFzc2lnbm1lbnRzIGJhc2VkIG9uIHRoZSBpbnB1dCBpbWFnZSBmb3JtYXRcbiAgICBpZiAoaW5wdXRmb3JtYXQgPT09ICdSR0JBJykge1xuICAgICAgclRlbnNvclBvaW50ZXIgPSAwO1xuICAgICAgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGU7XG4gICAgICBiVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDI7XG4gICAgICBhVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDM7XG4gICAgfSBlbHNlIGlmIChpbnB1dGZvcm1hdCA9PT0gJ1JHQicpIHtcbiAgICAgIHJUZW5zb3JQb2ludGVyID0gMDtcbiAgICAgIGdUZW5zb3JQb2ludGVyID0gc3RyaWRlO1xuICAgICAgYlRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyO1xuICAgIH0gZWxzZSBpZiAoaW5wdXRmb3JtYXQgPT09ICdSQkcnKSB7XG4gICAgICByVGVuc29yUG9pbnRlciA9IDA7XG4gICAgICBiVGVuc29yUG9pbnRlciA9IHN0cmlkZTtcbiAgICAgIGdUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMjtcbiAgICB9XG5cbiAgICBpbWFnZSA9IHBpeGVsczJEQ29udGV4dC5jcmVhdGVJbWFnZURhdGEod2lkdGgsIGhlaWdodCk7XG5cbiAgICBmb3IgKFxuICAgICAgbGV0IGkgPSAwO1xuICAgICAgaSA8IGhlaWdodCAqIHdpZHRoO1xuICAgICAgckltYWdlUG9pbnRlciArPSBzdGVwLCBnSW1hZ2VQb2ludGVyICs9IHN0ZXAsIGJJbWFnZVBvaW50ZXIgKz0gc3RlcCwgYUltYWdlUG9pbnRlciArPSBzdGVwLCBpKytcbiAgICApIHtcbiAgICAgIGltYWdlLmRhdGFbckltYWdlUG9pbnRlcl0gPSAoKHRlbnNvci5kYXRhW3JUZW5zb3JQb2ludGVyKytdIGFzIG51bWJlcikgLSBub3JtQmlhc1swXSkgKiBub3JtTWVhblswXTsgLy8gUiB2YWx1ZVxuICAgICAgaW1hZ2UuZGF0YVtnSW1hZ2VQb2ludGVyXSA9ICgodGVuc29yLmRhdGFbZ1RlbnNvclBvaW50ZXIrK10gYXMgbnVtYmVyKSAtIG5vcm1CaWFzWzFdKSAqIG5vcm1NZWFuWzFdOyAvLyBHIHZhbHVlXG4gICAgICBpbWFnZS5kYXRhW2JJbWFnZVBvaW50ZXJdID0gKCh0ZW5zb3IuZGF0YVtiVGVuc29yUG9pbnRlcisrXSBhcyBudW1iZXIpIC0gbm9ybUJpYXNbMl0pICogbm9ybU1lYW5bMl07IC8vIEIgdmFsdWVcbiAgICAgIGltYWdlLmRhdGFbYUltYWdlUG9pbnRlcl0gPVxuICAgICAgICBhVGVuc29yUG9pbnRlciA9PT0gLTEgPyAyNTUgOiAoKHRlbnNvci5kYXRhW2FUZW5zb3JQb2ludGVyKytdIGFzIG51bWJlcikgLSBub3JtQmlhc1szXSkgKiBub3JtTWVhblszXTsgLy8gQSB2YWx1ZVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgYWNjZXNzIGltYWdlIGRhdGEnKTtcbiAgfVxuICByZXR1cm4gaW1hZ2U7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge1xuICBPcHRpb25zRGltZW5zaW9ucyxcbiAgT3B0aW9uc0Zvcm1hdCxcbiAgT3B0aW9uc05vcm1hbGl6YXRpb25QYXJhbWV0ZXJzLFxuICBPcHRpb25zVGVuc29yRm9ybWF0LFxuICBPcHRpb25zVGVuc29yTGF5b3V0LFxuICBUZW5zb3JGcm9tR3B1QnVmZmVyT3B0aW9ucyxcbiAgVGVuc29yRnJvbUltYWdlQml0bWFwT3B0aW9ucyxcbiAgVGVuc29yRnJvbUltYWdlRGF0YU9wdGlvbnMsXG4gIFRlbnNvckZyb21JbWFnZUVsZW1lbnRPcHRpb25zLFxuICBUZW5zb3JGcm9tTUxUZW5zb3JPcHRpb25zLFxuICBUZW5zb3JGcm9tVGV4dHVyZU9wdGlvbnMsXG4gIFRlbnNvckZyb21VcmxPcHRpb25zLFxufSBmcm9tICcuL3RlbnNvci1mYWN0b3J5LmpzJztcbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4vdGVuc29yLWltcGwuanMnO1xuaW1wb3J0IHsgVGVuc29yIGFzIFRlbnNvckludGVyZmFjZSB9IGZyb20gJy4vdGVuc29yLmpzJztcblxuaW50ZXJmYWNlIEJ1ZmZlclRvVGVuc29yT3B0aW9uc1xuICBleHRlbmRzIE9wdGlvbnNEaW1lbnNpb25zLFxuICAgIE9wdGlvbnNUZW5zb3JMYXlvdXQsXG4gICAgT3B0aW9uc05vcm1hbGl6YXRpb25QYXJhbWV0ZXJzLFxuICAgIE9wdGlvbnNGb3JtYXQsXG4gICAgT3B0aW9uc1RlbnNvckZvcm1hdCB7fVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyB0ZW5zb3Igb2JqZWN0IGZyb20gaW1hZ2Ugb2JqZWN0XG4gKlxuICogQHBhcmFtIGJ1ZmZlciAtIEV4dHJhY3RlZCBpbWFnZSBidWZmZXIgZGF0YSAtIGFzc3VtaW5nIFJHQkEgZm9ybWF0XG4gKiBAcGFyYW0gaW1hZ2VGb3JtYXQgLSBpbnB1dCBpbWFnZSBjb25maWd1cmF0aW9uIC0gcmVxdWlyZWQgY29uZmlndXJhdGlvbnMgaGVpZ2h0LCB3aWR0aCwgZm9ybWF0XG4gKiBAcGFyYW0gdGVuc29yRm9ybWF0IC0gb3V0cHV0IHRlbnNvciBjb25maWd1cmF0aW9uIC0gRGVmYXVsdCBpcyBSR0IgZm9ybWF0XG4gKi9cbmV4cG9ydCBjb25zdCBidWZmZXJUb1RlbnNvciA9IChidWZmZXI6IFVpbnQ4Q2xhbXBlZEFycmF5IHwgdW5kZWZpbmVkLCBvcHRpb25zOiBCdWZmZXJUb1RlbnNvck9wdGlvbnMpOiBUZW5zb3IgPT4ge1xuICBpZiAoYnVmZmVyID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIGJ1ZmZlciBtdXN0IGJlIGRlZmluZWQnKTtcbiAgfVxuICBpZiAob3B0aW9ucy5oZWlnaHQgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLndpZHRoID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIGhlaWdodCBhbmQgd2lkdGggbXVzdCBiZSBkZWZpbmVkJyk7XG4gIH1cbiAgaWYgKG9wdGlvbnMudGVuc29yTGF5b3V0ID09PSAnTkhXQycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05IV0MgVGVuc29yIGxheW91dCBpcyBub3Qgc3VwcG9ydGVkIHlldCcpO1xuICB9XG5cbiAgY29uc3QgeyBoZWlnaHQsIHdpZHRoIH0gPSBvcHRpb25zO1xuXG4gIGNvbnN0IG5vcm0gPSBvcHRpb25zLm5vcm0gPz8geyBtZWFuOiAyNTUsIGJpYXM6IDAgfTtcbiAgbGV0IG5vcm1NZWFuOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgbGV0IG5vcm1CaWFzOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcblxuICBpZiAodHlwZW9mIG5vcm0ubWVhbiA9PT0gJ251bWJlcicpIHtcbiAgICBub3JtTWVhbiA9IFtub3JtLm1lYW4sIG5vcm0ubWVhbiwgbm9ybS5tZWFuLCBub3JtLm1lYW5dO1xuICB9IGVsc2Uge1xuICAgIG5vcm1NZWFuID0gW25vcm0ubWVhbiFbMF0sIG5vcm0ubWVhbiFbMV0sIG5vcm0ubWVhbiFbMl0sIG5vcm0ubWVhbiFbM10gPz8gMjU1XTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygbm9ybS5iaWFzID09PSAnbnVtYmVyJykge1xuICAgIG5vcm1CaWFzID0gW25vcm0uYmlhcywgbm9ybS5iaWFzLCBub3JtLmJpYXMsIG5vcm0uYmlhc107XG4gIH0gZWxzZSB7XG4gICAgbm9ybUJpYXMgPSBbbm9ybS5iaWFzIVswXSwgbm9ybS5iaWFzIVsxXSwgbm9ybS5iaWFzIVsyXSwgbm9ybS5iaWFzIVszXSA/PyAwXTtcbiAgfVxuXG4gIGNvbnN0IGlucHV0Zm9ybWF0ID0gb3B0aW9ucy5mb3JtYXQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZm9ybWF0IDogJ1JHQkEnO1xuICAvLyBkZWZhdWx0IHZhbHVlIGlzIFJHQkEgc2luY2UgaW1hZ2VkYXRhIGFuZCBIVE1MSW1hZ2VFbGVtZW50IHVzZXMgaXRcblxuICBjb25zdCBvdXRwdXRmb3JtYXQgPVxuICAgIG9wdGlvbnMudGVuc29yRm9ybWF0ICE9PSB1bmRlZmluZWQgPyAob3B0aW9ucy50ZW5zb3JGb3JtYXQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMudGVuc29yRm9ybWF0IDogJ1JHQicpIDogJ1JHQic7XG4gIGNvbnN0IHN0cmlkZSA9IGhlaWdodCAqIHdpZHRoO1xuICBjb25zdCBmbG9hdDMyRGF0YSA9IG91dHB1dGZvcm1hdCA9PT0gJ1JHQkEnID8gbmV3IEZsb2F0MzJBcnJheShzdHJpZGUgKiA0KSA6IG5ldyBGbG9hdDMyQXJyYXkoc3RyaWRlICogMyk7XG5cbiAgLy8gRGVmYXVsdCBwb2ludGVyIGFzc2lnbm1lbnRzXG4gIGxldCBzdGVwID0gNCxcbiAgICBySW1hZ2VQb2ludGVyID0gMCxcbiAgICBnSW1hZ2VQb2ludGVyID0gMSxcbiAgICBiSW1hZ2VQb2ludGVyID0gMixcbiAgICBhSW1hZ2VQb2ludGVyID0gMztcbiAgbGV0IHJUZW5zb3JQb2ludGVyID0gMCxcbiAgICBnVGVuc29yUG9pbnRlciA9IHN0cmlkZSxcbiAgICBiVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDIsXG4gICAgYVRlbnNvclBvaW50ZXIgPSAtMTtcblxuICAvLyBVcGRhdGluZyB0aGUgcG9pbnRlciBhc3NpZ25tZW50cyBiYXNlZCBvbiB0aGUgaW5wdXQgaW1hZ2UgZm9ybWF0XG4gIGlmIChpbnB1dGZvcm1hdCA9PT0gJ1JHQicpIHtcbiAgICBzdGVwID0gMztcbiAgICBySW1hZ2VQb2ludGVyID0gMDtcbiAgICBnSW1hZ2VQb2ludGVyID0gMTtcbiAgICBiSW1hZ2VQb2ludGVyID0gMjtcbiAgICBhSW1hZ2VQb2ludGVyID0gLTE7XG4gIH1cblxuICAvLyBVcGRhdGluZyB0aGUgcG9pbnRlciBhc3NpZ25tZW50cyBiYXNlZCBvbiB0aGUgb3V0cHV0IHRlbnNvciBmb3JtYXRcbiAgaWYgKG91dHB1dGZvcm1hdCA9PT0gJ1JHQkEnKSB7XG4gICAgYVRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAzO1xuICB9IGVsc2UgaWYgKG91dHB1dGZvcm1hdCA9PT0gJ1JCRycpIHtcbiAgICByVGVuc29yUG9pbnRlciA9IDA7XG4gICAgYlRlbnNvclBvaW50ZXIgPSBzdHJpZGU7XG4gICAgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyO1xuICB9IGVsc2UgaWYgKG91dHB1dGZvcm1hdCA9PT0gJ0JHUicpIHtcbiAgICBiVGVuc29yUG9pbnRlciA9IDA7XG4gICAgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGU7XG4gICAgclRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyO1xuICB9XG5cbiAgZm9yIChcbiAgICBsZXQgaSA9IDA7XG4gICAgaSA8IHN0cmlkZTtcbiAgICBpKyssIHJJbWFnZVBvaW50ZXIgKz0gc3RlcCwgYkltYWdlUG9pbnRlciArPSBzdGVwLCBnSW1hZ2VQb2ludGVyICs9IHN0ZXAsIGFJbWFnZVBvaW50ZXIgKz0gc3RlcFxuICApIHtcbiAgICBmbG9hdDMyRGF0YVtyVGVuc29yUG9pbnRlcisrXSA9IChidWZmZXJbckltYWdlUG9pbnRlcl0gKyBub3JtQmlhc1swXSkgLyBub3JtTWVhblswXTtcbiAgICBmbG9hdDMyRGF0YVtnVGVuc29yUG9pbnRlcisrXSA9IChidWZmZXJbZ0ltYWdlUG9pbnRlcl0gKyBub3JtQmlhc1sxXSkgLyBub3JtTWVhblsxXTtcbiAgICBmbG9hdDMyRGF0YVtiVGVuc29yUG9pbnRlcisrXSA9IChidWZmZXJbYkltYWdlUG9pbnRlcl0gKyBub3JtQmlhc1syXSkgLyBub3JtTWVhblsyXTtcbiAgICBpZiAoYVRlbnNvclBvaW50ZXIgIT09IC0xICYmIGFJbWFnZVBvaW50ZXIgIT09IC0xKSB7XG4gICAgICBmbG9hdDMyRGF0YVthVGVuc29yUG9pbnRlcisrXSA9IChidWZmZXJbYUltYWdlUG9pbnRlcl0gKyBub3JtQmlhc1szXSkgLyBub3JtTWVhblszXTtcbiAgICB9XG4gIH1cblxuICAvLyBGbG9hdDMyQXJyYXkgLT4gb3J0LlRlbnNvclxuICBjb25zdCBvdXRwdXRUZW5zb3IgPVxuICAgIG91dHB1dGZvcm1hdCA9PT0gJ1JHQkEnXG4gICAgICA/IG5ldyBUZW5zb3IoJ2Zsb2F0MzInLCBmbG9hdDMyRGF0YSwgWzEsIDQsIGhlaWdodCwgd2lkdGhdKVxuICAgICAgOiBuZXcgVGVuc29yKCdmbG9hdDMyJywgZmxvYXQzMkRhdGEsIFsxLCAzLCBoZWlnaHQsIHdpZHRoXSk7XG4gIHJldHVybiBvdXRwdXRUZW5zb3I7XG59O1xuXG4vKipcbiAqIGltcGxlbWVudGF0aW9uIG9mIFRlbnNvci5mcm9tSW1hZ2UoKS5cbiAqL1xuZXhwb3J0IGNvbnN0IHRlbnNvckZyb21JbWFnZSA9IGFzeW5jIChcbiAgaW1hZ2U6IEltYWdlRGF0YSB8IEhUTUxJbWFnZUVsZW1lbnQgfCBJbWFnZUJpdG1hcCB8IHN0cmluZyxcbiAgb3B0aW9ucz86XG4gICAgfCBUZW5zb3JGcm9tSW1hZ2VEYXRhT3B0aW9uc1xuICAgIHwgVGVuc29yRnJvbUltYWdlRWxlbWVudE9wdGlvbnNcbiAgICB8IFRlbnNvckZyb21JbWFnZUJpdG1hcE9wdGlvbnNcbiAgICB8IFRlbnNvckZyb21VcmxPcHRpb25zLFxuKTogUHJvbWlzZTxUZW5zb3I+ID0+IHtcbiAgLy8gY2hlY2tpbmcgdGhlIHR5cGUgb2YgaW1hZ2Ugb2JqZWN0XG4gIGNvbnN0IGlzSFRNTEltYWdlRWxlID0gdHlwZW9mIEhUTUxJbWFnZUVsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGltYWdlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudDtcbiAgY29uc3QgaXNJbWFnZURhdGFFbGUgPSB0eXBlb2YgSW1hZ2VEYXRhICE9PSAndW5kZWZpbmVkJyAmJiBpbWFnZSBpbnN0YW5jZW9mIEltYWdlRGF0YTtcbiAgY29uc3QgaXNJbWFnZUJpdG1hcCA9IHR5cGVvZiBJbWFnZUJpdG1hcCAhPT0gJ3VuZGVmaW5lZCcgJiYgaW1hZ2UgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcDtcbiAgY29uc3QgaXNTdHJpbmcgPSB0eXBlb2YgaW1hZ2UgPT09ICdzdHJpbmcnO1xuXG4gIGxldCBkYXRhOiBVaW50OENsYW1wZWRBcnJheSB8IHVuZGVmaW5lZDtcbiAgbGV0IGJ1ZmZlclRvVGVuc29yT3B0aW9uczogQnVmZmVyVG9UZW5zb3JPcHRpb25zID0gb3B0aW9ucyA/PyB7fTtcblxuICBjb25zdCBjcmVhdGVDYW52YXMgPSAoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gbmV3IE9mZnNjcmVlbkNhbnZhcygxLCAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW52YXMgaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgY3JlYXRlQ2FudmFzQ29udGV4dCA9IChjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50IHwgT2Zmc2NyZWVuQ2FudmFzKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgY2FudmFzIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQpIHtcbiAgICAgIHJldHVybiBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB9IGVsc2UgaWYgKGNhbnZhcyBpbnN0YW5jZW9mIE9mZnNjcmVlbkNhbnZhcykge1xuICAgICAgcmV0dXJuIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpIGFzIE9mZnNjcmVlbkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xuICAvLyBmaWxsaW5nIGFuZCBjaGVja2luZyBpbWFnZSBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgaWYgKGlzSFRNTEltYWdlRWxlKSB7XG4gICAgLy8gSFRNTEltYWdlRWxlbWVudCAtIGltYWdlIG9iamVjdCAtIGZvcm1hdCBpcyBSR0JBIGJ5IGRlZmF1bHRcbiAgICBjb25zdCBjYW52YXMgPSBjcmVhdGVDYW52YXMoKTtcbiAgICBjYW52YXMud2lkdGggPSBpbWFnZS53aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuICAgIGNvbnN0IHBpeGVsczJEQ29udGV4dCA9IGNyZWF0ZUNhbnZhc0NvbnRleHQoY2FudmFzKTtcblxuICAgIGlmIChwaXhlbHMyRENvbnRleHQgIT0gbnVsbCkge1xuICAgICAgbGV0IGhlaWdodCA9IGltYWdlLmhlaWdodDtcbiAgICAgIGxldCB3aWR0aCA9IGltYWdlLndpZHRoO1xuICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnJlc2l6ZWRIZWlnaHQgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnJlc2l6ZWRXaWR0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGhlaWdodCA9IG9wdGlvbnMucmVzaXplZEhlaWdodDtcbiAgICAgICAgd2lkdGggPSBvcHRpb25zLnJlc2l6ZWRXaWR0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICBpZiAob3B0aW9ucy50ZW5zb3JGb3JtYXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2UgaW5wdXQgY29uZmlnIGZvcm1hdCBtdXN0IGJlIFJHQkEgZm9yIEhUTUxJbWFnZUVsZW1lbnQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMudGVuc29yRm9ybWF0ID0gJ1JHQkEnO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy53aWR0aCA9IHdpZHRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLnRlbnNvckZvcm1hdCA9ICdSR0JBJztcbiAgICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLndpZHRoID0gd2lkdGg7XG4gICAgICB9XG5cbiAgICAgIHBpeGVsczJEQ29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDApO1xuICAgICAgZGF0YSA9IHBpeGVsczJEQ29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCkuZGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhJyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzSW1hZ2VEYXRhRWxlKSB7XG4gICAgbGV0IGhlaWdodDogbnVtYmVyO1xuICAgIGxldCB3aWR0aDogbnVtYmVyO1xuXG4gICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnJlc2l6ZWRXaWR0aCAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMucmVzaXplZEhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBoZWlnaHQgPSBvcHRpb25zLnJlc2l6ZWRIZWlnaHQ7XG4gICAgICB3aWR0aCA9IG9wdGlvbnMucmVzaXplZFdpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICBoZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG4gICAgICB3aWR0aCA9IGltYWdlLndpZHRoO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy5mb3JtYXQgPSAnUkdCQSc7XG4gICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLmhlaWdodCA9IGhlaWdodDtcbiAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMud2lkdGggPSB3aWR0aDtcblxuICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IHRlbXBDYW52YXMgPSBjcmVhdGVDYW52YXMoKTtcblxuICAgICAgdGVtcENhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgdGVtcENhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgIGNvbnN0IHBpeGVsczJEQ29udGV4dCA9IGNyZWF0ZUNhbnZhc0NvbnRleHQodGVtcENhbnZhcyk7XG5cbiAgICAgIGlmIChwaXhlbHMyRENvbnRleHQgIT0gbnVsbCkge1xuICAgICAgICBwaXhlbHMyRENvbnRleHQucHV0SW1hZ2VEYXRhKGltYWdlLCAwLCAwKTtcbiAgICAgICAgZGF0YSA9IHBpeGVsczJEQ29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCkuZGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YScpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhID0gaW1hZ2UuZGF0YTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNJbWFnZUJpdG1hcCkge1xuICAgIC8vIEltYWdlQml0bWFwIC0gaW1hZ2Ugb2JqZWN0IC0gZm9ybWF0IG11c3QgYmUgcHJvdmlkZWQgYnkgdXNlclxuICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHByb3ZpZGUgaW1hZ2UgY29uZmlnIHdpdGggZm9ybWF0IGZvciBJbWFnZWJpdG1hcCcpO1xuICAgIH1cblxuICAgIGNvbnN0IGNhbnZhcyA9IGNyZWF0ZUNhbnZhcygpO1xuICAgIGNhbnZhcy53aWR0aCA9IGltYWdlLndpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG4gICAgY29uc3QgcGl4ZWxzMkRDb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dChjYW52YXMpO1xuXG4gICAgaWYgKHBpeGVsczJEQ29udGV4dCAhPSBudWxsKSB7XG4gICAgICBjb25zdCBoZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG4gICAgICBjb25zdCB3aWR0aCA9IGltYWdlLndpZHRoO1xuICAgICAgcGl4ZWxzMkRDb250ZXh0LmRyYXdJbWFnZShpbWFnZSwgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBkYXRhID0gcGl4ZWxzMkRDb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KS5kYXRhO1xuICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy53aWR0aCA9IHdpZHRoO1xuICAgICAgcmV0dXJuIGJ1ZmZlclRvVGVuc29yKGRhdGEsIGJ1ZmZlclRvVGVuc29yT3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YScpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc1N0cmluZykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBjYW52YXMgPSBjcmVhdGVDYW52YXMoKTtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVDYW52YXNDb250ZXh0KGNhbnZhcyk7XG4gICAgICBpZiAoIWltYWdlIHx8ICFjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiByZWplY3QoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5ld0ltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICBuZXdJbWFnZS5jcm9zc09yaWdpbiA9ICdBbm9ueW1vdXMnO1xuICAgICAgbmV3SW1hZ2Uuc3JjID0gaW1hZ2U7XG4gICAgICBuZXdJbWFnZS5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IG5ld0ltYWdlLndpZHRoO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gbmV3SW1hZ2UuaGVpZ2h0O1xuICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShuZXdJbWFnZSwgMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgY29uc3QgaW1nID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcblxuICAgICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMuaGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcbiAgICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLndpZHRoID0gY2FudmFzLndpZHRoO1xuICAgICAgICByZXNvbHZlKGJ1ZmZlclRvVGVuc29yKGltZy5kYXRhLCBidWZmZXJUb1RlbnNvck9wdGlvbnMpKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBkYXRhIHByb3ZpZGVkIGlzIG5vdCBzdXBwb3J0ZWQgLSBhYm9ydGVkIHRlbnNvciBjcmVhdGlvbicpO1xuICB9XG5cbiAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBidWZmZXJUb1RlbnNvcihkYXRhLCBidWZmZXJUb1RlbnNvck9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgZGF0YSBwcm92aWRlZCBpcyBub3Qgc3VwcG9ydGVkIC0gYWJvcnRlZCB0ZW5zb3IgY3JlYXRpb24nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiBUZW5zb3IuZnJvbVRleHR1cmUoKS5cbiAqL1xuZXhwb3J0IGNvbnN0IHRlbnNvckZyb21UZXh0dXJlID0gPFQgZXh0ZW5kcyBUZW5zb3JJbnRlcmZhY2UuVGV4dHVyZURhdGFUeXBlcz4oXG4gIHRleHR1cmU6IFRlbnNvckludGVyZmFjZS5UZXh0dXJlVHlwZSxcbiAgb3B0aW9uczogVGVuc29yRnJvbVRleHR1cmVPcHRpb25zPFQ+LFxuKTogVGVuc29yID0+IHtcbiAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCBkb3dubG9hZCwgZGlzcG9zZSB9ID0gb3B0aW9ucztcbiAgLy8gQWx3YXlzIGFzc3VtZSBSR0JBRjMyLiBUT0RPOiBzdXBwb3J0IGRpZmZlcmVudCB0ZXh0dXJlIGZvcm1hdFxuICBjb25zdCBkaW1zID0gWzEsIGhlaWdodCwgd2lkdGgsIDRdO1xuICByZXR1cm4gbmV3IFRlbnNvcih7IGxvY2F0aW9uOiAndGV4dHVyZScsIHR5cGU6ICdmbG9hdDMyJywgdGV4dHVyZSwgZGltcywgZG93bmxvYWQsIGRpc3Bvc2UgfSk7XG59O1xuXG4vKipcbiAqIGltcGxlbWVudGF0aW9uIG9mIFRlbnNvci5mcm9tR3B1QnVmZmVyKCkuXG4gKi9cbmV4cG9ydCBjb25zdCB0ZW5zb3JGcm9tR3B1QnVmZmVyID0gPFQgZXh0ZW5kcyBUZW5zb3JJbnRlcmZhY2UuR3B1QnVmZmVyRGF0YVR5cGVzPihcbiAgZ3B1QnVmZmVyOiBUZW5zb3JJbnRlcmZhY2UuR3B1QnVmZmVyVHlwZSxcbiAgb3B0aW9uczogVGVuc29yRnJvbUdwdUJ1ZmZlck9wdGlvbnM8VD4sXG4pOiBUZW5zb3IgPT4ge1xuICBjb25zdCB7IGRhdGFUeXBlLCBkaW1zLCBkb3dubG9hZCwgZGlzcG9zZSB9ID0gb3B0aW9ucztcbiAgcmV0dXJuIG5ldyBUZW5zb3IoeyBsb2NhdGlvbjogJ2dwdS1idWZmZXInLCB0eXBlOiBkYXRhVHlwZSA/PyAnZmxvYXQzMicsIGdwdUJ1ZmZlciwgZGltcywgZG93bmxvYWQsIGRpc3Bvc2UgfSk7XG59O1xuXG4vKipcbiAqIGltcGxlbWVudGF0aW9uIG9mIFRlbnNvci5mcm9tTUxUZW5zb3IoKS5cbiAqL1xuZXhwb3J0IGNvbnN0IHRlbnNvckZyb21NTFRlbnNvciA9IDxUIGV4dGVuZHMgVGVuc29ySW50ZXJmYWNlLk1MVGVuc29yRGF0YVR5cGVzPihcbiAgbWxUZW5zb3I6IFRlbnNvckludGVyZmFjZS5NTFRlbnNvclR5cGUsXG4gIG9wdGlvbnM6IFRlbnNvckZyb21NTFRlbnNvck9wdGlvbnM8VD4sXG4pOiBUZW5zb3IgPT4ge1xuICBjb25zdCB7IGRhdGFUeXBlLCBkaW1zLCBkb3dubG9hZCwgZGlzcG9zZSB9ID0gb3B0aW9ucztcbiAgcmV0dXJuIG5ldyBUZW5zb3IoeyBsb2NhdGlvbjogJ21sLXRlbnNvcicsIHR5cGU6IGRhdGFUeXBlID8/ICdmbG9hdDMyJywgbWxUZW5zb3IsIGRpbXMsIGRvd25sb2FkLCBkaXNwb3NlIH0pO1xufTtcblxuLyoqXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiBUZW5zb3IuZnJvbVBpbm5lZEJ1ZmZlcigpLlxuICovXG5leHBvcnQgY29uc3QgdGVuc29yRnJvbVBpbm5lZEJ1ZmZlciA9IDxUIGV4dGVuZHMgVGVuc29ySW50ZXJmYWNlLkNwdVBpbm5lZERhdGFUeXBlcz4oXG4gIHR5cGU6IFQsXG4gIGJ1ZmZlcjogVGVuc29ySW50ZXJmYWNlLkRhdGFUeXBlTWFwW1RdLFxuICBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10sXG4pOiBUZW5zb3IgPT4gbmV3IFRlbnNvcih7IGxvY2F0aW9uOiAnY3B1LXBpbm5lZCcsIHR5cGUsIGRhdGE6IGJ1ZmZlciwgZGltczogZGltcyA/PyBbYnVmZmVyLmxlbmd0aF0gfSk7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4vdGVuc29yLmpzJztcblxuZXhwb3J0IHR5cGUgU3VwcG9ydGVkVHlwZWRBcnJheUNvbnN0cnVjdG9ycyA9XG4gIHwgRmxvYXQzMkFycmF5Q29uc3RydWN0b3JcbiAgfCBVaW50OEFycmF5Q29uc3RydWN0b3JcbiAgfCBJbnQ4QXJyYXlDb25zdHJ1Y3RvclxuICB8IFVpbnQxNkFycmF5Q29uc3RydWN0b3JcbiAgfCBJbnQxNkFycmF5Q29uc3RydWN0b3JcbiAgfCBJbnQzMkFycmF5Q29uc3RydWN0b3JcbiAgfCBCaWdJbnQ2NEFycmF5Q29uc3RydWN0b3JcbiAgfCBVaW50OEFycmF5Q29uc3RydWN0b3JcbiAgfCBGbG9hdDY0QXJyYXlDb25zdHJ1Y3RvclxuICB8IFVpbnQzMkFycmF5Q29uc3RydWN0b3JcbiAgfCBCaWdVaW50NjRBcnJheUNvbnN0cnVjdG9yO1xuZXhwb3J0IHR5cGUgU3VwcG9ydGVkVHlwZWRBcnJheSA9IEluc3RhbmNlVHlwZTxTdXBwb3J0ZWRUeXBlZEFycmF5Q29uc3RydWN0b3JzPjtcblxuLy8gYSBydW50aW1lIG1hcCB0aGF0IG1hcHMgdHlwZSBzdHJpbmcgdG8gVHlwZWRBcnJheSBjb25zdHJ1Y3Rvci4gU2hvdWxkIG1hdGNoIFRlbnNvci5EYXRhVHlwZU1hcC5cbmV4cG9ydCBjb25zdCBOVU1FUklDX1RFTlNPUl9UWVBFX1RPX1RZUEVEQVJSQVlfTUFQID0gbmV3IE1hcDxzdHJpbmcsIFN1cHBvcnRlZFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnM+KFtcbiAgWydmbG9hdDMyJywgRmxvYXQzMkFycmF5XSxcbiAgWyd1aW50OCcsIFVpbnQ4QXJyYXldLFxuICBbJ2ludDgnLCBJbnQ4QXJyYXldLFxuICBbJ3VpbnQxNicsIFVpbnQxNkFycmF5XSxcbiAgWydpbnQxNicsIEludDE2QXJyYXldLFxuICBbJ2ludDMyJywgSW50MzJBcnJheV0sXG4gIFsnYm9vbCcsIFVpbnQ4QXJyYXldLFxuICBbJ2Zsb2F0NjQnLCBGbG9hdDY0QXJyYXldLFxuICBbJ3VpbnQzMicsIFVpbnQzMkFycmF5XSxcbiAgWydpbnQ0JywgVWludDhBcnJheV0sXG4gIFsndWludDQnLCBVaW50OEFycmF5XSxcbl0pO1xuXG4vLyBhIHJ1bnRpbWUgbWFwIHRoYXQgbWFwcyB0eXBlIHN0cmluZyB0byBUeXBlZEFycmF5IGNvbnN0cnVjdG9yLiBTaG91bGQgbWF0Y2ggVGVuc29yLkRhdGFUeXBlTWFwLlxuZXhwb3J0IGNvbnN0IE5VTUVSSUNfVEVOU09SX1RZUEVEQVJSQVlfVE9fVFlQRV9NQVAgPSBuZXcgTWFwPFN1cHBvcnRlZFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnMsIFRlbnNvci5UeXBlPihbXG4gIFtGbG9hdDMyQXJyYXksICdmbG9hdDMyJ10sXG4gIFtVaW50OEFycmF5LCAndWludDgnXSxcbiAgW0ludDhBcnJheSwgJ2ludDgnXSxcbiAgW1VpbnQxNkFycmF5LCAndWludDE2J10sXG4gIFtJbnQxNkFycmF5LCAnaW50MTYnXSxcbiAgW0ludDMyQXJyYXksICdpbnQzMiddLFxuICBbRmxvYXQ2NEFycmF5LCAnZmxvYXQ2NCddLFxuICBbVWludDMyQXJyYXksICd1aW50MzInXSxcbl0pO1xuXG4vLyBhIGR1bW15IHR5cGUgZGVjbGFyYXRpb24gZm9yIEZsb2F0MTZBcnJheSBpbiBjYXNlIGFueSBwb2x5ZmlsbCBpcyBhdmFpbGFibGUuXG5kZWNsYXJlIGdsb2JhbCB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb24sIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgY29uc3QgRmxvYXQxNkFycmF5OiBhbnk7XG59XG5cbi8vIHRoZSBmb2xsb3dpbmcgY29kZSBhbGxvd3MgZGVsYXlpbmcgZXhlY3V0aW9uIG9mIEJpZ0ludC9GbG9hdDE2QXJyYXkgY2hlY2tpbmcuIFRoaXMgYWxsb3dzIGxhenkgaW5pdGlhbGl6YXRpb24gZm9yXG4vLyBOVU1FUklDX1RFTlNPUl9UWVBFX1RPX1RZUEVEQVJSQVlfTUFQIGFuZCBOVU1FUklDX1RFTlNPUl9UWVBFREFSUkFZX1RPX1RZUEVfTUFQLCB3aGljaCBhbGxvd3MgQmlnSW50L0Zsb2F0MTZBcnJheVxuLy8gcG9seWZpbGwgaWYgYXZhaWxhYmxlLlxubGV0IGlzVHlwZWRBcnJheUNoZWNrZWQgPSBmYWxzZTtcbmV4cG9ydCBjb25zdCBjaGVja1R5cGVkQXJyYXkgPSAoKSA9PiB7XG4gIGlmICghaXNUeXBlZEFycmF5Q2hlY2tlZCkge1xuICAgIGlzVHlwZWRBcnJheUNoZWNrZWQgPSB0cnVlO1xuICAgIGNvbnN0IGlzQmlnSW50NjRBcnJheUF2YWlsYWJsZSA9IHR5cGVvZiBCaWdJbnQ2NEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiBCaWdJbnQ2NEFycmF5LmZyb207XG4gICAgY29uc3QgaXNCaWdVaW50NjRBcnJheUF2YWlsYWJsZSA9IHR5cGVvZiBCaWdVaW50NjRBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgQmlnVWludDY0QXJyYXkuZnJvbTtcbiAgICBjb25zdCBpc0Zsb2F0MTZBcnJheUF2YWlsYWJsZSA9IHR5cGVvZiBGbG9hdDE2QXJyYXkgIT09ICd1bmRlZmluZWQnICYmIEZsb2F0MTZBcnJheS5mcm9tO1xuXG4gICAgaWYgKGlzQmlnSW50NjRBcnJheUF2YWlsYWJsZSkge1xuICAgICAgTlVNRVJJQ19URU5TT1JfVFlQRV9UT19UWVBFREFSUkFZX01BUC5zZXQoJ2ludDY0JywgQmlnSW50NjRBcnJheSk7XG4gICAgICBOVU1FUklDX1RFTlNPUl9UWVBFREFSUkFZX1RPX1RZUEVfTUFQLnNldChCaWdJbnQ2NEFycmF5LCAnaW50NjQnKTtcbiAgICB9XG4gICAgaWYgKGlzQmlnVWludDY0QXJyYXlBdmFpbGFibGUpIHtcbiAgICAgIE5VTUVSSUNfVEVOU09SX1RZUEVfVE9fVFlQRURBUlJBWV9NQVAuc2V0KCd1aW50NjQnLCBCaWdVaW50NjRBcnJheSk7XG4gICAgICBOVU1FUklDX1RFTlNPUl9UWVBFREFSUkFZX1RPX1RZUEVfTUFQLnNldChCaWdVaW50NjRBcnJheSwgJ3VpbnQ2NCcpO1xuICAgIH1cbiAgICBpZiAoaXNGbG9hdDE2QXJyYXlBdmFpbGFibGUpIHtcbiAgICAgIE5VTUVSSUNfVEVOU09SX1RZUEVfVE9fVFlQRURBUlJBWV9NQVAuc2V0KCdmbG9hdDE2JywgRmxvYXQxNkFycmF5KTtcbiAgICAgIE5VTUVSSUNfVEVOU09SX1RZUEVEQVJSQVlfVE9fVFlQRV9NQVAuc2V0KEZsb2F0MTZBcnJheSwgJ2Zsb2F0MTYnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgRmxvYXQxNkFycmF5IGlzIG5vdCBhdmFpbGFibGUsIHVzZSAnVWludDE2QXJyYXknIHRvIHN0b3JlIHRoZSBkYXRhLlxuICAgICAgTlVNRVJJQ19URU5TT1JfVFlQRV9UT19UWVBFREFSUkFZX01BUC5zZXQoJ2Zsb2F0MTYnLCBVaW50MTZBcnJheSk7XG4gICAgfVxuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge1xuICBDcHVQaW5uZWRDb25zdHJ1Y3RvclBhcmFtZXRlcnMsXG4gIEdwdUJ1ZmZlckNvbnN0cnVjdG9yUGFyYW1ldGVycyxcbiAgTUxUZW5zb3JDb25zdHJ1Y3RvclBhcmFtZXRlcnMsXG4gIFRleHR1cmVDb25zdHJ1Y3RvclBhcmFtZXRlcnMsXG59IGZyb20gJy4vdGVuc29yLWZhY3RvcnkuanMnO1xuaW1wb3J0IHsgVGVuc29yIH0gZnJvbSAnLi90ZW5zb3ItaW1wbC5qcyc7XG5cbi8qKlxuICogY2FsY3VsYXRlIHNpemUgZnJvbSBkaW1zLlxuICpcbiAqIEBwYXJhbSBkaW1zIHRoZSBkaW1zIGFycmF5LiBNYXkgYmUgYW4gaWxsZWdhbCBpbnB1dC5cbiAqL1xuZXhwb3J0IGNvbnN0IGNhbGN1bGF0ZVNpemUgPSAoZGltczogcmVhZG9ubHkgdW5rbm93bltdKTogbnVtYmVyID0+IHtcbiAgbGV0IHNpemUgPSAxO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRpbXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBkaW0gPSBkaW1zW2ldO1xuICAgIGlmICh0eXBlb2YgZGltICE9PSAnbnVtYmVyJyB8fCAhTnVtYmVyLmlzU2FmZUludGVnZXIoZGltKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgZGltc1ske2l9XSBtdXN0IGJlIGFuIGludGVnZXIsIGdvdDogJHtkaW19YCk7XG4gICAgfVxuICAgIGlmIChkaW0gPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgZGltc1ske2l9XSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIsIGdvdDogJHtkaW19YCk7XG4gICAgfVxuICAgIHNpemUgKj0gZGltO1xuICB9XG4gIHJldHVybiBzaXplO1xufTtcblxuLyoqXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiBUZW5zb3IucmVzaGFwZSgpXG4gKi9cbmV4cG9ydCBjb25zdCB0ZW5zb3JSZXNoYXBlID0gKHRlbnNvcjogVGVuc29yLCBkaW1zOiByZWFkb25seSBudW1iZXJbXSk6IFRlbnNvciA9PiB7XG4gIHN3aXRjaCAodGVuc29yLmxvY2F0aW9uKSB7XG4gICAgY2FzZSAnY3B1JzpcbiAgICAgIHJldHVybiBuZXcgVGVuc29yKHRlbnNvci50eXBlLCB0ZW5zb3IuZGF0YSwgZGltcyk7XG4gICAgY2FzZSAnY3B1LXBpbm5lZCc6XG4gICAgICByZXR1cm4gbmV3IFRlbnNvcih7XG4gICAgICAgIGxvY2F0aW9uOiAnY3B1LXBpbm5lZCcsXG4gICAgICAgIGRhdGE6IHRlbnNvci5kYXRhIGFzIENwdVBpbm5lZENvbnN0cnVjdG9yUGFyYW1ldGVyc1snZGF0YSddLFxuICAgICAgICB0eXBlOiB0ZW5zb3IudHlwZSBhcyBDcHVQaW5uZWRDb25zdHJ1Y3RvclBhcmFtZXRlcnNbJ3R5cGUnXSxcbiAgICAgICAgZGltcyxcbiAgICAgIH0pO1xuICAgIGNhc2UgJ3RleHR1cmUnOlxuICAgICAgcmV0dXJuIG5ldyBUZW5zb3Ioe1xuICAgICAgICBsb2NhdGlvbjogJ3RleHR1cmUnLFxuICAgICAgICB0ZXh0dXJlOiB0ZW5zb3IudGV4dHVyZSxcbiAgICAgICAgdHlwZTogdGVuc29yLnR5cGUgYXMgVGV4dHVyZUNvbnN0cnVjdG9yUGFyYW1ldGVyc1sndHlwZSddLFxuICAgICAgICBkaW1zLFxuICAgICAgfSk7XG4gICAgY2FzZSAnZ3B1LWJ1ZmZlcic6XG4gICAgICByZXR1cm4gbmV3IFRlbnNvcih7XG4gICAgICAgIGxvY2F0aW9uOiAnZ3B1LWJ1ZmZlcicsXG4gICAgICAgIGdwdUJ1ZmZlcjogdGVuc29yLmdwdUJ1ZmZlcixcbiAgICAgICAgdHlwZTogdGVuc29yLnR5cGUgYXMgR3B1QnVmZmVyQ29uc3RydWN0b3JQYXJhbWV0ZXJzWyd0eXBlJ10sXG4gICAgICAgIGRpbXMsXG4gICAgICB9KTtcbiAgICBjYXNlICdtbC10ZW5zb3InOlxuICAgICAgcmV0dXJuIG5ldyBUZW5zb3Ioe1xuICAgICAgICBsb2NhdGlvbjogJ21sLXRlbnNvcicsXG4gICAgICAgIG1sVGVuc29yOiB0ZW5zb3IubWxUZW5zb3IsXG4gICAgICAgIHR5cGU6IHRlbnNvci50eXBlIGFzIE1MVGVuc29yQ29uc3RydWN0b3JQYXJhbWV0ZXJzWyd0eXBlJ10sXG4gICAgICAgIGRpbXMsXG4gICAgICB9KTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB0ZW5zb3JSZXNoYXBlOiB0ZW5zb3IgbG9jYXRpb24gJHt0ZW5zb3IubG9jYXRpb259IGlzIG5vdCBzdXBwb3J0ZWRgKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgdGVuc29yVG9EYXRhVVJMLCB0ZW5zb3JUb0ltYWdlRGF0YSB9IGZyb20gJy4vdGVuc29yLWNvbnZlcnNpb24taW1wbC5qcyc7XG5pbXBvcnQgeyBUZW5zb3JUb0RhdGFVcmxPcHRpb25zLCBUZW5zb3JUb0ltYWdlRGF0YU9wdGlvbnMgfSBmcm9tICcuL3RlbnNvci1jb252ZXJzaW9uLmpzJztcbmltcG9ydCB7XG4gIHRlbnNvckZyb21HcHVCdWZmZXIsXG4gIHRlbnNvckZyb21JbWFnZSxcbiAgdGVuc29yRnJvbU1MVGVuc29yLFxuICB0ZW5zb3JGcm9tUGlubmVkQnVmZmVyLFxuICB0ZW5zb3JGcm9tVGV4dHVyZSxcbn0gZnJvbSAnLi90ZW5zb3ItZmFjdG9yeS1pbXBsLmpzJztcbmltcG9ydCB7XG4gIENwdVBpbm5lZENvbnN0cnVjdG9yUGFyYW1ldGVycyxcbiAgR3B1QnVmZmVyQ29uc3RydWN0b3JQYXJhbWV0ZXJzLFxuICBNTFRlbnNvckNvbnN0cnVjdG9yUGFyYW1ldGVycyxcbiAgVGVuc29yRnJvbUdwdUJ1ZmZlck9wdGlvbnMsXG4gIFRlbnNvckZyb21JbWFnZUJpdG1hcE9wdGlvbnMsXG4gIFRlbnNvckZyb21JbWFnZURhdGFPcHRpb25zLFxuICBUZW5zb3JGcm9tSW1hZ2VFbGVtZW50T3B0aW9ucyxcbiAgVGVuc29yRnJvbU1MVGVuc29yT3B0aW9ucyxcbiAgVGVuc29yRnJvbVRleHR1cmVPcHRpb25zLFxuICBUZW5zb3JGcm9tVXJsT3B0aW9ucyxcbiAgVGV4dHVyZUNvbnN0cnVjdG9yUGFyYW1ldGVycyxcbn0gZnJvbSAnLi90ZW5zb3ItZmFjdG9yeS5qcyc7XG5pbXBvcnQge1xuICBjaGVja1R5cGVkQXJyYXksXG4gIE5VTUVSSUNfVEVOU09SX1RZUEVfVE9fVFlQRURBUlJBWV9NQVAsXG4gIE5VTUVSSUNfVEVOU09SX1RZUEVEQVJSQVlfVE9fVFlQRV9NQVAsXG4gIFN1cHBvcnRlZFR5cGVkQXJyYXksXG4gIFN1cHBvcnRlZFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnMsXG59IGZyb20gJy4vdGVuc29yLWltcGwtdHlwZS1tYXBwaW5nLmpzJztcbmltcG9ydCB7IGNhbGN1bGF0ZVNpemUsIHRlbnNvclJlc2hhcGUgfSBmcm9tICcuL3RlbnNvci11dGlscy1pbXBsLmpzJztcbmltcG9ydCB7IFRlbnNvciBhcyBUZW5zb3JJbnRlcmZhY2UgfSBmcm9tICcuL3RlbnNvci5qcyc7XG5cbi8vIHR5cGUgYWxpYXNlcyBmb3IgdGhvc2UgZXhwb3J0ZWQgZnJvbSBUZW5zb3IgaW50ZXJmYWNlXG5cbnR5cGUgVGVuc29yVHlwZSA9IFRlbnNvckludGVyZmFjZS5UeXBlO1xudHlwZSBUZW5zb3JEYXRhVHlwZSA9IFRlbnNvckludGVyZmFjZS5EYXRhVHlwZTtcbnR5cGUgVGVuc29yRGF0YUxvY2F0aW9uID0gVGVuc29ySW50ZXJmYWNlLkRhdGFMb2NhdGlvbjtcbnR5cGUgVGVuc29yVGV4dHVyZVR5cGUgPSBUZW5zb3JJbnRlcmZhY2UuVGV4dHVyZVR5cGU7XG50eXBlIFRlbnNvckdwdUJ1ZmZlclR5cGUgPSBUZW5zb3JJbnRlcmZhY2UuR3B1QnVmZmVyVHlwZTtcbnR5cGUgVGVuc29yTUxUZW5zb3JUeXBlID0gVGVuc29ySW50ZXJmYWNlLk1MVGVuc29yVHlwZTtcblxuLyoqXG4gKiB0aGUgaW1wbGVtZW50YXRpb24gb2YgVGVuc29yIGludGVyZmFjZS5cbiAqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBUZW5zb3IgaW1wbGVtZW50cyBUZW5zb3JJbnRlcmZhY2Uge1xuICAvLyAjcmVnaW9uIGNvbnN0cnVjdG9yc1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgQ1BVIHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gdHlwZSwgZGF0YSBhbmQgZGltcy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHR5cGU6IFRlbnNvclR5cGUsXG4gICAgZGF0YTogVGVuc29yRGF0YVR5cGUgfCBVaW50OENsYW1wZWRBcnJheSB8IHJlYWRvbmx5IHN0cmluZ1tdIHwgcmVhZG9ubHkgbnVtYmVyW10gfCByZWFkb25seSBib29sZWFuW10sXG4gICAgZGltcz86IHJlYWRvbmx5IG51bWJlcltdLFxuICApO1xuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IENQVSB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuIFR5cGUgaXMgaW5mZXJyZWQgZnJvbSBkYXRhLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgZGF0YTogVGVuc29yRGF0YVR5cGUgfCBVaW50OENsYW1wZWRBcnJheSB8IHJlYWRvbmx5IHN0cmluZ1tdIHwgcmVhZG9ubHkgYm9vbGVhbltdLFxuICAgIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSxcbiAgKTtcbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIHBpbm5lZCBDUFUgZGF0YSB3aXRoIHRoZSBnaXZlbiB0eXBlIGFuZCBkaW1zLlxuICAgKlxuICAgKiBUZW5zb3IncyBsb2NhdGlvbiB3aWxsIGJlIHNldCB0byAnY3B1LXBpbm5lZCcuXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBTcGVjaWZ5IHRoZSBwYXJhbWV0ZXJzIHRvIGNvbnN0cnVjdCB0aGUgdGVuc29yLlxuICAgKi9cbiAgY29uc3RydWN0b3IocGFyYW1zOiBDcHVQaW5uZWRDb25zdHJ1Y3RvclBhcmFtZXRlcnMpO1xuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgV2ViR0wgdGV4dHVyZSB3aXRoIHRoZSBnaXZlbiB0eXBlIGFuZCBkaW1zLlxuICAgKlxuICAgKiBUZW5zb3IncyBsb2NhdGlvbiB3aWxsIGJlIHNldCB0byAndGV4dHVyZScuXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBTcGVjaWZ5IHRoZSBwYXJhbWV0ZXJzIHRvIGNvbnN0cnVjdCB0aGUgdGVuc29yLlxuICAgKi9cbiAgY29uc3RydWN0b3IocGFyYW1zOiBUZXh0dXJlQ29uc3RydWN0b3JQYXJhbWV0ZXJzKTtcbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIFdlYkdQVSBidWZmZXIgd2l0aCB0aGUgZ2l2ZW4gdHlwZSBhbmQgZGltcy5cbiAgICpcbiAgICogVGVuc29yJ3MgbG9jYXRpb24gd2lsbCBiZSBzZXQgdG8gJ2dwdS1idWZmZXInLlxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zIC0gU3BlY2lmeSB0aGUgcGFyYW1ldGVycyB0byBjb25zdHJ1Y3QgdGhlIHRlbnNvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHBhcmFtczogR3B1QnVmZmVyQ29uc3RydWN0b3JQYXJhbWV0ZXJzKTtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgV2ViTk4gTUxUZW5zb3Igd2l0aCB0aGUgZ2l2ZW4gdHlwZSBhbmQgZGltcy5cbiAgICpcbiAgICogVGVuc29yJ3MgbG9jYXRpb24gd2lsbCBiZSBzZXQgdG8gJ21sLXRlbnNvcicuXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBTcGVjaWZ5IHRoZSBwYXJhbWV0ZXJzIHRvIGNvbnN0cnVjdCB0aGUgdGVuc29yLlxuICAgKi9cbiAgY29uc3RydWN0b3IocGFyYW1zOiBNTFRlbnNvckNvbnN0cnVjdG9yUGFyYW1ldGVycyk7XG5cbiAgLyoqXG4gICAqIGltcGxlbWVudGF0aW9uLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgYXJnMDpcbiAgICAgIHwgVGVuc29yVHlwZVxuICAgICAgfCBUZW5zb3JEYXRhVHlwZVxuICAgICAgfCBVaW50OENsYW1wZWRBcnJheVxuICAgICAgfCByZWFkb25seSBzdHJpbmdbXVxuICAgICAgfCByZWFkb25seSBib29sZWFuW11cbiAgICAgIHwgQ3B1UGlubmVkQ29uc3RydWN0b3JQYXJhbWV0ZXJzXG4gICAgICB8IFRleHR1cmVDb25zdHJ1Y3RvclBhcmFtZXRlcnNcbiAgICAgIHwgR3B1QnVmZmVyQ29uc3RydWN0b3JQYXJhbWV0ZXJzXG4gICAgICB8IE1MVGVuc29yQ29uc3RydWN0b3JQYXJhbWV0ZXJzLFxuICAgIGFyZzE/OiBUZW5zb3JEYXRhVHlwZSB8IFVpbnQ4Q2xhbXBlZEFycmF5IHwgcmVhZG9ubHkgbnVtYmVyW10gfCByZWFkb25seSBzdHJpbmdbXSB8IHJlYWRvbmx5IGJvb2xlYW5bXSxcbiAgICBhcmcyPzogcmVhZG9ubHkgbnVtYmVyW10sXG4gICkge1xuICAgIC8vIHBlcmZvcm0gb25lLXRpbWUgY2hlY2sgZm9yIEJpZ0ludC9GbG9hdDE2QXJyYXkgc3VwcG9ydFxuICAgIGNoZWNrVHlwZWRBcnJheSgpO1xuXG4gICAgbGV0IHR5cGU6IFRlbnNvclR5cGU7XG4gICAgbGV0IGRpbXM6IHJlYWRvbmx5IG51bWJlcltdO1xuXG4gICAgaWYgKHR5cGVvZiBhcmcwID09PSAnb2JqZWN0JyAmJiAnbG9jYXRpb24nIGluIGFyZzApIHtcbiAgICAgIC8vXG4gICAgICAvLyBjb25zdHJ1Y3RpbmcgdGVuc29yIGZyb20gc3BlY2lmaWMgbG9jYXRpb25cbiAgICAgIC8vXG4gICAgICB0aGlzLmRhdGFMb2NhdGlvbiA9IGFyZzAubG9jYXRpb247XG4gICAgICB0eXBlID0gYXJnMC50eXBlO1xuICAgICAgZGltcyA9IGFyZzAuZGltcztcbiAgICAgIHN3aXRjaCAoYXJnMC5sb2NhdGlvbikge1xuICAgICAgICBjYXNlICdjcHUtcGlubmVkJzoge1xuICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gTlVNRVJJQ19URU5TT1JfVFlQRV9UT19UWVBFREFSUkFZX01BUC5nZXQodHlwZSk7XG4gICAgICAgICAgaWYgKCFleHBlY3RlZFR5cGVkQXJyYXlDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZSBcIiR7dHlwZX1cIiB0byBjcmVhdGUgdGVuc29yIGZyb20gcGlubmVkIGJ1ZmZlcmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIShhcmcwLmRhdGEgaW5zdGFuY2VvZiBleHBlY3RlZFR5cGVkQXJyYXlDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGJ1ZmZlciBzaG91bGQgYmUgb2YgdHlwZSAke2V4cGVjdGVkVHlwZWRBcnJheUNvbnN0cnVjdG9yLm5hbWV9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuY3B1RGF0YSA9IGFyZzAuZGF0YTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICd0ZXh0dXJlJzoge1xuICAgICAgICAgIGlmICh0eXBlICE9PSAnZmxvYXQzMicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHVuc3VwcG9ydGVkIHR5cGUgXCIke3R5cGV9XCIgdG8gY3JlYXRlIHRlbnNvciBmcm9tIHRleHR1cmVgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5ncHVUZXh0dXJlRGF0YSA9IGFyZzAudGV4dHVyZTtcbiAgICAgICAgICB0aGlzLmRvd25sb2FkZXIgPSBhcmcwLmRvd25sb2FkO1xuICAgICAgICAgIHRoaXMuZGlzcG9zZXIgPSBhcmcwLmRpc3Bvc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnZ3B1LWJ1ZmZlcic6IHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICB0eXBlICE9PSAnZmxvYXQzMicgJiZcbiAgICAgICAgICAgIHR5cGUgIT09ICdmbG9hdDE2JyAmJlxuICAgICAgICAgICAgdHlwZSAhPT0gJ2ludDMyJyAmJlxuICAgICAgICAgICAgdHlwZSAhPT0gJ2ludDY0JyAmJlxuICAgICAgICAgICAgdHlwZSAhPT0gJ3VpbnQzMicgJiZcbiAgICAgICAgICAgIHR5cGUgIT09ICd1aW50OCcgJiZcbiAgICAgICAgICAgIHR5cGUgIT09ICdib29sJyAmJlxuICAgICAgICAgICAgdHlwZSAhPT0gJ3VpbnQ0JyAmJlxuICAgICAgICAgICAgdHlwZSAhPT0gJ2ludDQnXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB1bnN1cHBvcnRlZCB0eXBlIFwiJHt0eXBlfVwiIHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbSBncHUgYnVmZmVyYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZ3B1QnVmZmVyRGF0YSA9IGFyZzAuZ3B1QnVmZmVyO1xuICAgICAgICAgIHRoaXMuZG93bmxvYWRlciA9IGFyZzAuZG93bmxvYWQ7XG4gICAgICAgICAgdGhpcy5kaXNwb3NlciA9IGFyZzAuZGlzcG9zZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdtbC10ZW5zb3InOiB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgdHlwZSAhPT0gJ2Zsb2F0MzInICYmXG4gICAgICAgICAgICB0eXBlICE9PSAnZmxvYXQxNicgJiZcbiAgICAgICAgICAgIHR5cGUgIT09ICdpbnQzMicgJiZcbiAgICAgICAgICAgIHR5cGUgIT09ICdpbnQ2NCcgJiZcbiAgICAgICAgICAgIHR5cGUgIT09ICd1aW50MzInICYmXG4gICAgICAgICAgICB0eXBlICE9PSAndWludDY0JyAmJlxuICAgICAgICAgICAgdHlwZSAhPT0gJ2ludDgnICYmXG4gICAgICAgICAgICB0eXBlICE9PSAndWludDgnICYmXG4gICAgICAgICAgICB0eXBlICE9PSAnYm9vbCcgJiZcbiAgICAgICAgICAgIHR5cGUgIT09ICd1aW50NCcgJiZcbiAgICAgICAgICAgIHR5cGUgIT09ICdpbnQ0J1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZSBcIiR7dHlwZX1cIiB0byBjcmVhdGUgdGVuc29yIGZyb20gTUxUZW5zb3JgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5tbFRlbnNvckRhdGEgPSBhcmcwLm1sVGVuc29yO1xuICAgICAgICAgIHRoaXMuZG93bmxvYWRlciA9IGFyZzAuZG93bmxvYWQ7XG4gICAgICAgICAgdGhpcy5kaXNwb3NlciA9IGFyZzAuZGlzcG9zZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGVuc29yIGNvbnN0cnVjdG9yOiB1bnN1cHBvcnRlZCBsb2NhdGlvbiAnJHt0aGlzLmRhdGFMb2NhdGlvbn0nYCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vXG4gICAgICAvLyBjb25zdHJ1Y3RpbmcgdGVuc29yIG9mIGxvY2F0aW9uICdjcHUnXG4gICAgICAvL1xuICAgICAgbGV0IGRhdGE6IFRlbnNvckRhdGFUeXBlO1xuICAgICAgbGV0IG1heWJlRGltczogdHlwZW9mIGFyZzEgfCB0eXBlb2YgYXJnMjtcbiAgICAgIC8vIGNoZWNrIHdoZXRoZXIgYXJnMCBpcyB0eXBlIG9yIGRhdGFcbiAgICAgIGlmICh0eXBlb2YgYXJnMCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gT3ZlcnJpZGU6IGNvbnN0cnVjdG9yKHR5cGUsIGRhdGEsIC4uLilcbiAgICAgICAgLy9cbiAgICAgICAgdHlwZSA9IGFyZzA7XG4gICAgICAgIG1heWJlRGltcyA9IGFyZzI7XG4gICAgICAgIGlmIChhcmcwID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIC8vIHN0cmluZyB0ZW5zb3JcbiAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJnMSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBIHN0cmluZyB0ZW5zb3IncyBkYXRhIG11c3QgYmUgYSBzdHJpbmcgYXJyYXkuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB3ZSBkb24ndCBjaGVjayB3aGV0aGVyIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIGFycmF5IGlzIHN0cmluZzsgdGhpcyBpcyB0b28gc2xvdy4gd2UgYXNzdW1lIGl0J3MgY29ycmVjdCBhbmRcbiAgICAgICAgICAvLyBlcnJvciB3aWxsIGJlIHBvcHVsYXRlZCBhdCBpbmZlcmVuY2VcbiAgICAgICAgICBkYXRhID0gYXJnMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBudW1lcmljIHRlbnNvclxuICAgICAgICAgIGNvbnN0IHR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IE5VTUVSSUNfVEVOU09SX1RZUEVfVE9fVFlQRURBUlJBWV9NQVAuZ2V0KGFyZzApO1xuICAgICAgICAgIGlmICh0eXBlZEFycmF5Q29uc3RydWN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVW5zdXBwb3J0ZWQgdGVuc29yIHR5cGU6ICR7YXJnMH0uYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZzEpKSB7XG4gICAgICAgICAgICBpZiAoKGFyZzAgPT09ICdmbG9hdDE2JyAmJiB0eXBlZEFycmF5Q29uc3RydWN0b3IgPT09IFVpbnQxNkFycmF5KSB8fCBhcmcwID09PSAndWludDQnIHx8IGFyZzAgPT09ICdpbnQ0Jykge1xuICAgICAgICAgICAgICAvLyAtICdmbG9hdDE2JzpcbiAgICAgICAgICAgICAgLy8gICBXaGVuIG5vIEZsb2F0MTZBcnJheSBwb2x5ZmlsbCBpcyB1c2VkLCB3ZSBjYW5ub3QgY3JlYXRlICdmbG9hdDE2JyB0ZW5zb3IgZnJvbSBudW1iZXIgYXJyYXkuXG4gICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgIC8vICAgVGhyb3cgZXJyb3IgaGVyZSBiZWNhdXNlIHdoZW4gdXNlciB0cnkgdG8gdXNlIG51bWJlciBhcnJheSBhcyBkYXRhLFxuICAgICAgICAgICAgICAvLyAgIGUuZy4gbmV3IFRlbnNvcignZmxvYXQxNicsIFsxLCAyLCAzLCA0XSwgZGltcykpLCBpdCB3aWxsIGFjdHVhbGx5IGNhbGxcbiAgICAgICAgICAgICAgLy8gICBVaW50MTZBcnJheS5mcm9tKGFyZzEpIHdoaWNoIGdlbmVyYXRlcyB3cm9uZyBkYXRhLlxuICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAvLyAtICd1aW50NCcgYW5kICdpbnQ0JzpcbiAgICAgICAgICAgICAgLy8gICBVaW50OEFycmF5LmZyb20oYXJnMSkgd2lsbCBnZW5lcmF0ZSB3cm9uZyBkYXRhIGZvciAndWludDQnIGFuZCAnaW50NCcgdGVuc29yLlxuICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgIGBDcmVhdGluZyBhICR7YXJnMH0gdGVuc29yIGZyb20gbnVtYmVyIGFycmF5IGlzIG5vdCBzdXBwb3J0ZWQuIFBsZWFzZSB1c2UgJHt0eXBlZEFycmF5Q29uc3RydWN0b3IubmFtZX0gYXMgZGF0YS5gLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhcmcwID09PSAndWludDY0JyB8fCBhcmcwID09PSAnaW50NjQnKSB7XG4gICAgICAgICAgICAgIC8vIHVzZSAnYXMgYW55JyBoZXJlIGJlY2F1c2U6XG4gICAgICAgICAgICAgIC8vIDEuIFR5cGVTY3JpcHQncyBjaGVjayBvbiB0eXBlIG9mICdBcnJheS5pc0FycmF5KCknIGRvZXMgbm90IHdvcmsgd2l0aCByZWFkb25seSBhcnJheXMuXG4gICAgICAgICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzE3MDAyXG4gICAgICAgICAgICAgIC8vIDIuIFR5cGVTY3JpcHQncyBjaGVjayBvbiB1bmlvbiB0eXBlIG9mICcoQmlnSW50NjRBcnJheUNvbnN0cnVjdG9yfEJpZ1VpbnQ2NEFycmF5Q29uc3RydWN0b3IpLmZyb20oKSdcbiAgICAgICAgICAgICAgLy8gZG9lcyBub3QgYWNjZXB0IHBhcmFtZXRlciBtYXBGbi5cbiAgICAgICAgICAgICAgLy8gMy4gcGFyYW1ldGVycyBvZiAnU3VwcG9ydGVkVHlwZWRBcnJheUNvbnN0cnVjdG9ycy5mcm9tKCknIGRvZXMgbm90IG1hdGNoIHRoZSByZXF1aXJlbWVudCBvZiB0aGUgdW5pb25cbiAgICAgICAgICAgICAgLy8gdHlwZS5cblxuICAgICAgICAgICAgICAvLyBhc3N1bWUgJ2FyZzEnIGlzIG9mIHR5cGUgXCJyZWFkb25seSBudW1iZXJbXXxyZWFkb25seSBiaWdpbnRbXVwiIGhlcmUuXG5cbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgZGF0YSA9ICh0eXBlZEFycmF5Q29uc3RydWN0b3IgYXMgYW55KS5mcm9tKGFyZzEsIEJpZ0ludCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBhc3N1bWUgJ2FyZzEnIGlzIG9mIHR5cGUgXCJyZWFkb25seSBudW1iZXJbXVwiIGhlcmUuXG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgIGRhdGEgPSAodHlwZWRBcnJheUNvbnN0cnVjdG9yIGFzIGFueSkuZnJvbShhcmcxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGFyZzEgaW5zdGFuY2VvZiB0eXBlZEFycmF5Q29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGRhdGEgPSBhcmcxO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYXJnMSBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5KSB7XG4gICAgICAgICAgICBpZiAoYXJnMCA9PT0gJ3VpbnQ4Jykge1xuICAgICAgICAgICAgICBkYXRhID0gVWludDhBcnJheS5mcm9tKGFyZzEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQSBVaW50OENsYW1wZWRBcnJheSB0ZW5zb3IncyBkYXRhIG11c3QgYmUgdHlwZSBvZiB1aW50OGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBBICR7dHlwZX0gdGVuc29yJ3MgZGF0YSBtdXN0IGJlIHR5cGUgb2YgJHt0eXBlZEFycmF5Q29uc3RydWN0b3J9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvL1xuICAgICAgICAvLyBPdmVycmlkZTogY29uc3RydWN0b3IoZGF0YSwgLi4uKVxuICAgICAgICAvL1xuICAgICAgICBtYXliZURpbXMgPSBhcmcxO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcwKSkge1xuICAgICAgICAgIC8vIG9ubHkgYm9vbGVhbltdIGFuZCBzdHJpbmdbXSBpcyBzdXBwb3J0ZWRcbiAgICAgICAgICBpZiAoYXJnMC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RlbnNvciB0eXBlIGNhbm5vdCBiZSBpbmZlcnJlZCBmcm9tIGFuIGVtcHR5IGFycmF5LicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBmaXJzdEVsZW1lbnRUeXBlID0gdHlwZW9mIGFyZzBbMF07XG4gICAgICAgICAgaWYgKGZpcnN0RWxlbWVudFR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0eXBlID0gJ3N0cmluZyc7XG4gICAgICAgICAgICBkYXRhID0gYXJnMDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGZpcnN0RWxlbWVudFR5cGUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgdHlwZSA9ICdib29sJztcbiAgICAgICAgICAgIC8vICdhcmcwJyBpcyBvZiB0eXBlICdib29sZWFuW10nLiBVaW50OEFycmF5LmZyb20oYm9vbGVhbltdKSBhY3R1YWxseSB3b3JrcywgYnV0IHR5cGVzY3JpcHQgdGhpbmtzIHRoaXMgaXNcbiAgICAgICAgICAgIC8vIHdyb25nIHR5cGUuIFdlIHVzZSAnYXMgYW55JyB0byBtYWtlIGl0IGhhcHB5LlxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIGRhdGEgPSBVaW50OEFycmF5LmZyb20oYXJnMCBhcyBhbnlbXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgZWxlbWVudCB0eXBlIG9mIGRhdGEgYXJyYXk6ICR7Zmlyc3RFbGVtZW50VHlwZX0uYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGFyZzAgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSkge1xuICAgICAgICAgIHR5cGUgPSAndWludDgnO1xuICAgICAgICAgIGRhdGEgPSBVaW50OEFycmF5LmZyb20oYXJnMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZ2V0IHRlbnNvciB0eXBlIGZyb20gVHlwZWRBcnJheVxuICAgICAgICAgIGNvbnN0IG1hcHBlZFR5cGUgPSBOVU1FUklDX1RFTlNPUl9UWVBFREFSUkFZX1RPX1RZUEVfTUFQLmdldChcbiAgICAgICAgICAgIGFyZzAuY29uc3RydWN0b3IgYXMgU3VwcG9ydGVkVHlwZWRBcnJheUNvbnN0cnVjdG9ycyxcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChtYXBwZWRUeXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFVuc3VwcG9ydGVkIHR5cGUgZm9yIHRlbnNvciBkYXRhOiAke2FyZzAuY29uc3RydWN0b3J9LmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0eXBlID0gbWFwcGVkVHlwZTtcbiAgICAgICAgICBkYXRhID0gYXJnMCBhcyBTdXBwb3J0ZWRUeXBlZEFycmF5O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHR5cGUgYW5kIGRhdGEgaXMgcHJvY2Vzc2VkLCBub3cgcHJvY2Vzc2luZyBkaW1zXG4gICAgICBpZiAobWF5YmVEaW1zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gYXNzdW1lIDEtRCB0ZW5zb3IgaWYgZGltcyBvbWl0dGVkXG4gICAgICAgIG1heWJlRGltcyA9IFtkYXRhLmxlbmd0aF07XG4gICAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KG1heWJlRGltcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkEgdGVuc29yJ3MgZGltcyBtdXN0IGJlIGEgbnVtYmVyIGFycmF5XCIpO1xuICAgICAgfVxuICAgICAgZGltcyA9IG1heWJlRGltcyBhcyByZWFkb25seSBudW1iZXJbXTtcblxuICAgICAgdGhpcy5jcHVEYXRhID0gZGF0YTtcbiAgICAgIHRoaXMuZGF0YUxvY2F0aW9uID0gJ2NwdSc7XG4gICAgfVxuXG4gICAgLy8gcGVyZm9ybSBjaGVjayBvbiBkaW1zXG4gICAgY29uc3Qgc2l6ZSA9IGNhbGN1bGF0ZVNpemUoZGltcyk7XG4gICAgLy8gaWYgZGF0YSBpcyBvbiBDUFUsIGNoZWNrIHdoZXRoZXIgZGF0YSBsZW5ndGggbWF0Y2hlcyB0ZW5zb3Igc2l6ZVxuICAgIGlmICh0aGlzLmNwdURhdGEgJiYgc2l6ZSAhPT0gdGhpcy5jcHVEYXRhLmxlbmd0aCkge1xuICAgICAgaWYgKCh0eXBlID09PSAndWludDQnIHx8IHR5cGUgPT09ICdpbnQ0JykgJiYgTWF0aC5jZWlsKHNpemUgLyAyKSA9PT0gdGhpcy5jcHVEYXRhLmxlbmd0aCkge1xuICAgICAgICAvLyBmb3IgKHUpaW50NCwgdGhlIGRhdGEgbGVuZ3RoIGlzIGhhbGYgb2YgdGhlIHRlbnNvciBzaXplLiBTbyB3ZSBjaGVjayB0aGlzIHNwZWNpYWwgY2FzZSB3aGVuIHNpemUgaXMgb2RkLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUZW5zb3IncyBzaXplKCR7c2l6ZX0pIGRvZXMgbm90IG1hdGNoIGRhdGEgbGVuZ3RoKCR7dGhpcy5jcHVEYXRhLmxlbmd0aH0pLmApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5kaW1zID0gZGltcztcbiAgICB0aGlzLnNpemUgPSBzaXplO1xuICB9XG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIGZhY3RvcnlcbiAgc3RhdGljIGFzeW5jIGZyb21JbWFnZShcbiAgICBpbWFnZTogSW1hZ2VEYXRhIHwgSFRNTEltYWdlRWxlbWVudCB8IEltYWdlQml0bWFwIHwgc3RyaW5nLFxuICAgIG9wdGlvbnM/OlxuICAgICAgfCBUZW5zb3JGcm9tSW1hZ2VEYXRhT3B0aW9uc1xuICAgICAgfCBUZW5zb3JGcm9tSW1hZ2VFbGVtZW50T3B0aW9uc1xuICAgICAgfCBUZW5zb3JGcm9tSW1hZ2VCaXRtYXBPcHRpb25zXG4gICAgICB8IFRlbnNvckZyb21VcmxPcHRpb25zLFxuICApOiBQcm9taXNlPFRlbnNvckludGVyZmFjZT4ge1xuICAgIHJldHVybiB0ZW5zb3JGcm9tSW1hZ2UoaW1hZ2UsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21UZXh0dXJlPFQgZXh0ZW5kcyBUZW5zb3JJbnRlcmZhY2UuVGV4dHVyZURhdGFUeXBlcz4oXG4gICAgdGV4dHVyZTogVGVuc29yVGV4dHVyZVR5cGUsXG4gICAgb3B0aW9uczogVGVuc29yRnJvbVRleHR1cmVPcHRpb25zPFQ+LFxuICApOiBUZW5zb3JJbnRlcmZhY2Uge1xuICAgIHJldHVybiB0ZW5zb3JGcm9tVGV4dHVyZSh0ZXh0dXJlLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tR3B1QnVmZmVyPFQgZXh0ZW5kcyBUZW5zb3JJbnRlcmZhY2UuR3B1QnVmZmVyRGF0YVR5cGVzPihcbiAgICBncHVCdWZmZXI6IFRlbnNvckdwdUJ1ZmZlclR5cGUsXG4gICAgb3B0aW9uczogVGVuc29yRnJvbUdwdUJ1ZmZlck9wdGlvbnM8VD4sXG4gICk6IFRlbnNvckludGVyZmFjZSB7XG4gICAgcmV0dXJuIHRlbnNvckZyb21HcHVCdWZmZXIoZ3B1QnVmZmVyLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tTUxUZW5zb3I8VCBleHRlbmRzIFRlbnNvckludGVyZmFjZS5NTFRlbnNvckRhdGFUeXBlcz4oXG4gICAgbWxUZW5zb3I6IFRlbnNvck1MVGVuc29yVHlwZSxcbiAgICBvcHRpb25zOiBUZW5zb3JGcm9tTUxUZW5zb3JPcHRpb25zPFQ+LFxuICApOiBUZW5zb3JJbnRlcmZhY2Uge1xuICAgIHJldHVybiB0ZW5zb3JGcm9tTUxUZW5zb3IobWxUZW5zb3IsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21QaW5uZWRCdWZmZXI8VCBleHRlbmRzIFRlbnNvckludGVyZmFjZS5DcHVQaW5uZWREYXRhVHlwZXM+KFxuICAgIHR5cGU6IFQsXG4gICAgYnVmZmVyOiBUZW5zb3JJbnRlcmZhY2UuRGF0YVR5cGVNYXBbVF0sXG4gICAgZGltcz86IHJlYWRvbmx5IG51bWJlcltdLFxuICApOiBUZW5zb3Ige1xuICAgIHJldHVybiB0ZW5zb3JGcm9tUGlubmVkQnVmZmVyKHR5cGUsIGJ1ZmZlciwgZGltcyk7XG4gIH1cblxuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiBjb252ZXJzaW9uc1xuICB0b0RhdGFVUkwob3B0aW9ucz86IFRlbnNvclRvRGF0YVVybE9wdGlvbnMpOiBzdHJpbmcge1xuICAgIHJldHVybiB0ZW5zb3JUb0RhdGFVUkwodGhpcywgb3B0aW9ucyk7XG4gIH1cblxuICB0b0ltYWdlRGF0YShvcHRpb25zPzogVGVuc29yVG9JbWFnZURhdGFPcHRpb25zKTogSW1hZ2VEYXRhIHtcbiAgICByZXR1cm4gdGVuc29yVG9JbWFnZURhdGEodGhpcywgb3B0aW9ucyk7XG4gIH1cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gcHVibGljIGZpZWxkc1xuICByZWFkb25seSBkaW1zOiByZWFkb25seSBudW1iZXJbXTtcbiAgcmVhZG9ubHkgdHlwZTogVGVuc29yVHlwZTtcbiAgcmVhZG9ubHkgc2l6ZTogbnVtYmVyO1xuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiBwcml2YXRlIGZpZWxkc1xuXG4gIC8qKlxuICAgKiBzdG9yZXMgdGhlIGxvY2F0aW9uIG9mIHRoZSBkYXRhLlxuICAgKi9cbiAgcHJpdmF0ZSBkYXRhTG9jYXRpb246IFRlbnNvckRhdGFMb2NhdGlvbjtcblxuICAvKipcbiAgICogc3RvcmVzIHRoZSBkYXRhIG9uIENQVSwgaWYgbG9jYXRpb24gaXMgJ2NwdScgb3IgJ2NwdS1waW5uZWQnLiBvdGhlcndpc2UgZW1wdHkuXG4gICAqL1xuICBwcml2YXRlIGNwdURhdGE/OiBUZW5zb3JEYXRhVHlwZTtcblxuICAvKipcbiAgICogc3RvcmVzIHRoZSB1bmRlcmx5aW5nIHRleHR1cmUgd2hlbiBsb2NhdGlvbiBpcyAndGV4dHVyZScuIG90aGVyd2lzZSBlbXB0eS5cbiAgICovXG4gIHByaXZhdGUgZ3B1VGV4dHVyZURhdGE/OiBUZW5zb3JUZXh0dXJlVHlwZTtcblxuICAvKipcbiAgICogc3RvcmVzIHRoZSB1bmRlcmx5aW5nIEdQVSBidWZmZXIgd2hlbiBsb2NhdGlvbiBpcyAnZ3B1LWJ1ZmZlcicuIG90aGVyd2lzZSBlbXB0eS5cbiAgICovXG4gIHByaXZhdGUgZ3B1QnVmZmVyRGF0YT86IFRlbnNvckdwdUJ1ZmZlclR5cGU7XG5cbiAgLyoqXG4gICAqIHN0b3JlcyB0aGUgdW5kZXJseWluZyBXZWJOTiBNTFRlbnNvciB3aGVuIGxvY2F0aW9uIGlzICdtbC10ZW5zb3InLiBvdGhlcndpc2UgZW1wdHkuXG4gICAqL1xuICBwcml2YXRlIG1sVGVuc29yRGF0YT86IFRlbnNvck1MVGVuc29yVHlwZTtcblxuICAvKipcbiAgICogc3RvcmVzIGFuIG9wdGlvbmFsIGRvd25sb2FkZXIgZnVuY3Rpb24gdG8gZG93bmxvYWQgZGF0YSBmcm9tIEdQVSB0byBDUFUuXG4gICAqL1xuICBwcml2YXRlIGRvd25sb2FkZXI/KCk6IFByb21pc2U8VGVuc29yRGF0YVR5cGU+O1xuXG4gIC8qKlxuICAgKiBhIGZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBkYXRhIGlzIGJlaW5nIGRvd25sb2FkZWQgZnJvbSBHUFUgdG8gQ1BVLlxuICAgKi9cbiAgcHJpdmF0ZSBpc0Rvd25sb2FkaW5nPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogc3RvcmVzIGFuIG9wdGlvbmFsIGRpc3Bvc2VyIGZ1bmN0aW9uIHRvIGRpc3Bvc2UgdGhlIHVuZGVybHlpbmcgZGF0YS5cbiAgICovXG4gIHByaXZhdGUgZGlzcG9zZXI/KCk6IHZvaWQ7XG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIHByb3BlcnRpZXNcbiAgZ2V0IGRhdGEoKTogVGVuc29yRGF0YVR5cGUge1xuICAgIHRoaXMuZW5zdXJlVmFsaWQoKTtcbiAgICBpZiAoIXRoaXMuY3B1RGF0YSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnVGhlIGRhdGEgaXMgbm90IG9uIENQVS4gVXNlIGBnZXREYXRhKClgIHRvIGRvd25sb2FkIEdQVSBkYXRhIHRvIENQVSwgJyArXG4gICAgICAgICAgJ29yIHVzZSBgdGV4dHVyZWAgb3IgYGdwdUJ1ZmZlcmAgcHJvcGVydHkgdG8gYWNjZXNzIHRoZSBHUFUgZGF0YSBkaXJlY3RseS4nLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY3B1RGF0YTtcbiAgfVxuXG4gIGdldCBsb2NhdGlvbigpOiBUZW5zb3JEYXRhTG9jYXRpb24ge1xuICAgIHJldHVybiB0aGlzLmRhdGFMb2NhdGlvbjtcbiAgfVxuXG4gIGdldCB0ZXh0dXJlKCk6IFRlbnNvclRleHR1cmVUeXBlIHtcbiAgICB0aGlzLmVuc3VyZVZhbGlkKCk7XG4gICAgaWYgKCF0aGlzLmdwdVRleHR1cmVEYXRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBkYXRhIGlzIG5vdCBzdG9yZWQgYXMgYSBXZWJHTCB0ZXh0dXJlLicpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5ncHVUZXh0dXJlRGF0YTtcbiAgfVxuXG4gIGdldCBncHVCdWZmZXIoKTogVGVuc29yR3B1QnVmZmVyVHlwZSB7XG4gICAgdGhpcy5lbnN1cmVWYWxpZCgpO1xuICAgIGlmICghdGhpcy5ncHVCdWZmZXJEYXRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBkYXRhIGlzIG5vdCBzdG9yZWQgYXMgYSBXZWJHUFUgYnVmZmVyLicpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5ncHVCdWZmZXJEYXRhO1xuICB9XG5cbiAgZ2V0IG1sVGVuc29yKCk6IFRlbnNvck1MVGVuc29yVHlwZSB7XG4gICAgdGhpcy5lbnN1cmVWYWxpZCgpO1xuICAgIGlmICghdGhpcy5tbFRlbnNvckRhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGRhdGEgaXMgbm90IHN0b3JlZCBhcyBhIFdlYk5OIE1MVGVuc29yLicpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5tbFRlbnNvckRhdGE7XG4gIH1cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gbWV0aG9kc1xuXG4gIGFzeW5jIGdldERhdGEocmVsZWFzZURhdGE/OiBib29sZWFuKTogUHJvbWlzZTxUZW5zb3JEYXRhVHlwZT4ge1xuICAgIHRoaXMuZW5zdXJlVmFsaWQoKTtcbiAgICBzd2l0Y2ggKHRoaXMuZGF0YUxvY2F0aW9uKSB7XG4gICAgICBjYXNlICdjcHUnOlxuICAgICAgY2FzZSAnY3B1LXBpbm5lZCc6XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGE7XG4gICAgICBjYXNlICd0ZXh0dXJlJzpcbiAgICAgIGNhc2UgJ2dwdS1idWZmZXInOlxuICAgICAgY2FzZSAnbWwtdGVuc29yJzoge1xuICAgICAgICBpZiAoIXRoaXMuZG93bmxvYWRlcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGN1cnJlbnQgdGVuc29yIGlzIG5vdCBjcmVhdGVkIHdpdGggYSBzcGVjaWZpZWQgZGF0YSBkb3dubG9hZGVyLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzRG93bmxvYWRpbmcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBjdXJyZW50IHRlbnNvciBpcyBiZWluZyBkb3dubG9hZGVkLicpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5pc0Rvd25sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5kb3dubG9hZGVyKCk7XG4gICAgICAgICAgdGhpcy5kb3dubG9hZGVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHRoaXMuZGF0YUxvY2F0aW9uID0gJ2NwdSc7XG4gICAgICAgICAgdGhpcy5jcHVEYXRhID0gZGF0YTtcblxuICAgICAgICAgIGlmIChyZWxlYXNlRGF0YSAmJiB0aGlzLmRpc3Bvc2VyKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2VyKCk7XG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2VyID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRoaXMuaXNEb3dubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBnZXQgZGF0YSBmcm9tIGxvY2F0aW9uOiAke3RoaXMuZGF0YUxvY2F0aW9ufWApO1xuICAgIH1cbiAgfVxuXG4gIGRpc3Bvc2UoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaXNEb3dubG9hZGluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgY3VycmVudCB0ZW5zb3IgaXMgYmVpbmcgZG93bmxvYWRlZC4nKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5kaXNwb3Nlcikge1xuICAgICAgdGhpcy5kaXNwb3NlcigpO1xuICAgICAgdGhpcy5kaXNwb3NlciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdGhpcy5jcHVEYXRhID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZ3B1VGV4dHVyZURhdGEgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ncHVCdWZmZXJEYXRhID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWxUZW5zb3JEYXRhID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZG93bmxvYWRlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmlzRG93bmxvYWRpbmcgPSB1bmRlZmluZWQ7XG5cbiAgICB0aGlzLmRhdGFMb2NhdGlvbiA9ICdub25lJztcbiAgfVxuXG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIHRlbnNvciB1dGlsaXRpZXNcbiAgcHJpdmF0ZSBlbnN1cmVWYWxpZCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5kYXRhTG9jYXRpb24gPT09ICdub25lJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgdGVuc29yIGlzIGRpc3Bvc2VkLicpO1xuICAgIH1cbiAgfVxuXG4gIHJlc2hhcGUoZGltczogcmVhZG9ubHkgbnVtYmVyW10pOiBUZW5zb3JJbnRlcmZhY2Uge1xuICAgIHRoaXMuZW5zdXJlVmFsaWQoKTtcbiAgICBpZiAodGhpcy5kb3dubG9hZGVyIHx8IHRoaXMuZGlzcG9zZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlc2hhcGUgYSB0ZW5zb3IgdGhhdCBvd25zIEdQVSByZXNvdXJjZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRlbnNvclJlc2hhcGUodGhpcywgZGltcyk7XG4gIH1cbiAgLy8gI2VuZHJlZ2lvblxufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBUZW5zb3JGYWN0b3J5IH0gZnJvbSAnLi90ZW5zb3ItZmFjdG9yeS5qcyc7XG5pbXBvcnQgeyBUZW5zb3IgYXMgVGVuc29ySW1wbCB9IGZyb20gJy4vdGVuc29yLWltcGwuanMnO1xuaW1wb3J0IHsgVHlwZWRUZW5zb3JVdGlscyB9IGZyb20gJy4vdGVuc29yLXV0aWxzLmpzJztcblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlZGVjbGFyZSAqL1xuXG4vKipcbiAqIHJlcHJlc2VudCBhIGJhc2ljIHRlbnNvciB3aXRoIHNwZWNpZmllZCBkaW1lbnNpb25zIGFuZCBkYXRhIHR5cGUuXG4gKi9cbmludGVyZmFjZSBUeXBlZFRlbnNvckJhc2U8VCBleHRlbmRzIFRlbnNvci5UeXBlPiB7XG4gIC8qKlxuICAgKiBHZXQgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIHRlbnNvci5cbiAgICovXG4gIHJlYWRvbmx5IGRpbXM6IHJlYWRvbmx5IG51bWJlcltdO1xuICAvKipcbiAgICogR2V0IHRoZSBkYXRhIHR5cGUgb2YgdGhlIHRlbnNvci5cbiAgICovXG4gIHJlYWRvbmx5IHR5cGU6IFQ7XG4gIC8qKlxuICAgKiBHZXQgdGhlIGJ1ZmZlciBkYXRhIG9mIHRoZSB0ZW5zb3IuXG4gICAqXG4gICAqIElmIHRoZSBkYXRhIGlzIG5vdCBvbiBDUFUgKGVnLiBpdCdzIGluIHRoZSBmb3JtIG9mIFdlYkdMIHRleHR1cmUgb3IgV2ViR1BVIGJ1ZmZlciksIHRocm93IGVycm9yLlxuICAgKi9cbiAgcmVhZG9ubHkgZGF0YTogVGVuc29yLkRhdGFUeXBlTWFwW1RdO1xuICAvKipcbiAgICogR2V0IHRoZSBsb2NhdGlvbiBvZiB0aGUgZGF0YS5cbiAgICovXG4gIHJlYWRvbmx5IGxvY2F0aW9uOiBUZW5zb3IuRGF0YUxvY2F0aW9uO1xuICAvKipcbiAgICogR2V0IHRoZSBXZWJHTCB0ZXh0dXJlIHRoYXQgaG9sZHMgdGhlIHRlbnNvciBkYXRhLlxuICAgKlxuICAgKiBJZiB0aGUgZGF0YSBpcyBub3Qgb24gR1BVIGFzIFdlYkdMIHRleHR1cmUsIHRocm93IGVycm9yLlxuICAgKi9cbiAgcmVhZG9ubHkgdGV4dHVyZTogVGVuc29yLlRleHR1cmVUeXBlO1xuICAvKipcbiAgICogR2V0IHRoZSBXZWJHUFUgYnVmZmVyIHRoYXQgaG9sZHMgdGhlIHRlbnNvciBkYXRhLlxuICAgKlxuICAgKiBJZiB0aGUgZGF0YSBpcyBub3Qgb24gR1BVIGFzIFdlYkdQVSBidWZmZXIsIHRocm93IGVycm9yLlxuICAgKi9cbiAgcmVhZG9ubHkgZ3B1QnVmZmVyOiBUZW5zb3IuR3B1QnVmZmVyVHlwZTtcblxuICAvKipcbiAgICogR2V0IHRoZSBXZWJOTiBNTFRlbnNvciB0aGF0IGhvbGRzIHRoZSB0ZW5zb3IgZGF0YS5cbiAgICpcbiAgICogSWYgdGhlIGRhdGEgaXMgbm90IGluIGEgV2ViTk4gTUxUZW5zb3IsIHRocm93IGVycm9yLlxuICAgKi9cbiAgcmVhZG9ubHkgbWxUZW5zb3I6IFRlbnNvci5NTFRlbnNvclR5cGU7XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYnVmZmVyIGRhdGEgb2YgdGhlIHRlbnNvci5cbiAgICpcbiAgICogSWYgdGhlIGRhdGEgaXMgb24gQ1BVLCByZXR1cm5zIHRoZSBkYXRhIGltbWVkaWF0ZWx5LlxuICAgKiBJZiB0aGUgZGF0YSBpcyBvbiBHUFUsIGRvd25sb2FkcyB0aGUgZGF0YSBhbmQgcmV0dXJucyB0aGUgcHJvbWlzZS5cbiAgICpcbiAgICogQHBhcmFtIHJlbGVhc2VEYXRhIC0gd2hldGhlciByZWxlYXNlIHRoZSBkYXRhIG9uIEdQVS4gSWdub3JlIGlmIGRhdGEgaXMgYWxyZWFkeSBvbiBDUFUuXG4gICAqL1xuICBnZXREYXRhKHJlbGVhc2VEYXRhPzogYm9vbGVhbik6IFByb21pc2U8VGVuc29yLkRhdGFUeXBlTWFwW1RdPjtcblxuICAvKipcbiAgICogRGlzcG9zZSB0aGUgdGVuc29yIGRhdGEuXG4gICAqXG4gICAqIElmIHRoZSBkYXRhIGlzIG9uIENQVSwgcmVtb3ZlIGl0cyBpbnRlcm5hbCByZWZlcmVuY2UgdG8gdGhlIHVuZGVybHlpbmcgZGF0YS5cbiAgICogSWYgdGhlIGRhdGEgaXMgb24gR1BVLCByZWxlYXNlIHRoZSBkYXRhIG9uIEdQVS5cbiAgICpcbiAgICogQWZ0ZXIgY2FsbGluZyB0aGlzIGZ1bmN0aW9uLCB0aGUgdGVuc29yIGlzIGNvbnNpZGVyZWQgbm8gbG9uZ2VyIHZhbGlkLiBJdHMgbG9jYXRpb24gd2lsbCBiZSBzZXQgdG8gJ25vbmUnLlxuICAgKi9cbiAgZGlzcG9zZSgpOiB2b2lkO1xufVxuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgVGVuc29yIHtcbiAgaW50ZXJmYWNlIERhdGFUeXBlTWFwIHtcbiAgICBmbG9hdDMyOiBGbG9hdDMyQXJyYXk7XG4gICAgdWludDg6IFVpbnQ4QXJyYXk7XG4gICAgaW50ODogSW50OEFycmF5O1xuICAgIHVpbnQxNjogVWludDE2QXJyYXk7XG4gICAgaW50MTY6IEludDE2QXJyYXk7XG4gICAgaW50MzI6IEludDMyQXJyYXk7XG4gICAgaW50NjQ6IEJpZ0ludDY0QXJyYXk7XG4gICAgc3RyaW5nOiBzdHJpbmdbXTtcbiAgICBib29sOiBVaW50OEFycmF5O1xuICAgIGZsb2F0MTY6IFVpbnQxNkFycmF5OyAvLyBLZWVwIHVzaW5nIFVpbnQxNkFycmF5IHVudGlsIHdlIGhhdmUgYSBjb25jcmV0ZSBzb2x1dGlvbiBmb3IgZmxvYXQgMTYuXG4gICAgZmxvYXQ2NDogRmxvYXQ2NEFycmF5O1xuICAgIHVpbnQzMjogVWludDMyQXJyYXk7XG4gICAgdWludDY0OiBCaWdVaW50NjRBcnJheTtcbiAgICAvLyBjb21wbGV4NjQ6IG5ldmVyO1xuICAgIC8vIGNvbXBsZXgxMjg6IG5ldmVyO1xuICAgIC8vIGJmbG9hdDE2OiBuZXZlcjtcbiAgICB1aW50NDogVWludDhBcnJheTtcbiAgICBpbnQ0OiBJbnQ4QXJyYXk7XG4gIH1cblxuICBpbnRlcmZhY2UgRWxlbWVudFR5cGVNYXAge1xuICAgIGZsb2F0MzI6IG51bWJlcjtcbiAgICB1aW50ODogbnVtYmVyO1xuICAgIGludDg6IG51bWJlcjtcbiAgICB1aW50MTY6IG51bWJlcjtcbiAgICBpbnQxNjogbnVtYmVyO1xuICAgIGludDMyOiBudW1iZXI7XG4gICAgaW50NjQ6IGJpZ2ludDtcbiAgICBzdHJpbmc6IHN0cmluZztcbiAgICBib29sOiBib29sZWFuO1xuICAgIGZsb2F0MTY6IG51bWJlcjsgLy8gS2VlcCB1c2luZyBVaW50MTZBcnJheSB1bnRpbCB3ZSBoYXZlIGEgY29uY3JldGUgc29sdXRpb24gZm9yIGZsb2F0IDE2LlxuICAgIGZsb2F0NjQ6IG51bWJlcjtcbiAgICB1aW50MzI6IG51bWJlcjtcbiAgICB1aW50NjQ6IGJpZ2ludDtcbiAgICAvLyBjb21wbGV4NjQ6IG5ldmVyO1xuICAgIC8vIGNvbXBsZXgxMjg6IG5ldmVyO1xuICAgIC8vIGJmbG9hdDE2OiBuZXZlcjtcbiAgICB1aW50NDogbnVtYmVyO1xuICAgIGludDQ6IG51bWJlcjtcbiAgfVxuXG4gIHR5cGUgRGF0YVR5cGUgPSBEYXRhVHlwZU1hcFtUeXBlXTtcbiAgdHlwZSBFbGVtZW50VHlwZSA9IEVsZW1lbnRUeXBlTWFwW1R5cGVdO1xuXG4gIC8qKlxuICAgKiBzdXBwb3J0ZWQgZGF0YSB0eXBlcyBmb3IgY29uc3RydWN0aW5nIGEgdGVuc29yIGZyb20gYSBwaW5uZWQgQ1BVIGJ1ZmZlclxuICAgKi9cbiAgZXhwb3J0IHR5cGUgQ3B1UGlubmVkRGF0YVR5cGVzID0gRXhjbHVkZTxUZW5zb3IuVHlwZSwgJ3N0cmluZyc+O1xuXG4gIC8qKlxuICAgKiB0eXBlIGFsaWFzIGZvciBXZWJHTCB0ZXh0dXJlXG4gICAqL1xuICBleHBvcnQgdHlwZSBUZXh0dXJlVHlwZSA9IFdlYkdMVGV4dHVyZTtcblxuICAvKipcbiAgICogc3VwcG9ydGVkIGRhdGEgdHlwZXMgZm9yIGNvbnN0cnVjdGluZyBhIHRlbnNvciBmcm9tIGEgV2ViR0wgdGV4dHVyZVxuICAgKi9cbiAgZXhwb3J0IHR5cGUgVGV4dHVyZURhdGFUeXBlcyA9ICdmbG9hdDMyJztcblxuICAvKipcbiAgICogdHlwZSBhbGlhcyBmb3IgV2ViR1BVIGJ1ZmZlclxuICAgKlxuICAgKiBUaGUgcmVhc29uIHdoeSB3ZSBkb24ndCB1c2UgdHlwZSBcIkdQVUJ1ZmZlclwiIGRlZmluZWQgaW4gd2ViZ3B1LmQudHMgZnJvbSBAd2ViZ3B1L3R5cGVzIGlzIGJlY2F1c2UgXCJAd2ViZ3B1L3R5cGVzXCJcbiAgICogcmVxdWlyZXMgXCJAdHlwZXMvZG9tLXdlYmNvZGVjc1wiIGFzIHBlZXIgZGVwZW5kZW5jeSB3aGVuIHVzaW5nIFR5cGVTY3JpcHQgPCB2NS4xIGFuZCBpdHMgdmVyc2lvbiBuZWVkIHRvIGJlIGNob3NlblxuICAgKiBjYXJlZnVsbHkgYWNjb3JkaW5nIHRvIHRoZSBUeXBlU2NyaXB0IHZlcnNpb24gYmVpbmcgdXNlZC4gVGhpcyBtZWFucyBzbyBmYXIgdGhlcmUgaXMgbm90IGEgd2F5IHRvIGtlZXAgZXZlcnlcbiAgICogVHlwZVNjcmlwdCB2ZXJzaW9uIGhhcHB5LiBJdCB0dXJucyBvdXQgdGhhdCB3ZSB3aWxsIGVhc2lseSBicm9rZSB1c2VycyBvbiBzb21lIFR5cGVTY3JpcHQgdmVyc2lvbi5cbiAgICpcbiAgICogZm9yIG1vcmUgaW5mbyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2dwdXdlYi90eXBlcy9pc3N1ZXMvMTI3XG4gICAqL1xuICBleHBvcnQgdHlwZSBHcHVCdWZmZXJUeXBlID0geyBzaXplOiBudW1iZXI7IG1hcFN0YXRlOiAndW5tYXBwZWQnIHwgJ3BlbmRpbmcnIHwgJ21hcHBlZCcgfTtcblxuICAvKipcbiAgICogdHlwZSBhbGlhcyBmb3IgV2ViTk4gTUxUZW5zb3JcbiAgICpcbiAgICogVGhlIHNwZWNpZmljYXRpb24gZm9yIFdlYk5OJ3MgTUxUZW5zb3IgaXMgY3VycmVudGx5IGluIGZsdXguXG4gICAqL1xuICBleHBvcnQgdHlwZSBNTFRlbnNvclR5cGUgPSB1bmtub3duO1xuXG4gIC8qKlxuICAgKiBzdXBwb3J0ZWQgZGF0YSB0eXBlcyBmb3IgY29uc3RydWN0aW5nIGEgdGVuc29yIGZyb20gYSBXZWJHUFUgYnVmZmVyXG4gICAqL1xuICBleHBvcnQgdHlwZSBHcHVCdWZmZXJEYXRhVHlwZXMgPSAnZmxvYXQzMicgfCAnZmxvYXQxNicgfCAnaW50MzInIHwgJ2ludDY0JyB8ICd1aW50MzInIHwgJ3VpbnQ4JyB8ICdib29sJztcblxuICAvKipcbiAgICogc3VwcG9ydGVkIGRhdGEgdHlwZXMgZm9yIGNvbnN0cnVjdGluZyBhIHRlbnNvciBmcm9tIGEgV2ViTk4gTUxUZW5zb3JcbiAgICovXG4gIGV4cG9ydCB0eXBlIE1MVGVuc29yRGF0YVR5cGVzID1cbiAgICB8ICdmbG9hdDMyJ1xuICAgIHwgJ2Zsb2F0MTYnXG4gICAgfCAnaW50OCdcbiAgICB8ICd1aW50OCdcbiAgICB8ICdpbnQzMidcbiAgICB8ICd1aW50MzInXG4gICAgfCAnaW50NjQnXG4gICAgfCAndWludDY0J1xuICAgIHwgJ2Jvb2wnXG4gICAgfCAndWludDQnXG4gICAgfCAnaW50NCc7XG5cbiAgLyoqXG4gICAqIHJlcHJlc2VudCB3aGVyZSB0aGUgdGVuc29yIGRhdGEgaXMgc3RvcmVkXG4gICAqL1xuICBleHBvcnQgdHlwZSBEYXRhTG9jYXRpb24gPSAnbm9uZScgfCAnY3B1JyB8ICdjcHUtcGlubmVkJyB8ICd0ZXh0dXJlJyB8ICdncHUtYnVmZmVyJyB8ICdtbC10ZW5zb3InO1xuXG4gIC8qKlxuICAgKiByZXByZXNlbnQgdGhlIGRhdGEgdHlwZSBvZiBhIHRlbnNvclxuICAgKi9cbiAgZXhwb3J0IHR5cGUgVHlwZSA9IGtleW9mIERhdGFUeXBlTWFwO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudCBtdWx0aS1kaW1lbnNpb25hbCBhcnJheXMgdG8gZmVlZCB0byBvciBmZXRjaCBmcm9tIG1vZGVsIGluZmVyZW5jaW5nLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFR5cGVkVGVuc29yPFQgZXh0ZW5kcyBUZW5zb3IuVHlwZT4gZXh0ZW5kcyBUeXBlZFRlbnNvckJhc2U8VD4sIFR5cGVkVGVuc29yVXRpbHM8VD4ge31cbi8qKlxuICogUmVwcmVzZW50IG11bHRpLWRpbWVuc2lvbmFsIGFycmF5cyB0byBmZWVkIHRvIG9yIGZldGNoIGZyb20gbW9kZWwgaW5mZXJlbmNpbmcuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGVuc29yIGV4dGVuZHMgVHlwZWRUZW5zb3JCYXNlPFRlbnNvci5UeXBlPiwgVHlwZWRUZW5zb3JVdGlsczxUZW5zb3IuVHlwZT4ge31cblxuLyoqXG4gKiB0eXBlIFRlbnNvckNvbnN0cnVjdG9yIGRlZmluZXMgdGhlIGNvbnN0cnVjdG9ycyBvZiAnVGVuc29yJyB0byBjcmVhdGUgQ1BVIHRlbnNvciBpbnN0YW5jZXMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGVuc29yQ29uc3RydWN0b3IgZXh0ZW5kcyBUZW5zb3JGYWN0b3J5IHtcbiAgLy8gI3JlZ2lvbiBDUFUgdGVuc29yIC0gc3BlY2lmeSBlbGVtZW50IHR5cGVcbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyBzdHJpbmcgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiB0eXBlLCBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gdHlwZSAtIFNwZWNpZnkgdGhlIGVsZW1lbnQgdHlwZS5cbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3IChcbiAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICBkYXRhOiBUZW5zb3IuRGF0YVR5cGVNYXBbJ3N0cmluZyddIHwgcmVhZG9ubHkgc3RyaW5nW10sXG4gICAgZGltcz86IHJlYWRvbmx5IG51bWJlcltdLFxuICApOiBUeXBlZFRlbnNvcjwnc3RyaW5nJz47XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyBib29sIHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gdHlwZSwgZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIHR5cGUgLSBTcGVjaWZ5IHRoZSBlbGVtZW50IHR5cGUuXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyAoXG4gICAgdHlwZTogJ2Jvb2wnLFxuICAgIGRhdGE6IFRlbnNvci5EYXRhVHlwZU1hcFsnYm9vbCddIHwgcmVhZG9ubHkgYm9vbGVhbltdLFxuICAgIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSxcbiAgKTogVHlwZWRUZW5zb3I8J2Jvb2wnPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IHVpbnQ4IHRlbnNvciBvYmplY3QgZnJvbSBhIFVpbnQ4Q2xhbXBlZEFycmF5LCBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gdHlwZSAtIFNwZWNpZnkgdGhlIGVsZW1lbnQgdHlwZS5cbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3ICh0eXBlOiAndWludDgnLCBkYXRhOiBVaW50OENsYW1wZWRBcnJheSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVHlwZWRUZW5zb3I8J3VpbnQ4Jz47XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyA2NC1iaXQgaW50ZWdlciB0eXBlZCB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIHR5cGUsIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSB0eXBlIC0gU3BlY2lmeSB0aGUgZWxlbWVudCB0eXBlLlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcgPFQgZXh0ZW5kcyAndWludDY0JyB8ICdpbnQ2NCc+KFxuICAgIHR5cGU6IFQsXG4gICAgZGF0YTogVGVuc29yLkRhdGFUeXBlTWFwW1RdIHwgcmVhZG9ubHkgYmlnaW50W10gfCByZWFkb25seSBudW1iZXJbXSxcbiAgICBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10sXG4gICk6IFR5cGVkVGVuc29yPFQ+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgbnVtZXJpYyB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIHR5cGUsIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSB0eXBlIC0gU3BlY2lmeSB0aGUgZWxlbWVudCB0eXBlLlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcgPFQgZXh0ZW5kcyBFeGNsdWRlPFRlbnNvci5UeXBlLCAnc3RyaW5nJyB8ICdib29sJyB8ICd1aW50NjQnIHwgJ2ludDY0Jz4+KFxuICAgIHR5cGU6IFQsXG4gICAgZGF0YTogVGVuc29yLkRhdGFUeXBlTWFwW1RdIHwgcmVhZG9ubHkgbnVtYmVyW10sXG4gICAgZGltcz86IHJlYWRvbmx5IG51bWJlcltdLFxuICApOiBUeXBlZFRlbnNvcjxUPjtcbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gQ1BVIHRlbnNvciAtIGluZmVyIGVsZW1lbnQgdHlwZXNcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IGZsb2F0MzIgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcgKGRhdGE6IEZsb2F0MzJBcnJheSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVHlwZWRUZW5zb3I8J2Zsb2F0MzInPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IGludDggdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcgKGRhdGE6IEludDhBcnJheSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVHlwZWRUZW5zb3I8J2ludDgnPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IHVpbnQ4IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3IChkYXRhOiBVaW50OEFycmF5LCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwndWludDgnPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IHVpbnQ4IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3IChkYXRhOiBVaW50OENsYW1wZWRBcnJheSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVHlwZWRUZW5zb3I8J3VpbnQ4Jz47XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyB1aW50MTYgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcgKGRhdGE6IFVpbnQxNkFycmF5LCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwndWludDE2Jz47XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyBpbnQxNiB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyAoZGF0YTogSW50MTZBcnJheSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVHlwZWRUZW5zb3I8J2ludDE2Jz47XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyBpbnQzMiB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyAoZGF0YTogSW50MzJBcnJheSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVHlwZWRUZW5zb3I8J2ludDMyJz47XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyBpbnQ2NCB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyAoZGF0YTogQmlnSW50NjRBcnJheSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVHlwZWRUZW5zb3I8J2ludDY0Jz47XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyBzdHJpbmcgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcgKGRhdGE6IHJlYWRvbmx5IHN0cmluZ1tdLCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwnc3RyaW5nJz47XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyBib29sIHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3IChkYXRhOiByZWFkb25seSBib29sZWFuW10sIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCdib29sJz47XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyBmbG9hdDY0IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3IChkYXRhOiBGbG9hdDY0QXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCdmbG9hdDY0Jz47XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyB1aW50MzIgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcgKGRhdGE6IFVpbnQzMkFycmF5LCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwndWludDMyJz47XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyB1aW50NjQgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcgKGRhdGE6IEJpZ1VpbnQ2NEFycmF5LCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwndWludDY0Jz47XG5cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gQ1BVIHRlbnNvciAtIGZhbGwgYmFjayB0byBub24tZ2VuZXJpYyB0ZW5zb3IgdHlwZSBkZWNsYXJhdGlvblxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiB0eXBlLCBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gdHlwZSAtIFNwZWNpZnkgdGhlIGVsZW1lbnQgdHlwZS5cbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3IChcbiAgICB0eXBlOiBUZW5zb3IuVHlwZSxcbiAgICBkYXRhOiBUZW5zb3IuRGF0YVR5cGUgfCByZWFkb25seSBudW1iZXJbXSB8IHJlYWRvbmx5IHN0cmluZ1tdIHwgcmVhZG9ubHkgYmlnaW50W10gfCByZWFkb25seSBib29sZWFuW10sXG4gICAgZGltcz86IHJlYWRvbmx5IG51bWJlcltdLFxuICApOiBUZW5zb3I7XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyAoZGF0YTogVGVuc29yLkRhdGFUeXBlLCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUZW5zb3I7XG4gIC8vICNlbmRyZWdpb25cbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuZXhwb3J0IGNvbnN0IFRlbnNvciA9IFRlbnNvckltcGwgYXMgVGVuc29yQ29uc3RydWN0b3I7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IGVudiB9IGZyb20gJy4vZW52LWltcGwuanMnO1xuXG4vKipcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0IGNvbnN0IFRSQUNFID0gKGRldmljZVR5cGU6IHN0cmluZywgbGFiZWw6IHN0cmluZykgPT4ge1xuICBpZiAodHlwZW9mIGVudi50cmFjZSA9PT0gJ3VuZGVmaW5lZCcgPyAhZW52Lndhc20udHJhY2UgOiAhZW52LnRyYWNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gIGNvbnNvbGUudGltZVN0YW1wKGAke2RldmljZVR5cGV9OjpPUlQ6OiR7bGFiZWx9YCk7XG59O1xuXG5jb25zdCBUUkFDRV9GVU5DID0gKG1zZzogc3RyaW5nLCBleHRyYU1zZz86IHN0cmluZykgPT4ge1xuICBjb25zdCBzdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrPy5zcGxpdCgvXFxyXFxufFxccnxcXG4vZykgfHwgW107XG4gIGxldCBoYXNUcmFjZUZ1bmMgPSBmYWxzZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKykge1xuICAgIGlmIChoYXNUcmFjZUZ1bmMgJiYgIXN0YWNrW2ldLmluY2x1ZGVzKCdUUkFDRV9GVU5DJykpIHtcbiAgICAgIGxldCBsYWJlbCA9IGBGVU5DXyR7bXNnfTo6JHtzdGFja1tpXS50cmltKCkuc3BsaXQoJyAnKVsxXX1gO1xuICAgICAgaWYgKGV4dHJhTXNnKSB7XG4gICAgICAgIGxhYmVsICs9IGA6OiR7ZXh0cmFNc2d9YDtcbiAgICAgIH1cbiAgICAgIFRSQUNFKCdDUFUnLCBsYWJlbCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzdGFja1tpXS5pbmNsdWRlcygnVFJBQ0VfRlVOQycpKSB7XG4gICAgICBoYXNUcmFjZUZ1bmMgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBjb25zdCBUUkFDRV9GVU5DX0JFR0lOID0gKGV4dHJhTXNnPzogc3RyaW5nKSA9PiB7XG4gIGlmICh0eXBlb2YgZW52LnRyYWNlID09PSAndW5kZWZpbmVkJyA/ICFlbnYud2FzbS50cmFjZSA6ICFlbnYudHJhY2UpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgVFJBQ0VfRlVOQygnQkVHSU4nLCBleHRyYU1zZyk7XG59O1xuXG4vKipcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0IGNvbnN0IFRSQUNFX0ZVTkNfRU5EID0gKGV4dHJhTXNnPzogc3RyaW5nKSA9PiB7XG4gIGlmICh0eXBlb2YgZW52LnRyYWNlID09PSAndW5kZWZpbmVkJyA/ICFlbnYud2FzbS50cmFjZSA6ICFlbnYudHJhY2UpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgVFJBQ0VfRlVOQygnRU5EJywgZXh0cmFNc2cpO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgcmVzb2x2ZUJhY2tlbmRBbmRFeGVjdXRpb25Qcm92aWRlcnMgfSBmcm9tICcuL2JhY2tlbmQtaW1wbC5qcyc7XG5pbXBvcnQgeyBJbmZlcmVuY2VTZXNzaW9uSGFuZGxlciB9IGZyb20gJy4vYmFja2VuZC5qcyc7XG5pbXBvcnQgeyBJbmZlcmVuY2VTZXNzaW9uIGFzIEluZmVyZW5jZVNlc3Npb25JbnRlcmZhY2UgfSBmcm9tICcuL2luZmVyZW5jZS1zZXNzaW9uLmpzJztcbmltcG9ydCB7IE9ubnhWYWx1ZSB9IGZyb20gJy4vb25ueC12YWx1ZS5qcyc7XG5pbXBvcnQgeyBUZW5zb3IgfSBmcm9tICcuL3RlbnNvci5qcyc7XG5pbXBvcnQgeyBUUkFDRV9GVU5DX0JFR0lOLCBUUkFDRV9GVU5DX0VORCB9IGZyb20gJy4vdHJhY2UuanMnO1xuXG50eXBlIFNlc3Npb25PcHRpb25zID0gSW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZS5TZXNzaW9uT3B0aW9ucztcbnR5cGUgUnVuT3B0aW9ucyA9IEluZmVyZW5jZVNlc3Npb25JbnRlcmZhY2UuUnVuT3B0aW9ucztcbnR5cGUgRmVlZHNUeXBlID0gSW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZS5GZWVkc1R5cGU7XG50eXBlIEZldGNoZXNUeXBlID0gSW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZS5GZXRjaGVzVHlwZTtcbnR5cGUgUmV0dXJuVHlwZSA9IEluZmVyZW5jZVNlc3Npb25JbnRlcmZhY2UuUmV0dXJuVHlwZTtcblxuZXhwb3J0IGNsYXNzIEluZmVyZW5jZVNlc3Npb24gaW1wbGVtZW50cyBJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlIHtcbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihoYW5kbGVyOiBJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcikge1xuICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XG4gIH1cbiAgcnVuKGZlZWRzOiBGZWVkc1R5cGUsIG9wdGlvbnM/OiBSdW5PcHRpb25zKTogUHJvbWlzZTxSZXR1cm5UeXBlPjtcbiAgcnVuKGZlZWRzOiBGZWVkc1R5cGUsIGZldGNoZXM6IEZldGNoZXNUeXBlLCBvcHRpb25zPzogUnVuT3B0aW9ucyk6IFByb21pc2U8UmV0dXJuVHlwZT47XG4gIGFzeW5jIHJ1bihmZWVkczogRmVlZHNUeXBlLCBhcmcxPzogRmV0Y2hlc1R5cGUgfCBSdW5PcHRpb25zLCBhcmcyPzogUnVuT3B0aW9ucyk6IFByb21pc2U8UmV0dXJuVHlwZT4ge1xuICAgIFRSQUNFX0ZVTkNfQkVHSU4oKTtcbiAgICBjb25zdCBmZXRjaGVzOiB7IFtuYW1lOiBzdHJpbmddOiBPbm54VmFsdWUgfCBudWxsIH0gPSB7fTtcbiAgICBsZXQgb3B0aW9uczogUnVuT3B0aW9ucyA9IHt9O1xuICAgIC8vIGNoZWNrIGlucHV0c1xuICAgIGlmICh0eXBlb2YgZmVlZHMgIT09ICdvYmplY3QnIHx8IGZlZWRzID09PSBudWxsIHx8IGZlZWRzIGluc3RhbmNlb2YgVGVuc29yIHx8IEFycmF5LmlzQXJyYXkoZmVlZHMpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBcIidmZWVkcycgbXVzdCBiZSBhbiBvYmplY3QgdGhhdCB1c2UgaW5wdXQgbmFtZXMgYXMga2V5cyBhbmQgT25ueFZhbHVlIGFzIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlwiLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBsZXQgaXNGZXRjaGVzRW1wdHkgPSB0cnVlO1xuICAgIC8vIGRldGVybWluZSB3aGljaCBvdmVycmlkZSBpcyBiZWluZyB1c2VkXG4gICAgaWYgKHR5cGVvZiBhcmcxID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKGFyZzEgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5leHBlY3RlZCBhcmd1bWVudFsxXTogY2Fubm90IGJlIG51bGwuJyk7XG4gICAgICB9XG4gICAgICBpZiAoYXJnMSBpbnN0YW5jZW9mIFRlbnNvcikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2ZldGNoZXMnIGNhbm5vdCBiZSBhIFRlbnNvclwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnMSkpIHtcbiAgICAgICAgaWYgKGFyZzEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIidmZXRjaGVzJyBjYW5ub3QgYmUgYW4gZW1wdHkgYXJyYXkuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlzRmV0Y2hlc0VtcHR5ID0gZmFsc2U7XG4gICAgICAgIC8vIG91dHB1dCBuYW1lc1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgYXJnMSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCInZmV0Y2hlcycgbXVzdCBiZSBhIHN0cmluZyBhcnJheSBvciBhbiBvYmplY3QuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5vdXRwdXROYW1lcy5pbmRleE9mKG5hbWUpID09PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYCdmZXRjaGVzJyBjb250YWlucyBpbnZhbGlkIG91dHB1dCBuYW1lOiAke25hbWV9LmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmZXRjaGVzW25hbWVdID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYXJnMiA9PT0gJ29iamVjdCcgJiYgYXJnMiAhPT0gbnVsbCkge1xuICAgICAgICAgIG9wdGlvbnMgPSBhcmcyO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkZWNpZGUgd2hldGhlciBhcmcxIGlzIGZldGNoZXMgb3Igb3B0aW9uc1xuICAgICAgICAvLyBpZiBhbnkgb3V0cHV0IG5hbWUgaXMgcHJlc2VudCBhbmQgaXRzIHZhbHVlIGlzIHZhbGlkIE9ubnhWYWx1ZSwgd2UgY29uc2lkZXIgaXQgZmV0Y2hlc1xuICAgICAgICBsZXQgaXNGZXRjaGVzID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGFyZzFLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJnMSk7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiB0aGlzLm91dHB1dE5hbWVzKSB7XG4gICAgICAgICAgaWYgKGFyZzFLZXlzLmluZGV4T2YobmFtZSkgIT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gKGFyZzEgYXMgSW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZS5OdWxsYWJsZU9ubnhWYWx1ZU1hcFR5cGUpW25hbWVdO1xuICAgICAgICAgICAgaWYgKHYgPT09IG51bGwgfHwgdiBpbnN0YW5jZW9mIFRlbnNvcikge1xuICAgICAgICAgICAgICBpc0ZldGNoZXMgPSB0cnVlO1xuICAgICAgICAgICAgICBpc0ZldGNoZXNFbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICBmZXRjaGVzW25hbWVdID0gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNGZXRjaGVzKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBhcmcyID09PSAnb2JqZWN0JyAmJiBhcmcyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gYXJnMjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wdGlvbnMgPSBhcmcxIGFzIFJ1bk9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcxICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuZXhwZWN0ZWQgYXJndW1lbnRbMV06IG11c3QgYmUgJ2ZldGNoZXMnIG9yICdvcHRpb25zJy5cIik7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgaWYgYWxsIGlucHV0cyBhcmUgaW4gZmVlZFxuICAgIGZvciAoY29uc3QgbmFtZSBvZiB0aGlzLmlucHV0TmFtZXMpIHtcbiAgICAgIGlmICh0eXBlb2YgZmVlZHNbbmFtZV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW5wdXQgJyR7bmFtZX0nIGlzIG1pc3NpbmcgaW4gJ2ZlZWRzJy5gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiBubyBmZXRjaGVzIGlzIHNwZWNpZmllZCwgd2UgdXNlIHRoZSBmdWxsIG91dHB1dCBuYW1lcyBsaXN0XG4gICAgaWYgKGlzRmV0Y2hlc0VtcHR5KSB7XG4gICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgdGhpcy5vdXRwdXROYW1lcykge1xuICAgICAgICBmZXRjaGVzW25hbWVdID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBmZWVkcywgZmV0Y2hlcyBhbmQgb3B0aW9ucyBhcmUgcHJlcGFyZWRcblxuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCB0aGlzLmhhbmRsZXIucnVuKGZlZWRzLCBmZXRjaGVzLCBvcHRpb25zKTtcbiAgICBjb25zdCByZXR1cm5WYWx1ZTogeyBbbmFtZTogc3RyaW5nXTogT25ueFZhbHVlIH0gPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiByZXN1bHRzKSB7XG4gICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwocmVzdWx0cywga2V5KSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSByZXN1bHRzW2tleV07XG4gICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBUZW5zb3IpIHtcbiAgICAgICAgICByZXR1cm5WYWx1ZVtrZXldID0gcmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVyblZhbHVlW2tleV0gPSBuZXcgVGVuc29yKHJlc3VsdC50eXBlLCByZXN1bHQuZGF0YSwgcmVzdWx0LmRpbXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFRSQUNFX0ZVTkNfRU5EKCk7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICB9XG5cbiAgYXN5bmMgcmVsZWFzZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVyLmRpc3Bvc2UoKTtcbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGUocGF0aDogc3RyaW5nLCBvcHRpb25zPzogU2Vzc2lvbk9wdGlvbnMpOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb25JbnRlcmZhY2U+O1xuICBzdGF0aWMgY3JlYXRlKGJ1ZmZlcjogQXJyYXlCdWZmZXJMaWtlLCBvcHRpb25zPzogU2Vzc2lvbk9wdGlvbnMpOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb25JbnRlcmZhY2U+O1xuICBzdGF0aWMgY3JlYXRlKFxuICAgIGJ1ZmZlcjogQXJyYXlCdWZmZXJMaWtlLFxuICAgIGJ5dGVPZmZzZXQ6IG51bWJlcixcbiAgICBieXRlTGVuZ3RoPzogbnVtYmVyLFxuICAgIG9wdGlvbnM/OiBTZXNzaW9uT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlPjtcbiAgc3RhdGljIGNyZWF0ZShidWZmZXI6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBTZXNzaW9uT3B0aW9ucyk6IFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZT47XG4gIHN0YXRpYyBhc3luYyBjcmVhdGUoXG4gICAgYXJnMDogc3RyaW5nIHwgQXJyYXlCdWZmZXJMaWtlIHwgVWludDhBcnJheSxcbiAgICBhcmcxPzogU2Vzc2lvbk9wdGlvbnMgfCBudW1iZXIsXG4gICAgYXJnMj86IG51bWJlcixcbiAgICBhcmczPzogU2Vzc2lvbk9wdGlvbnMsXG4gICk6IFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZT4ge1xuICAgIFRSQUNFX0ZVTkNfQkVHSU4oKTtcbiAgICAvLyBlaXRoZXIgbG9hZCBmcm9tIGEgZmlsZSBvciBidWZmZXJcbiAgICBsZXQgZmlsZVBhdGhPclVpbnQ4QXJyYXk6IHN0cmluZyB8IFVpbnQ4QXJyYXk7XG4gICAgbGV0IG9wdGlvbnM6IFNlc3Npb25PcHRpb25zID0ge307XG5cbiAgICBpZiAodHlwZW9mIGFyZzAgPT09ICdzdHJpbmcnKSB7XG4gICAgICBmaWxlUGF0aE9yVWludDhBcnJheSA9IGFyZzA7XG4gICAgICBpZiAodHlwZW9mIGFyZzEgPT09ICdvYmplY3QnICYmIGFyZzEgIT09IG51bGwpIHtcbiAgICAgICAgb3B0aW9ucyA9IGFyZzE7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcxICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFyZzAgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICBmaWxlUGF0aE9yVWludDhBcnJheSA9IGFyZzA7XG4gICAgICBpZiAodHlwZW9mIGFyZzEgPT09ICdvYmplY3QnICYmIGFyZzEgIT09IG51bGwpIHtcbiAgICAgICAgb3B0aW9ucyA9IGFyZzE7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcxICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgYXJnMCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8XG4gICAgICAodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBhcmcwIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXIpXG4gICAgKSB7XG4gICAgICBjb25zdCBidWZmZXIgPSBhcmcwO1xuICAgICAgbGV0IGJ5dGVPZmZzZXQgPSAwO1xuICAgICAgbGV0IGJ5dGVMZW5ndGggPSBhcmcwLmJ5dGVMZW5ndGg7XG4gICAgICBpZiAodHlwZW9mIGFyZzEgPT09ICdvYmplY3QnICYmIGFyZzEgIT09IG51bGwpIHtcbiAgICAgICAgb3B0aW9ucyA9IGFyZzE7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcxID09PSAnbnVtYmVyJykge1xuICAgICAgICBieXRlT2Zmc2V0ID0gYXJnMTtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihieXRlT2Zmc2V0KSkge1xuICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiJ2J5dGVPZmZzZXQnIG11c3QgYmUgYW4gaW50ZWdlci5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgJ2J5dGVPZmZzZXQnIGlzIG91dCBvZiByYW5nZSBbMCwgJHtidWZmZXIuYnl0ZUxlbmd0aH0pLmApO1xuICAgICAgICB9XG4gICAgICAgIGJ5dGVMZW5ndGggPSBhcmcwLmJ5dGVMZW5ndGggLSBieXRlT2Zmc2V0O1xuICAgICAgICBpZiAodHlwZW9mIGFyZzIgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgYnl0ZUxlbmd0aCA9IGFyZzI7XG4gICAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihieXRlTGVuZ3RoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCInYnl0ZUxlbmd0aCcgbXVzdCBiZSBhbiBpbnRlZ2VyLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGJ5dGVMZW5ndGggPD0gMCB8fCBieXRlT2Zmc2V0ICsgYnl0ZUxlbmd0aCA+IGJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgJ2J5dGVMZW5ndGgnIGlzIG91dCBvZiByYW5nZSAoMCwgJHtidWZmZXIuYnl0ZUxlbmd0aCAtIGJ5dGVPZmZzZXR9XS5gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBhcmczID09PSAnb2JqZWN0JyAmJiBhcmczICE9PSBudWxsKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gYXJnMztcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmczICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCInYnl0ZUxlbmd0aCcgbXVzdCBiZSBhIG51bWJlci5cIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpO1xuICAgICAgfVxuICAgICAgZmlsZVBhdGhPclVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheShidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5leHBlY3RlZCBhcmd1bWVudFswXTogbXVzdCBiZSAncGF0aCcgb3IgJ2J1ZmZlcicuXCIpO1xuICAgIH1cblxuICAgIC8vIHJlc29sdmUgYmFja2VuZCwgdXBkYXRlIHNlc3Npb24gb3B0aW9ucyB3aXRoIHZhbGlkYXRlZCBFUHMsIGFuZCBjcmVhdGUgc2Vzc2lvbiBoYW5kbGVyXG4gICAgY29uc3QgW2JhY2tlbmQsIG9wdGlvbnNXaXRoVmFsaWRhdGVkRVBzXSA9IGF3YWl0IHJlc29sdmVCYWNrZW5kQW5kRXhlY3V0aW9uUHJvdmlkZXJzKG9wdGlvbnMpO1xuICAgIGNvbnN0IGhhbmRsZXIgPSBhd2FpdCBiYWNrZW5kLmNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyKGZpbGVQYXRoT3JVaW50OEFycmF5LCBvcHRpb25zV2l0aFZhbGlkYXRlZEVQcyk7XG4gICAgVFJBQ0VfRlVOQ19FTkQoKTtcbiAgICByZXR1cm4gbmV3IEluZmVyZW5jZVNlc3Npb24oaGFuZGxlcik7XG4gIH1cblxuICBzdGFydFByb2ZpbGluZygpOiB2b2lkIHtcbiAgICB0aGlzLmhhbmRsZXIuc3RhcnRQcm9maWxpbmcoKTtcbiAgfVxuICBlbmRQcm9maWxpbmcoKTogdm9pZCB7XG4gICAgdGhpcy5oYW5kbGVyLmVuZFByb2ZpbGluZygpO1xuICB9XG5cbiAgZ2V0IGlucHV0TmFtZXMoKTogcmVhZG9ubHkgc3RyaW5nW10ge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZXIuaW5wdXROYW1lcztcbiAgfVxuICBnZXQgb3V0cHV0TmFtZXMoKTogcmVhZG9ubHkgc3RyaW5nW10ge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZXIub3V0cHV0TmFtZXM7XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZXI6IEluZmVyZW5jZVNlc3Npb25IYW5kbGVyO1xufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBJbmZlcmVuY2VTZXNzaW9uIGFzIEluZmVyZW5jZVNlc3Npb25JbXBsIH0gZnJvbSAnLi9pbmZlcmVuY2Utc2Vzc2lvbi1pbXBsLmpzJztcbmltcG9ydCB7IE9ubnhNb2RlbE9wdGlvbnMgfSBmcm9tICcuL29ubngtbW9kZWwuanMnO1xuaW1wb3J0IHsgT25ueFZhbHVlLCBPbm54VmFsdWVEYXRhTG9jYXRpb24gfSBmcm9tICcuL29ubngtdmFsdWUuanMnO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVkZWNsYXJlICovXG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBJbmZlcmVuY2VTZXNzaW9uIHtcbiAgLy8gI3JlZ2lvbiBpbnB1dC9vdXRwdXQgdHlwZXNcblxuICB0eXBlIE9ubnhWYWx1ZU1hcFR5cGUgPSB7IHJlYWRvbmx5IFtuYW1lOiBzdHJpbmddOiBPbm54VmFsdWUgfTtcbiAgdHlwZSBOdWxsYWJsZU9ubnhWYWx1ZU1hcFR5cGUgPSB7IHJlYWRvbmx5IFtuYW1lOiBzdHJpbmddOiBPbm54VmFsdWUgfCBudWxsIH07XG5cbiAgLyoqXG4gICAqIEEgZmVlZHMgKG1vZGVsIGlucHV0cykgaXMgYW4gb2JqZWN0IHRoYXQgdXNlcyBpbnB1dCBuYW1lcyBhcyBrZXlzIGFuZCBPbm54VmFsdWUgYXMgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAqL1xuICB0eXBlIEZlZWRzVHlwZSA9IE9ubnhWYWx1ZU1hcFR5cGU7XG5cbiAgLyoqXG4gICAqIEEgZmV0Y2hlcyAobW9kZWwgb3V0cHV0cykgY291bGQgYmUgb25lIG9mIHRoZSBmb2xsb3dpbmc6XG4gICAqXG4gICAqIC0gT21pdHRlZC4gVXNlIG1vZGVsJ3Mgb3V0cHV0IG5hbWVzIGRlZmluaXRpb24uXG4gICAqIC0gQW4gYXJyYXkgb2Ygc3RyaW5nIGluZGljYXRpbmcgdGhlIG91dHB1dCBuYW1lcy5cbiAgICogLSBBbiBvYmplY3QgdGhhdCB1c2Ugb3V0cHV0IG5hbWVzIGFzIGtleXMgYW5kIE9ubnhWYWx1ZSBvciBudWxsIGFzIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgKlxuICAgKiBAcmVtYXJrXG4gICAqIGRpZmZlcmVudCBmcm9tIGlucHV0IGFyZ3VtZW50LCBpbiBvdXRwdXQsIE9ubnhWYWx1ZSBpcyBvcHRpb25hbC4gSWYgYW4gT25ueFZhbHVlIGlzIHByZXNlbnQgaXQgd2lsbCBiZVxuICAgKiB1c2VkIGFzIGEgcHJlLWFsbG9jYXRlZCB2YWx1ZSBieSB0aGUgaW5mZXJlbmNlIGVuZ2luZTsgaWYgb21pdHRlZCwgaW5mZXJlbmNlIGVuZ2luZSB3aWxsIGFsbG9jYXRlIGJ1ZmZlclxuICAgKiBpbnRlcm5hbGx5LlxuICAgKi9cbiAgdHlwZSBGZXRjaGVzVHlwZSA9IHJlYWRvbmx5IHN0cmluZ1tdIHwgTnVsbGFibGVPbm54VmFsdWVNYXBUeXBlO1xuXG4gIC8qKlxuICAgKiBBIGluZmVyZW5jaW5nIHJldHVybiB0eXBlIGlzIGFuIG9iamVjdCB0aGF0IHVzZXMgb3V0cHV0IG5hbWVzIGFzIGtleXMgYW5kIE9ubnhWYWx1ZSBhcyBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICovXG4gIHR5cGUgUmV0dXJuVHlwZSA9IE9ubnhWYWx1ZU1hcFR5cGU7XG5cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gc2Vzc2lvbiBvcHRpb25zXG5cbiAgLyoqXG4gICAqIEEgc2V0IG9mIGNvbmZpZ3VyYXRpb25zIGZvciBzZXNzaW9uIGJlaGF2aW9yLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBTZXNzaW9uT3B0aW9ucyBleHRlbmRzIE9ubnhNb2RlbE9wdGlvbnMge1xuICAgIC8qKlxuICAgICAqIEFuIGFycmF5IG9mIGV4ZWN1dGlvbiBwcm92aWRlciBvcHRpb25zLlxuICAgICAqXG4gICAgICogQW4gZXhlY3V0aW9uIHByb3ZpZGVyIG9wdGlvbiBjYW4gYmUgYSBzdHJpbmcgaW5kaWNhdGluZyB0aGUgbmFtZSBvZiB0aGUgZXhlY3V0aW9uIHByb3ZpZGVyLFxuICAgICAqIG9yIGFuIG9iamVjdCBvZiBjb3JyZXNwb25kaW5nIHR5cGUuXG4gICAgICovXG4gICAgZXhlY3V0aW9uUHJvdmlkZXJzPzogcmVhZG9ubHkgRXhlY3V0aW9uUHJvdmlkZXJDb25maWdbXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnRyYSBPUCB0aHJlYWRzIG51bWJlci5cbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAoTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUpLlxuICAgICAqL1xuICAgIGludHJhT3BOdW1UaHJlYWRzPzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGludGVyIE9QIHRocmVhZHMgbnVtYmVyLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSkuXG4gICAgICovXG4gICAgaW50ZXJPcE51bVRocmVhZHM/OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnJlZSBkaW1lbnNpb24gb3ZlcnJpZGUuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlKSBvciBXZWJBc3NlbWJseSBiYWNrZW5kXG4gICAgICovXG4gICAgZnJlZURpbWVuc2lvbk92ZXJyaWRlcz86IHsgcmVhZG9ubHkgW2RpbWVuc2lvbk5hbWU6IHN0cmluZ106IG51bWJlciB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9wdGltaXphdGlvbiBsZXZlbC5cbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAoTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUpIG9yIFdlYkFzc2VtYmx5IGJhY2tlbmRcbiAgICAgKi9cbiAgICBncmFwaE9wdGltaXphdGlvbkxldmVsPzogJ2Rpc2FibGVkJyB8ICdiYXNpYycgfCAnZXh0ZW5kZWQnIHwgJ2FsbCc7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGVuYWJsZSBDUFUgbWVtb3J5IGFyZW5hLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSkgb3IgV2ViQXNzZW1ibHkgYmFja2VuZFxuICAgICAqL1xuICAgIGVuYWJsZUNwdU1lbUFyZW5hPzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgZW5hYmxlIG1lbW9yeSBwYXR0ZXJuLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSkgb3IgV2ViQXNzZW1ibHkgYmFja2VuZFxuICAgICAqL1xuICAgIGVuYWJsZU1lbVBhdHRlcm4/OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogRXhlY3V0aW9uIG1vZGUuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlKSBvciBXZWJBc3NlbWJseSBiYWNrZW5kXG4gICAgICovXG4gICAgZXhlY3V0aW9uTW9kZT86ICdzZXF1ZW50aWFsJyB8ICdwYXJhbGxlbCc7XG5cbiAgICAvKipcbiAgICAgKiBPcHRpbWl6ZWQgbW9kZWwgZmlsZSBwYXRoLlxuICAgICAqXG4gICAgICogSWYgdGhpcyBzZXR0aW5nIGlzIHNwZWNpZmllZCwgdGhlIG9wdGltaXplZCBtb2RlbCB3aWxsIGJlIGR1bXBlZC4gSW4gYnJvd3NlciwgYSBibG9iIHdpbGwgYmUgY3JlYXRlZFxuICAgICAqIHdpdGggYSBwb3AtdXAgd2luZG93LlxuICAgICAqL1xuICAgIG9wdGltaXplZE1vZGVsRmlsZVBhdGg/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGVuYWJsZSBwcm9maWxpbmcuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYSBwbGFjZWhvbGRlciBmb3IgYSBmdXR1cmUgdXNlLlxuICAgICAqL1xuICAgIGVuYWJsZVByb2ZpbGluZz86IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBGaWxlIHByZWZpeCBmb3IgcHJvZmlsaW5nLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGEgcGxhY2Vob2xkZXIgZm9yIGEgZnV0dXJlIHVzZS5cbiAgICAgKi9cbiAgICBwcm9maWxlRmlsZVByZWZpeD86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIExvZyBJRC5cbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAoTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUpIG9yIFdlYkFzc2VtYmx5IGJhY2tlbmRcbiAgICAgKi9cbiAgICBsb2dJZD86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIExvZyBzZXZlcml0eSBsZXZlbC4gU2VlXG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9vbm54cnVudGltZS9ibG9iL21haW4vaW5jbHVkZS9vbm54cnVudGltZS9jb3JlL2NvbW1vbi9sb2dnaW5nL3NldmVyaXR5LmhcbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAoTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUpIG9yIFdlYkFzc2VtYmx5IGJhY2tlbmRcbiAgICAgKi9cbiAgICBsb2dTZXZlcml0eUxldmVsPzogMCB8IDEgfCAyIHwgMyB8IDQ7XG5cbiAgICAvKipcbiAgICAgKiBMb2cgdmVyYm9zaXR5IGxldmVsLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIFdlYkFzc2VtYmx5IGJhY2tlbmQuIFdpbGwgc3VwcG9ydCBOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSBsYXRlclxuICAgICAqL1xuICAgIGxvZ1ZlcmJvc2l0eUxldmVsPzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogU3BlY2lmeSBzdHJpbmcgYXMgYSBwcmVmZXJyZWQgZGF0YSBsb2NhdGlvbiBmb3IgYWxsIG91dHB1dHMsIG9yIGFuIG9iamVjdCB0aGF0IHVzZSBvdXRwdXQgbmFtZXMgYXMga2V5cyBhbmQgYVxuICAgICAqIHByZWZlcnJlZCBkYXRhIGxvY2F0aW9uIGFzIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIFdlYiBmb3IgV2ViR0wgYW5kIFdlYkdQVSBFUC5cbiAgICAgKi9cbiAgICBwcmVmZXJyZWRPdXRwdXRMb2NhdGlvbj86IE9ubnhWYWx1ZURhdGFMb2NhdGlvbiB8IHsgcmVhZG9ubHkgW291dHB1dE5hbWU6IHN0cmluZ106IE9ubnhWYWx1ZURhdGFMb2NhdGlvbiB9O1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBlbmFibGUgZ3JhcGggY2FwdHVyZS5cbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgV2ViIGZvciBXZWJHUFUgRVAuXG4gICAgICovXG4gICAgZW5hYmxlR3JhcGhDYXB0dXJlPzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIFN0b3JlIGNvbmZpZ3VyYXRpb25zIGZvciBhIHNlc3Npb24uIFNlZVxuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvb25ueHJ1bnRpbWUvYmxvYi9tYWluL2luY2x1ZGUvb25ueHJ1bnRpbWUvY29yZS9zZXNzaW9uL1xuICAgICAqIG9ubnhydW50aW1lX3Nlc3Npb25fb3B0aW9uc19jb25maWdfa2V5cy5oXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gV2ViQXNzZW1ibHkgYmFja2VuZC4gV2lsbCBzdXBwb3J0IE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlIGxhdGVyXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogZXh0cmE6IHtcbiAgICAgKiAgIHNlc3Npb246IHtcbiAgICAgKiAgICAgc2V0X2Rlbm9ybWFsX2FzX3plcm86IFwiMVwiLFxuICAgICAqICAgICBkaXNhYmxlX3ByZXBhY2tpbmc6IFwiMVwiXG4gICAgICogICB9LFxuICAgICAqICAgb3B0aW1pemF0aW9uOiB7XG4gICAgICogICAgIGVuYWJsZV9nZWx1X2FwcHJveGltYXRpb246IFwiMVwiXG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGV4dHJhPzogUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gIH1cblxuICAvLyAjcmVnaW9uIGV4ZWN1dGlvbiBwcm92aWRlcnNcblxuICAvLyBDdXJyZW50bHksIHdlIGhhdmUgdGhlIGZvbGxvd2luZyBiYWNrZW5kcyB0byBzdXBwb3J0IGV4ZWN1dGlvbiBwcm92aWRlcnM6XG4gIC8vIEJhY2tlbmQgTm9kZS5qcyBiaW5kaW5nOiBzdXBwb3J0cyAnY3B1JywgJ2RtbCcgKHdpbjMyKSwgJ2NvcmVtbCcgKG1hY09TKSBhbmQgJ2N1ZGEnIChsaW51eCkuXG4gIC8vIEJhY2tlbmQgV2ViQXNzZW1ibHk6IHN1cHBvcnRzICdjcHUnLCAnd2FzbScsICd3ZWJncHUnIGFuZCAnd2Vibm4nLlxuICAvLyBCYWNrZW5kIE9OTlguanM6IHN1cHBvcnRzICd3ZWJnbCcuXG4gIC8vIEJhY2tlbmQgUmVhY3QgTmF0aXZlOiBzdXBwb3J0cyAnY3B1JywgJ3hubnBhY2snLCAnY29yZW1sJyAoaU9TKSwgJ25uYXBpJyAoQW5kcm9pZCkuXG4gIGludGVyZmFjZSBFeGVjdXRpb25Qcm92aWRlck9wdGlvbk1hcCB7XG4gICAgY29yZW1sOiBDb3JlTUxFeGVjdXRpb25Qcm92aWRlck9wdGlvbjtcbiAgICBjcHU6IENwdUV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgIGN1ZGE6IEN1ZGFFeGVjdXRpb25Qcm92aWRlck9wdGlvbjtcbiAgICBkbWw6IERtbEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgIG5uYXBpOiBObmFwaUV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgIHRlbnNvcnJ0OiBUZW5zb3JSdEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgIHdhc206IFdlYkFzc2VtYmx5RXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XG4gICAgd2ViZ2w6IFdlYkdMRXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XG4gICAgd2ViZ3B1OiBXZWJHcHVFeGVjdXRpb25Qcm92aWRlck9wdGlvbjtcbiAgICB3ZWJubjogV2ViTk5FeGVjdXRpb25Qcm92aWRlck9wdGlvbjtcbiAgICBxbm46IFFubkV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgIHhubnBhY2s6IFhubnBhY2tFeGVjdXRpb25Qcm92aWRlck9wdGlvbjtcbiAgfVxuXG4gIHR5cGUgRXhlY3V0aW9uUHJvdmlkZXJOYW1lID0ga2V5b2YgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb25NYXA7XG4gIHR5cGUgRXhlY3V0aW9uUHJvdmlkZXJDb25maWcgPVxuICAgIHwgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb25NYXBbRXhlY3V0aW9uUHJvdmlkZXJOYW1lXVxuICAgIHwgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb25cbiAgICB8IEV4ZWN1dGlvblByb3ZpZGVyTmFtZVxuICAgIHwgc3RyaW5nO1xuXG4gIGV4cG9ydCBpbnRlcmZhY2UgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xuICAgIHJlYWRvbmx5IG5hbWU6IHN0cmluZztcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIENwdUV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIGV4dGVuZHMgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xuICAgIHJlYWRvbmx5IG5hbWU6ICdjcHUnO1xuICAgIHVzZUFyZW5hPzogYm9vbGVhbjtcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIEN1ZGFFeGVjdXRpb25Qcm92aWRlck9wdGlvbiBleHRlbmRzIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIHtcbiAgICByZWFkb25seSBuYW1lOiAnY3VkYSc7XG4gICAgZGV2aWNlSWQ/OiBudW1iZXI7XG4gIH1cbiAgZXhwb3J0IGludGVyZmFjZSBEbWxFeGVjdXRpb25Qcm92aWRlck9wdGlvbiBleHRlbmRzIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIHtcbiAgICByZWFkb25seSBuYW1lOiAnZG1sJztcbiAgICBkZXZpY2VJZD86IG51bWJlcjtcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIFRlbnNvclJ0RXhlY3V0aW9uUHJvdmlkZXJPcHRpb24gZXh0ZW5kcyBFeGVjdXRpb25Qcm92aWRlck9wdGlvbiB7XG4gICAgcmVhZG9ubHkgbmFtZTogJ3RlbnNvcnJ0JztcbiAgICBkZXZpY2VJZD86IG51bWJlcjtcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIFdlYkFzc2VtYmx5RXhlY3V0aW9uUHJvdmlkZXJPcHRpb24gZXh0ZW5kcyBFeGVjdXRpb25Qcm92aWRlck9wdGlvbiB7XG4gICAgcmVhZG9ubHkgbmFtZTogJ3dhc20nO1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViR0xFeGVjdXRpb25Qcm92aWRlck9wdGlvbiBleHRlbmRzIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIHtcbiAgICByZWFkb25seSBuYW1lOiAnd2ViZ2wnO1xuICAgIC8vIFRPRE86IGFkZCBmbGFnc1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgWG5ucGFja0V4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIGV4dGVuZHMgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xuICAgIHJlYWRvbmx5IG5hbWU6ICd4bm5wYWNrJztcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIFdlYkdwdUV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIGV4dGVuZHMgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xuICAgIHJlYWRvbmx5IG5hbWU6ICd3ZWJncHUnO1xuICAgIHByZWZlcnJlZExheW91dD86ICdOQ0hXJyB8ICdOSFdDJztcbiAgfVxuXG4gIC8vICNyZWdpb24gV2ViTk4gb3B0aW9uc1xuXG4gIGludGVyZmFjZSBXZWJOTkV4ZWN1dGlvblByb3ZpZGVyTmFtZSBleHRlbmRzIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIHtcbiAgICByZWFkb25seSBuYW1lOiAnd2Vibm4nO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgYSBzZXQgb2Ygb3B0aW9ucyBmb3IgY3JlYXRpbmcgYSBXZWJOTiBNTENvbnRleHQuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYm5uLyNkaWN0ZGVmLW1sY29udGV4dG9wdGlvbnNcbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViTk5Db250ZXh0T3B0aW9ucyB7XG4gICAgZGV2aWNlVHlwZT86ICdjcHUnIHwgJ2dwdScgfCAnbnB1JztcbiAgICBudW1UaHJlYWRzPzogbnVtYmVyO1xuICAgIHBvd2VyUHJlZmVyZW5jZT86ICdkZWZhdWx0JyB8ICdsb3ctcG93ZXInIHwgJ2hpZ2gtcGVyZm9ybWFuY2UnO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgYSBzZXQgb2Ygb3B0aW9ucyBmb3IgV2ViTk4gZXhlY3V0aW9uIHByb3ZpZGVyIHdpdGhvdXQgTUxDb250ZXh0LlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBXZWJOTk9wdGlvbnNXaXRob3V0TUxDb250ZXh0IGV4dGVuZHMgV2ViTk5FeGVjdXRpb25Qcm92aWRlck5hbWUsIFdlYk5OQ29udGV4dE9wdGlvbnMge1xuICAgIGNvbnRleHQ/OiBuZXZlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXByZXNlbnRzIGEgc2V0IG9mIG9wdGlvbnMgZm9yIFdlYk5OIGV4ZWN1dGlvbiBwcm92aWRlciB3aXRoIE1MQ29udGV4dC5cbiAgICpcbiAgICogV2hlbiBNTENvbnRleHQgaXMgcHJvdmlkZWQsIHRoZSBkZXZpY2VUeXBlIGlzIGFsc28gcmVxdWlyZWQgc28gdGhhdCB0aGUgV2ViTk4gRVAgY2FuIGRldGVybWluZSB0aGUgcHJlZmVycmVkXG4gICAqIGNoYW5uZWwgbGF5b3V0LlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJubi8jZG9tLW1sLWNyZWF0ZWNvbnRleHRcbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViTk5PcHRpb25zV2l0aE1MQ29udGV4dFxuICAgIGV4dGVuZHMgV2ViTk5FeGVjdXRpb25Qcm92aWRlck5hbWUsXG4gICAgICBPbWl0PFdlYk5OQ29udGV4dE9wdGlvbnMsICdkZXZpY2VUeXBlJz4sXG4gICAgICBSZXF1aXJlZDxQaWNrPFdlYk5OQ29udGV4dE9wdGlvbnMsICdkZXZpY2VUeXBlJz4+IHtcbiAgICBjb250ZXh0OiB1bmtub3duIC8qIE1MQ29udGV4dCAqLztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXByZXNlbnRzIGEgc2V0IG9mIG9wdGlvbnMgZm9yIFdlYk5OIGV4ZWN1dGlvbiBwcm92aWRlciB3aXRoIE1MQ29udGV4dCB3aGljaCBpcyBjcmVhdGVkIGZyb20gR1BVRGV2aWNlLlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJubi8jZG9tLW1sLWNyZWF0ZWNvbnRleHQtZ3B1ZGV2aWNlXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFdlYk5OT3B0aW9uc1dlYkdwdSBleHRlbmRzIFdlYk5ORXhlY3V0aW9uUHJvdmlkZXJOYW1lIHtcbiAgICBjb250ZXh0OiB1bmtub3duIC8qIE1MQ29udGV4dCAqLztcbiAgICBncHVEZXZpY2U6IHVua25vd24gLyogR1BVRGV2aWNlICovO1xuICB9XG5cbiAgLyoqXG4gICAqIE9wdGlvbnMgZm9yIFdlYk5OIGV4ZWN1dGlvbiBwcm92aWRlci5cbiAgICovXG4gIGV4cG9ydCB0eXBlIFdlYk5ORXhlY3V0aW9uUHJvdmlkZXJPcHRpb24gPVxuICAgIHwgV2ViTk5PcHRpb25zV2l0aG91dE1MQ29udGV4dFxuICAgIHwgV2ViTk5PcHRpb25zV2l0aE1MQ29udGV4dFxuICAgIHwgV2ViTk5PcHRpb25zV2ViR3B1O1xuXG4gIC8vICNlbmRyZWdpb25cblxuICBleHBvcnQgaW50ZXJmYWNlIFFubkV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIGV4dGVuZHMgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xuICAgIHJlYWRvbmx5IG5hbWU6ICdxbm4nO1xuICAgIC8vIFRPRE8gYWRkIGZsYWdzXG4gIH1cbiAgZXhwb3J0IGludGVyZmFjZSBDb3JlTUxFeGVjdXRpb25Qcm92aWRlck9wdGlvbiBleHRlbmRzIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIHtcbiAgICByZWFkb25seSBuYW1lOiAnY29yZW1sJztcbiAgICAvKipcbiAgICAgKiBUaGUgYml0IGZsYWdzIGZvciBDb3JlTUwgZXhlY3V0aW9uIHByb3ZpZGVyLlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogQ09SRU1MX0ZMQUdfVVNFX0NQVV9PTkxZID0gMHgwMDFcbiAgICAgKiBDT1JFTUxfRkxBR19FTkFCTEVfT05fU1VCR1JBUEggPSAweDAwMlxuICAgICAqIENPUkVNTF9GTEFHX09OTFlfRU5BQkxFX0RFVklDRV9XSVRIX0FORSA9IDB4MDA0XG4gICAgICogQ09SRU1MX0ZMQUdfT05MWV9BTExPV19TVEFUSUNfSU5QVVRfU0hBUEVTID0gMHgwMDhcbiAgICAgKiBDT1JFTUxfRkxBR19DUkVBVEVfTUxQUk9HUkFNID0gMHgwMTBcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFNlZSBpbmNsdWRlL29ubnhydW50aW1lL2NvcmUvcHJvdmlkZXJzL2NvcmVtbC9jb3JlbWxfcHJvdmlkZXJfZmFjdG9yeS5oIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBUaGlzIGZsYWcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKE5vZGUuanMgYmluZGluZykuXG4gICAgICovXG4gICAgY29yZU1sRmxhZ3M/OiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogU3BlY2lmeSB3aGV0aGVyIHRvIHVzZSBDUFUgb25seSBpbiBDb3JlTUwgRVAuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKHJlYWN0LW5hdGl2ZSkuXG4gICAgICovXG4gICAgdXNlQ1BVT25seT86IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogU3BlY2lmeSB3aGV0aGVyIHRvIGVuYWJsZSBDb3JlTUwgRVAgb24gc3ViZ3JhcGguXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKHJlYWN0LW5hdGl2ZSkuXG4gICAgICovXG4gICAgZW5hYmxlT25TdWJncmFwaD86IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogU3BlY2lmeSB3aGV0aGVyIHRvIG9ubHkgZW5hYmxlIENvcmVNTCBFUCBmb3IgQXBwbGUgZGV2aWNlcyB3aXRoIEFORSAoQXBwbGUgTmV1cmFsIEVuZ2luZSkuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKHJlYWN0LW5hdGl2ZSkuXG4gICAgICovXG4gICAgb25seUVuYWJsZURldmljZVdpdGhBTkU/OiBib29sZWFuO1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgTm5hcGlFeGVjdXRpb25Qcm92aWRlck9wdGlvbiBleHRlbmRzIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIHtcbiAgICByZWFkb25seSBuYW1lOiAnbm5hcGknO1xuICAgIHVzZUZQMTY/OiBib29sZWFuO1xuICAgIHVzZU5DSFc/OiBib29sZWFuO1xuICAgIGNwdURpc2FibGVkPzogYm9vbGVhbjtcbiAgICBjcHVPbmx5PzogYm9vbGVhbjtcbiAgfVxuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gcnVuIG9wdGlvbnNcblxuICAvKipcbiAgICogQSBzZXQgb2YgY29uZmlndXJhdGlvbnMgZm9yIGluZmVyZW5jZSBydW4gYmVoYXZpb3JcbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgUnVuT3B0aW9ucyB7XG4gICAgLyoqXG4gICAgICogTG9nIHNldmVyaXR5IGxldmVsLiBTZWVcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L29ubnhydW50aW1lL2Jsb2IvbWFpbi9pbmNsdWRlL29ubnhydW50aW1lL2NvcmUvY29tbW9uL2xvZ2dpbmcvc2V2ZXJpdHkuaFxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSkgb3IgV2ViQXNzZW1ibHkgYmFja2VuZFxuICAgICAqL1xuICAgIGxvZ1NldmVyaXR5TGV2ZWw/OiAwIHwgMSB8IDIgfCAzIHwgNDtcblxuICAgIC8qKlxuICAgICAqIExvZyB2ZXJib3NpdHkgbGV2ZWwuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gV2ViQXNzZW1ibHkgYmFja2VuZC4gV2lsbCBzdXBwb3J0IE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlIGxhdGVyXG4gICAgICovXG4gICAgbG9nVmVyYm9zaXR5TGV2ZWw/OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUZXJtaW5hdGUgYWxsIGluY29tcGxldGUgT3J0UnVuIGNhbGxzIGFzIHNvb24gYXMgcG9zc2libGUgaWYgdHJ1ZVxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIFdlYkFzc2VtYmx5IGJhY2tlbmQuIFdpbGwgc3VwcG9ydCBOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSBsYXRlclxuICAgICAqL1xuICAgIHRlcm1pbmF0ZT86IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBBIHRhZyBmb3IgdGhlIFJ1bigpIGNhbGxzIHVzaW5nIHRoaXNcbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAoTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUpIG9yIFdlYkFzc2VtYmx5IGJhY2tlbmRcbiAgICAgKi9cbiAgICB0YWc/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgYSBzaW5nbGUgcnVuIGNvbmZpZ3VyYXRpb24gZW50cnkuIFNlZVxuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvb25ueHJ1bnRpbWUvYmxvYi9tYWluL2luY2x1ZGUvb25ueHJ1bnRpbWUvY29yZS9zZXNzaW9uL1xuICAgICAqIG9ubnhydW50aW1lX3J1bl9vcHRpb25zX2NvbmZpZ19rZXlzLmhcbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBXZWJBc3NlbWJseSBiYWNrZW5kLiBXaWxsIHN1cHBvcnQgTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUgbGF0ZXJcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGBqc1xuICAgICAqIGV4dHJhOiB7XG4gICAgICogICBtZW1vcnk6IHtcbiAgICAgKiAgICAgZW5hYmxlX21lbW9yeV9hcmVuYV9zaHJpbmthZ2U6IFwiMVwiLFxuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBleHRyYT86IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuICB9XG5cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gdmFsdWUgbWV0YWRhdGFcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWludGVyZmFjZVxuICBpbnRlcmZhY2UgVmFsdWVNZXRhZGF0YSB7XG4gICAgLy8gVEJEXG4gIH1cblxuICAvLyAjZW5kcmVnaW9uXG59XG5cbi8qKlxuICogUmVwcmVzZW50IGEgcnVudGltZSBpbnN0YW5jZSBvZiBhbiBPTk5YIG1vZGVsLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEluZmVyZW5jZVNlc3Npb24ge1xuICAvLyAjcmVnaW9uIHJ1bigpXG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgdGhlIG1vZGVsIGFzeW5jaHJvbm91c2x5IHdpdGggdGhlIGdpdmVuIGZlZWRzIGFuZCBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0gZmVlZHMgLSBSZXByZXNlbnRhdGlvbiBvZiB0aGUgbW9kZWwgaW5wdXQuIFNlZSB0eXBlIGRlc2NyaXB0aW9uIG9mIGBJbmZlcmVuY2VTZXNzaW9uLklucHV0VHlwZWAgZm9yIGRldGFpbC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbC4gQSBzZXQgb2Ygb3B0aW9ucyB0aGF0IGNvbnRyb2xzIHRoZSBiZWhhdmlvciBvZiBtb2RlbCBpbmZlcmVuY2UuXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgbWFwLCB3aGljaCB1c2VzIG91dHB1dCBuYW1lcyBhcyBrZXlzIGFuZCBPbm54VmFsdWUgYXMgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAqL1xuICBydW4oZmVlZHM6IEluZmVyZW5jZVNlc3Npb24uRmVlZHNUeXBlLCBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uLlJldHVyblR5cGU+O1xuXG4gIC8qKlxuICAgKiBFeGVjdXRlIHRoZSBtb2RlbCBhc3luY2hyb25vdXNseSB3aXRoIHRoZSBnaXZlbiBmZWVkcywgZmV0Y2hlcyBhbmQgb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIGZlZWRzIC0gUmVwcmVzZW50YXRpb24gb2YgdGhlIG1vZGVsIGlucHV0LiBTZWUgdHlwZSBkZXNjcmlwdGlvbiBvZiBgSW5mZXJlbmNlU2Vzc2lvbi5JbnB1dFR5cGVgIGZvciBkZXRhaWwuXG4gICAqIEBwYXJhbSBmZXRjaGVzIC0gUmVwcmVzZW50YXRpb24gb2YgdGhlIG1vZGVsIG91dHB1dC4gU2VlIHR5cGUgZGVzY3JpcHRpb24gb2YgYEluZmVyZW5jZVNlc3Npb24uT3V0cHV0VHlwZWAgZm9yXG4gICAqIGRldGFpbC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbC4gQSBzZXQgb2Ygb3B0aW9ucyB0aGF0IGNvbnRyb2xzIHRoZSBiZWhhdmlvciBvZiBtb2RlbCBpbmZlcmVuY2UuXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgbWFwLCB3aGljaCB1c2VzIG91dHB1dCBuYW1lcyBhcyBrZXlzIGFuZCBPbm54VmFsdWUgYXMgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAqL1xuICBydW4oXG4gICAgZmVlZHM6IEluZmVyZW5jZVNlc3Npb24uRmVlZHNUeXBlLFxuICAgIGZldGNoZXM6IEluZmVyZW5jZVNlc3Npb24uRmV0Y2hlc1R5cGUsXG4gICAgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uLlJldHVyblR5cGU+O1xuXG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIHJlbGVhc2UoKVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlIHRoZSBpbmZlcmVuY2Ugc2Vzc2lvbiBhbmQgdGhlIHVuZGVybHlpbmcgcmVzb3VyY2VzLlxuICAgKi9cbiAgcmVsZWFzZSgpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIHByb2ZpbGluZ1xuXG4gIC8qKlxuICAgKiBTdGFydCBwcm9maWxpbmcuXG4gICAqL1xuICBzdGFydFByb2ZpbGluZygpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBFbmQgcHJvZmlsaW5nLlxuICAgKi9cbiAgZW5kUHJvZmlsaW5nKCk6IHZvaWQ7XG5cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gbWV0YWRhdGFcblxuICAvKipcbiAgICogR2V0IGlucHV0IG5hbWVzIG9mIHRoZSBsb2FkZWQgbW9kZWwuXG4gICAqL1xuICByZWFkb25seSBpbnB1dE5hbWVzOiByZWFkb25seSBzdHJpbmdbXTtcblxuICAvKipcbiAgICogR2V0IG91dHB1dCBuYW1lcyBvZiB0aGUgbG9hZGVkIG1vZGVsLlxuICAgKi9cbiAgcmVhZG9ubHkgb3V0cHV0TmFtZXM6IHJlYWRvbmx5IHN0cmluZ1tdO1xuXG4gIC8vIC8qKlxuICAvLyAgKiBHZXQgaW5wdXQgbWV0YWRhdGEgb2YgdGhlIGxvYWRlZCBtb2RlbC5cbiAgLy8gICovXG4gIC8vIHJlYWRvbmx5IGlucHV0TWV0YWRhdGE6IFJlYWRvbmx5QXJyYXk8UmVhZG9ubHk8SW5mZXJlbmNlU2Vzc2lvbi5WYWx1ZU1ldGFkYXRhPj47XG5cbiAgLy8gLyoqXG4gIC8vICAqIEdldCBvdXRwdXQgbWV0YWRhdGEgb2YgdGhlIGxvYWRlZCBtb2RlbC5cbiAgLy8gICovXG4gIC8vIHJlYWRvbmx5IG91dHB1dE1ldGFkYXRhOiBSZWFkb25seUFycmF5PFJlYWRvbmx5PEluZmVyZW5jZVNlc3Npb24uVmFsdWVNZXRhZGF0YT4+O1xuXG4gIC8vICNlbmRyZWdpb25cbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbmZlcmVuY2VTZXNzaW9uRmFjdG9yeSB7XG4gIC8vICNyZWdpb24gY3JlYXRlKClcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGluZmVyZW5jZSBzZXNzaW9uIGFuZCBsb2FkIG1vZGVsIGFzeW5jaHJvbm91c2x5IGZyb20gYW4gT05OWCBtb2RlbCBmaWxlLlxuICAgKlxuICAgKiBAcGFyYW0gdXJpIC0gVGhlIFVSSSBvciBmaWxlIHBhdGggb2YgdGhlIG1vZGVsIHRvIGxvYWQuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gc3BlY2lmeSBjb25maWd1cmF0aW9uIGZvciBjcmVhdGluZyBhIG5ldyBpbmZlcmVuY2Ugc2Vzc2lvbi5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gSW5mZXJlbmNlU2Vzc2lvbiBvYmplY3QuXG4gICAqL1xuICBjcmVhdGUodXJpOiBzdHJpbmcsIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uPjtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGluZmVyZW5jZSBzZXNzaW9uIGFuZCBsb2FkIG1vZGVsIGFzeW5jaHJvbm91c2x5IGZyb20gYW4gYXJyYXkgYnVmZXIuXG4gICAqXG4gICAqIEBwYXJhbSBidWZmZXIgLSBBbiBBcnJheUJ1ZmZlciByZXByZXNlbnRhdGlvbiBvZiBhbiBPTk5YIG1vZGVsLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIHNwZWNpZnkgY29uZmlndXJhdGlvbiBmb3IgY3JlYXRpbmcgYSBuZXcgaW5mZXJlbmNlIHNlc3Npb24uXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIEluZmVyZW5jZVNlc3Npb24gb2JqZWN0LlxuICAgKi9cbiAgY3JlYXRlKGJ1ZmZlcjogQXJyYXlCdWZmZXJMaWtlLCBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyk6IFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbj47XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBpbmZlcmVuY2Ugc2Vzc2lvbiBhbmQgbG9hZCBtb2RlbCBhc3luY2hyb25vdXNseSBmcm9tIHNlZ21lbnQgb2YgYW4gYXJyYXkgYnVmZXIuXG4gICAqXG4gICAqIEBwYXJhbSBidWZmZXIgLSBBbiBBcnJheUJ1ZmZlciByZXByZXNlbnRhdGlvbiBvZiBhbiBPTk5YIG1vZGVsLlxuICAgKiBAcGFyYW0gYnl0ZU9mZnNldCAtIFRoZSBiZWdpbm5pbmcgb2YgdGhlIHNwZWNpZmllZCBwb3J0aW9uIG9mIHRoZSBhcnJheSBidWZmZXIuXG4gICAqIEBwYXJhbSBieXRlTGVuZ3RoIC0gVGhlIGxlbmd0aCBpbiBieXRlcyBvZiB0aGUgYXJyYXkgYnVmZmVyLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIHNwZWNpZnkgY29uZmlndXJhdGlvbiBmb3IgY3JlYXRpbmcgYSBuZXcgaW5mZXJlbmNlIHNlc3Npb24uXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIEluZmVyZW5jZVNlc3Npb24gb2JqZWN0LlxuICAgKi9cbiAgY3JlYXRlKFxuICAgIGJ1ZmZlcjogQXJyYXlCdWZmZXJMaWtlLFxuICAgIGJ5dGVPZmZzZXQ6IG51bWJlcixcbiAgICBieXRlTGVuZ3RoPzogbnVtYmVyLFxuICAgIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zLFxuICApOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb24+O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgaW5mZXJlbmNlIHNlc3Npb24gYW5kIGxvYWQgbW9kZWwgYXN5bmNocm9ub3VzbHkgZnJvbSBhIFVpbnQ4QXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSBidWZmZXIgLSBBIFVpbnQ4QXJyYXkgcmVwcmVzZW50YXRpb24gb2YgYW4gT05OWCBtb2RlbC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBzcGVjaWZ5IGNvbmZpZ3VyYXRpb24gZm9yIGNyZWF0aW5nIGEgbmV3IGluZmVyZW5jZSBzZXNzaW9uLlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBJbmZlcmVuY2VTZXNzaW9uIG9iamVjdC5cbiAgICovXG4gIGNyZWF0ZShidWZmZXI6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uPjtcblxuICAvLyAjZW5kcmVnaW9uXG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbmV4cG9ydCBjb25zdCBJbmZlcmVuY2VTZXNzaW9uOiBJbmZlcmVuY2VTZXNzaW9uRmFjdG9yeSA9IEluZmVyZW5jZVNlc3Npb25JbXBsO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBPcHRpb25zRm9ybWF0LCBPcHRpb25zTm9ybWFsaXphdGlvblBhcmFtZXRlcnMsIE9wdGlvbnNUZW5zb3JMYXlvdXQgfSBmcm9tICcuL3RlbnNvci1mYWN0b3J5LmpzJztcblxuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JUb0RhdGFVcmxPcHRpb25zIGV4dGVuZHMgT3B0aW9uc1RlbnNvckxheW91dCwgT3B0aW9uc0Zvcm1hdCwgT3B0aW9uc05vcm1hbGl6YXRpb25QYXJhbWV0ZXJzIHt9XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGVuc29yVG9JbWFnZURhdGFPcHRpb25zIGV4dGVuZHMgT3B0aW9uc1RlbnNvckxheW91dCwgT3B0aW9uc0Zvcm1hdCwgT3B0aW9uc05vcm1hbGl6YXRpb25QYXJhbWV0ZXJzIHt9XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29udmVyc2lvblV0aWxzIHtcbiAgLyoqXG4gICAqIGNyZWF0ZXMgYSBEYXRhVVJMIGluc3RhbmNlIGZyb20gdGVuc29yXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb3B0aW9uYWwgb2JqZWN0IHJlcHJlc2VudGluZyBvcHRpb25zIGZvciBjcmVhdGluZyBhIERhdGFVUkwgaW5zdGFuY2UgZnJvbSB0aGUgdGVuc29yLlxuICAgKlxuICAgKiBUaGUgZm9sbG93aW5nIGRlZmF1bHQgc2V0dGluZ3Mgd2lsbCBiZSBhcHBsaWVkOlxuICAgKiAtIGBmb3JtYXRgOiBgJ1JHQidgXG4gICAqIC0gYHRlbnNvckxheW91dGA6IGAnTkNIVydgXG4gICAqIEByZXR1cm5zIGEgRGF0YVVSTCBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBpbWFnZSBjb252ZXJ0ZWQgZnJvbSB0ZW5zb3IgZGF0YVxuICAgKi9cbiAgdG9EYXRhVVJMKG9wdGlvbnM/OiBUZW5zb3JUb0RhdGFVcmxPcHRpb25zKTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBjcmVhdGVzIGFuIEltYWdlRGF0YSBpbnN0YW5jZSBmcm9tIHRlbnNvclxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbmFsIG9iamVjdCByZXByZXNlbnRpbmcgb3B0aW9ucyBmb3IgY3JlYXRpbmcgYW4gSW1hZ2VEYXRhIGluc3RhbmNlIGZyb20gdGhlIHRlbnNvci5cbiAgICpcbiAgICogVGhlIGZvbGxvd2luZyBkZWZhdWx0IHNldHRpbmdzIHdpbGwgYmUgYXBwbGllZDpcbiAgICogLSBgZm9ybWF0YDogYCdSR0InYFxuICAgKiAtIGB0ZW5zb3JMYXlvdXRgOiBgJ05DSFcnYFxuICAgKiBAcmV0dXJucyBhbiBJbWFnZURhdGEgaW5zdGFuY2UgcmVwcmVzZW50aW5nIHRoZSBpbWFnZSBjb252ZXJ0ZWQgZnJvbSB0ZW5zb3IgZGF0YVxuICAgKi9cbiAgdG9JbWFnZURhdGEob3B0aW9ucz86IFRlbnNvclRvSW1hZ2VEYXRhT3B0aW9ucyk6IEltYWdlRGF0YTtcbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgVGVuc29yLCBUeXBlZFRlbnNvciB9IGZyb20gJy4vdGVuc29yLmpzJztcblxuZXhwb3J0IHR5cGUgSW1hZ2VGb3JtYXQgPSAnUkdCJyB8ICdSR0JBJyB8ICdCR1InIHwgJ1JCRyc7XG5leHBvcnQgdHlwZSBJbWFnZVRlbnNvckxheW91dCA9ICdOSFdDJyB8ICdOQ0hXJztcblxuLy8gdGhlIGZvbGxvd2luZyByZWdpb24gY29udGFpbnMgdHlwZSBkZWZpbml0aW9ucyBmb3IgY29uc3RydWN0aW5nIHRlbnNvciBmcm9tIGEgc3BlY2lmaWMgbG9jYXRpb24uXG5cbi8vICNyZWdpb24gdHlwZXMgZm9yIGNvbnN0cnVjdGluZyBhIHRlbnNvciBmcm9tIGEgc3BlY2lmaWMgbG9jYXRpb25cblxuLyoqXG4gKiByZXByZXNlbnQgY29tbW9uIHByb3BlcnRpZXMgb2YgdGhlIHBhcmFtZXRlciBmb3IgY29uc3RydWN0aW5nIGEgdGVuc29yIGZyb20gYSBzcGVjaWZpYyBsb2NhdGlvbi5cbiAqL1xuaW50ZXJmYWNlIENvbW1vbkNvbnN0cnVjdG9yUGFyYW1ldGVyczxUPiBleHRlbmRzIFBpY2s8VGVuc29yLCAnZGltcyc+IHtcbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIGRhdGEgdHlwZSBvZiB0aGUgdGVuc29yLlxuICAgKi9cbiAgcmVhZG9ubHkgdHlwZTogVDtcbn1cblxuLyoqXG4gKiByZXByZXNlbnQgdGhlIHBhcmFtZXRlciBmb3IgY29uc3RydWN0aW5nIGEgdGVuc29yIGZyb20gYSBHUFUgcmVzb3VyY2UuXG4gKi9cbmludGVyZmFjZSBHcHVSZXNvdXJjZUNvbnN0cnVjdG9yUGFyYW1ldGVyczxUIGV4dGVuZHMgVGVuc29yLlR5cGU+IHtcbiAgLyoqXG4gICAqIGFuIG9wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGRvd25sb2FkIGRhdGEgZnJvbSBHUFUgdG8gQ1BVLlxuICAgKlxuICAgKiBJZiBub3QgcHJvdmlkZWQsIHRoZSB0ZW5zb3IgdHJlYXQgdGhlIEdQVSBkYXRhIGFzIGV4dGVybmFsIHJlc291cmNlLlxuICAgKi9cbiAgZG93bmxvYWQ/KCk6IFByb21pc2U8VGVuc29yLkRhdGFUeXBlTWFwW1RdPjtcblxuICAvKipcbiAgICogYW4gb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSB0ZW5zb3IgaXMgZGlzcG9zZWQuXG4gICAqXG4gICAqIElmIG5vdCBwcm92aWRlZCwgdGhlIHRlbnNvciB0cmVhdCB0aGUgR1BVIGRhdGEgYXMgZXh0ZXJuYWwgcmVzb3VyY2UuXG4gICAqL1xuICBkaXNwb3NlPygpOiB2b2lkO1xufVxuXG4vKipcbiAqIHJlcHJlc2VudCB0aGUgcGFyYW1ldGVyIGZvciBjb25zdHJ1Y3RpbmcgYSB0ZW5zb3IgZnJvbSBhIHBpbm5lZCBDUFUgYnVmZmVyXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ3B1UGlubmVkQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQgZXh0ZW5kcyBUZW5zb3IuQ3B1UGlubmVkRGF0YVR5cGVzID0gVGVuc29yLkNwdVBpbm5lZERhdGFUeXBlcz5cbiAgZXh0ZW5kcyBDb21tb25Db25zdHJ1Y3RvclBhcmFtZXRlcnM8VD4ge1xuICAvKipcbiAgICogU3BlY2lmeSB0aGUgbG9jYXRpb24gb2YgdGhlIGRhdGEgdG8gYmUgJ2NwdS1waW5uZWQnLlxuICAgKi9cbiAgcmVhZG9ubHkgbG9jYXRpb246ICdjcHUtcGlubmVkJztcbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIENQVSBwaW5uZWQgYnVmZmVyIHRoYXQgaG9sZHMgdGhlIHRlbnNvciBkYXRhLlxuICAgKi9cbiAgcmVhZG9ubHkgZGF0YTogVGVuc29yLkRhdGFUeXBlTWFwW1RdO1xufVxuXG4vKipcbiAqIHJlcHJlc2VudCB0aGUgcGFyYW1ldGVyIGZvciBjb25zdHJ1Y3RpbmcgYSB0ZW5zb3IgZnJvbSBhIFdlYkdMIHRleHR1cmVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUZXh0dXJlQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQgZXh0ZW5kcyBUZW5zb3IuVGV4dHVyZURhdGFUeXBlcyA9IFRlbnNvci5UZXh0dXJlRGF0YVR5cGVzPlxuICBleHRlbmRzIENvbW1vbkNvbnN0cnVjdG9yUGFyYW1ldGVyczxUPixcbiAgICBHcHVSZXNvdXJjZUNvbnN0cnVjdG9yUGFyYW1ldGVyczxUPiB7XG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSBsb2NhdGlvbiBvZiB0aGUgZGF0YSB0byBiZSAndGV4dHVyZScuXG4gICAqL1xuICByZWFkb25seSBsb2NhdGlvbjogJ3RleHR1cmUnO1xuICAvKipcbiAgICogU3BlY2lmeSB0aGUgV2ViR0wgdGV4dHVyZSB0aGF0IGhvbGRzIHRoZSB0ZW5zb3IgZGF0YS5cbiAgICovXG4gIHJlYWRvbmx5IHRleHR1cmU6IFRlbnNvci5UZXh0dXJlVHlwZTtcbn1cblxuLyoqXG4gKiByZXByZXNlbnQgdGhlIHBhcmFtZXRlciBmb3IgY29uc3RydWN0aW5nIGEgdGVuc29yIGZyb20gYSBXZWJHUFUgYnVmZmVyXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgR3B1QnVmZmVyQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQgZXh0ZW5kcyBUZW5zb3IuR3B1QnVmZmVyRGF0YVR5cGVzID0gVGVuc29yLkdwdUJ1ZmZlckRhdGFUeXBlcz5cbiAgZXh0ZW5kcyBDb21tb25Db25zdHJ1Y3RvclBhcmFtZXRlcnM8VD4sXG4gICAgR3B1UmVzb3VyY2VDb25zdHJ1Y3RvclBhcmFtZXRlcnM8VD4ge1xuICAvKipcbiAgICogU3BlY2lmeSB0aGUgbG9jYXRpb24gb2YgdGhlIGRhdGEgdG8gYmUgJ2dwdS1idWZmZXInLlxuICAgKi9cbiAgcmVhZG9ubHkgbG9jYXRpb246ICdncHUtYnVmZmVyJztcbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIFdlYkdQVSBidWZmZXIgdGhhdCBob2xkcyB0aGUgdGVuc29yIGRhdGEuXG4gICAqL1xuICByZWFkb25seSBncHVCdWZmZXI6IFRlbnNvci5HcHVCdWZmZXJUeXBlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1MVGVuc29yQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQgZXh0ZW5kcyBUZW5zb3IuTUxUZW5zb3JEYXRhVHlwZXMgPSBUZW5zb3IuTUxUZW5zb3JEYXRhVHlwZXM+XG4gIGV4dGVuZHMgQ29tbW9uQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQ+LFxuICAgIEdwdVJlc291cmNlQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQ+IHtcbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIGxvY2F0aW9uIG9mIHRoZSBkYXRhIHRvIGJlICdtbC10ZW5zb3InLlxuICAgKi9cbiAgcmVhZG9ubHkgbG9jYXRpb246ICdtbC10ZW5zb3InO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSBXZWJOTiBNTFRlbnNvciB0aGF0IGhvbGRzIHRoZSB0ZW5zb3IgZGF0YS5cbiAgICovXG4gIHJlYWRvbmx5IG1sVGVuc29yOiBUZW5zb3IuTUxUZW5zb3JUeXBlO1xufVxuXG4vLyAjZW5kcmVnaW9uXG5cbi8vIHRoZSBmb2xsb3dpbmcgcmVnaW9uIGNvbnRhaW5zIHR5cGUgZGVmaW5pdGlvbnMgb2YgZWFjaCBpbmRpdmlkdWFsIG9wdGlvbnMuXG4vLyB0aGUgdGVuc29yIGZhY3RvcnkgZnVuY3Rpb25zIHVzZSBhIGNvbXBvc2l0aW9uIG9mIHRob3NlIG9wdGlvbnMgYXMgdGhlIHBhcmFtZXRlciB0eXBlLlxuXG4vLyAjcmVnaW9uIE9wdGlvbnMgZmllbGRzXG5cbmV4cG9ydCBpbnRlcmZhY2UgT3B0aW9uc0Zvcm1hdCB7XG4gIC8qKlxuICAgKiBEZXNjcmliZXMgdGhlIGltYWdlIGZvcm1hdCByZXByZXNlbnRlZCBpbiBSR0JBIGNvbG9yIHNwYWNlLlxuICAgKi9cbiAgZm9ybWF0PzogSW1hZ2VGb3JtYXQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3B0aW9uc1RlbnNvckZvcm1hdCB7XG4gIC8qKlxuICAgKiBEZXNjcmliZXMgdGhlIGltYWdlIGZvcm1hdCBvZiB0aGUgdGVuc29yLlxuICAgKlxuICAgKiBOT1RFOiB0aGlzIGlzIGRpZmZlcmVudCBmcm9tIG9wdGlvbiAnZm9ybWF0Jy4gV2hpbGUgb3B0aW9uICdmb3JtYXQnIHJlcHJlc2VudHMgdGhlIG9yaWdpbmFsIGltYWdlLCAndGVuc29yRm9ybWF0J1xuICAgKiByZXByZXNlbnRzIHRoZSB0YXJnZXQgZm9ybWF0IG9mIHRoZSB0ZW5zb3IuIEEgdHJhbnNwb3NlIHdpbGwgYmUgcGVyZm9ybWVkIGlmIHRoZXkgYXJlIGRpZmZlcmVudC5cbiAgICovXG4gIHRlbnNvckZvcm1hdD86IEltYWdlRm9ybWF0O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE9wdGlvbnNUZW5zb3JEYXRhVHlwZSB7XG4gIC8qKlxuICAgKiBEZXNjcmliZXMgdGhlIGRhdGEgdHlwZSBvZiB0aGUgdGVuc29yLlxuICAgKi9cbiAgZGF0YVR5cGU/OiAnZmxvYXQzMicgfCAndWludDgnO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE9wdGlvbnNUZW5zb3JMYXlvdXQge1xuICAvKipcbiAgICogRGVzY3JpYmVzIHRoZSB0ZW5zb3IgbGF5b3V0IHdoZW4gcmVwcmVzZW50aW5nIGRhdGEgb2Ygb25lIG9yIG1vcmUgaW1hZ2UocykuXG4gICAqL1xuICB0ZW5zb3JMYXlvdXQ/OiBJbWFnZVRlbnNvckxheW91dDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBPcHRpb25zRGltZW5zaW9ucyB7XG4gIC8qKlxuICAgKiBEZXNjcmliZXMgdGhlIGltYWdlIGhlaWdodCBpbiBwaXhlbFxuICAgKi9cbiAgaGVpZ2h0PzogbnVtYmVyO1xuICAvKipcbiAgICogRGVzY3JpYmVzIHRoZSBpbWFnZSB3aWR0aCBpbiBwaXhlbFxuICAgKi9cbiAgd2lkdGg/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3B0aW9uUmVzaXplZERpbWVuc2lvbnMge1xuICAvKipcbiAgICogRGVzY3JpYmVzIHRoZSByZXNpemVkIGhlaWdodC4gSWYgb21pdHRlZCwgb3JpZ2luYWwgaGVpZ2h0IHdpbGwgYmUgdXNlZC5cbiAgICovXG4gIHJlc2l6ZWRIZWlnaHQ/OiBudW1iZXI7XG4gIC8qKlxuICAgKiBEZXNjcmliZXMgcmVzaXplZCB3aWR0aCAtIGNhbiBiZSBhY2Nlc3NlZCB2aWEgdGVuc29yIGRpbWVuc2lvbnMgYXMgd2VsbFxuICAgKi9cbiAgcmVzaXplZFdpZHRoPzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE9wdGlvbnNOb3JtYWxpemF0aW9uUGFyYW1ldGVycyB7XG4gIC8qKlxuICAgKiBEZXNjcmliZXMgbm9ybWFsaXphdGlvbiBwYXJhbWV0ZXJzIHdoZW4gcHJlcHJvY2Vzc2luZyB0aGUgaW1hZ2UgYXMgbW9kZWwgaW5wdXQuXG4gICAqXG4gICAqIERhdGEgZWxlbWVudCBhcmUgcmFuZ2VkIGZyb20gMCB0byAyNTUuXG4gICAqL1xuICBub3JtPzoge1xuICAgIC8qKlxuICAgICAqIFRoZSAnYmlhcycgdmFsdWUgZm9yIGltYWdlIG5vcm1hbGl6YXRpb24uXG4gICAgICogLSBJZiBvbWl0dGVkLCB1c2UgZGVmYXVsdCB2YWx1ZSAwLlxuICAgICAqIC0gSWYgaXQncyBhIHNpbmdsZSBudW1iZXIsIGFwcGx5IHRvIGVhY2ggY2hhbm5lbFxuICAgICAqIC0gSWYgaXQncyBhbiBhcnJheSBvZiAzIG9yIDQgbnVtYmVycywgYXBwbHkgZWxlbWVudC13aXNlLiBOdW1iZXIgb2YgZWxlbWVudHMgbmVlZCB0byBtYXRjaCB0aGUgbnVtYmVyIG9mIGNoYW5uZWxzXG4gICAgICogZm9yIHRoZSBjb3JyZXNwb25kaW5nIGltYWdlIGZvcm1hdFxuICAgICAqL1xuICAgIGJpYXM/OiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gfCBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgICAvKipcbiAgICAgKiBUaGUgJ21lYW4nIHZhbHVlIGZvciBpbWFnZSBub3JtYWxpemF0aW9uLlxuICAgICAqIC0gSWYgb21pdHRlZCwgdXNlIGRlZmF1bHQgdmFsdWUgMjU1LlxuICAgICAqIC0gSWYgaXQncyBhIHNpbmdsZSBudW1iZXIsIGFwcGx5IHRvIGVhY2ggY2hhbm5lbFxuICAgICAqIC0gSWYgaXQncyBhbiBhcnJheSBvZiAzIG9yIDQgbnVtYmVycywgYXBwbHkgZWxlbWVudC13aXNlLiBOdW1iZXIgb2YgZWxlbWVudHMgbmVlZCB0byBtYXRjaCB0aGUgbnVtYmVyIG9mIGNoYW5uZWxzXG4gICAgICogZm9yIHRoZSBjb3JyZXNwb25kaW5nIGltYWdlIGZvcm1hdFxuICAgICAqL1xuICAgIG1lYW4/OiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gfCBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgfTtcbn1cblxuLy8gI2VuZHJlZ2lvblxuXG4vLyAjcmVnaW9uIE9wdGlvbnMgY29tcG9zaXRpb25cblxuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JGcm9tSW1hZ2VEYXRhT3B0aW9uc1xuICBleHRlbmRzIE9wdGlvblJlc2l6ZWREaW1lbnNpb25zLFxuICAgIE9wdGlvbnNUZW5zb3JGb3JtYXQsXG4gICAgT3B0aW9uc1RlbnNvckxheW91dCxcbiAgICBPcHRpb25zVGVuc29yRGF0YVR5cGUsXG4gICAgT3B0aW9uc05vcm1hbGl6YXRpb25QYXJhbWV0ZXJzIHt9XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGVuc29yRnJvbUltYWdlRWxlbWVudE9wdGlvbnNcbiAgZXh0ZW5kcyBPcHRpb25SZXNpemVkRGltZW5zaW9ucyxcbiAgICBPcHRpb25zVGVuc29yRm9ybWF0LFxuICAgIE9wdGlvbnNUZW5zb3JMYXlvdXQsXG4gICAgT3B0aW9uc1RlbnNvckRhdGFUeXBlLFxuICAgIE9wdGlvbnNOb3JtYWxpemF0aW9uUGFyYW1ldGVycyB7fVxuXG5leHBvcnQgaW50ZXJmYWNlIFRlbnNvckZyb21VcmxPcHRpb25zXG4gIGV4dGVuZHMgT3B0aW9uc0RpbWVuc2lvbnMsXG4gICAgT3B0aW9uUmVzaXplZERpbWVuc2lvbnMsXG4gICAgT3B0aW9uc1RlbnNvckZvcm1hdCxcbiAgICBPcHRpb25zVGVuc29yTGF5b3V0LFxuICAgIE9wdGlvbnNUZW5zb3JEYXRhVHlwZSxcbiAgICBPcHRpb25zTm9ybWFsaXphdGlvblBhcmFtZXRlcnMge31cblxuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JGcm9tSW1hZ2VCaXRtYXBPcHRpb25zXG4gIGV4dGVuZHMgT3B0aW9uUmVzaXplZERpbWVuc2lvbnMsXG4gICAgT3B0aW9uc1RlbnNvckZvcm1hdCxcbiAgICBPcHRpb25zVGVuc29yTGF5b3V0LFxuICAgIE9wdGlvbnNUZW5zb3JEYXRhVHlwZSxcbiAgICBPcHRpb25zTm9ybWFsaXphdGlvblBhcmFtZXRlcnMge31cblxuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JGcm9tVGV4dHVyZU9wdGlvbnM8VCBleHRlbmRzIFRlbnNvci5UZXh0dXJlRGF0YVR5cGVzPlxuICBleHRlbmRzIFJlcXVpcmVkPE9wdGlvbnNEaW1lbnNpb25zPixcbiAgICBPcHRpb25zRm9ybWF0LFxuICAgIEdwdVJlc291cmNlQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQ+IC8qIFRPRE86IGFkZCBtb3JlICovIHt9XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGVuc29yRnJvbUdwdUJ1ZmZlck9wdGlvbnM8VCBleHRlbmRzIFRlbnNvci5HcHVCdWZmZXJEYXRhVHlwZXM+XG4gIGV4dGVuZHMgUGljazxUZW5zb3IsICdkaW1zJz4sXG4gICAgR3B1UmVzb3VyY2VDb25zdHJ1Y3RvclBhcmFtZXRlcnM8VD4ge1xuICAvKipcbiAgICogRGVzY3JpYmVzIHRoZSBkYXRhIHR5cGUgb2YgdGhlIHRlbnNvci5cbiAgICovXG4gIGRhdGFUeXBlPzogVDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JGcm9tTUxUZW5zb3JPcHRpb25zPFQgZXh0ZW5kcyBUZW5zb3IuTUxUZW5zb3JEYXRhVHlwZXM+XG4gIGV4dGVuZHMgUGljazxUZW5zb3IsICdkaW1zJz4sXG4gICAgR3B1UmVzb3VyY2VDb25zdHJ1Y3RvclBhcmFtZXRlcnM8VD4ge1xuICAvKipcbiAgICogRGVzY3JpYmVzIHRoZSBkYXRhIHR5cGUgb2YgdGhlIHRlbnNvci5cbiAgICovXG4gIGRhdGFUeXBlPzogVDtcbn1cblxuLy8gI2VuZHJlZ2lvblxuXG4vKipcbiAqIHR5cGUgVGVuc29yRmFjdG9yeSBkZWZpbmVzIHRoZSBmYWN0b3J5IGZ1bmN0aW9ucyBvZiAnVGVuc29yJyB0byBjcmVhdGUgdGVuc29yIGluc3RhbmNlcyBmcm9tIGV4aXN0aW5nIGRhdGEgb3JcbiAqIHJlc291cmNlcy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JGYWN0b3J5IHtcbiAgLyoqXG4gICAqIGNyZWF0ZSBhIHRlbnNvciBmcm9tIGFuIEltYWdlRGF0YSBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIGltYWdlRGF0YSAtIHRoZSBJbWFnZURhdGEgb2JqZWN0IHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbVxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbmFsIG9iamVjdCByZXByZXNlbnRpbmcgb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGVuc29yIGZyb20gSW1hZ2VEYXRhLlxuICAgKlxuICAgKiBUaGUgZm9sbG93aW5nIGRlZmF1bHQgc2V0dGluZ3Mgd2lsbCBiZSBhcHBsaWVkOlxuICAgKiAtIGB0ZW5zb3JGb3JtYXRgOiBgJ1JHQidgXG4gICAqIC0gYHRlbnNvckxheW91dGA6IGAnTkNIVydgXG4gICAqIC0gYGRhdGFUeXBlYDogYCdmbG9hdDMyJ2BcbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSB0ZW5zb3Igb2JqZWN0XG4gICAqL1xuICBmcm9tSW1hZ2UoXG4gICAgaW1hZ2VEYXRhOiBJbWFnZURhdGEsXG4gICAgb3B0aW9ucz86IFRlbnNvckZyb21JbWFnZURhdGFPcHRpb25zLFxuICApOiBQcm9taXNlPFR5cGVkVGVuc29yPCdmbG9hdDMyJz4gfCBUeXBlZFRlbnNvcjwndWludDgnPj47XG5cbiAgLyoqXG4gICAqIGNyZWF0ZSBhIHRlbnNvciBmcm9tIGEgSFRNTEltYWdlRWxlbWVudCBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIGltYWdlRWxlbWVudCAtIHRoZSBIVE1MSW1hZ2VFbGVtZW50IG9iamVjdCB0byBjcmVhdGUgdGVuc29yIGZyb21cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25hbCBvYmplY3QgcmVwcmVzZW50aW5nIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRlbnNvciBmcm9tIEhUTUxJbWFnZUVsZW1lbnQuXG4gICAqXG4gICAqIFRoZSBmb2xsb3dpbmcgZGVmYXVsdCBzZXR0aW5ncyB3aWxsIGJlIGFwcGxpZWQ6XG4gICAqIC0gYHRlbnNvckZvcm1hdGA6IGAnUkdCJ2BcbiAgICogLSBgdGVuc29yTGF5b3V0YDogYCdOQ0hXJ2BcbiAgICogLSBgZGF0YVR5cGVgOiBgJ2Zsb2F0MzInYFxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIHRlbnNvciBvYmplY3RcbiAgICovXG4gIGZyb21JbWFnZShcbiAgICBpbWFnZUVsZW1lbnQ6IEhUTUxJbWFnZUVsZW1lbnQsXG4gICAgb3B0aW9ucz86IFRlbnNvckZyb21JbWFnZUVsZW1lbnRPcHRpb25zLFxuICApOiBQcm9taXNlPFR5cGVkVGVuc29yPCdmbG9hdDMyJz4gfCBUeXBlZFRlbnNvcjwndWludDgnPj47XG5cbiAgLyoqXG4gICAqIGNyZWF0ZSBhIHRlbnNvciBmcm9tIFVSTFxuICAgKlxuICAgKiBAcGFyYW0gdXJsU291cmNlIC0gYSBzdHJpbmcgYXMgYSBVUkwgdG8gdGhlIGltYWdlIG9yIGEgZGF0YSBVUkwgY29udGFpbmluZyB0aGUgaW1hZ2UgZGF0YS5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25hbCBvYmplY3QgcmVwcmVzZW50aW5nIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRlbnNvciBmcm9tIFVSTC5cbiAgICpcbiAgICogVGhlIGZvbGxvd2luZyBkZWZhdWx0IHNldHRpbmdzIHdpbGwgYmUgYXBwbGllZDpcbiAgICogLSBgdGVuc29yRm9ybWF0YDogYCdSR0InYFxuICAgKiAtIGB0ZW5zb3JMYXlvdXRgOiBgJ05DSFcnYFxuICAgKiAtIGBkYXRhVHlwZWA6IGAnZmxvYXQzMidgXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgdGVuc29yIG9iamVjdFxuICAgKi9cbiAgZnJvbUltYWdlKHVybFNvdXJjZTogc3RyaW5nLCBvcHRpb25zPzogVGVuc29yRnJvbVVybE9wdGlvbnMpOiBQcm9taXNlPFR5cGVkVGVuc29yPCdmbG9hdDMyJz4gfCBUeXBlZFRlbnNvcjwndWludDgnPj47XG5cbiAgLyoqXG4gICAqIGNyZWF0ZSBhIHRlbnNvciBmcm9tIGFuIEltYWdlQml0bWFwIG9iamVjdFxuICAgKlxuICAgKiBAcGFyYW0gYml0bWFwIC0gdGhlIEltYWdlQml0bWFwIG9iamVjdCB0byBjcmVhdGUgdGVuc29yIGZyb21cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25hbCBvYmplY3QgcmVwcmVzZW50aW5nIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRlbnNvciBmcm9tIFVSTC5cbiAgICpcbiAgICogVGhlIGZvbGxvd2luZyBkZWZhdWx0IHNldHRpbmdzIHdpbGwgYmUgYXBwbGllZDpcbiAgICogLSBgdGVuc29yRm9ybWF0YDogYCdSR0InYFxuICAgKiAtIGB0ZW5zb3JMYXlvdXRgOiBgJ05DSFcnYFxuICAgKiAtIGBkYXRhVHlwZWA6IGAnZmxvYXQzMidgXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgdGVuc29yIG9iamVjdFxuICAgKi9cbiAgZnJvbUltYWdlKFxuICAgIGJpdG1hcDogSW1hZ2VCaXRtYXAsXG4gICAgb3B0aW9uczogVGVuc29yRnJvbUltYWdlQml0bWFwT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxUeXBlZFRlbnNvcjwnZmxvYXQzMic+IHwgVHlwZWRUZW5zb3I8J3VpbnQ4Jz4+O1xuXG4gIC8qKlxuICAgKiBjcmVhdGUgYSB0ZW5zb3IgZnJvbSBhIFdlYkdMIHRleHR1cmVcbiAgICpcbiAgICogQHBhcmFtIHRleHR1cmUgLSB0aGUgV2ViR0xUZXh0dXJlIG9iamVjdCB0byBjcmVhdGUgdGVuc29yIGZyb21cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25hbCBvYmplY3QgcmVwcmVzZW50aW5nIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRlbnNvciBmcm9tIFdlYkdMIHRleHR1cmUuXG4gICAqXG4gICAqIFRoZSBvcHRpb25zIGluY2x1ZGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqIC0gYHdpZHRoYDogdGhlIHdpZHRoIG9mIHRoZSB0ZXh0dXJlLiBSZXF1aXJlZC5cbiAgICogLSBgaGVpZ2h0YDogdGhlIGhlaWdodCBvZiB0aGUgdGV4dHVyZS4gUmVxdWlyZWQuXG4gICAqIC0gYGZvcm1hdGA6IHRoZSBmb3JtYXQgb2YgdGhlIHRleHR1cmUuIElmIG9taXR0ZWQsIGFzc3VtZSAnUkdCQScuXG4gICAqIC0gYGRvd25sb2FkYDogYW4gb3B0aW9uYWwgZnVuY3Rpb24gdG8gZG93bmxvYWQgdGhlIHRlbnNvciBkYXRhIGZyb20gR1BVIHRvIENQVS4gSWYgb21pdHRlZCwgdGhlIEdQVSBkYXRhXG4gICAqIHdpbGwgbm90IGJlIGFibGUgdG8gZG93bmxvYWQuIFVzdWFsbHksIHRoaXMgaXMgcHJvdmlkZWQgYnkgYSBHUFUgYmFja2VuZCBmb3IgdGhlIGluZmVyZW5jZSBvdXRwdXRzLiBVc2VycyBkb24ndFxuICAgKiBuZWVkIHRvIHByb3ZpZGUgdGhpcyBmdW5jdGlvbi5cbiAgICogLSBgZGlzcG9zZWA6IGFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIGRpc3Bvc2UgdGhlIHRlbnNvciBkYXRhIG9uIEdQVS4gSWYgb21pdHRlZCwgdGhlIEdQVSBkYXRhIHdpbGwgbm90IGJlIGRpc3Bvc2VkLlxuICAgKiBVc3VhbGx5LCB0aGlzIGlzIHByb3ZpZGVkIGJ5IGEgR1BVIGJhY2tlbmQgZm9yIHRoZSBpbmZlcmVuY2Ugb3V0cHV0cy4gVXNlcnMgZG9uJ3QgbmVlZCB0byBwcm92aWRlIHRoaXMgZnVuY3Rpb24uXG4gICAqXG4gICAqIEByZXR1cm5zIGEgdGVuc29yIG9iamVjdFxuICAgKi9cbiAgZnJvbVRleHR1cmU8VCBleHRlbmRzIFRlbnNvci5UZXh0dXJlRGF0YVR5cGVzID0gJ2Zsb2F0MzInPihcbiAgICB0ZXh0dXJlOiBUZW5zb3IuVGV4dHVyZVR5cGUsXG4gICAgb3B0aW9uczogVGVuc29yRnJvbVRleHR1cmVPcHRpb25zPFQ+LFxuICApOiBUeXBlZFRlbnNvcjwnZmxvYXQzMic+O1xuXG4gIC8qKlxuICAgKiBjcmVhdGUgYSB0ZW5zb3IgZnJvbSBhIFdlYkdQVSBidWZmZXJcbiAgICpcbiAgICogQHBhcmFtIGJ1ZmZlciAtIHRoZSBHUFVCdWZmZXIgb2JqZWN0IHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbVxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbmFsIG9iamVjdCByZXByZXNlbnRpbmcgb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGVuc29yIGZyb20gV2ViR1BVIGJ1ZmZlci5cbiAgICpcbiAgICogVGhlIG9wdGlvbnMgaW5jbHVkZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICogLSBgZGF0YVR5cGVgOiB0aGUgZGF0YSB0eXBlIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGFzc3VtZSAnZmxvYXQzMicuXG4gICAqIC0gYGRpbXNgOiB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIFJlcXVpcmVkLlxuICAgKiAtIGBkb3dubG9hZGA6IGFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIGRvd25sb2FkIHRoZSB0ZW5zb3IgZGF0YSBmcm9tIEdQVSB0byBDUFUuIElmIG9taXR0ZWQsIHRoZSBHUFUgZGF0YVxuICAgKiB3aWxsIG5vdCBiZSBhYmxlIHRvIGRvd25sb2FkLiBVc3VhbGx5LCB0aGlzIGlzIHByb3ZpZGVkIGJ5IGEgR1BVIGJhY2tlbmQgZm9yIHRoZSBpbmZlcmVuY2Ugb3V0cHV0cy4gVXNlcnMgZG9uJ3RcbiAgICogbmVlZCB0byBwcm92aWRlIHRoaXMgZnVuY3Rpb24uXG4gICAqIC0gYGRpc3Bvc2VgOiBhbiBvcHRpb25hbCBmdW5jdGlvbiB0byBkaXNwb3NlIHRoZSB0ZW5zb3IgZGF0YSBvbiBHUFUuIElmIG9taXR0ZWQsIHRoZSBHUFUgZGF0YSB3aWxsIG5vdCBiZSBkaXNwb3NlZC5cbiAgICogVXN1YWxseSwgdGhpcyBpcyBwcm92aWRlZCBieSBhIEdQVSBiYWNrZW5kIGZvciB0aGUgaW5mZXJlbmNlIG91dHB1dHMuIFVzZXJzIGRvbid0IG5lZWQgdG8gcHJvdmlkZSB0aGlzIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJucyBhIHRlbnNvciBvYmplY3RcbiAgICovXG4gIGZyb21HcHVCdWZmZXI8VCBleHRlbmRzIFRlbnNvci5HcHVCdWZmZXJEYXRhVHlwZXM+KFxuICAgIGJ1ZmZlcjogVGVuc29yLkdwdUJ1ZmZlclR5cGUsXG4gICAgb3B0aW9uczogVGVuc29yRnJvbUdwdUJ1ZmZlck9wdGlvbnM8VD4sXG4gICk6IFR5cGVkVGVuc29yPFQ+O1xuXG4gIC8qKlxuICAgKiBjcmVhdGUgYSB0ZW5zb3IgZnJvbSBhIFdlYk5OIE1MVGVuc29yXG4gICAqXG4gICAqIEBwYXJhbSB0ZW5zb3IgLSB0aGUgTUxUZW5zb3Igb2JqZWN0IHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbVxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbmFsIG9iamVjdCByZXByZXNlbnRpbmcgb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGVuc29yIGZyb20gYSBXZWJOTiBNTFRlbnNvci5cbiAgICpcbiAgICogVGhlIG9wdGlvbnMgaW5jbHVkZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICogLSBgZGF0YVR5cGVgOiB0aGUgZGF0YSB0eXBlIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGFzc3VtZSAnZmxvYXQzMicuXG4gICAqIC0gYGRpbXNgOiB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIFJlcXVpcmVkLlxuICAgKiAtIGBkb3dubG9hZGA6IGFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIGRvd25sb2FkIHRoZSB0ZW5zb3IgZGF0YSBmcm9tIHRoZSBNTFRlbnNvciB0byBDUFUuIElmIG9taXR0ZWQsIHRoZSBNTFRlbnNvclxuICAgKiBkYXRhIHdpbGwgbm90IGJlIGFibGUgdG8gZG93bmxvYWQuIFVzdWFsbHksIHRoaXMgaXMgcHJvdmlkZWQgYnkgdGhlIFdlYk5OIGJhY2tlbmQgZm9yIHRoZSBpbmZlcmVuY2Ugb3V0cHV0cy5cbiAgICogVXNlcnMgZG9uJ3QgbmVlZCB0byBwcm92aWRlIHRoaXMgZnVuY3Rpb24uXG4gICAqIC0gYGRpc3Bvc2VgOiBhbiBvcHRpb25hbCBmdW5jdGlvbiB0byBkaXNwb3NlIHRoZSB0ZW5zb3IgZGF0YSBvbiB0aGUgV2ViTk4gTUxUZW5zb3IuIElmIG9taXR0ZWQsIHRoZSBNTFRlbnNvciB3aWxsXG4gICAqIG5vdCBiZSBkaXNwb3NlZC4gVXN1YWxseSwgdGhpcyBpcyBwcm92aWRlZCBieSB0aGUgV2ViTk4gYmFja2VuZCBmb3IgdGhlIGluZmVyZW5jZSBvdXRwdXRzLiBVc2VycyBkb24ndCBuZWVkIHRvXG4gICAqIHByb3ZpZGUgdGhpcyBmdW5jdGlvbi5cbiAgICpcbiAgICogQHJldHVybnMgYSB0ZW5zb3Igb2JqZWN0XG4gICAqL1xuICBmcm9tTUxUZW5zb3I8VCBleHRlbmRzIFRlbnNvci5NTFRlbnNvckRhdGFUeXBlcz4oXG4gICAgdGVuc29yOiBUZW5zb3IuTUxUZW5zb3JUeXBlLFxuICAgIG9wdGlvbnM6IFRlbnNvckZyb21NTFRlbnNvck9wdGlvbnM8VD4sXG4gICk6IFR5cGVkVGVuc29yPFQ+O1xuXG4gIC8qKlxuICAgKiBjcmVhdGUgYSB0ZW5zb3IgZnJvbSBhIHByZS1hbGxvY2F0ZWQgYnVmZmVyLiBUaGUgYnVmZmVyIHdpbGwgYmUgdXNlZCBhcyBhIHBpbm5lZCBidWZmZXIuXG4gICAqXG4gICAqIEBwYXJhbSB0eXBlIC0gdGhlIHRlbnNvciBlbGVtZW50IHR5cGUuXG4gICAqIEBwYXJhbSBidWZmZXIgLSBhIFR5cGVkQXJyYXkgY29ycmVzcG9uZGluZyB0byB0aGUgdHlwZS5cbiAgICogQHBhcmFtIGRpbXMgLSBzcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIGEgdGVuc29yIG9iamVjdFxuICAgKi9cbiAgZnJvbVBpbm5lZEJ1ZmZlcjxUIGV4dGVuZHMgRXhjbHVkZTxUZW5zb3IuVHlwZSwgJ3N0cmluZyc+PihcbiAgICB0eXBlOiBULFxuICAgIGJ1ZmZlcjogVGVuc29yLkRhdGFUeXBlTWFwW1RdLFxuICAgIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSxcbiAgKTogVHlwZWRUZW5zb3I8VD47XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbi8qKlxuICogQSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIGEgZmlsZSdzIFVSTCBvciBwYXRoLlxuICpcbiAqIFBhdGggaXMgdmFpbGFibGUgb25seSBpbiBvbm54cnVudGltZS1ub2RlIG9yIG9ubnhydW50aW1lLXdlYiBydW5uaW5nIGluIE5vZGUuanMuXG4gKi9cbmV4cG9ydCB0eXBlIEZpbGVVcmxPclBhdGggPSBzdHJpbmc7XG5cbi8qKlxuICogQSBCbG9iIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgYSBmaWxlLlxuICovXG5leHBvcnQgdHlwZSBGaWxlQmxvYiA9IEJsb2I7XG5cbi8qKlxuICogQSBVaW50OEFycmF5LCBBcnJheUJ1ZmZlciBvciBTaGFyZWRBcnJheUJ1ZmZlciBvYmplY3QgdGhhdCByZXByZXNlbnRzIGEgZmlsZSBjb250ZW50LlxuICpcbiAqIFdoZW4gaXQgaXMgYW4gQXJyYXlCdWZmZXIgb3IgU2hhcmVkQXJyYXlCdWZmZXIsIHRoZSB3aG9sZSBidWZmZXIgaXMgYXNzdW1lZCB0byBiZSB0aGUgZmlsZSBjb250ZW50LlxuICovXG5leHBvcnQgdHlwZSBGaWxlRGF0YSA9IFVpbnQ4QXJyYXkgfCBBcnJheUJ1ZmZlckxpa2U7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGZpbGUgdGhhdCBjYW4gYmUgbG9hZGVkIGJ5IHRoZSBPTk5YIFJ1bnRpbWUgSmF2YVNjcmlwdCBBUEkuXG4gKi9cbmV4cG9ydCB0eXBlIEZpbGVUeXBlID0gRmlsZVVybE9yUGF0aCB8IEZpbGVCbG9iIHwgRmlsZURhdGE7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiBleHRlcm5hbCBkYXRhIGZpbGUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRXh0ZXJuYWxEYXRhRmlsZURlc2NyaXB0aW9uIHtcbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIGV4dGVybmFsIGRhdGEgZmlsZS5cbiAgICovXG4gIGRhdGE6IEZpbGVUeXBlO1xuICAvKipcbiAgICogU3BlY2lmeSB0aGUgZmlsZSBwYXRoLlxuICAgKi9cbiAgcGF0aDogc3RyaW5nO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gZXh0ZXJuYWwgZGF0YSBmaWxlLlxuICpcbiAqIFdoZW4gdXNpbmcgYSBzdHJpbmcsIGl0IHNob3VsZCBiZSBhIGZpbGUgVVJMIG9yIHBhdGggdGhhdCBpbiB0aGUgc2FtZSBkaXJlY3RvcnkgYXMgdGhlIG1vZGVsIGZpbGUuXG4gKi9cbmV4cG9ydCB0eXBlIEV4dGVybmFsRGF0YUZpbGVUeXBlID0gRXh0ZXJuYWxEYXRhRmlsZURlc2NyaXB0aW9uIHwgRmlsZVVybE9yUGF0aDtcblxuLyoqXG4gKiBPcHRpb25zIGZvciBtb2RlbCBsb2FkaW5nLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE9ubnhNb2RlbE9wdGlvbnMge1xuICAvKipcbiAgICogU3BlY2lmeWluZyBhIGxpc3Qgb2YgZmlsZXMgdGhhdCByZXByZXNlbnRzIHRoZSBleHRlcm5hbCBkYXRhLlxuICAgKi9cbiAgZXh0ZXJuYWxEYXRhPzogcmVhZG9ubHkgRXh0ZXJuYWxEYXRhRmlsZVR5cGVbXTtcbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgVGVuc29yIH0gZnJvbSAnLi90ZW5zb3IuanMnO1xuXG5leHBvcnQgdHlwZSBOb25UZW5zb3JUeXBlID0gbmV2ZXI7XG5cbi8qKlxuICogVHlwZSBPbm54VmFsdWUgUmVwcmVzZW50cyBib3RoIHRlbnNvcnMgYW5kIG5vbi10ZW5zb3JzIHZhbHVlIGZvciBtb2RlbCdzIGlucHV0cy9vdXRwdXRzLlxuICpcbiAqIE5PVEU6IGN1cnJlbnRseSBub3Qgc3VwcG9ydCBub24tdGVuc29yXG4gKi9cbmV4cG9ydCB0eXBlIE9ubnhWYWx1ZSA9IFRlbnNvciB8IE5vblRlbnNvclR5cGU7XG5cbi8qKlxuICogVHlwZSBPbm54VmFsdWVEYXRhTG9jYXRpb24gcmVwcmVzZW50cyB0aGUgbG9jYXRpb24gb2YgdGhlIGRhdGEgb2YgYW4gT25ueFZhbHVlLlxuICovXG5leHBvcnQgdHlwZSBPbm54VmFsdWVEYXRhTG9jYXRpb24gPSBUZW5zb3IuRGF0YUxvY2F0aW9uO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyByZXNvbHZlQmFja2VuZEFuZEV4ZWN1dGlvblByb3ZpZGVycyB9IGZyb20gJy4vYmFja2VuZC1pbXBsLmpzJztcbmltcG9ydCB7IFNlc3Npb25IYW5kbGVyLCBUcmFpbmluZ1Nlc3Npb25IYW5kbGVyIH0gZnJvbSAnLi9iYWNrZW5kLmpzJztcbmltcG9ydCB7IEluZmVyZW5jZVNlc3Npb24gYXMgSW5mZXJlbmNlU2Vzc2lvbiB9IGZyb20gJy4vaW5mZXJlbmNlLXNlc3Npb24uanMnO1xuaW1wb3J0IHsgT25ueFZhbHVlIH0gZnJvbSAnLi9vbm54LXZhbHVlLmpzJztcbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4vdGVuc29yLmpzJztcbmltcG9ydCB7IFRyYWluaW5nU2Vzc2lvbiBhcyBUcmFpbmluZ1Nlc3Npb25JbnRlcmZhY2UsIFRyYWluaW5nU2Vzc2lvbkNyZWF0ZU9wdGlvbnMgfSBmcm9tICcuL3RyYWluaW5nLXNlc3Npb24uanMnO1xuXG50eXBlIFNlc3Npb25PcHRpb25zID0gSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucztcbnR5cGUgRmVlZHNUeXBlID0gSW5mZXJlbmNlU2Vzc2lvbi5GZWVkc1R5cGU7XG50eXBlIEZldGNoZXNUeXBlID0gSW5mZXJlbmNlU2Vzc2lvbi5GZXRjaGVzVHlwZTtcbnR5cGUgUmV0dXJuVHlwZSA9IEluZmVyZW5jZVNlc3Npb24uUmV0dXJuVHlwZTtcbnR5cGUgUnVuT3B0aW9ucyA9IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucztcblxuY29uc3Qgbm9CYWNrZW5kRXJyTXNnOiBzdHJpbmcgPVxuICAnVHJhaW5pbmcgYmFja2VuZCBjb3VsZCBub3QgYmUgcmVzb2x2ZWQuICcgKyBcIk1ha2Ugc3VyZSB5b3UncmUgdXNpbmcgdGhlIGNvcnJlY3QgY29uZmlndXJhdGlvbiAmIFdlYkFzc2VtYmx5IGZpbGVzLlwiO1xuXG5leHBvcnQgY2xhc3MgVHJhaW5pbmdTZXNzaW9uIGltcGxlbWVudHMgVHJhaW5pbmdTZXNzaW9uSW50ZXJmYWNlIHtcbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihoYW5kbGVyOiBUcmFpbmluZ1Nlc3Npb25IYW5kbGVyLCBoYXNPcHRpbWl6ZXJNb2RlbDogYm9vbGVhbiwgaGFzRXZhbE1vZGVsOiBib29sZWFuKSB7XG4gICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcbiAgICB0aGlzLmhhc09wdGltaXplck1vZGVsID0gaGFzT3B0aW1pemVyTW9kZWw7XG4gICAgdGhpcy5oYXNFdmFsTW9kZWwgPSBoYXNFdmFsTW9kZWw7XG4gIH1cbiAgcHJpdmF0ZSBoYW5kbGVyOiBUcmFpbmluZ1Nlc3Npb25IYW5kbGVyO1xuICBwcml2YXRlIGhhc09wdGltaXplck1vZGVsOiBib29sZWFuO1xuICBwcml2YXRlIGhhc0V2YWxNb2RlbDogYm9vbGVhbjtcblxuICBnZXQgdHJhaW5pbmdJbnB1dE5hbWVzKCk6IHJlYWRvbmx5IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVyLmlucHV0TmFtZXM7XG4gIH1cbiAgZ2V0IHRyYWluaW5nT3V0cHV0TmFtZXMoKTogcmVhZG9ubHkgc3RyaW5nW10ge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZXIub3V0cHV0TmFtZXM7XG4gIH1cblxuICBnZXQgZXZhbElucHV0TmFtZXMoKTogcmVhZG9ubHkgc3RyaW5nW10ge1xuICAgIGlmICh0aGlzLmhhc0V2YWxNb2RlbCkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlci5ldmFsSW5wdXROYW1lcztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIHRyYWluaW5nIHNlc3Npb24gaGFzIG5vIGV2YWxNb2RlbCBsb2FkZWQuJyk7XG4gICAgfVxuICB9XG4gIGdldCBldmFsT3V0cHV0TmFtZXMoKTogcmVhZG9ubHkgc3RyaW5nW10ge1xuICAgIGlmICh0aGlzLmhhc0V2YWxNb2RlbCkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlci5ldmFsT3V0cHV0TmFtZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyB0cmFpbmluZyBzZXNzaW9uIGhhcyBubyBldmFsTW9kZWwgbG9hZGVkLicpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBjcmVhdGUoXG4gICAgdHJhaW5pbmdPcHRpb25zOiBUcmFpbmluZ1Nlc3Npb25DcmVhdGVPcHRpb25zLFxuICAgIHNlc3Npb25PcHRpb25zPzogU2Vzc2lvbk9wdGlvbnMsXG4gICk6IFByb21pc2U8VHJhaW5pbmdTZXNzaW9uPiB7XG4gICAgY29uc3QgZXZhbE1vZGVsOiBzdHJpbmcgfCBVaW50OEFycmF5ID0gdHJhaW5pbmdPcHRpb25zLmV2YWxNb2RlbCB8fCAnJztcbiAgICBjb25zdCBvcHRpbWl6ZXJNb2RlbDogc3RyaW5nIHwgVWludDhBcnJheSA9IHRyYWluaW5nT3B0aW9ucy5vcHRpbWl6ZXJNb2RlbCB8fCAnJztcbiAgICBjb25zdCBvcHRpb25zOiBTZXNzaW9uT3B0aW9ucyA9IHNlc3Npb25PcHRpb25zIHx8IHt9O1xuXG4gICAgLy8gcmVzb2x2ZSBiYWNrZW5kLCB1cGRhdGUgc2Vzc2lvbiBvcHRpb25zIHdpdGggdmFsaWRhdGVkIEVQcywgYW5kIGNyZWF0ZSBzZXNzaW9uIGhhbmRsZXJcbiAgICBjb25zdCBbYmFja2VuZCwgb3B0aW9uc1dpdGhWYWxpZGF0ZWRFUHNdID0gYXdhaXQgcmVzb2x2ZUJhY2tlbmRBbmRFeGVjdXRpb25Qcm92aWRlcnMob3B0aW9ucyk7XG4gICAgaWYgKGJhY2tlbmQuY3JlYXRlVHJhaW5pbmdTZXNzaW9uSGFuZGxlcikge1xuICAgICAgY29uc3QgaGFuZGxlciA9IGF3YWl0IGJhY2tlbmQuY3JlYXRlVHJhaW5pbmdTZXNzaW9uSGFuZGxlcihcbiAgICAgICAgdHJhaW5pbmdPcHRpb25zLmNoZWNrcG9pbnRTdGF0ZSxcbiAgICAgICAgdHJhaW5pbmdPcHRpb25zLnRyYWluTW9kZWwsXG4gICAgICAgIGV2YWxNb2RlbCxcbiAgICAgICAgb3B0aW1pemVyTW9kZWwsXG4gICAgICAgIG9wdGlvbnNXaXRoVmFsaWRhdGVkRVBzLFxuICAgICAgKTtcbiAgICAgIHJldHVybiBuZXcgVHJhaW5pbmdTZXNzaW9uKGhhbmRsZXIsICEhdHJhaW5pbmdPcHRpb25zLm9wdGltaXplck1vZGVsLCAhIXRyYWluaW5nT3B0aW9ucy5ldmFsTW9kZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3Iobm9CYWNrZW5kRXJyTXNnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIGZ1bmN0aW9uIGZvciBydW5UcmFpblN0ZXAgYW5kIGZ1dHVyZSBydW5TdGVwIG1ldGhvZHMgdGhhdCBoYW5kbGVzIHRoZSB0eXBlLW5hcnJvd2luZyBjb252ZXJzaW9uIGZyb21cbiAgICogdGhlIGdpdmVuIHBhcmFtZXRlcnMgdG8gU2Vzc2lvbkhhbmRsZXIuRmV0Y2hlc1R5cGUgYW5kIFJ1bk9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSBpbnB1dE5hbWVzIHRoZSBmZWVkcyBvYmplY3QgaXMgY2hlY2tlZCB0aGF0IHRoZXkgY29udGFpbiBhbGwgaW5wdXQgbmFtZXMgaW4gdGhlIHByb3ZpZGVkIGxpc3Qgb2YgaW5wdXRcbiAgICogbmFtZXMuXG4gICAqIEBwYXJhbSBvdXRwdXROYW1lcyB0aGUgZmV0Y2hlcyBvYmplY3QgaXMgY2hlY2tlZCB0aGF0IHRoZWlyIGtleXMgbWF0Y2ggdXAgd2l0aCB2YWxpZCBuYW1lcyBpbiB0aGUgbGlzdCBvZiBvdXRwdXRcbiAgICogbmFtZXMuXG4gICAqIEBwYXJhbSBmZWVkcyB0aGUgcmVxdWlyZWQgaW5wdXRcbiAgICogQHBhcmFtIGFyZzEgbmFycm93ZWQgJiBjb252ZXJ0ZWQgaW50byB0aGUgU2Vzc2lvbkhhbmRsZXIuRmV0Y2hlc1R5cGUgb3IgUnVuT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIGFyZzIgb3B0aW9uYWwgUnVuT3B0aW9ucyBvYmplY3QuXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICB0eXBlTmFycm93aW5nRm9yUnVuU3RlcChcbiAgICBpbnB1dE5hbWVzOiByZWFkb25seSBzdHJpbmdbXSxcbiAgICBvdXRwdXROYW1lczogcmVhZG9ubHkgc3RyaW5nW10sXG4gICAgZmVlZHM6IEZlZWRzVHlwZSxcbiAgICBhcmcxPzogRmV0Y2hlc1R5cGUgfCBSdW5PcHRpb25zLFxuICAgIGFyZzI/OiBSdW5PcHRpb25zLFxuICApOiBbU2Vzc2lvbkhhbmRsZXIuRmV0Y2hlc1R5cGUsIFJ1bk9wdGlvbnNdIHtcbiAgICBjb25zdCBmZXRjaGVzOiB7IFtuYW1lOiBzdHJpbmddOiBPbm54VmFsdWUgfCBudWxsIH0gPSB7fTtcbiAgICBsZXQgb3B0aW9uczogUnVuT3B0aW9ucyA9IHt9O1xuICAgIC8vIGNoZWNrIGlucHV0c1xuICAgIGlmICh0eXBlb2YgZmVlZHMgIT09ICdvYmplY3QnIHx8IGZlZWRzID09PSBudWxsIHx8IGZlZWRzIGluc3RhbmNlb2YgVGVuc29yIHx8IEFycmF5LmlzQXJyYXkoZmVlZHMpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBcIidmZWVkcycgbXVzdCBiZSBhbiBvYmplY3QgdGhhdCB1c2UgaW5wdXQgbmFtZXMgYXMga2V5cyBhbmQgT25ueFZhbHVlIGFzIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlwiLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBsZXQgaXNGZXRjaGVzRW1wdHkgPSB0cnVlO1xuICAgIC8vIGRldGVybWluZSB3aGljaCBvdmVycmlkZSBpcyBiZWluZyB1c2VkXG4gICAgaWYgKHR5cGVvZiBhcmcxID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKGFyZzEgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5leHBlY3RlZCBhcmd1bWVudFsxXTogY2Fubm90IGJlIG51bGwuJyk7XG4gICAgICB9XG4gICAgICBpZiAoYXJnMSBpbnN0YW5jZW9mIFRlbnNvcikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2ZldGNoZXMnIGNhbm5vdCBiZSBhIFRlbnNvclwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnMSkpIHtcbiAgICAgICAgaWYgKGFyZzEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIidmZXRjaGVzJyBjYW5ub3QgYmUgYW4gZW1wdHkgYXJyYXkuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlzRmV0Y2hlc0VtcHR5ID0gZmFsc2U7XG4gICAgICAgIC8vIG91dHB1dCBuYW1lc1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgYXJnMSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCInZmV0Y2hlcycgbXVzdCBiZSBhIHN0cmluZyBhcnJheSBvciBhbiBvYmplY3QuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3V0cHV0TmFtZXMuaW5kZXhPZihuYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGAnZmV0Y2hlcycgY29udGFpbnMgaW52YWxpZCBvdXRwdXQgbmFtZTogJHtuYW1lfS5gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmV0Y2hlc1tuYW1lXSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGFyZzIgPT09ICdvYmplY3QnICYmIGFyZzIgIT09IG51bGwpIHtcbiAgICAgICAgICBvcHRpb25zID0gYXJnMjtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnMiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZGVjaWRlIHdoZXRoZXIgYXJnMSBpcyBmZXRjaGVzIG9yIG9wdGlvbnNcbiAgICAgICAgLy8gaWYgYW55IG91dHB1dCBuYW1lIGlzIHByZXNlbnQgYW5kIGl0cyB2YWx1ZSBpcyB2YWxpZCBPbm54VmFsdWUsIHdlIGNvbnNpZGVyIGl0IGZldGNoZXNcbiAgICAgICAgbGV0IGlzRmV0Y2hlcyA9IGZhbHNlO1xuICAgICAgICBjb25zdCBhcmcxS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFyZzEpO1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2Ygb3V0cHV0TmFtZXMpIHtcbiAgICAgICAgICBpZiAoYXJnMUtleXMuaW5kZXhPZihuYW1lKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSAoYXJnMSBhcyBJbmZlcmVuY2VTZXNzaW9uLk51bGxhYmxlT25ueFZhbHVlTWFwVHlwZSlbbmFtZV07XG4gICAgICAgICAgICBpZiAodiA9PT0gbnVsbCB8fCB2IGluc3RhbmNlb2YgVGVuc29yKSB7XG4gICAgICAgICAgICAgIGlzRmV0Y2hlcyA9IHRydWU7XG4gICAgICAgICAgICAgIGlzRmV0Y2hlc0VtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgIGZldGNoZXNbbmFtZV0gPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0ZldGNoZXMpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGFyZzIgPT09ICdvYmplY3QnICYmIGFyZzIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBhcmcyO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0aW9ucyA9IGFyZzEgYXMgUnVuT3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5leHBlY3RlZCBhcmd1bWVudFsxXTogbXVzdCBiZSAnZmV0Y2hlcycgb3IgJ29wdGlvbnMnLlwiKTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiBhbGwgaW5wdXRzIGFyZSBpbiBmZWVkXG4gICAgZm9yIChjb25zdCBuYW1lIG9mIGlucHV0TmFtZXMpIHtcbiAgICAgIGlmICh0eXBlb2YgZmVlZHNbbmFtZV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW5wdXQgJyR7bmFtZX0nIGlzIG1pc3NpbmcgaW4gJ2ZlZWRzJy5gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiBubyBmZXRjaGVzIGlzIHNwZWNpZmllZCwgd2UgdXNlIHRoZSBmdWxsIG91dHB1dCBuYW1lcyBsaXN0XG4gICAgaWYgKGlzRmV0Y2hlc0VtcHR5KSB7XG4gICAgICBmb3IgKGNvbnN0IG5hbWUgb2Ygb3V0cHV0TmFtZXMpIHtcbiAgICAgICAgZmV0Y2hlc1tuYW1lXSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFtmZXRjaGVzLCBvcHRpb25zXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgbWV0aG9kIGZvciBydW5UcmFpblN0ZXAgYW5kIGFueSBvdGhlciBydW5TdGVwIG1ldGhvZHMuIFRha2VzIHRoZSBSZXR1cm5UeXBlIHJlc3VsdCBmcm9tIHRoZSBTZXNzaW9uSGFuZGxlclxuICAgKiBhbmQgY2hhbmdlcyBpdCBpbnRvIGEgbWFwIG9mIFRlbnNvcnMuXG4gICAqXG4gICAqIEBwYXJhbSByZXN1bHRzXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBjb252ZXJ0SGFuZGxlclJldHVyblR5cGVUb01hcE9mVGVuc29ycyhyZXN1bHRzOiBTZXNzaW9uSGFuZGxlci5SZXR1cm5UeXBlKTogUmV0dXJuVHlwZSB7XG4gICAgY29uc3QgcmV0dXJuVmFsdWU6IHsgW25hbWU6IHN0cmluZ106IE9ubnhWYWx1ZSB9ID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcmVzdWx0cykge1xuICAgICAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdHMsIGtleSkpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVzdWx0c1trZXldO1xuICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgVGVuc29yKSB7XG4gICAgICAgICAgcmV0dXJuVmFsdWVba2V5XSA9IHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm5WYWx1ZVtrZXldID0gbmV3IFRlbnNvcihyZXN1bHQudHlwZSwgcmVzdWx0LmRhdGEsIHJlc3VsdC5kaW1zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gIH1cblxuICBhc3luYyBsYXp5UmVzZXRHcmFkKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHRoaXMuaGFuZGxlci5sYXp5UmVzZXRHcmFkKCk7XG4gIH1cblxuICBydW5UcmFpblN0ZXAoZmVlZHM6IEZlZWRzVHlwZSwgb3B0aW9ucz86IFJ1bk9wdGlvbnMpOiBQcm9taXNlPFJldHVyblR5cGU+O1xuICBydW5UcmFpblN0ZXAoZmVlZHM6IEZlZWRzVHlwZSwgZmV0Y2hlczogRmV0Y2hlc1R5cGUsIG9wdGlvbnM/OiBSdW5PcHRpb25zKTogUHJvbWlzZTxSZXR1cm5UeXBlPjtcbiAgYXN5bmMgcnVuVHJhaW5TdGVwKGZlZWRzOiBGZWVkc1R5cGUsIGFyZzE/OiBGZXRjaGVzVHlwZSB8IFJ1bk9wdGlvbnMsIGFyZzI/OiBSdW5PcHRpb25zKTogUHJvbWlzZTxSZXR1cm5UeXBlPiB7XG4gICAgY29uc3QgW2ZldGNoZXMsIG9wdGlvbnNdID0gdGhpcy50eXBlTmFycm93aW5nRm9yUnVuU3RlcChcbiAgICAgIHRoaXMudHJhaW5pbmdJbnB1dE5hbWVzLFxuICAgICAgdGhpcy50cmFpbmluZ091dHB1dE5hbWVzLFxuICAgICAgZmVlZHMsXG4gICAgICBhcmcxLFxuICAgICAgYXJnMixcbiAgICApO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCB0aGlzLmhhbmRsZXIucnVuVHJhaW5TdGVwKGZlZWRzLCBmZXRjaGVzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcy5jb252ZXJ0SGFuZGxlclJldHVyblR5cGVUb01hcE9mVGVuc29ycyhyZXN1bHRzKTtcbiAgfVxuXG4gIGFzeW5jIHJ1bk9wdGltaXplclN0ZXAob3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucyB8IHVuZGVmaW5lZCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICh0aGlzLmhhc09wdGltaXplck1vZGVsKSB7XG4gICAgICBhd2FpdCB0aGlzLmhhbmRsZXIucnVuT3B0aW1pemVyU3RlcChvcHRpb25zIHx8IHt9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIFRyYWluaW5nU2Vzc2lvbiBoYXMgbm8gT3B0aW1pemVyTW9kZWwgbG9hZGVkLicpO1xuICAgIH1cbiAgfVxuXG4gIHJ1bkV2YWxTdGVwKGZlZWRzOiBGZWVkc1R5cGUsIG9wdGlvbnM/OiBSdW5PcHRpb25zIHwgdW5kZWZpbmVkKTogUHJvbWlzZTxSZXR1cm5UeXBlPjtcbiAgcnVuRXZhbFN0ZXAoZmVlZHM6IEZlZWRzVHlwZSwgZmV0Y2hlczogRmV0Y2hlc1R5cGUsIG9wdGlvbnM/OiBSdW5PcHRpb25zIHwgdW5kZWZpbmVkKTogUHJvbWlzZTxSZXR1cm5UeXBlPjtcbiAgYXN5bmMgcnVuRXZhbFN0ZXAoZmVlZHM6IEZlZWRzVHlwZSwgYXJnMT86IEZldGNoZXNUeXBlIHwgUnVuT3B0aW9ucywgYXJnMj86IFJ1bk9wdGlvbnMpOiBQcm9taXNlPFJldHVyblR5cGU+IHtcbiAgICBpZiAodGhpcy5oYXNFdmFsTW9kZWwpIHtcbiAgICAgIGNvbnN0IFtmZXRjaGVzLCBvcHRpb25zXSA9IHRoaXMudHlwZU5hcnJvd2luZ0ZvclJ1blN0ZXAoXG4gICAgICAgIHRoaXMuZXZhbElucHV0TmFtZXMsXG4gICAgICAgIHRoaXMuZXZhbE91dHB1dE5hbWVzLFxuICAgICAgICBmZWVkcyxcbiAgICAgICAgYXJnMSxcbiAgICAgICAgYXJnMixcbiAgICAgICk7XG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgdGhpcy5oYW5kbGVyLnJ1bkV2YWxTdGVwKGZlZWRzLCBmZXRjaGVzLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRIYW5kbGVyUmV0dXJuVHlwZVRvTWFwT2ZUZW5zb3JzKHJlc3VsdHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgVHJhaW5pbmdTZXNzaW9uIGhhcyBubyBFdmFsTW9kZWwgbG9hZGVkLicpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGdldFBhcmFtZXRlcnNTaXplKHRyYWluYWJsZU9ubHkgPSB0cnVlKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVyLmdldFBhcmFtZXRlcnNTaXplKHRyYWluYWJsZU9ubHkpO1xuICB9XG5cbiAgYXN5bmMgbG9hZFBhcmFtZXRlcnNCdWZmZXIoYXJyYXk6IFVpbnQ4QXJyYXksIHRyYWluYWJsZU9ubHkgPSB0cnVlKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgcGFyYW1zU2l6ZSA9IGF3YWl0IHRoaXMuZ2V0UGFyYW1ldGVyc1NpemUodHJhaW5hYmxlT25seSk7XG4gICAgLy8gY2hlY2tpbmcgdGhhdCB0aGUgc2l6ZSBvZiB0aGUgVWludDhBcnJheSBpcyBlcXVpdmFsZW50IHRvIHRoZSBieXRlIGxlbmd0aCBvZiBhIEZsb2F0MzJBcnJheSBvZiB0aGUgbnVtYmVyXG4gICAgLy8gb2YgcGFyYW1ldGVyc1xuICAgIGlmIChhcnJheS5sZW5ndGggIT09IDQgKiBwYXJhbXNTaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdTaXplIG9mIHRoZSBidWZmZXIgcGFzc2VkIGludG8gbG9hZFBhcmFtZXRlcnNCdWZmZXIgbXVzdCBtYXRjaCB0aGUgbnVtYmVyIG9mIHBhcmFtZXRlcnMgaW4gJyArXG4gICAgICAgICAgJ3RoZSBtb2RlbC4gUGxlYXNlIHVzZSBnZXRQYXJhbWV0ZXJzU2l6ZSBtZXRob2QgdG8gY2hlY2suJyxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmhhbmRsZXIubG9hZFBhcmFtZXRlcnNCdWZmZXIoYXJyYXksIHRyYWluYWJsZU9ubHkpO1xuICB9XG5cbiAgYXN5bmMgZ2V0Q29udGlndW91c1BhcmFtZXRlcnModHJhaW5hYmxlT25seSA9IHRydWUpOiBQcm9taXNlPE9ubnhWYWx1ZT4ge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZXIuZ2V0Q29udGlndW91c1BhcmFtZXRlcnModHJhaW5hYmxlT25seSk7XG4gIH1cblxuICBhc3luYyByZWxlYXNlKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZXIuZGlzcG9zZSgpO1xuICB9XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEluZmVyZW5jZVNlc3Npb24gfSBmcm9tICcuL2luZmVyZW5jZS1zZXNzaW9uLmpzJztcbmltcG9ydCB7IE9ubnhWYWx1ZSB9IGZyb20gJy4vb25ueC12YWx1ZS5qcyc7XG5pbXBvcnQgeyBUcmFpbmluZ1Nlc3Npb24gYXMgVHJhaW5pbmdTZXNzaW9uSW1wbCB9IGZyb20gJy4vdHJhaW5pbmctc2Vzc2lvbi1pbXBsLmpzJztcblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlZGVjbGFyZSAqL1xuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgVHJhaW5pbmdTZXNzaW9uIHtcbiAgLyoqXG4gICAqIEVpdGhlciBVUkkgZmlsZSBwYXRoIChzdHJpbmcpIG9yIFVpbnQ4QXJyYXkgY29udGFpbmluZyBtb2RlbCBvciBjaGVja3BvaW50IGluZm9ybWF0aW9uLlxuICAgKi9cbiAgdHlwZSBVcmlPckJ1ZmZlciA9IHN0cmluZyB8IFVpbnQ4QXJyYXk7XG59XG5cbi8qKlxuICogUmVwcmVzZW50IGEgcnVudGltZSBpbnN0YW5jZSBvZiBhbiBPTk5YIHRyYWluaW5nIHNlc3Npb24sXG4gKiB3aGljaCBjb250YWlucyBhIG1vZGVsIHRoYXQgY2FuIGJlIHRyYWluZWQsIGFuZCwgb3B0aW9uYWxseSxcbiAqIGFuIGV2YWwgYW5kIG9wdGltaXplciBtb2RlbC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUcmFpbmluZ1Nlc3Npb24ge1xuICAvLyAjcmVnaW9uIHJ1bigpXG5cbiAgLyoqXG4gICAqIExhemlseSByZXNldHMgdGhlIGdyYWRpZW50cyBvZiBhbGwgdHJhaW5hYmxlIHBhcmFtZXRlcnMgdG8gemVyby4gU2hvdWxkIGhhcHBlbiBhZnRlciB0aGUgaW52b2NhdGlvbiBvZlxuICAgKiBydW5PcHRpbWl6ZXJTdGVwLlxuICAgKi9cbiAgbGF6eVJlc2V0R3JhZCgpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKlxuICAgKiBSdW4gVHJhaW5TdGVwIGFzeW5jaHJvbm91c2x5IHdpdGggdGhlIGdpdmVuIGZlZWRzIGFuZCBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0gZmVlZHMgLSBSZXByZXNlbnRhdGlvbiBvZiB0aGUgbW9kZWwgaW5wdXQuIFNlZSB0eXBlIGRlc2NyaXB0aW9uIG9mIGBJbmZlcmVuY2VTZXNzaW9uLklucHV0VHlwZWAgZm9yXG4gICBkZXRhaWwuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uYWwuIEEgc2V0IG9mIG9wdGlvbnMgdGhhdCBjb250cm9scyB0aGUgYmVoYXZpb3Igb2YgbW9kZWwgdHJhaW5pbmcuXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgbWFwLCB3aGljaCB1c2VzIG91dHB1dCBuYW1lcyBhcyBrZXlzIGFuZCBPbm54VmFsdWUgYXMgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAqL1xuICBydW5UcmFpblN0ZXAoXG4gICAgZmVlZHM6IEluZmVyZW5jZVNlc3Npb24uRmVlZHNUeXBlLFxuICAgIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMsXG4gICk6IFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbi5SZXR1cm5UeXBlPjtcblxuICAvKipcbiAgICogUnVuIGEgc2luZ2xlIHRyYWluIHN0ZXAgd2l0aCB0aGUgZ2l2ZW4gaW5wdXRzIGFuZCBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0gZmVlZHMgLSBSZXByZXNlbnRhdGlvbiBvZiB0aGUgbW9kZWwgaW5wdXQuXG4gICAqIEBwYXJhbSBmZXRjaGVzIC0gUmVwcmVzZW50YXRpb24gb2YgdGhlIG1vZGVsIG91dHB1dC5cbiAgICogZGV0YWlsLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbmFsLiBBIHNldCBvZiBvcHRpb25zIHRoYXQgY29udHJvbHMgdGhlIGJlaGF2aW9yIG9mIG1vZGVsIHRyYWluaW5nLlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIG1hcCwgd2hpY2ggdXNlcyBvdXRwdXQgbmFtZXMgYXMga2V5cyBhbmQgT25ueFZhbHVlIGFzIGNvcnJlc3BvbmRpbmdcbiAgIHZhbHVlcy5cbiAgICovXG4gIHJ1blRyYWluU3RlcChcbiAgICBmZWVkczogSW5mZXJlbmNlU2Vzc2lvbi5GZWVkc1R5cGUsXG4gICAgZmV0Y2hlczogSW5mZXJlbmNlU2Vzc2lvbi5GZXRjaGVzVHlwZSxcbiAgICBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zLFxuICApOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb24uUmV0dXJuVHlwZT47XG5cbiAgLyoqXG4gICAqIFJ1bnMgYSBzaW5nbGUgb3B0aW1pemVyIHN0ZXAsIHdoaWNoIHBlcmZvcm1zIHdlaWdodCB1cGRhdGVzIGZvciB0aGUgdHJhaW5hYmxlIHBhcmFtZXRlcnMgdXNpbmcgdGhlIG9wdGltaXplciBtb2RlbC5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbC4gQSBzZXQgb2Ygb3B0aW9ucyB0aGF0IGNvbnRyb2xzIHRoZSBiZWhhdmlvciBvZiBtb2RlbCBvcHRpbWl6aW5nLlxuICAgKi9cbiAgcnVuT3B0aW1pemVyU3RlcChvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zKTogUHJvbWlzZTx2b2lkPjtcblxuICAvKipcbiAgICogUnVuIGEgc2luZ2xlIGV2YWwgc3RlcCB3aXRoIHRoZSBnaXZlbiBpbnB1dHMgYW5kIG9wdGlvbnMgdXNpbmcgdGhlIGV2YWwgbW9kZWwuXG4gICAqXG4gICAqIEBwYXJhbSBmZWVkcyAtIFJlcHJlc2VudGF0aW9uIG9mIHRoZSBtb2RlbCBpbnB1dC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbC4gQSBzZXQgb2Ygb3B0aW9ucyB0aGF0IGNvbnRyb2xzIHRoZSBiZWhhdmlvciBvZiBtb2RlbCBldmFsIHN0ZXAuXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgbWFwLCB3aGljaCB1c2VzIG91dHB1dCBuYW1lcyBhcyBrZXlzIGFuZCBPbm54VmFsdWUgYXMgY29ycmVzcG9uZGluZ1xuICAgdmFsdWVzLlxuICAgKi9cbiAgcnVuRXZhbFN0ZXAoXG4gICAgZmVlZHM6IEluZmVyZW5jZVNlc3Npb24uRmVlZHNUeXBlLFxuICAgIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMsXG4gICk6IFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbi5SZXR1cm5UeXBlPjtcblxuICAvKipcbiAgICogUnVuIGEgc2luZ2xlIGV2YWwgc3RlcCB3aXRoIHRoZSBnaXZlbiBpbnB1dHMgYW5kIG9wdGlvbnMgdXNpbmcgdGhlIGV2YWwgbW9kZWwuXG4gICAqXG4gICAqIEBwYXJhbSBmZWVkcyAtIFJlcHJlc2VudGF0aW9uIG9mIHRoZSBtb2RlbCBpbnB1dC5cbiAgICogQHBhcmFtIGZldGNoZXMgLSBSZXByZXNlbnRhdGlvbiBvZiB0aGUgbW9kZWwgb3V0cHV0LlxuICAgKiBkZXRhaWwuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uYWwuIEEgc2V0IG9mIG9wdGlvbnMgdGhhdCBjb250cm9scyB0aGUgYmVoYXZpb3Igb2YgbW9kZWwgZXZhbCBzdGVwLlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIG1hcCwgd2hpY2ggdXNlcyBvdXRwdXQgbmFtZXMgYXMga2V5cyBhbmQgT25ueFZhbHVlIGFzIGNvcnJlc3BvbmRpbmdcbiAgIHZhbHVlcy5cbiAgICovXG4gIHJ1bkV2YWxTdGVwKFxuICAgIGZlZWRzOiBJbmZlcmVuY2VTZXNzaW9uLkZlZWRzVHlwZSxcbiAgICBmZXRjaGVzOiBJbmZlcmVuY2VTZXNzaW9uLkZldGNoZXNUeXBlLFxuICAgIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMsXG4gICk6IFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbi5SZXR1cm5UeXBlPjtcblxuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiBjb3B5IHBhcmFtZXRlcnNcblxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBzaXplIG9mIGFsbCBwYXJhbWV0ZXJzIGZvciB0aGUgdHJhaW5pbmcgc3RhdGUuIENhbGN1bGF0ZXMgdGhlIHRvdGFsIG51bWJlciBvZiBwcmltaXRpdmUgKGRhdGF0eXBlIG9mXG4gICAqIHRoZSBwYXJhbWV0ZXJzKSBlbGVtZW50cyBvZiBhbGwgdGhlIHBhcmFtZXRlcnMgaW4gdGhlIHRyYWluaW5nIHN0YXRlLlxuICAgKlxuICAgKiBAcGFyYW0gdHJhaW5hYmxlT25seSAtIFdoZW4gc2V0IHRvIHRydWUsIHRoZSBzaXplIGlzIGNhbGN1bGF0ZWQgZm9yIHRyYWluYWJsZSBwYXJhbXMgb25seS4gRGVmYXVsdCB2YWx1ZSBpcyB0cnVlLlxuICAgKi9cbiAgZ2V0UGFyYW1ldGVyc1NpemUodHJhaW5hYmxlT25seTogYm9vbGVhbik6IFByb21pc2U8bnVtYmVyPjtcblxuICAvKipcbiAgICogQ29waWVzIHBhcmFtZXRlciB2YWx1ZXMgZnJvbSB0aGUgZ2l2ZW4gYnVmZmVyIHRvIHRoZSB0cmFpbmluZyBzdGF0ZS4gQ3VycmVudGx5LCBvbmx5IHN1cHBvcnRpbmcgbW9kZWxzIHdpdGhcbiAgICogcGFyYW1ldGVycyBvZiB0eXBlIEZsb2F0MzIuXG4gICAqXG4gICAqIEBwYXJhbSBidWZmZXIgLSBBIFVpbnQ4QXJyYXkgcmVwcmVzZW50YXRpb24gb2YgRmxvYXQzMiBwYXJhbWV0ZXJzLlxuICAgKiBAcGFyYW0gdHJhaW5hYmxlT25seSAtIFRydWUgaWYgdHJhaW5hYmxlIHBhcmFtZXRlcnMgb25seSB0byBiZSBtb2RpZmllZCwgZmFsc2Ugb3RoZXJ3aXNlLiBEZWZhdWx0IHZhbHVlIGlzIHRydWUuXG4gICAqL1xuICBsb2FkUGFyYW1ldGVyc0J1ZmZlcihidWZmZXI6IFVpbnQ4QXJyYXksIHRyYWluYWJsZU9ubHk6IGJvb2xlYW4pOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKlxuICAgKiBDb3BpZXMgdGhlIG1vZGVsIHBhcmFtZXRlcnMgdG8gYSBjb250aWd1b3VzIGJ1ZmZlci4gVXN1YWxseSB1c2VkIGluIHRoZSBjb250ZXh0IG9mIEZlZGVyYXRlZCBMZWFybmluZy5cbiAgICogQ3VycmVudGx5LCBvbmx5IHN1cHBvcnRpbmcgbW9kZWxzIHdpdGggcGFyYW1ldGVycyBvZiB0eXBlIEZsb2F0MzIuXG4gICAqXG4gICAqIEBwYXJhbSB0cmFpbmFibGVPbmx5IC0gV2hlbiBzZXQgdG8gdHJ1ZSwgb25seSB0cmFpbmFibGUgcGFyYW1ldGVycyBhcmUgY29waWVkLiBUcmFpbmFibGUgcGFyYW1ldGVycyBhcmUgcGFyYW1ldGVyc1xuICAgKiBmb3Igd2hpY2ggcmVxdWlyZXNfZ3JhZCBpcyBzZXQgdG8gdHJ1ZS4gRGVmYXVsdCB2YWx1ZSBpcyB0cnVlLlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIEZsb2F0MzIgT25ueFZhbHVlIG9mIHRoZSByZXF1ZXN0ZWQgcGFyYW1ldGVycy5cbiAgICovXG4gIGdldENvbnRpZ3VvdXNQYXJhbWV0ZXJzKHRyYWluYWJsZU9ubHk6IGJvb2xlYW4pOiBQcm9taXNlPE9ubnhWYWx1ZT47XG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIHJlbGVhc2UoKVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlIHRoZSBpbmZlcmVuY2Ugc2Vzc2lvbiBhbmQgdGhlIHVuZGVybHlpbmcgcmVzb3VyY2VzLlxuICAgKi9cbiAgcmVsZWFzZSgpOiBQcm9taXNlPHZvaWQ+O1xuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiBtZXRhZGF0YVxuXG4gIC8qKlxuICAgKiBHZXQgaW5wdXQgbmFtZXMgb2YgdGhlIGxvYWRlZCB0cmFpbmluZyBtb2RlbC5cbiAgICovXG4gIHJlYWRvbmx5IHRyYWluaW5nSW5wdXROYW1lczogcmVhZG9ubHkgc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIEdldCBvdXRwdXQgbmFtZXMgb2YgdGhlIGxvYWRlZCB0cmFpbmluZyBtb2RlbC5cbiAgICovXG4gIHJlYWRvbmx5IHRyYWluaW5nT3V0cHV0TmFtZXM6IHJlYWRvbmx5IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBHZXQgaW5wdXQgbmFtZXMgb2YgdGhlIGxvYWRlZCBldmFsIG1vZGVsLiBJcyBhbiBlbXB0eSBhcnJheSBpZiBubyBldmFsIG1vZGVsIGlzIGxvYWRlZC5cbiAgICovXG4gIHJlYWRvbmx5IGV2YWxJbnB1dE5hbWVzOiByZWFkb25seSBzdHJpbmdbXTtcblxuICAvKipcbiAgICogR2V0IG91dHB1dCBuYW1lcyBvZiB0aGUgbG9hZGVkIGV2YWwgbW9kZWwuIElzIGFuIGVtcHR5IGFycmF5IGlmIG5vIGV2YWwgbW9kZWwgaXMgbG9hZGVkLlxuICAgKi9cbiAgcmVhZG9ubHkgZXZhbE91dHB1dE5hbWVzOiByZWFkb25seSBzdHJpbmdbXTtcblxuICAvLyAjZW5kcmVnaW9uXG59XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgb3B0aW9uYWwgcGFyYW1ldGVycyB0aGF0IGNhbiBiZSBwYXNzZWQgaW50byB0aGUgVHJhaW5pbmdTZXNzaW9uRmFjdG9yeS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUcmFpbmluZ1Nlc3Npb25DcmVhdGVPcHRpb25zIHtcbiAgLyoqXG4gICAqIFVSSSBvciBidWZmZXIgZm9yIGEgLmNrcHQgZmlsZSB0aGF0IGNvbnRhaW5zIHRoZSBjaGVja3BvaW50IGZvciB0aGUgdHJhaW5pbmcgbW9kZWwuXG4gICAqL1xuICBjaGVja3BvaW50U3RhdGU6IFRyYWluaW5nU2Vzc2lvbi5VcmlPckJ1ZmZlcjtcbiAgLyoqXG4gICAqIFVSSSBvciBidWZmZXIgZm9yIHRoZSAub25ueCB0cmFpbmluZyBmaWxlLlxuICAgKi9cbiAgdHJhaW5Nb2RlbDogVHJhaW5pbmdTZXNzaW9uLlVyaU9yQnVmZmVyO1xuICAvKipcbiAgICogT3B0aW9uYWwuIFVSSSBvciBidWZmZXIgZm9yIHRoZSAub25ueCBvcHRpbWl6ZXIgbW9kZWwgZmlsZS5cbiAgICovXG4gIG9wdGltaXplck1vZGVsPzogVHJhaW5pbmdTZXNzaW9uLlVyaU9yQnVmZmVyO1xuICAvKipcbiAgICogT3B0aW9uYWwuIFVSSSBvciBidWZmZXIgZm9yIHRoZSAub25ueCBldmFsIG1vZGVsIGZpbGUuXG4gICAqL1xuICBldmFsTW9kZWw/OiBUcmFpbmluZ1Nlc3Npb24uVXJpT3JCdWZmZXI7XG59XG5cbi8qKlxuICogRGVmaW5lcyBtZXRob2Qgb3ZlcmxvYWQgcG9zc2liaWxpdGllcyBmb3IgY3JlYXRpbmcgYSBUcmFpbmluZ1Nlc3Npb24uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVHJhaW5pbmdTZXNzaW9uRmFjdG9yeSB7XG4gIC8vICNyZWdpb24gY3JlYXRlKClcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBUcmFpbmluZ1Nlc3Npb24gYW5kIGFzeW5jaHJvbm91c2x5IGxvYWRzIGFueSBtb2RlbHMgcGFzc2VkIGluIHRocm91Z2ggdHJhaW5pbmdPcHRpb25zXG4gICAqXG4gICAqIEBwYXJhbSB0cmFpbmluZ09wdGlvbnMgc3BlY2lmeSBtb2RlbHMgYW5kIGNoZWNrcG9pbnRzIHRvIGxvYWQgaW50byB0aGUgVHJhaW5pbmcgU2Vzc2lvblxuICAgKiBAcGFyYW0gc2Vzc2lvbk9wdGlvbnMgc3BlY2lmeSBjb25maWd1cmF0aW9uIGZvciB0cmFpbmluZyBzZXNzaW9uIGJlaGF2aW9yXG4gICAqXG4gICAqIEByZXR1cm5zIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIFRyYWluaW5nU2Vzc2lvbiBvYmplY3RcbiAgICovXG4gIGNyZWF0ZShcbiAgICB0cmFpbmluZ09wdGlvbnM6IFRyYWluaW5nU2Vzc2lvbkNyZWF0ZU9wdGlvbnMsXG4gICAgc2Vzc2lvbk9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zLFxuICApOiBQcm9taXNlPFRyYWluaW5nU2Vzc2lvbj47XG5cbiAgLy8gI2VuZHJlZ2lvblxufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5leHBvcnQgY29uc3QgVHJhaW5pbmdTZXNzaW9uOiBUcmFpbmluZ1Nlc3Npb25GYWN0b3J5ID0gVHJhaW5pbmdTZXNzaW9uSW1wbDtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuLyoqXG4gKiAjIE9OTlggUnVudGltZSBKYXZhU2NyaXB0IEFQSVxuICpcbiAqIE9OTlggUnVudGltZSBKYXZhU2NyaXB0IEFQSSBpcyBhIHVuaWZpZWQgQVBJIGZvciBhbGwgSmF2YVNjcmlwdCB1c2FnZXMsIGluY2x1ZGluZyB0aGUgZm9sbG93aW5nIE5QTSBwYWNrYWdlczpcbiAqXG4gKiAtIFtvbm54cnVudGltZS1ub2RlXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9vbm54cnVudGltZS1ub2RlKVxuICogLSBbb25ueHJ1bnRpbWUtd2ViXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9vbm54cnVudGltZS13ZWIpXG4gKiAtIFtvbm54cnVudGltZS1yZWFjdC1uYXRpdmVdKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL29ubnhydW50aW1lLXJlYWN0LW5hdGl2ZSlcbiAqXG4gKiBTZWUgYWxzbzpcbiAqIC0gW0dldCBTdGFydGVkXShodHRwczovL29ubnhydW50aW1lLmFpL2RvY3MvZ2V0LXN0YXJ0ZWQvd2l0aC1qYXZhc2NyaXB0LylcbiAqIC0gW0luZmVyZW5jZSBleGFtcGxlc10oaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9vbm54cnVudGltZS1pbmZlcmVuY2UtZXhhbXBsZXMvdHJlZS9tYWluL2pzKVxuICpcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICovXG5cbmV4cG9ydCAqIGZyb20gJy4vYmFja2VuZC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2Vudi5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2luZmVyZW5jZS1zZXNzaW9uLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vdGVuc29yLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vdGVuc29yLWNvbnZlcnNpb24uanMnO1xuZXhwb3J0ICogZnJvbSAnLi90ZW5zb3ItZmFjdG9yeS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3RyYWNlLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vb25ueC1tb2RlbC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL29ubngtdmFsdWUuanMnO1xuZXhwb3J0ICogZnJvbSAnLi90cmFpbmluZy1zZXNzaW9uLmpzJztcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRW52IH0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuaW1wb3J0IHsgV2ViR0xDb250ZXh0IH0gZnJvbSAnLi9iYWNrZW5kcy93ZWJnbC93ZWJnbC1jb250ZXh0JztcblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIExvZ2dlciB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgU2V2ZXJpdHlUeXBlTWFwIHtcbiAgICB2ZXJib3NlOiAndic7XG4gICAgaW5mbzogJ2knO1xuICAgIHdhcm5pbmc6ICd3JztcbiAgICBlcnJvcjogJ2UnO1xuICAgIGZhdGFsOiAnZic7XG4gIH1cblxuICBleHBvcnQgdHlwZSBTZXZlcml0eSA9IGtleW9mIFNldmVyaXR5VHlwZU1hcDtcblxuICBleHBvcnQgdHlwZSBQcm92aWRlciA9ICdub25lJyB8ICdjb25zb2xlJztcblxuICAvKipcbiAgICogTG9nZ2luZyBjb25maWcgdGhhdCB1c2VkIHRvIGNvbnRyb2wgdGhlIGJlaGF2aW9yIG9mIGxvZ2dlclxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBDb25maWcge1xuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgdGhlIGxvZ2dpbmcgcHJvdmlkZXIuICdjb25zb2xlJyBieSBkZWZhdWx0XG4gICAgICovXG4gICAgcHJvdmlkZXI/OiBQcm92aWRlcjtcbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IHRoZSBtaW5pbWFsIGxvZ2dlciBzZXJ2ZXJpdHkuICd3YXJuaW5nJyBieSBkZWZhdWx0XG4gICAgICovXG4gICAgbWluaW1hbFNldmVyaXR5PzogTG9nZ2VyLlNldmVyaXR5O1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gb3V0cHV0IGRhdGUgdGltZSBpbiBsb2cuIHRydWUgYnkgZGVmYXVsdFxuICAgICAqL1xuICAgIGxvZ0RhdGVUaW1lPzogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIG91dHB1dCBzb3VyY2UgaW5mb3JtYXRpb24gKE5vdCB5ZXQgc3VwcG9ydGVkKS4gZmFsc2UgYnkgZGVmYXVsdFxuICAgICAqL1xuICAgIGxvZ1NvdXJjZUxvY2F0aW9uPzogYm9vbGVhbjtcbiAgfVxuXG4gIGV4cG9ydCBpbnRlcmZhY2UgQ2F0ZWdvcml6ZWRMb2dnZXIge1xuICAgIHZlcmJvc2UoY29udGVudDogc3RyaW5nKTogdm9pZDtcbiAgICBpbmZvKGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gICAgd2FybmluZyhjb250ZW50OiBzdHJpbmcpOiB2b2lkO1xuICAgIGVycm9yKGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gICAgZmF0YWwoY29udGVudDogc3RyaW5nKTogdm9pZDtcbiAgfVxufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlZGVjbGFyZVxuZXhwb3J0IGludGVyZmFjZSBMb2dnZXIge1xuICAoY2F0ZWdvcnk6IHN0cmluZyk6IExvZ2dlci5DYXRlZ29yaXplZExvZ2dlcjtcblxuICB2ZXJib3NlKGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gIHZlcmJvc2UoY2F0ZWdvcnk6IHN0cmluZywgY29udGVudDogc3RyaW5nKTogdm9pZDtcbiAgaW5mbyhjb250ZW50OiBzdHJpbmcpOiB2b2lkO1xuICBpbmZvKGNhdGVnb3J5OiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gIHdhcm5pbmcoY29udGVudDogc3RyaW5nKTogdm9pZDtcbiAgd2FybmluZyhjYXRlZ29yeTogc3RyaW5nLCBjb250ZW50OiBzdHJpbmcpOiB2b2lkO1xuICBlcnJvcihjb250ZW50OiBzdHJpbmcpOiB2b2lkO1xuICBlcnJvcihjYXRlZ29yeTogc3RyaW5nLCBjb250ZW50OiBzdHJpbmcpOiB2b2lkO1xuICBmYXRhbChjb250ZW50OiBzdHJpbmcpOiB2b2lkO1xuICBmYXRhbChjYXRlZ29yeTogc3RyaW5nLCBjb250ZW50OiBzdHJpbmcpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBSZXNldCB0aGUgbG9nZ2VyIGNvbmZpZ3VyYXRpb24uXG4gICAqIEBwYXJhbSBjb25maWcgc3BlY2lmeSBhbiBvcHRpb25hbCBkZWZhdWx0IGNvbmZpZ1xuICAgKi9cbiAgcmVzZXQoY29uZmlnPzogTG9nZ2VyLkNvbmZpZyk6IHZvaWQ7XG4gIC8qKlxuICAgKiBTZXQgdGhlIGxvZ2dlcidzIGJlaGF2aW9yIG9uIHRoZSBnaXZlbiBjYXRlZ29yeVxuICAgKiBAcGFyYW0gY2F0ZWdvcnkgc3BlY2lmeSBhIGNhdGVnb3J5IHN0cmluZy4gSWYgJyonIGlzIHNwZWNpZmllZCwgYWxsIHByZXZpb3VzIGNvbmZpZ3VyYXRpb24gd2lsbCBiZSBvdmVyd3JpdHRlbi4gSWZcbiAgICogJycgaXMgc3BlY2lmaWVkLCB0aGUgZGVmYXVsdCBiZWhhdmlvciB3aWxsIGJlIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSBjb25maWcgdGhlIGNvbmZpZyBvYmplY3QgdG8gaW5kaWNhdGUgdGhlIGxvZ2dlcidzIGJlaGF2aW9yXG4gICAqL1xuICBzZXQoY2F0ZWdvcnk6IHN0cmluZywgY29uZmlnOiBMb2dnZXIuQ29uZmlnKTogdm9pZDtcblxuICAvKipcbiAgICogU2V0IHRoZSBsb2dnZXIncyBiZWhhdmlvciBmcm9tIG9ydC1jb21tb24gZW52XG4gICAqIEBwYXJhbSBlbnYgdGhlIGVudiB1c2VkIHRvIHNldCBsb2dnZXIuIEN1cnJlbnRseSBvbmx5IHNldHRpbmcgbG9nbGV2ZWwgaXMgc3VwcG9ydGVkIHRocm91Z2ggRW52LlxuICAgKi9cbiAgc2V0V2l0aEVudihlbnY6IEVudik6IHZvaWQ7XG59XG5cbmludGVyZmFjZSBMb2dnZXJQcm92aWRlciB7XG4gIGxvZyhzZXZlcml0eTogTG9nZ2VyLlNldmVyaXR5LCBjb250ZW50OiBzdHJpbmcsIGNhdGVnb3J5Pzogc3RyaW5nKTogdm9pZDtcbn1cbmNsYXNzIE5vT3BMb2dnZXJQcm92aWRlciBpbXBsZW1lbnRzIExvZ2dlclByb3ZpZGVyIHtcbiAgbG9nKF9zZXZlcml0eTogTG9nZ2VyLlNldmVyaXR5LCBfY29udGVudDogc3RyaW5nLCBfY2F0ZWdvcnk/OiBzdHJpbmcpIHtcbiAgICAvLyBkbyBub3RoaW5nXG4gIH1cbn1cbmNsYXNzIENvbnNvbGVMb2dnZXJQcm92aWRlciBpbXBsZW1lbnRzIExvZ2dlclByb3ZpZGVyIHtcbiAgbG9nKHNldmVyaXR5OiBMb2dnZXIuU2V2ZXJpdHksIGNvbnRlbnQ6IHN0cmluZywgY2F0ZWdvcnk/OiBzdHJpbmcpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGNvbnNvbGUubG9nKGAke3RoaXMuY29sb3Ioc2V2ZXJpdHkpfSAke2NhdGVnb3J5ID8gJ1xceDFiWzM1bScgKyBjYXRlZ29yeSArICdcXHgxYlswbSAnIDogJyd9JHtjb250ZW50fWApO1xuICB9XG5cbiAgcHJpdmF0ZSBjb2xvcihzZXZlcml0eTogTG9nZ2VyLlNldmVyaXR5KSB7XG4gICAgc3dpdGNoIChzZXZlcml0eSkge1xuICAgICAgY2FzZSAndmVyYm9zZSc6XG4gICAgICAgIHJldHVybiAnXFx4MWJbMzQ7NDBtdlxceDFiWzBtJztcbiAgICAgIGNhc2UgJ2luZm8nOlxuICAgICAgICByZXR1cm4gJ1xceDFiWzMybWlcXHgxYlswbSc7XG4gICAgICBjYXNlICd3YXJuaW5nJzpcbiAgICAgICAgcmV0dXJuICdcXHgxYlszMDs0M213XFx4MWJbMG0nO1xuICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICByZXR1cm4gJ1xceDFiWzMxOzQwbWVcXHgxYlswbSc7XG4gICAgICBjYXNlICdmYXRhbCc6XG4gICAgICAgIHJldHVybiAnXFx4MWJbMTAxbWZcXHgxYlswbSc7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIHNldmVyaXR5OiAke3NldmVyaXR5fWApO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBTRVZFUklUWV9WQUxVRSA9IHtcbiAgdmVyYm9zZTogMTAwMCxcbiAgaW5mbzogMjAwMCxcbiAgd2FybmluZzogNDAwMCxcbiAgZXJyb3I6IDUwMDAsXG4gIGZhdGFsOiA2MDAwLFxufTtcblxuY29uc3QgTE9HR0VSX1BST1ZJREVSX01BUDogeyByZWFkb25seSBbcHJvdmlkZXI6IHN0cmluZ106IFJlYWRvbmx5PExvZ2dlclByb3ZpZGVyPiB9ID0ge1xuICBbJ25vbmUnXTogbmV3IE5vT3BMb2dnZXJQcm92aWRlcigpLFxuICBbJ2NvbnNvbGUnXTogbmV3IENvbnNvbGVMb2dnZXJQcm92aWRlcigpLFxufTtcbmNvbnN0IExPR0dFUl9ERUZBVUxUX0NPTkZJRyA9IHtcbiAgcHJvdmlkZXI6ICdjb25zb2xlJyxcbiAgbWluaW1hbFNldmVyaXR5OiAnd2FybmluZycsXG4gIGxvZ0RhdGVUaW1lOiB0cnVlLFxuICBsb2dTb3VyY2VMb2NhdGlvbjogZmFsc2UsXG59O1xubGV0IExPR0dFUl9DT05GSUdfTUFQOiB7IFtjYXRlZ29yeTogc3RyaW5nXTogUmVhZG9ubHk8UmVxdWlyZWQ8TG9nZ2VyLkNvbmZpZz4+IH0gPSB7XG4gIFsnJ106IExPR0dFUl9ERUZBVUxUX0NPTkZJRyBhcyBSZXF1aXJlZDxMb2dnZXIuQ29uZmlnPixcbn07XG5cbmZ1bmN0aW9uIGxvZyhjYXRlZ29yeTogc3RyaW5nKTogTG9nZ2VyLkNhdGVnb3JpemVkTG9nZ2VyO1xuZnVuY3Rpb24gbG9nKHNldmVyaXR5OiBMb2dnZXIuU2V2ZXJpdHksIGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG5mdW5jdGlvbiBsb2coc2V2ZXJpdHk6IExvZ2dlci5TZXZlcml0eSwgY2F0ZWdvcnk6IHN0cmluZywgY29udGVudDogc3RyaW5nKTogdm9pZDtcbmZ1bmN0aW9uIGxvZyhzZXZlcml0eTogTG9nZ2VyLlNldmVyaXR5LCBhcmcxOiBzdHJpbmcsIGFyZzI/OiBzdHJpbmcpOiB2b2lkO1xuZnVuY3Rpb24gbG9nKFxuICBhcmcwOiBzdHJpbmcgfCBMb2dnZXIuU2V2ZXJpdHksXG4gIGFyZzE/OiBzdHJpbmcsXG4gIGFyZzI/OiBzdHJpbmcgfCBudW1iZXIsXG4gIGFyZzM/OiBudW1iZXIsXG4pOiBMb2dnZXIuQ2F0ZWdvcml6ZWRMb2dnZXIgfCB2b2lkIHtcbiAgaWYgKGFyZzEgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIGxvZyhjYXRlZ29yeTogc3RyaW5nKTogTG9nZ2VyLkNhdGVnb3JpemVkTG9nZ2VyO1xuICAgIHJldHVybiBjcmVhdGVDYXRlZ29yaXplZExvZ2dlcihhcmcwKTtcbiAgfSBlbHNlIGlmIChhcmcyID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBsb2coc2V2ZXJpdHksIGNvbnRlbnQpO1xuICAgIGxvZ0ludGVybmFsKGFyZzAgYXMgTG9nZ2VyLlNldmVyaXR5LCBhcmcxLCAxKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYXJnMiA9PT0gJ251bWJlcicgJiYgYXJnMyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gbG9nKHNldmVyaXR5LCBjb250ZW50LCBzdGFjaylcbiAgICBsb2dJbnRlcm5hbChhcmcwIGFzIExvZ2dlci5TZXZlcml0eSwgYXJnMSwgYXJnMik7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGFyZzIgPT09ICdzdHJpbmcnICYmIGFyZzMgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIGxvZyhzZXZlcml0eSwgY2F0ZWdvcnksIGNvbnRlbnQpXG4gICAgbG9nSW50ZXJuYWwoYXJnMCBhcyBMb2dnZXIuU2V2ZXJpdHksIGFyZzIsIDEsIGFyZzEpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcyID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgYXJnMyA9PT0gJ251bWJlcicpIHtcbiAgICAvLyBsb2coc2V2ZXJpdHksIGNhdGVnb3J5LCBjb250ZW50LCBzdGFjaylcbiAgICBsb2dJbnRlcm5hbChhcmcwIGFzIExvZ2dlci5TZXZlcml0eSwgYXJnMiwgYXJnMywgYXJnMSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW5wdXQgaXMgdmFsaWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDYXRlZ29yaXplZExvZ2dlcihjYXRlZ29yeTogc3RyaW5nKTogTG9nZ2VyLkNhdGVnb3JpemVkTG9nZ2VyIHtcbiAgcmV0dXJuIHtcbiAgICB2ZXJib3NlOiBsb2cudmVyYm9zZS5iaW5kKG51bGwsIGNhdGVnb3J5KSxcbiAgICBpbmZvOiBsb2cuaW5mby5iaW5kKG51bGwsIGNhdGVnb3J5KSxcbiAgICB3YXJuaW5nOiBsb2cud2FybmluZy5iaW5kKG51bGwsIGNhdGVnb3J5KSxcbiAgICBlcnJvcjogbG9nLmVycm9yLmJpbmQobnVsbCwgY2F0ZWdvcnkpLFxuICAgIGZhdGFsOiBsb2cuZmF0YWwuYmluZChudWxsLCBjYXRlZ29yeSksXG4gIH07XG59XG5cbi8vIE5PVEU6IGFyZ3VtZW50ICdjYXRlZ29yeScgaXMgcHV0IHRoZSBsYXN0IHBhcmFtZXRlciBiZWFjYXVzZSB0eXBlc2NyaXB0XG4vLyBkb2Vzbid0IGFsbG93IG9wdGlvbmFsIGFyZ3VtZW50IHB1dCBpbiBmcm9udCBvZiByZXF1aXJlZCBhcmd1bWVudC4gVGhpc1xuLy8gb3JkZXIgaXMgZGlmZmVyZW50IGZyb20gYSB1c3VhbCBsb2dnaW5nIEFQSS5cbmZ1bmN0aW9uIGxvZ0ludGVybmFsKHNldmVyaXR5OiBMb2dnZXIuU2V2ZXJpdHksIGNvbnRlbnQ6IHN0cmluZywgX3N0YWNrOiBudW1iZXIsIGNhdGVnb3J5Pzogc3RyaW5nKSB7XG4gIGNvbnN0IGNvbmZpZyA9IExPR0dFUl9DT05GSUdfTUFQW2NhdGVnb3J5IHx8ICcnXSB8fCBMT0dHRVJfQ09ORklHX01BUFsnJ107XG4gIGlmIChTRVZFUklUWV9WQUxVRVtzZXZlcml0eV0gPCBTRVZFUklUWV9WQUxVRVtjb25maWcubWluaW1hbFNldmVyaXR5XSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjb25maWcubG9nRGF0ZVRpbWUpIHtcbiAgICBjb250ZW50ID0gYCR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpfXwke2NvbnRlbnR9YDtcbiAgfVxuXG4gIGlmIChjb25maWcubG9nU291cmNlTG9jYXRpb24pIHtcbiAgICAvLyBUT0RPOiBjYWxjdWxhdGUgc291cmNlIGxvY2F0aW9uIGZyb20gJ3N0YWNrJ1xuICB9XG5cbiAgTE9HR0VSX1BST1ZJREVSX01BUFtjb25maWcucHJvdmlkZXJdLmxvZyhzZXZlcml0eSwgY29udGVudCwgY2F0ZWdvcnkpO1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5hbWVzcGFjZVxubmFtZXNwYWNlIGxvZyB7XG4gIGV4cG9ydCBmdW5jdGlvbiB2ZXJib3NlKGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gIGV4cG9ydCBmdW5jdGlvbiB2ZXJib3NlKGNhdGVnb3J5OiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gIGV4cG9ydCBmdW5jdGlvbiB2ZXJib3NlKGFyZzA6IHN0cmluZywgYXJnMT86IHN0cmluZykge1xuICAgIGxvZygndmVyYm9zZScsIGFyZzAsIGFyZzEpO1xuICB9XG4gIGV4cG9ydCBmdW5jdGlvbiBpbmZvKGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gIGV4cG9ydCBmdW5jdGlvbiBpbmZvKGNhdGVnb3J5OiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gIGV4cG9ydCBmdW5jdGlvbiBpbmZvKGFyZzA6IHN0cmluZywgYXJnMT86IHN0cmluZykge1xuICAgIGxvZygnaW5mbycsIGFyZzAsIGFyZzEpO1xuICB9XG4gIGV4cG9ydCBmdW5jdGlvbiB3YXJuaW5nKGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gIGV4cG9ydCBmdW5jdGlvbiB3YXJuaW5nKGNhdGVnb3J5OiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gIGV4cG9ydCBmdW5jdGlvbiB3YXJuaW5nKGFyZzA6IHN0cmluZywgYXJnMT86IHN0cmluZykge1xuICAgIGxvZygnd2FybmluZycsIGFyZzAsIGFyZzEpO1xuICB9XG4gIGV4cG9ydCBmdW5jdGlvbiBlcnJvcihjb250ZW50OiBzdHJpbmcpOiB2b2lkO1xuICBleHBvcnQgZnVuY3Rpb24gZXJyb3IoY2F0ZWdvcnk6IHN0cmluZywgY29udGVudDogc3RyaW5nKTogdm9pZDtcbiAgZXhwb3J0IGZ1bmN0aW9uIGVycm9yKGFyZzA6IHN0cmluZywgYXJnMT86IHN0cmluZykge1xuICAgIGxvZygnZXJyb3InLCBhcmcwLCBhcmcxKTtcbiAgfVxuICBleHBvcnQgZnVuY3Rpb24gZmF0YWwoY29udGVudDogc3RyaW5nKTogdm9pZDtcbiAgZXhwb3J0IGZ1bmN0aW9uIGZhdGFsKGNhdGVnb3J5OiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gIGV4cG9ydCBmdW5jdGlvbiBmYXRhbChhcmcwOiBzdHJpbmcsIGFyZzE/OiBzdHJpbmcpIHtcbiAgICBsb2coJ2ZhdGFsJywgYXJnMCwgYXJnMSk7XG4gIH1cblxuICBleHBvcnQgZnVuY3Rpb24gcmVzZXQoY29uZmlnPzogTG9nZ2VyLkNvbmZpZyk6IHZvaWQge1xuICAgIExPR0dFUl9DT05GSUdfTUFQID0ge307XG4gICAgc2V0KCcnLCBjb25maWcgfHwge30pO1xuICB9XG4gIGV4cG9ydCBmdW5jdGlvbiBzZXQoY2F0ZWdvcnk6IHN0cmluZywgY29uZmlnOiBMb2dnZXIuQ29uZmlnKTogdm9pZCB7XG4gICAgaWYgKGNhdGVnb3J5ID09PSAnKicpIHtcbiAgICAgIHJlc2V0KGNvbmZpZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzQ29uZmlnID0gTE9HR0VSX0NPTkZJR19NQVBbY2F0ZWdvcnldIHx8IExPR0dFUl9ERUZBVUxUX0NPTkZJRztcbiAgICAgIExPR0dFUl9DT05GSUdfTUFQW2NhdGVnb3J5XSA9IHtcbiAgICAgICAgcHJvdmlkZXI6IGNvbmZpZy5wcm92aWRlciB8fCBwcmV2aW91c0NvbmZpZy5wcm92aWRlcixcbiAgICAgICAgbWluaW1hbFNldmVyaXR5OiBjb25maWcubWluaW1hbFNldmVyaXR5IHx8IHByZXZpb3VzQ29uZmlnLm1pbmltYWxTZXZlcml0eSxcbiAgICAgICAgbG9nRGF0ZVRpbWU6IGNvbmZpZy5sb2dEYXRlVGltZSA9PT0gdW5kZWZpbmVkID8gcHJldmlvdXNDb25maWcubG9nRGF0ZVRpbWUgOiBjb25maWcubG9nRGF0ZVRpbWUsXG4gICAgICAgIGxvZ1NvdXJjZUxvY2F0aW9uOlxuICAgICAgICAgIGNvbmZpZy5sb2dTb3VyY2VMb2NhdGlvbiA9PT0gdW5kZWZpbmVkID8gcHJldmlvdXNDb25maWcubG9nU291cmNlTG9jYXRpb24gOiBjb25maWcubG9nU291cmNlTG9jYXRpb24sXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIFRPRE86IHdlIHdhbnQgdG8gc3VwcG9ydCB3aWxkY2FyZCBvciByZWdleD9cbiAgfVxuXG4gIGV4cG9ydCBmdW5jdGlvbiBzZXRXaXRoRW52KGVudjogRW52KTogdm9pZCB7XG4gICAgY29uc3QgY29uZmlnOiBMb2dnZXIuQ29uZmlnID0ge307XG4gICAgaWYgKGVudi5sb2dMZXZlbCkge1xuICAgICAgY29uZmlnLm1pbmltYWxTZXZlcml0eSA9IGVudi5sb2dMZXZlbCBhcyBMb2dnZXIuU2V2ZXJpdHk7XG4gICAgfVxuICAgIHNldCgnJywgY29uZmlnKTtcbiAgfVxufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlZGVjbGFyZSwgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5leHBvcnQgY29uc3QgTG9nZ2VyOiBMb2dnZXIgPSBsb2c7XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBQcm9maWxlciB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgQ29uZmlnIHtcbiAgICBtYXhOdW1iZXJFdmVudHM/OiBudW1iZXI7XG4gICAgZmx1c2hCYXRjaFNpemU/OiBudW1iZXI7XG4gICAgZmx1c2hJbnRlcnZhbEluTWlsbGlzZWNvbmRzPzogbnVtYmVyO1xuICB9XG5cbiAgZXhwb3J0IHR5cGUgRXZlbnRDYXRlZ29yeSA9ICdzZXNzaW9uJyB8ICdub2RlJyB8ICdvcCcgfCAnYmFja2VuZCc7XG5cbiAgZXhwb3J0IGludGVyZmFjZSBFdmVudCB7XG4gICAgZW5kKCk6IHZvaWQgfCBQcm9taXNlPHZvaWQ+O1xuICB9XG59XG4vLyBUT0RPXG4vLyBjbGFzcyBXZWJHTEV2ZW50IGltcGxlbWVudHMgUHJvZmlsZXIuRXZlbnQge31cblxuY2xhc3MgRXZlbnQgaW1wbGVtZW50cyBQcm9maWxlci5FdmVudCB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBjYXRlZ29yeTogUHJvZmlsZXIuRXZlbnRDYXRlZ29yeSxcbiAgICBwdWJsaWMgbmFtZTogc3RyaW5nLFxuICAgIHB1YmxpYyBzdGFydFRpbWU6IG51bWJlcixcbiAgICBwcml2YXRlIGVuZENhbGxiYWNrOiAoZTogRXZlbnQpID0+IHZvaWQgfCBQcm9taXNlPHZvaWQ+LFxuICAgIHB1YmxpYyB0aW1lcj86IFdlYkdMUXVlcnksXG4gICAgcHVibGljIGN0eD86IFdlYkdMQ29udGV4dCxcbiAgKSB7fVxuXG4gIGFzeW5jIGVuZCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbmRDYWxsYmFjayh0aGlzKTtcbiAgfVxuXG4gIGFzeW5jIGNoZWNrVGltZXIoKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICBpZiAodGhpcy5jdHggPT09IHVuZGVmaW5lZCB8fCB0aGlzLnRpbWVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gd2ViZ2wgdGltZXIgZm91bmQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jdHguZW5kVGltZXIoKTtcbiAgICAgIHJldHVybiB0aGlzLmN0eC53YWl0Rm9yUXVlcnlBbmRHZXRUaW1lKHRoaXMudGltZXIpO1xuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBFdmVudFJlY29yZCB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBjYXRlZ29yeTogUHJvZmlsZXIuRXZlbnRDYXRlZ29yeSxcbiAgICBwdWJsaWMgbmFtZTogc3RyaW5nLFxuICAgIHB1YmxpYyBzdGFydFRpbWU6IG51bWJlcixcbiAgICBwdWJsaWMgZW5kVGltZTogbnVtYmVyLFxuICApIHt9XG59XG5cbmV4cG9ydCBjbGFzcyBQcm9maWxlciB7XG4gIHN0YXRpYyBjcmVhdGUoY29uZmlnPzogUHJvZmlsZXIuQ29uZmlnKTogUHJvZmlsZXIge1xuICAgIGlmIChjb25maWcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgdGhpcyhjb25maWcubWF4TnVtYmVyRXZlbnRzLCBjb25maWcuZmx1c2hCYXRjaFNpemUsIGNvbmZpZy5mbHVzaEludGVydmFsSW5NaWxsaXNlY29uZHMpO1xuICB9XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihtYXhOdW1iZXJFdmVudHM/OiBudW1iZXIsIGZsdXNoQmF0Y2hTaXplPzogbnVtYmVyLCBmbHVzaEludGVydmFsSW5NaWxsaXNlY29uZHM/OiBudW1iZXIpIHtcbiAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgdGhpcy5fbWF4TnVtYmVyRXZlbnRzID0gbWF4TnVtYmVyRXZlbnRzID09PSB1bmRlZmluZWQgPyAxMDAwMCA6IG1heE51bWJlckV2ZW50cztcbiAgICB0aGlzLl9mbHVzaEJhdGNoU2l6ZSA9IGZsdXNoQmF0Y2hTaXplID09PSB1bmRlZmluZWQgPyAxMCA6IGZsdXNoQmF0Y2hTaXplO1xuICAgIHRoaXMuX2ZsdXNoSW50ZXJ2YWxJbk1pbGxpc2Vjb25kcyA9IGZsdXNoSW50ZXJ2YWxJbk1pbGxpc2Vjb25kcyA9PT0gdW5kZWZpbmVkID8gNTAwMCA6IGZsdXNoSW50ZXJ2YWxJbk1pbGxpc2Vjb25kcztcbiAgfVxuXG4gIC8vIHN0YXJ0IHByb2ZpbGluZ1xuICBzdGFydCgpIHtcbiAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcbiAgICB0aGlzLl90aW1pbmdFdmVudHMgPSBbXTtcbiAgICB0aGlzLl9mbHVzaFRpbWUgPSBub3coKTtcbiAgICB0aGlzLl9mbHVzaFBvaW50ZXIgPSAwO1xuICB9XG5cbiAgLy8gc3RvcCBwcm9maWxpbmdcbiAgc3RvcCgpIHtcbiAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgZm9yICg7IHRoaXMuX2ZsdXNoUG9pbnRlciA8IHRoaXMuX3RpbWluZ0V2ZW50cy5sZW5ndGg7IHRoaXMuX2ZsdXNoUG9pbnRlcisrKSB7XG4gICAgICB0aGlzLmxvZ09uZUV2ZW50KHRoaXMuX3RpbWluZ0V2ZW50c1t0aGlzLl9mbHVzaFBvaW50ZXJdKTtcbiAgICB9XG4gIH1cblxuICAvLyBjcmVhdGUgYW4gZXZlbnQgc2NvcGUgZm9yIHRoZSBzcGVjaWZpYyBmdW5jdGlvblxuICBldmVudDxUPihjYXRlZ29yeTogUHJvZmlsZXIuRXZlbnRDYXRlZ29yeSwgbmFtZTogc3RyaW5nLCBmdW5jOiAoKSA9PiBULCBjdHg/OiBXZWJHTENvbnRleHQpOiBUO1xuICBldmVudDxUPihjYXRlZ29yeTogUHJvZmlsZXIuRXZlbnRDYXRlZ29yeSwgbmFtZTogc3RyaW5nLCBmdW5jOiAoKSA9PiBQcm9taXNlPFQ+LCBjdHg/OiBXZWJHTENvbnRleHQpOiBQcm9taXNlPFQ+O1xuXG4gIGV2ZW50PFQ+KFxuICAgIGNhdGVnb3J5OiBQcm9maWxlci5FdmVudENhdGVnb3J5LFxuICAgIG5hbWU6IHN0cmluZyxcbiAgICBmdW5jOiAoKSA9PiBUIHwgUHJvbWlzZTxUPixcbiAgICBjdHg/OiBXZWJHTENvbnRleHQsXG4gICk6IFQgfCBQcm9taXNlPFQ+IHtcbiAgICBjb25zdCBldmVudCA9IHRoaXMuX3N0YXJ0ZWQgPyB0aGlzLmJlZ2luKGNhdGVnb3J5LCBuYW1lLCBjdHgpIDogdW5kZWZpbmVkO1xuICAgIGxldCBpc1Byb21pc2UgPSBmYWxzZTtcblxuICAgIGNvbnN0IHJlcyA9IGZ1bmMoKTtcblxuICAgIC8vIHdlIGNvbnNpZGVyIGEgdGhlbi1hYmxlIG9iamVjdCBpcyBhIHByb21pc2VcbiAgICBpZiAocmVzICYmIHR5cGVvZiAocmVzIGFzIFByb21pc2U8VD4pLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlzUHJvbWlzZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2U8VD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAocmVzIGFzIFByb21pc2U8VD4pLnRoZW4oXG4gICAgICAgICAgYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAvLyBmdWxmaWxsZWRcbiAgICAgICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgICBhd2FpdCBldmVudC5lbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYXN5bmMgKHJlYXNvbikgPT4ge1xuICAgICAgICAgICAgLy8gcmVqZWN0ZWRcbiAgICAgICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgICBhd2FpdCBldmVudC5lbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlamVjdChyZWFzb24pO1xuICAgICAgICAgIH0sXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFpc1Byb21pc2UgJiYgZXZlbnQpIHtcbiAgICAgIGNvbnN0IGV2ZW50UmVzID0gZXZlbnQuZW5kKCk7XG4gICAgICBpZiAoZXZlbnRSZXMgJiYgdHlwZW9mIGV2ZW50UmVzLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPFQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICBldmVudFJlcy50aGVuKFxuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAvLyBmdWxmaWxsZWRcbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIChyZWFzb24pID0+IHtcbiAgICAgICAgICAgICAgLy8gcmVqZWN0ZWRcbiAgICAgICAgICAgICAgcmVqZWN0KHJlYXNvbik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgLy8gYmVnaW4gYW4gZXZlbnRcbiAgYmVnaW4oY2F0ZWdvcnk6IFByb2ZpbGVyLkV2ZW50Q2F0ZWdvcnksIG5hbWU6IHN0cmluZywgY3R4PzogV2ViR0xDb250ZXh0KTogRXZlbnQge1xuICAgIGlmICghdGhpcy5fc3RhcnRlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcm9maWxlciBpcyBub3Qgc3RhcnRlZCB5ZXQnKTtcbiAgICB9XG4gICAgaWYgKGN0eCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBub3coKTtcbiAgICAgIHRoaXMuZmx1c2goc3RhcnRUaW1lKTtcbiAgICAgIHJldHVybiBuZXcgRXZlbnQoY2F0ZWdvcnksIG5hbWUsIHN0YXJ0VGltZSwgKGUpID0+IHRoaXMuZW5kU3luYyhlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRpbWVyOiBXZWJHTFF1ZXJ5ID0gY3R4LmJlZ2luVGltZXIoKTtcbiAgICAgIHJldHVybiBuZXcgRXZlbnQoY2F0ZWdvcnksIG5hbWUsIDAsIGFzeW5jIChlKSA9PiB0aGlzLmVuZChlKSwgdGltZXIsIGN0eCk7XG4gICAgfVxuICB9XG5cbiAgLy8gZW5kIHRoZSBzcGVjaWZpYyBldmVudFxuICBwcml2YXRlIGFzeW5jIGVuZChldmVudDogRXZlbnQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBlbmRUaW1lOiBudW1iZXIgPSBhd2FpdCBldmVudC5jaGVja1RpbWVyKCk7XG4gICAgaWYgKHRoaXMuX3RpbWluZ0V2ZW50cy5sZW5ndGggPCB0aGlzLl9tYXhOdW1iZXJFdmVudHMpIHtcbiAgICAgIHRoaXMuX3RpbWluZ0V2ZW50cy5wdXNoKG5ldyBFdmVudFJlY29yZChldmVudC5jYXRlZ29yeSwgZXZlbnQubmFtZSwgZXZlbnQuc3RhcnRUaW1lLCBlbmRUaW1lKSk7XG4gICAgICB0aGlzLmZsdXNoKGVuZFRpbWUpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZW5kU3luYyhldmVudDogRXZlbnQpOiB2b2lkIHtcbiAgICBjb25zdCBlbmRUaW1lOiBudW1iZXIgPSBub3coKTtcbiAgICBpZiAodGhpcy5fdGltaW5nRXZlbnRzLmxlbmd0aCA8IHRoaXMuX21heE51bWJlckV2ZW50cykge1xuICAgICAgdGhpcy5fdGltaW5nRXZlbnRzLnB1c2gobmV3IEV2ZW50UmVjb3JkKGV2ZW50LmNhdGVnb3J5LCBldmVudC5uYW1lLCBldmVudC5zdGFydFRpbWUsIGVuZFRpbWUpKTtcbiAgICAgIHRoaXMuZmx1c2goZW5kVGltZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBsb2dPbmVFdmVudChldmVudDogRXZlbnRSZWNvcmQpIHtcbiAgICBMb2dnZXIudmVyYm9zZShcbiAgICAgIGBQcm9maWxlci4ke2V2ZW50LmNhdGVnb3J5fWAsXG4gICAgICBgJHsoZXZlbnQuZW5kVGltZSAtIGV2ZW50LnN0YXJ0VGltZSkudG9GaXhlZCgyKX1tcyBvbiBldmVudCAnJHtldmVudC5uYW1lfScgYXQgJHtldmVudC5lbmRUaW1lLnRvRml4ZWQoMil9YCxcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBmbHVzaChjdXJyZW50VGltZTogbnVtYmVyKSB7XG4gICAgaWYgKFxuICAgICAgdGhpcy5fdGltaW5nRXZlbnRzLmxlbmd0aCAtIHRoaXMuX2ZsdXNoUG9pbnRlciA+PSB0aGlzLl9mbHVzaEJhdGNoU2l6ZSB8fFxuICAgICAgY3VycmVudFRpbWUgLSB0aGlzLl9mbHVzaFRpbWUgPj0gdGhpcy5fZmx1c2hJbnRlcnZhbEluTWlsbGlzZWNvbmRzXG4gICAgKSB7XG4gICAgICAvLyBzaG91bGQgZmx1c2ggd2hlbiBlaXRoZXIgYmF0Y2ggc2l6ZSBhY2N1bWxhdGVkIG9yIGludGVydmFsIGVsZXBzZWRcblxuICAgICAgZm9yIChcbiAgICAgICAgY29uc3QgcHJldmlvdXNQb2ludGVyID0gdGhpcy5fZmx1c2hQb2ludGVyO1xuICAgICAgICB0aGlzLl9mbHVzaFBvaW50ZXIgPCBwcmV2aW91c1BvaW50ZXIgKyB0aGlzLl9mbHVzaEJhdGNoU2l6ZSAmJiB0aGlzLl9mbHVzaFBvaW50ZXIgPCB0aGlzLl90aW1pbmdFdmVudHMubGVuZ3RoO1xuICAgICAgICB0aGlzLl9mbHVzaFBvaW50ZXIrK1xuICAgICAgKSB7XG4gICAgICAgIHRoaXMubG9nT25lRXZlbnQodGhpcy5fdGltaW5nRXZlbnRzW3RoaXMuX2ZsdXNoUG9pbnRlcl0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9mbHVzaFRpbWUgPSBub3coKTtcbiAgICB9XG4gIH1cblxuICBnZXQgc3RhcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhcnRlZDtcbiAgfVxuICBwcml2YXRlIF9zdGFydGVkID0gZmFsc2U7XG4gIHByaXZhdGUgX3RpbWluZ0V2ZW50czogRXZlbnRSZWNvcmRbXTtcblxuICBwcml2YXRlIHJlYWRvbmx5IF9tYXhOdW1iZXJFdmVudHM6IG51bWJlcjtcblxuICBwcml2YXRlIHJlYWRvbmx5IF9mbHVzaEJhdGNoU2l6ZTogbnVtYmVyO1xuICBwcml2YXRlIHJlYWRvbmx5IF9mbHVzaEludGVydmFsSW5NaWxsaXNlY29uZHM6IG51bWJlcjtcblxuICBwcml2YXRlIF9mbHVzaFRpbWU6IG51bWJlcjtcbiAgcHJpdmF0ZSBfZmx1c2hQb2ludGVyID0gMDtcbn1cblxuLyoqXG4gKiByZXR1cm5zIGEgbnVtYmVyIHRvIHJlcHJlc2VudCB0aGUgY3VycmVudCB0aW1lc3RhbXAgaW4gYSByZXNvbHV0aW9uIGFzIGhpZ2ggYXMgcG9zc2libGUuXG4gKi9cbmV4cG9ydCBjb25zdCBub3cgPSB0eXBlb2YgcGVyZm9ybWFuY2UgIT09ICd1bmRlZmluZWQnICYmIHBlcmZvcm1hbmNlLm5vdyA/ICgpID0+IHBlcmZvcm1hbmNlLm5vdygpIDogRGF0ZS5ub3c7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEdyYXBoIH0gZnJvbSAnLi9ncmFwaCc7XG5pbXBvcnQgeyBPcGVyYXRvckltcGxlbWVudGF0aW9uLCBPcGVyYXRvckluaXRpYWxpemF0aW9uIH0gZnJvbSAnLi9vcGVyYXRvcnMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIE9wU2V0IHtcbiAgZG9tYWluOiBzdHJpbmc7XG4gIHZlcnNpb246IG51bWJlcjtcbn1cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBPcFNldCB7XG4gIC8qKlxuICAgKiBEb21haW4gb2YgYW4gb3BzZXQsIGl0IGNhbiBiZSBhbiBlbXB0eSBzdHJpbmcoZGVmYXVsdCB2YWx1ZSwgcmVwcmVzZW50IGZvciBhaS5vbm54KSwgb3IgJ2FpLm9ubngubWwnXG4gICAqL1xuICB0eXBlIERvbWFpbiA9ICcnIHwgJ2FpLm9ubngubWwnIHwgJ2NvbS5taWNyb3NvZnQnO1xuICAvKipcbiAgICogQSByZXNvbHZlIHJ1bGUgY29uc2lzdHMgb2YgNCBvciA1IGl0ZW1zOiBvcFR5cGUsIG9wU2V0RG9tYWluLCB2ZXJzaW9uU2VsZWN0b3IsIG9wZXJhdG9ySW1wbGVtZW50YXRpb24gYW5kXG4gICAqIG9wZXJhdG9ySW5pdGlhbGl6YXRpb24gKG9wdGlvbmFsKVxuICAgKi9cbiAgdHlwZSBSZXNvbHZlUnVsZSA9XG4gICAgfCBbc3RyaW5nLCBEb21haW4sIHN0cmluZywgT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxHcmFwaC5Ob2RlPl1cbiAgICB8IFtzdHJpbmcsIERvbWFpbiwgc3RyaW5nLCBPcGVyYXRvckltcGxlbWVudGF0aW9uPHVua25vd24+LCBPcGVyYXRvckluaXRpYWxpemF0aW9uPHVua25vd24+XTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVPcGVyYXRvcihub2RlOiBHcmFwaC5Ob2RlLCBvcHNldHM6IHJlYWRvbmx5IE9wU2V0W10sIHJ1bGVzOiByZWFkb25seSBPcFNldC5SZXNvbHZlUnVsZVtdKSB7XG4gIGZvciAoY29uc3QgcnVsZSBvZiBydWxlcykge1xuICAgIGNvbnN0IG9wVHlwZSA9IHJ1bGVbMF07XG4gICAgY29uc3QgZG9tYWluID0gcnVsZVsxXTtcbiAgICBjb25zdCB2ZXJzaW9uU2VsZWN0b3IgPSBydWxlWzJdO1xuICAgIGNvbnN0IG9wSW1wbCA9IHJ1bGVbM107XG4gICAgY29uc3Qgb3BJbml0ID0gcnVsZVs0XTtcblxuICAgIGlmIChub2RlLm9wVHlwZSA9PT0gb3BUeXBlKSB7XG4gICAgICAvLyBvcGVyYXRvciB0eXBlIG1hdGNoZXNcbiAgICAgIGZvciAoY29uc3Qgb3BzZXQgb2Ygb3BzZXRzKSB7XG4gICAgICAgIC8vIG9wc2V0ICcnIGFuZCAnYWkub25ueCcgYXJlIGNvbnNpZGVyZWQgdGhlIHNhbWUuXG4gICAgICAgIGlmIChvcHNldC5kb21haW4gPT09IGRvbWFpbiB8fCAob3BzZXQuZG9tYWluID09PSAnYWkub25ueCcgJiYgZG9tYWluID09PSAnJykpIHtcbiAgICAgICAgICAvLyBvcHNldCBkb21haW4gZm91bmRcbiAgICAgICAgICBpZiAobWF0Y2hTZWxlY3RvcihvcHNldC52ZXJzaW9uLCB2ZXJzaW9uU2VsZWN0b3IpKSB7XG4gICAgICAgICAgICByZXR1cm4geyBvcEltcGwsIG9wSW5pdCB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgYGNhbm5vdCByZXNvbHZlIG9wZXJhdG9yICcke25vZGUub3BUeXBlfScgd2l0aCBvcHNldHM6ICR7b3BzZXRzXG4gICAgICAubWFwKChzZXQpID0+IGAke3NldC5kb21haW4gfHwgJ2FpLm9ubngnfSB2JHtzZXQudmVyc2lvbn1gKVxuICAgICAgLmpvaW4oJywgJyl9YCxcbiAgKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hTZWxlY3Rvcih2ZXJzaW9uOiBudW1iZXIsIHNlbGVjdG9yOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgaWYgKHNlbGVjdG9yLmVuZHNXaXRoKCcrJykpIHtcbiAgICAvLyBtaW5pbXVtIHZlcnNpb24gbWF0Y2ggKCc3KycgZXhwZWN0cyB2ZXJzaW9uPj03KVxuICAgIGNvbnN0IHJhbmdlU3RhcnQgPSBOdW1iZXIucGFyc2VJbnQoc2VsZWN0b3Iuc3Vic3RyaW5nKDAsIHNlbGVjdG9yLmxlbmd0aCAtIDEpLCAxMCk7XG4gICAgcmV0dXJuICFpc05hTihyYW5nZVN0YXJ0KSAmJiByYW5nZVN0YXJ0IDw9IHZlcnNpb247XG4gIH0gZWxzZSBpZiAoc2VsZWN0b3Iuc3BsaXQoJy0nKS5sZW5ndGggPT09IDIpIHtcbiAgICAvLyByYW5nZSBtYXRjaCAoJzYtOCcgZXhwZWN0cyA2PD12ZXJzaW9uPD04KVxuICAgIGNvbnN0IHBhaXIgPSBzZWxlY3Rvci5zcGxpdCgnLScpO1xuICAgIGNvbnN0IHJhbmdlU3RhcnQgPSBOdW1iZXIucGFyc2VJbnQocGFpclswXSwgMTApO1xuICAgIGNvbnN0IHJhbmdlRW5kID0gTnVtYmVyLnBhcnNlSW50KHBhaXJbMV0sIDEwKTtcbiAgICByZXR1cm4gIWlzTmFOKHJhbmdlU3RhcnQpICYmICFpc05hTihyYW5nZUVuZCkgJiYgcmFuZ2VTdGFydCA8PSB2ZXJzaW9uICYmIHZlcnNpb24gPD0gcmFuZ2VFbmQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gZXhhY3QgbWF0Y2ggKCc3JyBleHBlY3RzIHZlcnNpb249PT03KVxuICAgIHJldHVybiBOdW1iZXIucGFyc2VJbnQoc2VsZWN0b3IsIDEwKSA9PT0gdmVyc2lvbjtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xyXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG52YXIgR3VpZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEd1aWQoZ3VpZCkge1xyXG4gICAgICAgIGlmICghZ3VpZCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhcmd1bWVudDsgYHZhbHVlYCBoYXMgbm8gdmFsdWUuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnZhbHVlID0gR3VpZC5FTVBUWTtcclxuICAgICAgICBpZiAoZ3VpZCAmJiBHdWlkLmlzR3VpZChndWlkKSkge1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gZ3VpZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBHdWlkLmlzR3VpZCA9IGZ1bmN0aW9uIChndWlkKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gZ3VpZC50b1N0cmluZygpO1xyXG4gICAgICAgIHJldHVybiBndWlkICYmIChndWlkIGluc3RhbmNlb2YgR3VpZCB8fCBHdWlkLnZhbGlkYXRvci50ZXN0KHZhbHVlKSk7XHJcbiAgICB9O1xyXG4gICAgR3VpZC5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBHdWlkKFtHdWlkLmdlbigyKSwgR3VpZC5nZW4oMSksIEd1aWQuZ2VuKDEpLCBHdWlkLmdlbigxKSwgR3VpZC5nZW4oMyldLmpvaW4oXCItXCIpKTtcclxuICAgIH07XHJcbiAgICBHdWlkLmNyZWF0ZUVtcHR5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgR3VpZChcImVtcHR5Z3VpZFwiKTtcclxuICAgIH07XHJcbiAgICBHdWlkLnBhcnNlID0gZnVuY3Rpb24gKGd1aWQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEd1aWQoZ3VpZCk7XHJcbiAgICB9O1xyXG4gICAgR3VpZC5yYXcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtHdWlkLmdlbigyKSwgR3VpZC5nZW4oMSksIEd1aWQuZ2VuKDEpLCBHdWlkLmdlbigxKSwgR3VpZC5nZW4oMyldLmpvaW4oXCItXCIpO1xyXG4gICAgfTtcclxuICAgIEd1aWQuZ2VuID0gZnVuY3Rpb24gKGNvdW50KSB7XHJcbiAgICAgICAgdmFyIG91dCA9IFwiXCI7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1iaXR3aXNlXHJcbiAgICAgICAgICAgIG91dCArPSAoKCgxICsgTWF0aC5yYW5kb20oKSkgKiAweDEwMDAwKSB8IDApLnRvU3RyaW5nKDE2KS5zdWJzdHJpbmcoMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9O1xyXG4gICAgR3VpZC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG90aGVyKSB7XHJcbiAgICAgICAgLy8gQ29tcGFyaW5nIHN0cmluZyBgdmFsdWVgIGFnYWluc3QgcHJvdmlkZWQgYGd1aWRgIHdpbGwgYXV0by1jYWxsXHJcbiAgICAgICAgLy8gdG9TdHJpbmcgb24gYGd1aWRgIGZvciBjb21wYXJpc29uXHJcbiAgICAgICAgcmV0dXJuIEd1aWQuaXNHdWlkKG90aGVyKSAmJiB0aGlzLnZhbHVlID09PSBvdGhlci50b1N0cmluZygpO1xyXG4gICAgfTtcclxuICAgIEd1aWQucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgPT09IEd1aWQuRU1QVFk7XHJcbiAgICB9O1xyXG4gICAgR3VpZC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XHJcbiAgICB9O1xyXG4gICAgR3VpZC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLnZhbHVlXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICBHdWlkLnZhbGlkYXRvciA9IG5ldyBSZWdFeHAoXCJeW2EtejAtOV17OH0tW2EtejAtOV17NH0tW2EtejAtOV17NH0tW2EtejAtOV17NH0tW2EtejAtOV17MTJ9JFwiLCBcImlcIik7XHJcbiAgICBHdWlkLkVNUFRZID0gXCIwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDBcIjtcclxuICAgIHJldHVybiBHdWlkO1xyXG59KCkpO1xyXG5leHBvcnRzLkd1aWQgPSBHdWlkO1xyXG4iLCAiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMDkgVGhlIENsb3N1cmUgTGlicmFyeSBBdXRob3JzXG4gKiBDb3B5cmlnaHQgMjAyMCBEYW5pZWwgV2lydHogLyBUaGUgbG9uZy5qcyBBdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cbi8vIFdlYkFzc2VtYmx5IG9wdGltaXphdGlvbnMgdG8gZG8gbmF0aXZlIGk2NCBtdWx0aXBsaWNhdGlvbiBhbmQgZGl2aWRlXG52YXIgd2FzbSA9IG51bGw7XG50cnkge1xuICB3YXNtID0gbmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKG5ldyBXZWJBc3NlbWJseS5Nb2R1bGUobmV3IFVpbnQ4QXJyYXkoW1xuICAgIDAsIDk3LCAxMTUsIDEwOSwgMSwgMCwgMCwgMCwgMSwgMTMsIDIsIDk2LCAwLCAxLCAxMjcsIDk2LCA0LCAxMjcsIDEyNywgMTI3LCAxMjcsIDEsIDEyNywgMywgNywgNiwgMCwgMSwgMSwgMSwgMSwgMSwgNiwgNiwgMSwgMTI3LCAxLCA2NSwgMCwgMTEsIDcsIDUwLCA2LCAzLCAxMDksIDExNywgMTA4LCAwLCAxLCA1LCAxMDAsIDEwNSwgMTE4LCA5NSwgMTE1LCAwLCAyLCA1LCAxMDAsIDEwNSwgMTE4LCA5NSwgMTE3LCAwLCAzLCA1LCAxMTQsIDEwMSwgMTA5LCA5NSwgMTE1LCAwLCA0LCA1LCAxMTQsIDEwMSwgMTA5LCA5NSwgMTE3LCAwLCA1LCA4LCAxMDMsIDEwMSwgMTE2LCA5NSwgMTA0LCAxMDUsIDEwMywgMTA0LCAwLCAwLCAxMCwgMTkxLCAxLCA2LCA0LCAwLCAzNSwgMCwgMTEsIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEyNiwgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLCAzMiwgNCwgMTY3LCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI3LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMjgsIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTEsIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEyOSwgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLCAzMiwgNCwgMTY3LCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTMwLCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExXG4gIF0pKSwge30pLmV4cG9ydHM7XG59IGNhdGNoIChlKSB7XG4gIC8vIG5vIHdhc20gc3VwcG9ydCA6KFxufVxuXG4vKipcbiAqIENvbnN0cnVjdHMgYSA2NCBiaXQgdHdvJ3MtY29tcGxlbWVudCBpbnRlZ2VyLCBnaXZlbiBpdHMgbG93IGFuZCBoaWdoIDMyIGJpdCB2YWx1ZXMgYXMgKnNpZ25lZCogaW50ZWdlcnMuXG4gKiAgU2VlIHRoZSBmcm9tKiBmdW5jdGlvbnMgYmVsb3cgZm9yIG1vcmUgY29udmVuaWVudCB3YXlzIG9mIGNvbnN0cnVjdGluZyBMb25ncy5cbiAqIEBleHBvcnRzIExvbmdcbiAqIEBjbGFzcyBBIExvbmcgY2xhc3MgZm9yIHJlcHJlc2VudGluZyBhIDY0IGJpdCB0d28ncy1jb21wbGVtZW50IGludGVnZXIgdmFsdWUuXG4gKiBAcGFyYW0ge251bWJlcn0gbG93IFRoZSBsb3cgKHNpZ25lZCkgMzIgYml0cyBvZiB0aGUgbG9uZ1xuICogQHBhcmFtIHtudW1iZXJ9IGhpZ2ggVGhlIGhpZ2ggKHNpZ25lZCkgMzIgYml0cyBvZiB0aGUgbG9uZ1xuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIExvbmcobG93LCBoaWdoLCB1bnNpZ25lZCkge1xuXG4gIC8qKlxuICAgKiBUaGUgbG93IDMyIGJpdHMgYXMgYSBzaWduZWQgdmFsdWUuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLmxvdyA9IGxvdyB8IDA7XG5cbiAgLyoqXG4gICAqIFRoZSBoaWdoIDMyIGJpdHMgYXMgYSBzaWduZWQgdmFsdWUuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLmhpZ2ggPSBoaWdoIHwgMDtcblxuICAvKipcbiAgICogV2hldGhlciB1bnNpZ25lZCBvciBub3QuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgdGhpcy51bnNpZ25lZCA9ICEhdW5zaWduZWQ7XG59XG5cbi8vIFRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiBhIGxvbmcgaXMgdGhlIHR3byBnaXZlbiBzaWduZWQsIDMyLWJpdCB2YWx1ZXMuXG4vLyBXZSB1c2UgMzItYml0IHBpZWNlcyBiZWNhdXNlIHRoZXNlIGFyZSB0aGUgc2l6ZSBvZiBpbnRlZ2VycyBvbiB3aGljaFxuLy8gSmF2YXNjcmlwdCBwZXJmb3JtcyBiaXQtb3BlcmF0aW9ucy4gIEZvciBvcGVyYXRpb25zIGxpa2UgYWRkaXRpb24gYW5kXG4vLyBtdWx0aXBsaWNhdGlvbiwgd2Ugc3BsaXQgZWFjaCBudW1iZXIgaW50byAxNiBiaXQgcGllY2VzLCB3aGljaCBjYW4gZWFzaWx5IGJlXG4vLyBtdWx0aXBsaWVkIHdpdGhpbiBKYXZhc2NyaXB0J3MgZmxvYXRpbmctcG9pbnQgcmVwcmVzZW50YXRpb24gd2l0aG91dCBvdmVyZmxvd1xuLy8gb3IgY2hhbmdlIGluIHNpZ24uXG4vL1xuLy8gSW4gdGhlIGFsZ29yaXRobXMgYmVsb3csIHdlIGZyZXF1ZW50bHkgcmVkdWNlIHRoZSBuZWdhdGl2ZSBjYXNlIHRvIHRoZVxuLy8gcG9zaXRpdmUgY2FzZSBieSBuZWdhdGluZyB0aGUgaW5wdXQocykgYW5kIHRoZW4gcG9zdC1wcm9jZXNzaW5nIHRoZSByZXN1bHQuXG4vLyBOb3RlIHRoYXQgd2UgbXVzdCBBTFdBWVMgY2hlY2sgc3BlY2lhbGx5IHdoZXRoZXIgdGhvc2UgdmFsdWVzIGFyZSBNSU5fVkFMVUVcbi8vICgtMl42MykgYmVjYXVzZSAtTUlOX1ZBTFVFID09IE1JTl9WQUxVRSAoc2luY2UgMl42MyBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgYXNcbi8vIGEgcG9zaXRpdmUgbnVtYmVyLCBpdCBvdmVyZmxvd3MgYmFjayBpbnRvIGEgbmVnYXRpdmUpLiAgTm90IGhhbmRsaW5nIHRoaXNcbi8vIGNhc2Ugd291bGQgb2Z0ZW4gcmVzdWx0IGluIGluZmluaXRlIHJlY3Vyc2lvbi5cbi8vXG4vLyBDb21tb24gY29uc3RhbnQgdmFsdWVzIFpFUk8sIE9ORSwgTkVHX09ORSwgZXRjLiBhcmUgZGVmaW5lZCBiZWxvdyB0aGUgZnJvbSpcbi8vIG1ldGhvZHMgb24gd2hpY2ggdGhleSBkZXBlbmQuXG5cbi8qKlxuICogQW4gaW5kaWNhdG9yIHVzZWQgdG8gcmVsaWFibHkgZGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIExvbmcgb3Igbm90LlxuICogQHR5cGUge2Jvb2xlYW59XG4gKiBAY29uc3RcbiAqIEBwcml2YXRlXG4gKi9cbkxvbmcucHJvdG90eXBlLl9faXNMb25nX187XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShMb25nLnByb3RvdHlwZSwgXCJfX2lzTG9uZ19fXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0geyp9IG9iaiBPYmplY3RcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICogQGlubmVyXG4gKi9cbmZ1bmN0aW9uIGlzTG9uZyhvYmopIHtcbiAgcmV0dXJuIChvYmogJiYgb2JqW1wiX19pc0xvbmdfX1wiXSkgPT09IHRydWU7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0geyp9IHZhbHVlIG51bWJlclxuICogQHJldHVybnMge251bWJlcn1cbiAqIEBpbm5lclxuICovXG5mdW5jdGlvbiBjdHozMih2YWx1ZSkge1xuICB2YXIgYyA9IE1hdGguY2x6MzIodmFsdWUgJiAtdmFsdWUpO1xuICByZXR1cm4gdmFsdWUgPyAzMSAtIGMgOiBjO1xufVxuXG4vKipcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgb2JqZWN0IGlzIGEgTG9uZy5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHsqfSBvYmogT2JqZWN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuTG9uZy5pc0xvbmcgPSBpc0xvbmc7XG5cbi8qKlxuICogQSBjYWNoZSBvZiB0aGUgTG9uZyByZXByZXNlbnRhdGlvbnMgb2Ygc21hbGwgaW50ZWdlciB2YWx1ZXMuXG4gKiBAdHlwZSB7IU9iamVjdH1cbiAqIEBpbm5lclxuICovXG52YXIgSU5UX0NBQ0hFID0ge307XG5cbi8qKlxuICogQSBjYWNoZSBvZiB0aGUgTG9uZyByZXByZXNlbnRhdGlvbnMgb2Ygc21hbGwgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuXG4gKiBAdHlwZSB7IU9iamVjdH1cbiAqIEBpbm5lclxuICovXG52YXIgVUlOVF9DQUNIRSA9IHt9O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWRcbiAqIEByZXR1cm5zIHshTG9uZ31cbiAqIEBpbm5lclxuICovXG5mdW5jdGlvbiBmcm9tSW50KHZhbHVlLCB1bnNpZ25lZCkge1xuICB2YXIgb2JqLCBjYWNoZWRPYmosIGNhY2hlO1xuICBpZiAodW5zaWduZWQpIHtcbiAgICB2YWx1ZSA+Pj49IDA7XG4gICAgaWYgKGNhY2hlID0gKDAgPD0gdmFsdWUgJiYgdmFsdWUgPCAyNTYpKSB7XG4gICAgICBjYWNoZWRPYmogPSBVSU5UX0NBQ0hFW3ZhbHVlXTtcbiAgICAgIGlmIChjYWNoZWRPYmopXG4gICAgICAgIHJldHVybiBjYWNoZWRPYmo7XG4gICAgfVxuICAgIG9iaiA9IGZyb21CaXRzKHZhbHVlLCAwLCB0cnVlKTtcbiAgICBpZiAoY2FjaGUpXG4gICAgICBVSU5UX0NBQ0hFW3ZhbHVlXSA9IG9iajtcbiAgICByZXR1cm4gb2JqO1xuICB9IGVsc2Uge1xuICAgIHZhbHVlIHw9IDA7XG4gICAgaWYgKGNhY2hlID0gKC0xMjggPD0gdmFsdWUgJiYgdmFsdWUgPCAxMjgpKSB7XG4gICAgICBjYWNoZWRPYmogPSBJTlRfQ0FDSEVbdmFsdWVdO1xuICAgICAgaWYgKGNhY2hlZE9iailcbiAgICAgICAgcmV0dXJuIGNhY2hlZE9iajtcbiAgICB9XG4gICAgb2JqID0gZnJvbUJpdHModmFsdWUsIHZhbHVlIDwgMCA/IC0xIDogMCwgZmFsc2UpO1xuICAgIGlmIChjYWNoZSlcbiAgICAgIElOVF9DQUNIRVt2YWx1ZV0gPSBvYmo7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gMzIgYml0IGludGVnZXIgdmFsdWUuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgMzIgYml0IGludGVnZXIgaW4gcXVlc3Rpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcbiAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxuICovXG5Mb25nLmZyb21JbnQgPSBmcm9tSW50O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWRcbiAqIEByZXR1cm5zIHshTG9uZ31cbiAqIEBpbm5lclxuICovXG5mdW5jdGlvbiBmcm9tTnVtYmVyKHZhbHVlLCB1bnNpZ25lZCkge1xuICBpZiAoaXNOYU4odmFsdWUpKVxuICAgIHJldHVybiB1bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcbiAgaWYgKHVuc2lnbmVkKSB7XG4gICAgaWYgKHZhbHVlIDwgMClcbiAgICAgIHJldHVybiBVWkVSTztcbiAgICBpZiAodmFsdWUgPj0gVFdPX1BXUl82NF9EQkwpXG4gICAgICByZXR1cm4gTUFYX1VOU0lHTkVEX1ZBTFVFO1xuICB9IGVsc2Uge1xuICAgIGlmICh2YWx1ZSA8PSAtVFdPX1BXUl82M19EQkwpXG4gICAgICByZXR1cm4gTUlOX1ZBTFVFO1xuICAgIGlmICh2YWx1ZSArIDEgPj0gVFdPX1BXUl82M19EQkwpXG4gICAgICByZXR1cm4gTUFYX1ZBTFVFO1xuICB9XG4gIGlmICh2YWx1ZSA8IDApXG4gICAgcmV0dXJuIGZyb21OdW1iZXIoLXZhbHVlLCB1bnNpZ25lZCkubmVnKCk7XG4gIHJldHVybiBmcm9tQml0cygodmFsdWUgJSBUV09fUFdSXzMyX0RCTCkgfCAwLCAodmFsdWUgLyBUV09fUFdSXzMyX0RCTCkgfCAwLCB1bnNpZ25lZCk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiB2YWx1ZSwgcHJvdmlkZWQgdGhhdCBpdCBpcyBhIGZpbml0ZSBudW1iZXIuIE90aGVyd2lzZSwgemVybyBpcyByZXR1cm5lZC5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBudW1iZXIgaW4gcXVlc3Rpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcbiAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxuICovXG5Mb25nLmZyb21OdW1iZXIgPSBmcm9tTnVtYmVyO1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3dCaXRzXG4gKiBAcGFyYW0ge251bWJlcn0gaGlnaEJpdHNcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkXG4gKiBAcmV0dXJucyB7IUxvbmd9XG4gKiBAaW5uZXJcbiAqL1xuZnVuY3Rpb24gZnJvbUJpdHMobG93Qml0cywgaGlnaEJpdHMsIHVuc2lnbmVkKSB7XG4gIHJldHVybiBuZXcgTG9uZyhsb3dCaXRzLCBoaWdoQml0cywgdW5zaWduZWQpO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGluZyB0aGUgNjQgYml0IGludGVnZXIgdGhhdCBjb21lcyBieSBjb25jYXRlbmF0aW5nIHRoZSBnaXZlbiBsb3cgYW5kIGhpZ2ggYml0cy4gRWFjaCBpc1xuICogIGFzc3VtZWQgdG8gdXNlIDMyIGJpdHMuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3dCaXRzIFRoZSBsb3cgMzIgYml0c1xuICogQHBhcmFtIHtudW1iZXJ9IGhpZ2hCaXRzIFRoZSBoaWdoIDMyIGJpdHNcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcbiAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxuICovXG5Mb25nLmZyb21CaXRzID0gZnJvbUJpdHM7XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gYmFzZVxuICogQHBhcmFtIHtudW1iZXJ9IGV4cG9uZW50XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICogQGlubmVyXG4gKi9cbnZhciBwb3dfZGJsID0gTWF0aC5wb3c7IC8vIFVzZWQgNCB0aW1lcyAoNCo4IHRvIDE1KzQpXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHBhcmFtIHsoYm9vbGVhbnxudW1iZXIpPX0gdW5zaWduZWRcbiAqIEBwYXJhbSB7bnVtYmVyPX0gcmFkaXhcbiAqIEByZXR1cm5zIHshTG9uZ31cbiAqIEBpbm5lclxuICovXG5mdW5jdGlvbiBmcm9tU3RyaW5nKHN0ciwgdW5zaWduZWQsIHJhZGl4KSB7XG4gIGlmIChzdHIubGVuZ3RoID09PSAwKVxuICAgIHRocm93IEVycm9yKCdlbXB0eSBzdHJpbmcnKTtcbiAgaWYgKHR5cGVvZiB1bnNpZ25lZCA9PT0gJ251bWJlcicpIHtcbiAgICAvLyBGb3IgZ29vZy5tYXRoLmxvbmcgY29tcGF0aWJpbGl0eVxuICAgIHJhZGl4ID0gdW5zaWduZWQ7XG4gICAgdW5zaWduZWQgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICB1bnNpZ25lZCA9ICEhdW5zaWduZWQ7XG4gIH1cbiAgaWYgKHN0ciA9PT0gXCJOYU5cIiB8fCBzdHIgPT09IFwiSW5maW5pdHlcIiB8fCBzdHIgPT09IFwiK0luZmluaXR5XCIgfHwgc3RyID09PSBcIi1JbmZpbml0eVwiKVxuICAgIHJldHVybiB1bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcbiAgcmFkaXggPSByYWRpeCB8fCAxMDtcbiAgaWYgKHJhZGl4IDwgMiB8fCAzNiA8IHJhZGl4KVxuICAgIHRocm93IFJhbmdlRXJyb3IoJ3JhZGl4Jyk7XG5cbiAgdmFyIHA7XG4gIGlmICgocCA9IHN0ci5pbmRleE9mKCctJykpID4gMClcbiAgICB0aHJvdyBFcnJvcignaW50ZXJpb3IgaHlwaGVuJyk7XG4gIGVsc2UgaWYgKHAgPT09IDApIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyhzdHIuc3Vic3RyaW5nKDEpLCB1bnNpZ25lZCwgcmFkaXgpLm5lZygpO1xuICB9XG5cbiAgLy8gRG8gc2V2ZXJhbCAoOCkgZGlnaXRzIGVhY2ggdGltZSB0aHJvdWdoIHRoZSBsb29wLCBzbyBhcyB0b1xuICAvLyBtaW5pbWl6ZSB0aGUgY2FsbHMgdG8gdGhlIHZlcnkgZXhwZW5zaXZlIGVtdWxhdGVkIGRpdi5cbiAgdmFyIHJhZGl4VG9Qb3dlciA9IGZyb21OdW1iZXIocG93X2RibChyYWRpeCwgOCkpO1xuXG4gIHZhciByZXN1bHQgPSBaRVJPO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gOCkge1xuICAgIHZhciBzaXplID0gTWF0aC5taW4oOCwgc3RyLmxlbmd0aCAtIGkpLFxuICAgICAgdmFsdWUgPSBwYXJzZUludChzdHIuc3Vic3RyaW5nKGksIGkgKyBzaXplKSwgcmFkaXgpO1xuICAgIGlmIChzaXplIDwgOCkge1xuICAgICAgdmFyIHBvd2VyID0gZnJvbU51bWJlcihwb3dfZGJsKHJhZGl4LCBzaXplKSk7XG4gICAgICByZXN1bHQgPSByZXN1bHQubXVsKHBvd2VyKS5hZGQoZnJvbU51bWJlcih2YWx1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSByZXN1bHQubXVsKHJhZGl4VG9Qb3dlcik7XG4gICAgICByZXN1bHQgPSByZXN1bHQuYWRkKGZyb21OdW1iZXIodmFsdWUpKTtcbiAgICB9XG4gIH1cbiAgcmVzdWx0LnVuc2lnbmVkID0gdW5zaWduZWQ7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIHN0cmluZywgd3JpdHRlbiB1c2luZyB0aGUgc3BlY2lmaWVkIHJhZGl4LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBMb25nXG4gKiBAcGFyYW0geyhib29sZWFufG51bWJlcik9fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXG4gKiBAcGFyYW0ge251bWJlcj19IHJhZGl4IFRoZSByYWRpeCBpbiB3aGljaCB0aGUgdGV4dCBpcyB3cml0dGVuICgyLTM2KSwgZGVmYXVsdHMgdG8gMTBcbiAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxuICovXG5Mb25nLmZyb21TdHJpbmcgPSBmcm9tU3RyaW5nO1xuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfCF7bG93OiBudW1iZXIsIGhpZ2g6IG51bWJlciwgdW5zaWduZWQ6IGJvb2xlYW59fSB2YWxcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkXG4gKiBAcmV0dXJucyB7IUxvbmd9XG4gKiBAaW5uZXJcbiAqL1xuZnVuY3Rpb24gZnJvbVZhbHVlKHZhbCwgdW5zaWduZWQpIHtcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKVxuICAgIHJldHVybiBmcm9tTnVtYmVyKHZhbCwgdW5zaWduZWQpO1xuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpXG4gICAgcmV0dXJuIGZyb21TdHJpbmcodmFsLCB1bnNpZ25lZCk7XG4gIC8vIFRocm93cyBmb3Igbm9uLW9iamVjdHMsIGNvbnZlcnRzIG5vbi1pbnN0YW5jZW9mIExvbmc6XG4gIHJldHVybiBmcm9tQml0cyh2YWwubG93LCB2YWwuaGlnaCwgdHlwZW9mIHVuc2lnbmVkID09PSAnYm9vbGVhbicgPyB1bnNpZ25lZCA6IHZhbC51bnNpZ25lZCk7XG59XG5cbi8qKlxuICogQ29udmVydHMgdGhlIHNwZWNpZmllZCB2YWx1ZSB0byBhIExvbmcgdXNpbmcgdGhlIGFwcHJvcHJpYXRlIGZyb20qIGZ1bmN0aW9uIGZvciBpdHMgdHlwZS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfCF7bG93OiBudW1iZXIsIGhpZ2g6IG51bWJlciwgdW5zaWduZWQ6IGJvb2xlYW59fSB2YWwgVmFsdWVcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcbiAqIEByZXR1cm5zIHshTG9uZ31cbiAqL1xuTG9uZy5mcm9tVmFsdWUgPSBmcm9tVmFsdWU7XG5cbi8vIE5PVEU6IHRoZSBjb21waWxlciBzaG91bGQgaW5saW5lIHRoZXNlIGNvbnN0YW50IHZhbHVlcyBiZWxvdyBhbmQgdGhlbiByZW1vdmUgdGhlc2UgdmFyaWFibGVzLCBzbyB0aGVyZSBzaG91bGQgYmVcbi8vIG5vIHJ1bnRpbWUgcGVuYWx0eSBmb3IgdGhlc2UuXG5cbi8qKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdFxuICogQGlubmVyXG4gKi9cbnZhciBUV09fUFdSXzE2X0RCTCA9IDEgPDwgMTY7XG5cbi8qKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdFxuICogQGlubmVyXG4gKi9cbnZhciBUV09fUFdSXzI0X0RCTCA9IDEgPDwgMjQ7XG5cbi8qKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdFxuICogQGlubmVyXG4gKi9cbnZhciBUV09fUFdSXzMyX0RCTCA9IFRXT19QV1JfMTZfREJMICogVFdPX1BXUl8xNl9EQkw7XG5cbi8qKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdFxuICogQGlubmVyXG4gKi9cbnZhciBUV09fUFdSXzY0X0RCTCA9IFRXT19QV1JfMzJfREJMICogVFdPX1BXUl8zMl9EQkw7XG5cbi8qKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdFxuICogQGlubmVyXG4gKi9cbnZhciBUV09fUFdSXzYzX0RCTCA9IFRXT19QV1JfNjRfREJMIC8gMjtcblxuLyoqXG4gKiBAdHlwZSB7IUxvbmd9XG4gKiBAY29uc3RcbiAqIEBpbm5lclxuICovXG52YXIgVFdPX1BXUl8yNCA9IGZyb21JbnQoVFdPX1BXUl8yNF9EQkwpO1xuXG4vKipcbiAqIEB0eXBlIHshTG9uZ31cbiAqIEBpbm5lclxuICovXG52YXIgWkVSTyA9IGZyb21JbnQoMCk7XG5cbi8qKlxuICogU2lnbmVkIHplcm8uXG4gKiBAdHlwZSB7IUxvbmd9XG4gKi9cbkxvbmcuWkVSTyA9IFpFUk87XG5cbi8qKlxuICogQHR5cGUgeyFMb25nfVxuICogQGlubmVyXG4gKi9cbnZhciBVWkVSTyA9IGZyb21JbnQoMCwgdHJ1ZSk7XG5cbi8qKlxuICogVW5zaWduZWQgemVyby5cbiAqIEB0eXBlIHshTG9uZ31cbiAqL1xuTG9uZy5VWkVSTyA9IFVaRVJPO1xuXG4vKipcbiAqIEB0eXBlIHshTG9uZ31cbiAqIEBpbm5lclxuICovXG52YXIgT05FID0gZnJvbUludCgxKTtcblxuLyoqXG4gKiBTaWduZWQgb25lLlxuICogQHR5cGUgeyFMb25nfVxuICovXG5Mb25nLk9ORSA9IE9ORTtcblxuLyoqXG4gKiBAdHlwZSB7IUxvbmd9XG4gKiBAaW5uZXJcbiAqL1xudmFyIFVPTkUgPSBmcm9tSW50KDEsIHRydWUpO1xuXG4vKipcbiAqIFVuc2lnbmVkIG9uZS5cbiAqIEB0eXBlIHshTG9uZ31cbiAqL1xuTG9uZy5VT05FID0gVU9ORTtcblxuLyoqXG4gKiBAdHlwZSB7IUxvbmd9XG4gKiBAaW5uZXJcbiAqL1xudmFyIE5FR19PTkUgPSBmcm9tSW50KC0xKTtcblxuLyoqXG4gKiBTaWduZWQgbmVnYXRpdmUgb25lLlxuICogQHR5cGUgeyFMb25nfVxuICovXG5Mb25nLk5FR19PTkUgPSBORUdfT05FO1xuXG4vKipcbiAqIEB0eXBlIHshTG9uZ31cbiAqIEBpbm5lclxuICovXG52YXIgTUFYX1ZBTFVFID0gZnJvbUJpdHMoMHhGRkZGRkZGRiB8IDAsIDB4N0ZGRkZGRkYgfCAwLCBmYWxzZSk7XG5cbi8qKlxuICogTWF4aW11bSBzaWduZWQgdmFsdWUuXG4gKiBAdHlwZSB7IUxvbmd9XG4gKi9cbkxvbmcuTUFYX1ZBTFVFID0gTUFYX1ZBTFVFO1xuXG4vKipcbiAqIEB0eXBlIHshTG9uZ31cbiAqIEBpbm5lclxuICovXG52YXIgTUFYX1VOU0lHTkVEX1ZBTFVFID0gZnJvbUJpdHMoMHhGRkZGRkZGRiB8IDAsIDB4RkZGRkZGRkYgfCAwLCB0cnVlKTtcblxuLyoqXG4gKiBNYXhpbXVtIHVuc2lnbmVkIHZhbHVlLlxuICogQHR5cGUgeyFMb25nfVxuICovXG5Mb25nLk1BWF9VTlNJR05FRF9WQUxVRSA9IE1BWF9VTlNJR05FRF9WQUxVRTtcblxuLyoqXG4gKiBAdHlwZSB7IUxvbmd9XG4gKiBAaW5uZXJcbiAqL1xudmFyIE1JTl9WQUxVRSA9IGZyb21CaXRzKDAsIDB4ODAwMDAwMDAgfCAwLCBmYWxzZSk7XG5cbi8qKlxuICogTWluaW11bSBzaWduZWQgdmFsdWUuXG4gKiBAdHlwZSB7IUxvbmd9XG4gKi9cbkxvbmcuTUlOX1ZBTFVFID0gTUlOX1ZBTFVFO1xuXG4vKipcbiAqIEBhbGlhcyBMb25nLnByb3RvdHlwZVxuICogQGlubmVyXG4gKi9cbnZhciBMb25nUHJvdG90eXBlID0gTG9uZy5wcm90b3R5cGU7XG5cbi8qKlxuICogQ29udmVydHMgdGhlIExvbmcgdG8gYSAzMiBiaXQgaW50ZWdlciwgYXNzdW1pbmcgaXQgaXMgYSAzMiBiaXQgaW50ZWdlci5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbkxvbmdQcm90b3R5cGUudG9JbnQgPSBmdW5jdGlvbiB0b0ludCgpIHtcbiAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyB0aGlzLmxvdyA+Pj4gMCA6IHRoaXMubG93O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgTG9uZyB0byBhIHRoZSBuZWFyZXN0IGZsb2F0aW5nLXBvaW50IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdmFsdWUgKGRvdWJsZSwgNTMgYml0IG1hbnRpc3NhKS5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbkxvbmdQcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiB0b051bWJlcigpIHtcbiAgaWYgKHRoaXMudW5zaWduZWQpXG4gICAgcmV0dXJuICgodGhpcy5oaWdoID4+PiAwKSAqIFRXT19QV1JfMzJfREJMKSArICh0aGlzLmxvdyA+Pj4gMCk7XG4gIHJldHVybiB0aGlzLmhpZ2ggKiBUV09fUFdSXzMyX0RCTCArICh0aGlzLmxvdyA+Pj4gMCk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBMb25nIHRvIGEgc3RyaW5nIHdyaXR0ZW4gaW4gdGhlIHNwZWNpZmllZCByYWRpeC5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEBwYXJhbSB7bnVtYmVyPX0gcmFkaXggUmFkaXggKDItMzYpLCBkZWZhdWx0cyB0byAxMFxuICogQHJldHVybnMge3N0cmluZ31cbiAqIEBvdmVycmlkZVxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYHJhZGl4YCBpcyBvdXQgb2YgcmFuZ2VcbiAqL1xuTG9uZ1Byb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKHJhZGl4KSB7XG4gIHJhZGl4ID0gcmFkaXggfHwgMTA7XG4gIGlmIChyYWRpeCA8IDIgfHwgMzYgPCByYWRpeClcbiAgICB0aHJvdyBSYW5nZUVycm9yKCdyYWRpeCcpO1xuICBpZiAodGhpcy5pc1plcm8oKSlcbiAgICByZXR1cm4gJzAnO1xuICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHsgLy8gVW5zaWduZWQgTG9uZ3MgYXJlIG5ldmVyIG5lZ2F0aXZlXG4gICAgaWYgKHRoaXMuZXEoTUlOX1ZBTFVFKSkge1xuICAgICAgLy8gV2UgbmVlZCB0byBjaGFuZ2UgdGhlIExvbmcgdmFsdWUgYmVmb3JlIGl0IGNhbiBiZSBuZWdhdGVkLCBzbyB3ZSByZW1vdmVcbiAgICAgIC8vIHRoZSBib3R0b20tbW9zdCBkaWdpdCBpbiB0aGlzIGJhc2UgYW5kIHRoZW4gcmVjdXJzZSB0byBkbyB0aGUgcmVzdC5cbiAgICAgIHZhciByYWRpeExvbmcgPSBmcm9tTnVtYmVyKHJhZGl4KSxcbiAgICAgICAgZGl2ID0gdGhpcy5kaXYocmFkaXhMb25nKSxcbiAgICAgICAgcmVtMSA9IGRpdi5tdWwocmFkaXhMb25nKS5zdWIodGhpcyk7XG4gICAgICByZXR1cm4gZGl2LnRvU3RyaW5nKHJhZGl4KSArIHJlbTEudG9JbnQoKS50b1N0cmluZyhyYWRpeCk7XG4gICAgfSBlbHNlXG4gICAgICByZXR1cm4gJy0nICsgdGhpcy5uZWcoKS50b1N0cmluZyhyYWRpeCk7XG4gIH1cblxuICAvLyBEbyBzZXZlcmFsICg2KSBkaWdpdHMgZWFjaCB0aW1lIHRocm91Z2ggdGhlIGxvb3AsIHNvIGFzIHRvXG4gIC8vIG1pbmltaXplIHRoZSBjYWxscyB0byB0aGUgdmVyeSBleHBlbnNpdmUgZW11bGF0ZWQgZGl2LlxuICB2YXIgcmFkaXhUb1Bvd2VyID0gZnJvbU51bWJlcihwb3dfZGJsKHJhZGl4LCA2KSwgdGhpcy51bnNpZ25lZCksXG4gICAgcmVtID0gdGhpcztcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciByZW1EaXYgPSByZW0uZGl2KHJhZGl4VG9Qb3dlciksXG4gICAgICBpbnR2YWwgPSByZW0uc3ViKHJlbURpdi5tdWwocmFkaXhUb1Bvd2VyKSkudG9JbnQoKSA+Pj4gMCxcbiAgICAgIGRpZ2l0cyA9IGludHZhbC50b1N0cmluZyhyYWRpeCk7XG4gICAgcmVtID0gcmVtRGl2O1xuICAgIGlmIChyZW0uaXNaZXJvKCkpXG4gICAgICByZXR1cm4gZGlnaXRzICsgcmVzdWx0O1xuICAgIGVsc2Uge1xuICAgICAgd2hpbGUgKGRpZ2l0cy5sZW5ndGggPCA2KVxuICAgICAgICBkaWdpdHMgPSAnMCcgKyBkaWdpdHM7XG4gICAgICByZXN1bHQgPSAnJyArIGRpZ2l0cyArIHJlc3VsdDtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogR2V0cyB0aGUgaGlnaCAzMiBiaXRzIGFzIGEgc2lnbmVkIGludGVnZXIuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBTaWduZWQgaGlnaCBiaXRzXG4gKi9cbkxvbmdQcm90b3R5cGUuZ2V0SGlnaEJpdHMgPSBmdW5jdGlvbiBnZXRIaWdoQml0cygpIHtcbiAgcmV0dXJuIHRoaXMuaGlnaDtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgaGlnaCAzMiBiaXRzIGFzIGFuIHVuc2lnbmVkIGludGVnZXIuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBVbnNpZ25lZCBoaWdoIGJpdHNcbiAqL1xuTG9uZ1Byb3RvdHlwZS5nZXRIaWdoQml0c1Vuc2lnbmVkID0gZnVuY3Rpb24gZ2V0SGlnaEJpdHNVbnNpZ25lZCgpIHtcbiAgcmV0dXJuIHRoaXMuaGlnaCA+Pj4gMDtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgbG93IDMyIGJpdHMgYXMgYSBzaWduZWQgaW50ZWdlci5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFNpZ25lZCBsb3cgYml0c1xuICovXG5Mb25nUHJvdG90eXBlLmdldExvd0JpdHMgPSBmdW5jdGlvbiBnZXRMb3dCaXRzKCkge1xuICByZXR1cm4gdGhpcy5sb3c7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIGxvdyAzMiBiaXRzIGFzIGFuIHVuc2lnbmVkIGludGVnZXIuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBVbnNpZ25lZCBsb3cgYml0c1xuICovXG5Mb25nUHJvdG90eXBlLmdldExvd0JpdHNVbnNpZ25lZCA9IGZ1bmN0aW9uIGdldExvd0JpdHNVbnNpZ25lZCgpIHtcbiAgcmV0dXJuIHRoaXMubG93ID4+PiAwO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBudW1iZXIgb2YgYml0cyBuZWVkZWQgdG8gcmVwcmVzZW50IHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGlzIExvbmcuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5Mb25nUHJvdG90eXBlLmdldE51bUJpdHNBYnMgPSBmdW5jdGlvbiBnZXROdW1CaXRzQWJzKCkge1xuICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIC8vIFVuc2lnbmVkIExvbmdzIGFyZSBuZXZlciBuZWdhdGl2ZVxuICAgIHJldHVybiB0aGlzLmVxKE1JTl9WQUxVRSkgPyA2NCA6IHRoaXMubmVnKCkuZ2V0TnVtQml0c0FicygpO1xuICB2YXIgdmFsID0gdGhpcy5oaWdoICE9IDAgPyB0aGlzLmhpZ2ggOiB0aGlzLmxvdztcbiAgZm9yICh2YXIgYml0ID0gMzE7IGJpdCA+IDA7IGJpdC0tKVxuICAgIGlmICgodmFsICYgKDEgPDwgYml0KSkgIT0gMClcbiAgICAgIGJyZWFrO1xuICByZXR1cm4gdGhpcy5oaWdoICE9IDAgPyBiaXQgKyAzMyA6IGJpdCArIDE7XG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGVxdWFscyB6ZXJvLlxuICogQHRoaXMgeyFMb25nfVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkxvbmdQcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gaXNaZXJvKCkge1xuICByZXR1cm4gdGhpcy5oaWdoID09PSAwICYmIHRoaXMubG93ID09PSAwO1xufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBlcXVhbHMgemVyby4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNpc1plcm99LlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkxvbmdQcm90b3R5cGUuZXF6ID0gTG9uZ1Byb3RvdHlwZS5pc1plcm87XG5cbi8qKlxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbmVnYXRpdmUuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuTG9uZ1Byb3RvdHlwZS5pc05lZ2F0aXZlID0gZnVuY3Rpb24gaXNOZWdhdGl2ZSgpIHtcbiAgcmV0dXJuICF0aGlzLnVuc2lnbmVkICYmIHRoaXMuaGlnaCA8IDA7XG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIHBvc2l0aXZlIG9yIHplcm8uXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuTG9uZ1Byb3RvdHlwZS5pc1Bvc2l0aXZlID0gZnVuY3Rpb24gaXNQb3NpdGl2ZSgpIHtcbiAgcmV0dXJuIHRoaXMudW5zaWduZWQgfHwgdGhpcy5oaWdoID49IDA7XG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIG9kZC5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5Mb25nUHJvdG90eXBlLmlzT2RkID0gZnVuY3Rpb24gaXNPZGQoKSB7XG4gIHJldHVybiAodGhpcy5sb3cgJiAxKSA9PT0gMTtcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZXZlbi5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5Mb25nUHJvdG90eXBlLmlzRXZlbiA9IGZ1bmN0aW9uIGlzRXZlbigpIHtcbiAgcmV0dXJuICh0aGlzLmxvdyAmIDEpID09PSAwO1xufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBlcXVhbHMgdGhlIHNwZWNpZmllZCdzLlxuICogQHRoaXMgeyFMb25nfVxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkxvbmdQcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7XG4gIGlmICghaXNMb25nKG90aGVyKSlcbiAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XG4gIGlmICh0aGlzLnVuc2lnbmVkICE9PSBvdGhlci51bnNpZ25lZCAmJiAodGhpcy5oaWdoID4+PiAzMSkgPT09IDEgJiYgKG90aGVyLmhpZ2ggPj4+IDMxKSA9PT0gMSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0aGlzLmhpZ2ggPT09IG90aGVyLmhpZ2ggJiYgdGhpcy5sb3cgPT09IG90aGVyLmxvdztcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZXF1YWxzIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNlcXVhbHN9LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuTG9uZ1Byb3RvdHlwZS5lcSA9IExvbmdQcm90b3R5cGUuZXF1YWxzO1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgc3BlY2lmaWVkJ3MuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuTG9uZ1Byb3RvdHlwZS5ub3RFcXVhbHMgPSBmdW5jdGlvbiBub3RFcXVhbHMob3RoZXIpIHtcbiAgcmV0dXJuICF0aGlzLmVxKC8qIHZhbGlkYXRlcyAqLyBvdGhlcik7XG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbm90RXF1YWxzfS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkxvbmdQcm90b3R5cGUubmVxID0gTG9uZ1Byb3RvdHlwZS5ub3RFcXVhbHM7XG5cbi8qKlxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZGlmZmVycyBmcm9tIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNub3RFcXVhbHN9LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuTG9uZ1Byb3RvdHlwZS5uZSA9IExvbmdQcm90b3R5cGUubm90RXF1YWxzO1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgc3BlY2lmaWVkJ3MuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbiA9IGZ1bmN0aW9uIGxlc3NUaGFuKG90aGVyKSB7XG4gIHJldHVybiB0aGlzLmNvbXAoLyogdmFsaWRhdGVzICovIG90aGVyKSA8IDA7XG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbGVzc1RoYW59LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuTG9uZ1Byb3RvdHlwZS5sdCA9IExvbmdQcm90b3R5cGUubGVzc1RoYW47XG5cbi8qKlxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5Mb25nUHJvdG90eXBlLmxlc3NUaGFuT3JFcXVhbCA9IGZ1bmN0aW9uIGxlc3NUaGFuT3JFcXVhbChvdGhlcikge1xuICByZXR1cm4gdGhpcy5jb21wKC8qIHZhbGlkYXRlcyAqLyBvdGhlcikgPD0gMDtcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNsZXNzVGhhbk9yRXF1YWx9LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuTG9uZ1Byb3RvdHlwZS5sdGUgPSBMb25nUHJvdG90eXBlLmxlc3NUaGFuT3JFcXVhbDtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2xlc3NUaGFuT3JFcXVhbH0uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5Mb25nUHJvdG90eXBlLmxlID0gTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbk9yRXF1YWw7XG5cbi8qKlxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBzcGVjaWZpZWQncy5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5Mb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuID0gZnVuY3Rpb24gZ3JlYXRlclRoYW4ob3RoZXIpIHtcbiAgcmV0dXJuIHRoaXMuY29tcCgvKiB2YWxpZGF0ZXMgKi8gb3RoZXIpID4gMDtcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNncmVhdGVyVGhhbn0uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5Mb25nUHJvdG90eXBlLmd0ID0gTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbjtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLlxuICogQHRoaXMgeyFMb25nfVxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkxvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsID0gZnVuY3Rpb24gZ3JlYXRlclRoYW5PckVxdWFsKG90aGVyKSB7XG4gIHJldHVybiB0aGlzLmNvbXAoLyogdmFsaWRhdGVzICovIG90aGVyKSA+PSAwO1xufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2dyZWF0ZXJUaGFuT3JFcXVhbH0uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5Mb25nUHJvdG90eXBlLmd0ZSA9IExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsO1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZ3JlYXRlclRoYW5PckVxdWFsfS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkxvbmdQcm90b3R5cGUuZ2UgPSBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuT3JFcXVhbDtcblxuLyoqXG4gKiBDb21wYXJlcyB0aGlzIExvbmcncyB2YWx1ZSB3aXRoIHRoZSBzcGVjaWZpZWQncy5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IDAgaWYgdGhleSBhcmUgdGhlIHNhbWUsIDEgaWYgdGhlIHRoaXMgaXMgZ3JlYXRlciBhbmQgLTFcbiAqICBpZiB0aGUgZ2l2ZW4gb25lIGlzIGdyZWF0ZXJcbiAqL1xuTG9uZ1Byb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZShvdGhlcikge1xuICBpZiAoIWlzTG9uZyhvdGhlcikpXG4gICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xuICBpZiAodGhpcy5lcShvdGhlcikpXG4gICAgcmV0dXJuIDA7XG4gIHZhciB0aGlzTmVnID0gdGhpcy5pc05lZ2F0aXZlKCksXG4gICAgb3RoZXJOZWcgPSBvdGhlci5pc05lZ2F0aXZlKCk7XG4gIGlmICh0aGlzTmVnICYmICFvdGhlck5lZylcbiAgICByZXR1cm4gLTE7XG4gIGlmICghdGhpc05lZyAmJiBvdGhlck5lZylcbiAgICByZXR1cm4gMTtcbiAgLy8gQXQgdGhpcyBwb2ludCB0aGUgc2lnbiBiaXRzIGFyZSB0aGUgc2FtZVxuICBpZiAoIXRoaXMudW5zaWduZWQpXG4gICAgcmV0dXJuIHRoaXMuc3ViKG90aGVyKS5pc05lZ2F0aXZlKCkgPyAtMSA6IDE7XG4gIC8vIEJvdGggYXJlIHBvc2l0aXZlIGlmIGF0IGxlYXN0IG9uZSBpcyB1bnNpZ25lZFxuICByZXR1cm4gKG90aGVyLmhpZ2ggPj4+IDApID4gKHRoaXMuaGlnaCA+Pj4gMCkgfHwgKG90aGVyLmhpZ2ggPT09IHRoaXMuaGlnaCAmJiAob3RoZXIubG93ID4+PiAwKSA+ICh0aGlzLmxvdyA+Pj4gMCkpID8gLTEgOiAxO1xufTtcblxuLyoqXG4gKiBDb21wYXJlcyB0aGlzIExvbmcncyB2YWx1ZSB3aXRoIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNjb21wYXJlfS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICogQHJldHVybnMge251bWJlcn0gMCBpZiB0aGV5IGFyZSB0aGUgc2FtZSwgMSBpZiB0aGUgdGhpcyBpcyBncmVhdGVyIGFuZCAtMVxuICogIGlmIHRoZSBnaXZlbiBvbmUgaXMgZ3JlYXRlclxuICovXG5Mb25nUHJvdG90eXBlLmNvbXAgPSBMb25nUHJvdG90eXBlLmNvbXBhcmU7XG5cbi8qKlxuICogTmVnYXRlcyB0aGlzIExvbmcncyB2YWx1ZS5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEByZXR1cm5zIHshTG9uZ30gTmVnYXRlZCBMb25nXG4gKi9cbkxvbmdQcm90b3R5cGUubmVnYXRlID0gZnVuY3Rpb24gbmVnYXRlKCkge1xuICBpZiAoIXRoaXMudW5zaWduZWQgJiYgdGhpcy5lcShNSU5fVkFMVUUpKVxuICAgIHJldHVybiBNSU5fVkFMVUU7XG4gIHJldHVybiB0aGlzLm5vdCgpLmFkZChPTkUpO1xufTtcblxuLyoqXG4gKiBOZWdhdGVzIHRoaXMgTG9uZydzIHZhbHVlLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI25lZ2F0ZX0uXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHshTG9uZ30gTmVnYXRlZCBMb25nXG4gKi9cbkxvbmdQcm90b3R5cGUubmVnID0gTG9uZ1Byb3RvdHlwZS5uZWdhdGU7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc3VtIG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gYWRkZW5kIEFkZGVuZFxuICogQHJldHVybnMgeyFMb25nfSBTdW1cbiAqL1xuTG9uZ1Byb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQoYWRkZW5kKSB7XG4gIGlmICghaXNMb25nKGFkZGVuZCkpXG4gICAgYWRkZW5kID0gZnJvbVZhbHVlKGFkZGVuZCk7XG5cbiAgLy8gRGl2aWRlIGVhY2ggbnVtYmVyIGludG8gNCBjaHVua3Mgb2YgMTYgYml0cywgYW5kIHRoZW4gc3VtIHRoZSBjaHVua3MuXG5cbiAgdmFyIGE0OCA9IHRoaXMuaGlnaCA+Pj4gMTY7XG4gIHZhciBhMzIgPSB0aGlzLmhpZ2ggJiAweEZGRkY7XG4gIHZhciBhMTYgPSB0aGlzLmxvdyA+Pj4gMTY7XG4gIHZhciBhMDAgPSB0aGlzLmxvdyAmIDB4RkZGRjtcblxuICB2YXIgYjQ4ID0gYWRkZW5kLmhpZ2ggPj4+IDE2O1xuICB2YXIgYjMyID0gYWRkZW5kLmhpZ2ggJiAweEZGRkY7XG4gIHZhciBiMTYgPSBhZGRlbmQubG93ID4+PiAxNjtcbiAgdmFyIGIwMCA9IGFkZGVuZC5sb3cgJiAweEZGRkY7XG5cbiAgdmFyIGM0OCA9IDAsIGMzMiA9IDAsIGMxNiA9IDAsIGMwMCA9IDA7XG4gIGMwMCArPSBhMDAgKyBiMDA7XG4gIGMxNiArPSBjMDAgPj4+IDE2O1xuICBjMDAgJj0gMHhGRkZGO1xuICBjMTYgKz0gYTE2ICsgYjE2O1xuICBjMzIgKz0gYzE2ID4+PiAxNjtcbiAgYzE2ICY9IDB4RkZGRjtcbiAgYzMyICs9IGEzMiArIGIzMjtcbiAgYzQ4ICs9IGMzMiA+Pj4gMTY7XG4gIGMzMiAmPSAweEZGRkY7XG4gIGM0OCArPSBhNDggKyBiNDg7XG4gIGM0OCAmPSAweEZGRkY7XG4gIHJldHVybiBmcm9tQml0cygoYzE2IDw8IDE2KSB8IGMwMCwgKGM0OCA8PCAxNikgfCBjMzIsIHRoaXMudW5zaWduZWQpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBkaWZmZXJlbmNlIG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gc3VidHJhaGVuZCBTdWJ0cmFoZW5kXG4gKiBAcmV0dXJucyB7IUxvbmd9IERpZmZlcmVuY2VcbiAqL1xuTG9uZ1Byb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uIHN1YnRyYWN0KHN1YnRyYWhlbmQpIHtcbiAgaWYgKCFpc0xvbmcoc3VidHJhaGVuZCkpXG4gICAgc3VidHJhaGVuZCA9IGZyb21WYWx1ZShzdWJ0cmFoZW5kKTtcbiAgcmV0dXJuIHRoaXMuYWRkKHN1YnRyYWhlbmQubmVnKCkpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBkaWZmZXJlbmNlIG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNzdWJ0cmFjdH0uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gc3VidHJhaGVuZCBTdWJ0cmFoZW5kXG4gKiBAcmV0dXJucyB7IUxvbmd9IERpZmZlcmVuY2VcbiAqL1xuTG9uZ1Byb3RvdHlwZS5zdWIgPSBMb25nUHJvdG90eXBlLnN1YnRyYWN0O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHByb2R1Y3Qgb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLlxuICogQHRoaXMgeyFMb25nfVxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBtdWx0aXBsaWVyIE11bHRpcGxpZXJcbiAqIEByZXR1cm5zIHshTG9uZ30gUHJvZHVjdFxuICovXG5Mb25nUHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gbXVsdGlwbHkobXVsdGlwbGllcikge1xuICBpZiAodGhpcy5pc1plcm8oKSlcbiAgICByZXR1cm4gdGhpcztcbiAgaWYgKCFpc0xvbmcobXVsdGlwbGllcikpXG4gICAgbXVsdGlwbGllciA9IGZyb21WYWx1ZShtdWx0aXBsaWVyKTtcblxuICAvLyB1c2Ugd2FzbSBzdXBwb3J0IGlmIHByZXNlbnRcbiAgaWYgKHdhc20pIHtcbiAgICB2YXIgbG93ID0gd2FzbVtcIm11bFwiXSh0aGlzLmxvdyxcbiAgICAgIHRoaXMuaGlnaCxcbiAgICAgIG11bHRpcGxpZXIubG93LFxuICAgICAgbXVsdGlwbGllci5oaWdoKTtcbiAgICByZXR1cm4gZnJvbUJpdHMobG93LCB3YXNtW1wiZ2V0X2hpZ2hcIl0oKSwgdGhpcy51bnNpZ25lZCk7XG4gIH1cblxuICBpZiAobXVsdGlwbGllci5pc1plcm8oKSlcbiAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcbiAgaWYgKHRoaXMuZXEoTUlOX1ZBTFVFKSlcbiAgICByZXR1cm4gbXVsdGlwbGllci5pc09kZCgpID8gTUlOX1ZBTFVFIDogWkVSTztcbiAgaWYgKG11bHRpcGxpZXIuZXEoTUlOX1ZBTFVFKSlcbiAgICByZXR1cm4gdGhpcy5pc09kZCgpID8gTUlOX1ZBTFVFIDogWkVSTztcblxuICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcbiAgICBpZiAobXVsdGlwbGllci5pc05lZ2F0aXZlKCkpXG4gICAgICByZXR1cm4gdGhpcy5uZWcoKS5tdWwobXVsdGlwbGllci5uZWcoKSk7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHRoaXMubmVnKCkubXVsKG11bHRpcGxpZXIpLm5lZygpO1xuICB9IGVsc2UgaWYgKG11bHRpcGxpZXIuaXNOZWdhdGl2ZSgpKVxuICAgIHJldHVybiB0aGlzLm11bChtdWx0aXBsaWVyLm5lZygpKS5uZWcoKTtcblxuICAvLyBJZiBib3RoIGxvbmdzIGFyZSBzbWFsbCwgdXNlIGZsb2F0IG11bHRpcGxpY2F0aW9uXG4gIGlmICh0aGlzLmx0KFRXT19QV1JfMjQpICYmIG11bHRpcGxpZXIubHQoVFdPX1BXUl8yNCkpXG4gICAgcmV0dXJuIGZyb21OdW1iZXIodGhpcy50b051bWJlcigpICogbXVsdGlwbGllci50b051bWJlcigpLCB0aGlzLnVuc2lnbmVkKTtcblxuICAvLyBEaXZpZGUgZWFjaCBsb25nIGludG8gNCBjaHVua3Mgb2YgMTYgYml0cywgYW5kIHRoZW4gYWRkIHVwIDR4NCBwcm9kdWN0cy5cbiAgLy8gV2UgY2FuIHNraXAgcHJvZHVjdHMgdGhhdCB3b3VsZCBvdmVyZmxvdy5cblxuICB2YXIgYTQ4ID0gdGhpcy5oaWdoID4+PiAxNjtcbiAgdmFyIGEzMiA9IHRoaXMuaGlnaCAmIDB4RkZGRjtcbiAgdmFyIGExNiA9IHRoaXMubG93ID4+PiAxNjtcbiAgdmFyIGEwMCA9IHRoaXMubG93ICYgMHhGRkZGO1xuXG4gIHZhciBiNDggPSBtdWx0aXBsaWVyLmhpZ2ggPj4+IDE2O1xuICB2YXIgYjMyID0gbXVsdGlwbGllci5oaWdoICYgMHhGRkZGO1xuICB2YXIgYjE2ID0gbXVsdGlwbGllci5sb3cgPj4+IDE2O1xuICB2YXIgYjAwID0gbXVsdGlwbGllci5sb3cgJiAweEZGRkY7XG5cbiAgdmFyIGM0OCA9IDAsIGMzMiA9IDAsIGMxNiA9IDAsIGMwMCA9IDA7XG4gIGMwMCArPSBhMDAgKiBiMDA7XG4gIGMxNiArPSBjMDAgPj4+IDE2O1xuICBjMDAgJj0gMHhGRkZGO1xuICBjMTYgKz0gYTE2ICogYjAwO1xuICBjMzIgKz0gYzE2ID4+PiAxNjtcbiAgYzE2ICY9IDB4RkZGRjtcbiAgYzE2ICs9IGEwMCAqIGIxNjtcbiAgYzMyICs9IGMxNiA+Pj4gMTY7XG4gIGMxNiAmPSAweEZGRkY7XG4gIGMzMiArPSBhMzIgKiBiMDA7XG4gIGM0OCArPSBjMzIgPj4+IDE2O1xuICBjMzIgJj0gMHhGRkZGO1xuICBjMzIgKz0gYTE2ICogYjE2O1xuICBjNDggKz0gYzMyID4+PiAxNjtcbiAgYzMyICY9IDB4RkZGRjtcbiAgYzMyICs9IGEwMCAqIGIzMjtcbiAgYzQ4ICs9IGMzMiA+Pj4gMTY7XG4gIGMzMiAmPSAweEZGRkY7XG4gIGM0OCArPSBhNDggKiBiMDAgKyBhMzIgKiBiMTYgKyBhMTYgKiBiMzIgKyBhMDAgKiBiNDg7XG4gIGM0OCAmPSAweEZGRkY7XG4gIHJldHVybiBmcm9tQml0cygoYzE2IDw8IDE2KSB8IGMwMCwgKGM0OCA8PCAxNikgfCBjMzIsIHRoaXMudW5zaWduZWQpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwcm9kdWN0IG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNtdWx0aXBseX0uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gbXVsdGlwbGllciBNdWx0aXBsaWVyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFByb2R1Y3RcbiAqL1xuTG9uZ1Byb3RvdHlwZS5tdWwgPSBMb25nUHJvdG90eXBlLm11bHRpcGx5O1xuXG4vKipcbiAqIFJldHVybnMgdGhpcyBMb25nIGRpdmlkZWQgYnkgdGhlIHNwZWNpZmllZC4gVGhlIHJlc3VsdCBpcyBzaWduZWQgaWYgdGhpcyBMb25nIGlzIHNpZ25lZCBvclxuICogIHVuc2lnbmVkIGlmIHRoaXMgTG9uZyBpcyB1bnNpZ25lZC5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXG4gKiBAcmV0dXJucyB7IUxvbmd9IFF1b3RpZW50XG4gKi9cbkxvbmdQcm90b3R5cGUuZGl2aWRlID0gZnVuY3Rpb24gZGl2aWRlKGRpdmlzb3IpIHtcbiAgaWYgKCFpc0xvbmcoZGl2aXNvcikpXG4gICAgZGl2aXNvciA9IGZyb21WYWx1ZShkaXZpc29yKTtcbiAgaWYgKGRpdmlzb3IuaXNaZXJvKCkpXG4gICAgdGhyb3cgRXJyb3IoJ2RpdmlzaW9uIGJ5IHplcm8nKTtcblxuICAvLyB1c2Ugd2FzbSBzdXBwb3J0IGlmIHByZXNlbnRcbiAgaWYgKHdhc20pIHtcbiAgICAvLyBndWFyZCBhZ2FpbnN0IHNpZ25lZCBkaXZpc2lvbiBvdmVyZmxvdzogdGhlIGxhcmdlc3RcbiAgICAvLyBuZWdhdGl2ZSBudW1iZXIgLyAtMSB3b3VsZCBiZSAxIGxhcmdlciB0aGFuIHRoZSBsYXJnZXN0XG4gICAgLy8gcG9zaXRpdmUgbnVtYmVyLCBkdWUgdG8gdHdvJ3MgY29tcGxlbWVudC5cbiAgICBpZiAoIXRoaXMudW5zaWduZWQgJiZcbiAgICAgIHRoaXMuaGlnaCA9PT0gLTB4ODAwMDAwMDAgJiZcbiAgICAgIGRpdmlzb3IubG93ID09PSAtMSAmJiBkaXZpc29yLmhpZ2ggPT09IC0xKSB7XG4gICAgICAvLyBiZSBjb25zaXN0ZW50IHdpdGggbm9uLXdhc20gY29kZSBwYXRoXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdmFyIGxvdyA9ICh0aGlzLnVuc2lnbmVkID8gd2FzbVtcImRpdl91XCJdIDogd2FzbVtcImRpdl9zXCJdKShcbiAgICAgIHRoaXMubG93LFxuICAgICAgdGhpcy5oaWdoLFxuICAgICAgZGl2aXNvci5sb3csXG4gICAgICBkaXZpc29yLmhpZ2hcbiAgICApO1xuICAgIHJldHVybiBmcm9tQml0cyhsb3csIHdhc21bXCJnZXRfaGlnaFwiXSgpLCB0aGlzLnVuc2lnbmVkKTtcbiAgfVxuXG4gIGlmICh0aGlzLmlzWmVybygpKVxuICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gVVpFUk8gOiBaRVJPO1xuICB2YXIgYXBwcm94LCByZW0sIHJlcztcbiAgaWYgKCF0aGlzLnVuc2lnbmVkKSB7XG4gICAgLy8gVGhpcyBzZWN0aW9uIGlzIG9ubHkgcmVsZXZhbnQgZm9yIHNpZ25lZCBsb25ncyBhbmQgaXMgZGVyaXZlZCBmcm9tIHRoZVxuICAgIC8vIGNsb3N1cmUgbGlicmFyeSBhcyBhIHdob2xlLlxuICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpIHtcbiAgICAgIGlmIChkaXZpc29yLmVxKE9ORSkgfHwgZGl2aXNvci5lcShORUdfT05FKSlcbiAgICAgICAgcmV0dXJuIE1JTl9WQUxVRTsgIC8vIHJlY2FsbCB0aGF0IC1NSU5fVkFMVUUgPT0gTUlOX1ZBTFVFXG4gICAgICBlbHNlIGlmIChkaXZpc29yLmVxKE1JTl9WQUxVRSkpXG4gICAgICAgIHJldHVybiBPTkU7XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgd2UgaGF2ZSB8b3RoZXJ8ID49IDIsIHNvIHx0aGlzL290aGVyfCA8IHxNSU5fVkFMVUV8LlxuICAgICAgICB2YXIgaGFsZlRoaXMgPSB0aGlzLnNocigxKTtcbiAgICAgICAgYXBwcm94ID0gaGFsZlRoaXMuZGl2KGRpdmlzb3IpLnNobCgxKTtcbiAgICAgICAgaWYgKGFwcHJveC5lcShaRVJPKSkge1xuICAgICAgICAgIHJldHVybiBkaXZpc29yLmlzTmVnYXRpdmUoKSA/IE9ORSA6IE5FR19PTkU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtID0gdGhpcy5zdWIoZGl2aXNvci5tdWwoYXBwcm94KSk7XG4gICAgICAgICAgcmVzID0gYXBwcm94LmFkZChyZW0uZGl2KGRpdmlzb3IpKTtcbiAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkaXZpc29yLmVxKE1JTl9WQUxVRSkpXG4gICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcbiAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcbiAgICAgIGlmIChkaXZpc29yLmlzTmVnYXRpdmUoKSlcbiAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkuZGl2KGRpdmlzb3IubmVnKCkpO1xuICAgICAgcmV0dXJuIHRoaXMubmVnKCkuZGl2KGRpdmlzb3IpLm5lZygpO1xuICAgIH0gZWxzZSBpZiAoZGl2aXNvci5pc05lZ2F0aXZlKCkpXG4gICAgICByZXR1cm4gdGhpcy5kaXYoZGl2aXNvci5uZWcoKSkubmVnKCk7XG4gICAgcmVzID0gWkVSTztcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGUgYWxnb3JpdGhtIGJlbG93IGhhcyBub3QgYmVlbiBtYWRlIGZvciB1bnNpZ25lZCBsb25ncy4gSXQncyB0aGVyZWZvcmVcbiAgICAvLyByZXF1aXJlZCB0byB0YWtlIHNwZWNpYWwgY2FyZSBvZiB0aGUgTVNCIHByaW9yIHRvIHJ1bm5pbmcgaXQuXG4gICAgaWYgKCFkaXZpc29yLnVuc2lnbmVkKVxuICAgICAgZGl2aXNvciA9IGRpdmlzb3IudG9VbnNpZ25lZCgpO1xuICAgIGlmIChkaXZpc29yLmd0KHRoaXMpKVxuICAgICAgcmV0dXJuIFVaRVJPO1xuICAgIGlmIChkaXZpc29yLmd0KHRoaXMuc2hydSgxKSkpIC8vIDE1ID4+PiAxID0gNyA7IHdpdGggZGl2aXNvciA9IDggOyB0cnVlXG4gICAgICByZXR1cm4gVU9ORTtcbiAgICByZXMgPSBVWkVSTztcbiAgfVxuXG4gIC8vIFJlcGVhdCB0aGUgZm9sbG93aW5nIHVudGlsIHRoZSByZW1haW5kZXIgaXMgbGVzcyB0aGFuIG90aGVyOiAgZmluZCBhXG4gIC8vIGZsb2F0aW5nLXBvaW50IHRoYXQgYXBwcm94aW1hdGVzIHJlbWFpbmRlciAvIG90aGVyICpmcm9tIGJlbG93KiwgYWRkIHRoaXNcbiAgLy8gaW50byB0aGUgcmVzdWx0LCBhbmQgc3VidHJhY3QgaXQgZnJvbSB0aGUgcmVtYWluZGVyLiAgSXQgaXMgY3JpdGljYWwgdGhhdFxuICAvLyB0aGUgYXBwcm94aW1hdGUgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSByZWFsIHZhbHVlIHNvIHRoYXQgdGhlXG4gIC8vIHJlbWFpbmRlciBuZXZlciBiZWNvbWVzIG5lZ2F0aXZlLlxuICByZW0gPSB0aGlzO1xuICB3aGlsZSAocmVtLmd0ZShkaXZpc29yKSkge1xuICAgIC8vIEFwcHJveGltYXRlIHRoZSByZXN1bHQgb2YgZGl2aXNpb24uIFRoaXMgbWF5IGJlIGEgbGl0dGxlIGdyZWF0ZXIgb3JcbiAgICAvLyBzbWFsbGVyIHRoYW4gdGhlIGFjdHVhbCB2YWx1ZS5cbiAgICBhcHByb3ggPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKHJlbS50b051bWJlcigpIC8gZGl2aXNvci50b051bWJlcigpKSk7XG5cbiAgICAvLyBXZSB3aWxsIHR3ZWFrIHRoZSBhcHByb3hpbWF0ZSByZXN1bHQgYnkgY2hhbmdpbmcgaXQgaW4gdGhlIDQ4LXRoIGRpZ2l0IG9yXG4gICAgLy8gdGhlIHNtYWxsZXN0IG5vbi1mcmFjdGlvbmFsIGRpZ2l0LCB3aGljaGV2ZXIgaXMgbGFyZ2VyLlxuICAgIHZhciBsb2cyID0gTWF0aC5jZWlsKE1hdGgubG9nKGFwcHJveCkgLyBNYXRoLkxOMiksXG4gICAgICBkZWx0YSA9IChsb2cyIDw9IDQ4KSA/IDEgOiBwb3dfZGJsKDIsIGxvZzIgLSA0OCksXG5cbiAgICAgIC8vIERlY3JlYXNlIHRoZSBhcHByb3hpbWF0aW9uIHVudGlsIGl0IGlzIHNtYWxsZXIgdGhhbiB0aGUgcmVtYWluZGVyLiAgTm90ZVxuICAgICAgLy8gdGhhdCBpZiBpdCBpcyB0b28gbGFyZ2UsIHRoZSBwcm9kdWN0IG92ZXJmbG93cyBhbmQgaXMgbmVnYXRpdmUuXG4gICAgICBhcHByb3hSZXMgPSBmcm9tTnVtYmVyKGFwcHJveCksXG4gICAgICBhcHByb3hSZW0gPSBhcHByb3hSZXMubXVsKGRpdmlzb3IpO1xuICAgIHdoaWxlIChhcHByb3hSZW0uaXNOZWdhdGl2ZSgpIHx8IGFwcHJveFJlbS5ndChyZW0pKSB7XG4gICAgICBhcHByb3ggLT0gZGVsdGE7XG4gICAgICBhcHByb3hSZXMgPSBmcm9tTnVtYmVyKGFwcHJveCwgdGhpcy51bnNpZ25lZCk7XG4gICAgICBhcHByb3hSZW0gPSBhcHByb3hSZXMubXVsKGRpdmlzb3IpO1xuICAgIH1cblxuICAgIC8vIFdlIGtub3cgdGhlIGFuc3dlciBjYW4ndCBiZSB6ZXJvLi4uIGFuZCBhY3R1YWxseSwgemVybyB3b3VsZCBjYXVzZVxuICAgIC8vIGluZmluaXRlIHJlY3Vyc2lvbiBzaW5jZSB3ZSB3b3VsZCBtYWtlIG5vIHByb2dyZXNzLlxuICAgIGlmIChhcHByb3hSZXMuaXNaZXJvKCkpXG4gICAgICBhcHByb3hSZXMgPSBPTkU7XG5cbiAgICByZXMgPSByZXMuYWRkKGFwcHJveFJlcyk7XG4gICAgcmVtID0gcmVtLnN1YihhcHByb3hSZW0pO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhpcyBMb25nIGRpdmlkZWQgYnkgdGhlIHNwZWNpZmllZC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNkaXZpZGV9LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxuICogQHJldHVybnMgeyFMb25nfSBRdW90aWVudFxuICovXG5Mb25nUHJvdG90eXBlLmRpdiA9IExvbmdQcm90b3R5cGUuZGl2aWRlO1xuXG4vKipcbiAqIFJldHVybnMgdGhpcyBMb25nIG1vZHVsbyB0aGUgc3BlY2lmaWVkLlxuICogQHRoaXMgeyFMb25nfVxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcbiAqIEByZXR1cm5zIHshTG9uZ30gUmVtYWluZGVyXG4gKi9cbkxvbmdQcm90b3R5cGUubW9kdWxvID0gZnVuY3Rpb24gbW9kdWxvKGRpdmlzb3IpIHtcbiAgaWYgKCFpc0xvbmcoZGl2aXNvcikpXG4gICAgZGl2aXNvciA9IGZyb21WYWx1ZShkaXZpc29yKTtcblxuICAvLyB1c2Ugd2FzbSBzdXBwb3J0IGlmIHByZXNlbnRcbiAgaWYgKHdhc20pIHtcbiAgICB2YXIgbG93ID0gKHRoaXMudW5zaWduZWQgPyB3YXNtW1wicmVtX3VcIl0gOiB3YXNtW1wicmVtX3NcIl0pKFxuICAgICAgdGhpcy5sb3csXG4gICAgICB0aGlzLmhpZ2gsXG4gICAgICBkaXZpc29yLmxvdyxcbiAgICAgIGRpdmlzb3IuaGlnaFxuICAgICk7XG4gICAgcmV0dXJuIGZyb21CaXRzKGxvdywgd2FzbVtcImdldF9oaWdoXCJdKCksIHRoaXMudW5zaWduZWQpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuc3ViKHRoaXMuZGl2KGRpdmlzb3IpLm11bChkaXZpc29yKSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhpcyBMb25nIG1vZHVsbyB0aGUgc3BlY2lmaWVkLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI21vZHVsb30uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXG4gKiBAcmV0dXJucyB7IUxvbmd9IFJlbWFpbmRlclxuICovXG5Mb25nUHJvdG90eXBlLm1vZCA9IExvbmdQcm90b3R5cGUubW9kdWxvO1xuXG4vKipcbiAqIFJldHVybnMgdGhpcyBMb25nIG1vZHVsbyB0aGUgc3BlY2lmaWVkLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI21vZHVsb30uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXG4gKiBAcmV0dXJucyB7IUxvbmd9IFJlbWFpbmRlclxuICovXG5Mb25nUHJvdG90eXBlLnJlbSA9IExvbmdQcm90b3R5cGUubW9kdWxvO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGJpdHdpc2UgTk9UIG9mIHRoaXMgTG9uZy5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEByZXR1cm5zIHshTG9uZ31cbiAqL1xuTG9uZ1Byb3RvdHlwZS5ub3QgPSBmdW5jdGlvbiBub3QoKSB7XG4gIHJldHVybiBmcm9tQml0cyh+dGhpcy5sb3csIH50aGlzLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGNvdW50IGxlYWRpbmcgemVyb3Mgb2YgdGhpcyBMb25nLlxuICogQHRoaXMgeyFMb25nfVxuICogQHJldHVybnMgeyFudW1iZXJ9XG4gKi9cbkxvbmdQcm90b3R5cGUuY291bnRMZWFkaW5nWmVyb3MgPSBmdW5jdGlvbiBjb3VudExlYWRpbmdaZXJvcygpIHtcbiAgcmV0dXJuIHRoaXMuaGlnaCA/IE1hdGguY2x6MzIodGhpcy5oaWdoKSA6IE1hdGguY2x6MzIodGhpcy5sb3cpICsgMzI7XG59O1xuXG4vKipcbiAqIFJldHVybnMgY291bnQgbGVhZGluZyB6ZXJvcy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNjb3VudExlYWRpbmdaZXJvc30uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7IUxvbmd9XG4gKiBAcmV0dXJucyB7IW51bWJlcn1cbiAqL1xuTG9uZ1Byb3RvdHlwZS5jbHogPSBMb25nUHJvdG90eXBlLmNvdW50TGVhZGluZ1plcm9zO1xuXG4vKipcbiAqIFJldHVybnMgY291bnQgdHJhaWxpbmcgemVyb3Mgb2YgdGhpcyBMb25nLlxuICogQHRoaXMgeyFMb25nfVxuICogQHJldHVybnMgeyFudW1iZXJ9XG4gKi9cbkxvbmdQcm90b3R5cGUuY291bnRUcmFpbGluZ1plcm9zID0gZnVuY3Rpb24gY291bnRUcmFpbGluZ1plcm9zKCkge1xuICByZXR1cm4gdGhpcy5sb3cgPyBjdHozMih0aGlzLmxvdykgOiBjdHozMih0aGlzLmhpZ2gpICsgMzI7XG59O1xuXG4vKipcbiAqIFJldHVybnMgY291bnQgdHJhaWxpbmcgemVyb3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjY291bnRUcmFpbGluZ1plcm9zfS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHshTG9uZ31cbiAqIEByZXR1cm5zIHshbnVtYmVyfVxuICovXG5Mb25nUHJvdG90eXBlLmN0eiA9IExvbmdQcm90b3R5cGUuY291bnRUcmFpbGluZ1plcm9zO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGJpdHdpc2UgQU5EIG9mIHRoaXMgTG9uZyBhbmQgdGhlIHNwZWNpZmllZC5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgTG9uZ1xuICogQHJldHVybnMgeyFMb25nfVxuICovXG5Mb25nUHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIGFuZChvdGhlcikge1xuICBpZiAoIWlzTG9uZyhvdGhlcikpXG4gICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xuICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgJiBvdGhlci5sb3csIHRoaXMuaGlnaCAmIG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBiaXR3aXNlIE9SIG9mIHRoaXMgTG9uZyBhbmQgdGhlIHNwZWNpZmllZC5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgTG9uZ1xuICogQHJldHVybnMgeyFMb25nfVxuICovXG5Mb25nUHJvdG90eXBlLm9yID0gZnVuY3Rpb24gb3Iob3RoZXIpIHtcbiAgaWYgKCFpc0xvbmcob3RoZXIpKVxuICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcbiAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IHwgb3RoZXIubG93LCB0aGlzLmhpZ2ggfCBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYml0d2lzZSBYT1Igb2YgdGhpcyBMb25nIGFuZCB0aGUgZ2l2ZW4gb25lLlxuICogQHRoaXMgeyFMb25nfVxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciBMb25nXG4gKiBAcmV0dXJucyB7IUxvbmd9XG4gKi9cbkxvbmdQcm90b3R5cGUueG9yID0gZnVuY3Rpb24geG9yKG90aGVyKSB7XG4gIGlmICghaXNMb25nKG90aGVyKSlcbiAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XG4gIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyBeIG90aGVyLmxvdywgdGhpcy5oaWdoIF4gb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBzaGlmdGVkIHRvIHRoZSBsZWZ0IGJ5IHRoZSBnaXZlbiBhbW91bnQuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcbiAqL1xuTG9uZ1Byb3RvdHlwZS5zaGlmdExlZnQgPSBmdW5jdGlvbiBzaGlmdExlZnQobnVtQml0cykge1xuICBpZiAoaXNMb25nKG51bUJpdHMpKVxuICAgIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7XG4gIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApXG4gICAgcmV0dXJuIHRoaXM7XG4gIGVsc2UgaWYgKG51bUJpdHMgPCAzMilcbiAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgPDwgbnVtQml0cywgKHRoaXMuaGlnaCA8PCBudW1CaXRzKSB8ICh0aGlzLmxvdyA+Pj4gKDMyIC0gbnVtQml0cykpLCB0aGlzLnVuc2lnbmVkKTtcbiAgZWxzZVxuICAgIHJldHVybiBmcm9tQml0cygwLCB0aGlzLmxvdyA8PCAobnVtQml0cyAtIDMyKSwgdGhpcy51bnNpZ25lZCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBzaGlmdGVkIHRvIHRoZSBsZWZ0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRMZWZ0fS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXG4gKi9cbkxvbmdQcm90b3R5cGUuc2hsID0gTG9uZ1Byb3RvdHlwZS5zaGlmdExlZnQ7XG5cbi8qKlxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGFyaXRobWV0aWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcbiAqL1xuTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0ID0gZnVuY3Rpb24gc2hpZnRSaWdodChudW1CaXRzKSB7XG4gIGlmIChpc0xvbmcobnVtQml0cykpXG4gICAgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTtcbiAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMClcbiAgICByZXR1cm4gdGhpcztcbiAgZWxzZSBpZiAobnVtQml0cyA8IDMyKVxuICAgIHJldHVybiBmcm9tQml0cygodGhpcy5sb3cgPj4+IG51bUJpdHMpIHwgKHRoaXMuaGlnaCA8PCAoMzIgLSBudW1CaXRzKSksIHRoaXMuaGlnaCA+PiBudW1CaXRzLCB0aGlzLnVuc2lnbmVkKTtcbiAgZWxzZVxuICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmhpZ2ggPj4gKG51bUJpdHMgLSAzMiksIHRoaXMuaGlnaCA+PSAwID8gMCA6IC0xLCB0aGlzLnVuc2lnbmVkKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGFyaXRobWV0aWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRSaWdodH0uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xuICovXG5Mb25nUHJvdG90eXBlLnNociA9IExvbmdQcm90b3R5cGUuc2hpZnRSaWdodDtcblxuLyoqXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgbG9naWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcbiAqL1xuTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0VW5zaWduZWQgPSBmdW5jdGlvbiBzaGlmdFJpZ2h0VW5zaWduZWQobnVtQml0cykge1xuICBpZiAoaXNMb25nKG51bUJpdHMpKSBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xuICBpZiAoKG51bUJpdHMgJj0gNjMpID09PSAwKSByZXR1cm4gdGhpcztcbiAgaWYgKG51bUJpdHMgPCAzMikgcmV0dXJuIGZyb21CaXRzKCh0aGlzLmxvdyA+Pj4gbnVtQml0cykgfCAodGhpcy5oaWdoIDw8ICgzMiAtIG51bUJpdHMpKSwgdGhpcy5oaWdoID4+PiBudW1CaXRzLCB0aGlzLnVuc2lnbmVkKTtcbiAgaWYgKG51bUJpdHMgPT09IDMyKSByZXR1cm4gZnJvbUJpdHModGhpcy5oaWdoLCAwLCB0aGlzLnVuc2lnbmVkKTtcbiAgcmV0dXJuIGZyb21CaXRzKHRoaXMuaGlnaCA+Pj4gKG51bUJpdHMgLSAzMiksIDAsIHRoaXMudW5zaWduZWQpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgbG9naWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRSaWdodFVuc2lnbmVkfS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXG4gKi9cbkxvbmdQcm90b3R5cGUuc2hydSA9IExvbmdQcm90b3R5cGUuc2hpZnRSaWdodFVuc2lnbmVkO1xuXG4vKipcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBsb2dpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNzaGlmdFJpZ2h0VW5zaWduZWR9LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcbiAqL1xuTG9uZ1Byb3RvdHlwZS5zaHJfdSA9IExvbmdQcm90b3R5cGUuc2hpZnRSaWdodFVuc2lnbmVkO1xuXG4vKipcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyByb3RhdGVkIHRvIHRoZSBsZWZ0IGJ5IHRoZSBnaXZlbiBhbW91bnQuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICogQHJldHVybnMgeyFMb25nfSBSb3RhdGVkIExvbmdcbiAqL1xuTG9uZ1Byb3RvdHlwZS5yb3RhdGVMZWZ0ID0gZnVuY3Rpb24gcm90YXRlTGVmdChudW1CaXRzKSB7XG4gIHZhciBiO1xuICBpZiAoaXNMb25nKG51bUJpdHMpKSBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xuICBpZiAoKG51bUJpdHMgJj0gNjMpID09PSAwKSByZXR1cm4gdGhpcztcbiAgaWYgKG51bUJpdHMgPT09IDMyKSByZXR1cm4gZnJvbUJpdHModGhpcy5oaWdoLCB0aGlzLmxvdywgdGhpcy51bnNpZ25lZCk7XG4gIGlmIChudW1CaXRzIDwgMzIpIHtcbiAgICBiID0gKDMyIC0gbnVtQml0cyk7XG4gICAgcmV0dXJuIGZyb21CaXRzKCgodGhpcy5sb3cgPDwgbnVtQml0cykgfCAodGhpcy5oaWdoID4+PiBiKSksICgodGhpcy5oaWdoIDw8IG51bUJpdHMpIHwgKHRoaXMubG93ID4+PiBiKSksIHRoaXMudW5zaWduZWQpO1xuICB9XG4gIG51bUJpdHMgLT0gMzI7XG4gIGIgPSAoMzIgLSBudW1CaXRzKTtcbiAgcmV0dXJuIGZyb21CaXRzKCgodGhpcy5oaWdoIDw8IG51bUJpdHMpIHwgKHRoaXMubG93ID4+PiBiKSksICgodGhpcy5sb3cgPDwgbnVtQml0cykgfCAodGhpcy5oaWdoID4+PiBiKSksIHRoaXMudW5zaWduZWQpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgcm90YXRlZCB0byB0aGUgbGVmdCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3JvdGF0ZUxlZnR9LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICogQHJldHVybnMgeyFMb25nfSBSb3RhdGVkIExvbmdcbiAqL1xuTG9uZ1Byb3RvdHlwZS5yb3RsID0gTG9uZ1Byb3RvdHlwZS5yb3RhdGVMZWZ0O1xuXG4vKipcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyByb3RhdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxuICogQHRoaXMgeyFMb25nfVxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAqIEByZXR1cm5zIHshTG9uZ30gUm90YXRlZCBMb25nXG4gKi9cbkxvbmdQcm90b3R5cGUucm90YXRlUmlnaHQgPSBmdW5jdGlvbiByb3RhdGVSaWdodChudW1CaXRzKSB7XG4gIHZhciBiO1xuICBpZiAoaXNMb25nKG51bUJpdHMpKSBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xuICBpZiAoKG51bUJpdHMgJj0gNjMpID09PSAwKSByZXR1cm4gdGhpcztcbiAgaWYgKG51bUJpdHMgPT09IDMyKSByZXR1cm4gZnJvbUJpdHModGhpcy5oaWdoLCB0aGlzLmxvdywgdGhpcy51bnNpZ25lZCk7XG4gIGlmIChudW1CaXRzIDwgMzIpIHtcbiAgICBiID0gKDMyIC0gbnVtQml0cyk7XG4gICAgcmV0dXJuIGZyb21CaXRzKCgodGhpcy5oaWdoIDw8IGIpIHwgKHRoaXMubG93ID4+PiBudW1CaXRzKSksICgodGhpcy5sb3cgPDwgYikgfCAodGhpcy5oaWdoID4+PiBudW1CaXRzKSksIHRoaXMudW5zaWduZWQpO1xuICB9XG4gIG51bUJpdHMgLT0gMzI7XG4gIGIgPSAoMzIgLSBudW1CaXRzKTtcbiAgcmV0dXJuIGZyb21CaXRzKCgodGhpcy5sb3cgPDwgYikgfCAodGhpcy5oaWdoID4+PiBudW1CaXRzKSksICgodGhpcy5oaWdoIDw8IGIpIHwgKHRoaXMubG93ID4+PiBudW1CaXRzKSksIHRoaXMudW5zaWduZWQpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgcm90YXRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNyb3RhdGVSaWdodH0uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXG4gKiBAcmV0dXJucyB7IUxvbmd9IFJvdGF0ZWQgTG9uZ1xuICovXG5Mb25nUHJvdG90eXBlLnJvdHIgPSBMb25nUHJvdG90eXBlLnJvdGF0ZVJpZ2h0O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byBzaWduZWQuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcmV0dXJucyB7IUxvbmd9IFNpZ25lZCBsb25nXG4gKi9cbkxvbmdQcm90b3R5cGUudG9TaWduZWQgPSBmdW5jdGlvbiB0b1NpZ25lZCgpIHtcbiAgaWYgKCF0aGlzLnVuc2lnbmVkKVxuICAgIHJldHVybiB0aGlzO1xuICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3csIHRoaXMuaGlnaCwgZmFsc2UpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gdW5zaWduZWQuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcmV0dXJucyB7IUxvbmd9IFVuc2lnbmVkIGxvbmdcbiAqL1xuTG9uZ1Byb3RvdHlwZS50b1Vuc2lnbmVkID0gZnVuY3Rpb24gdG9VbnNpZ25lZCgpIHtcbiAgaWYgKHRoaXMudW5zaWduZWQpXG4gICAgcmV0dXJuIHRoaXM7XG4gIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdywgdGhpcy5oaWdoLCB0cnVlKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBMb25nIHRvIGl0cyBieXRlIHJlcHJlc2VudGF0aW9uLlxuICogQHBhcmFtIHtib29sZWFuPX0gbGUgV2hldGhlciBsaXR0bGUgb3IgYmlnIGVuZGlhbiwgZGVmYXVsdHMgdG8gYmlnIGVuZGlhblxuICogQHRoaXMgeyFMb25nfVxuICogQHJldHVybnMgeyFBcnJheS48bnVtYmVyPn0gQnl0ZSByZXByZXNlbnRhdGlvblxuICovXG5Mb25nUHJvdG90eXBlLnRvQnl0ZXMgPSBmdW5jdGlvbiB0b0J5dGVzKGxlKSB7XG4gIHJldHVybiBsZSA/IHRoaXMudG9CeXRlc0xFKCkgOiB0aGlzLnRvQnl0ZXNCRSgpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gaXRzIGxpdHRsZSBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvbi5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEByZXR1cm5zIHshQXJyYXkuPG51bWJlcj59IExpdHRsZSBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvblxuICovXG5Mb25nUHJvdG90eXBlLnRvQnl0ZXNMRSA9IGZ1bmN0aW9uIHRvQnl0ZXNMRSgpIHtcbiAgdmFyIGhpID0gdGhpcy5oaWdoLFxuICAgIGxvID0gdGhpcy5sb3c7XG4gIHJldHVybiBbXG4gICAgbG8gJiAweGZmLFxuICAgIGxvID4+PiA4ICYgMHhmZixcbiAgICBsbyA+Pj4gMTYgJiAweGZmLFxuICAgIGxvID4+PiAyNCxcbiAgICBoaSAmIDB4ZmYsXG4gICAgaGkgPj4+IDggJiAweGZmLFxuICAgIGhpID4+PiAxNiAmIDB4ZmYsXG4gICAgaGkgPj4+IDI0XG4gIF07XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byBpdHMgYmlnIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uLlxuICogQHRoaXMgeyFMb25nfVxuICogQHJldHVybnMgeyFBcnJheS48bnVtYmVyPn0gQmlnIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uXG4gKi9cbkxvbmdQcm90b3R5cGUudG9CeXRlc0JFID0gZnVuY3Rpb24gdG9CeXRlc0JFKCkge1xuICB2YXIgaGkgPSB0aGlzLmhpZ2gsXG4gICAgbG8gPSB0aGlzLmxvdztcbiAgcmV0dXJuIFtcbiAgICBoaSA+Pj4gMjQsXG4gICAgaGkgPj4+IDE2ICYgMHhmZixcbiAgICBoaSA+Pj4gOCAmIDB4ZmYsXG4gICAgaGkgJiAweGZmLFxuICAgIGxvID4+PiAyNCxcbiAgICBsbyA+Pj4gMTYgJiAweGZmLFxuICAgIGxvID4+PiA4ICYgMHhmZixcbiAgICBsbyAmIDB4ZmZcbiAgXTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIExvbmcgZnJvbSBpdHMgYnl0ZSByZXByZXNlbnRhdGlvbi5cbiAqIEBwYXJhbSB7IUFycmF5LjxudW1iZXI+fSBieXRlcyBCeXRlIHJlcHJlc2VudGF0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBsZSBXaGV0aGVyIGxpdHRsZSBvciBiaWcgZW5kaWFuLCBkZWZhdWx0cyB0byBiaWcgZW5kaWFuXG4gKiBAcmV0dXJucyB7TG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxuICovXG5Mb25nLmZyb21CeXRlcyA9IGZ1bmN0aW9uIGZyb21CeXRlcyhieXRlcywgdW5zaWduZWQsIGxlKSB7XG4gIHJldHVybiBsZSA/IExvbmcuZnJvbUJ5dGVzTEUoYnl0ZXMsIHVuc2lnbmVkKSA6IExvbmcuZnJvbUJ5dGVzQkUoYnl0ZXMsIHVuc2lnbmVkKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIExvbmcgZnJvbSBpdHMgbGl0dGxlIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uLlxuICogQHBhcmFtIHshQXJyYXkuPG51bWJlcj59IGJ5dGVzIExpdHRsZSBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvblxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxuICogQHJldHVybnMge0xvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcbiAqL1xuTG9uZy5mcm9tQnl0ZXNMRSA9IGZ1bmN0aW9uIGZyb21CeXRlc0xFKGJ5dGVzLCB1bnNpZ25lZCkge1xuICByZXR1cm4gbmV3IExvbmcoXG4gICAgYnl0ZXNbMF0gfFxuICAgIGJ5dGVzWzFdIDw8IDggfFxuICAgIGJ5dGVzWzJdIDw8IDE2IHxcbiAgICBieXRlc1szXSA8PCAyNCxcbiAgICBieXRlc1s0XSB8XG4gICAgYnl0ZXNbNV0gPDwgOCB8XG4gICAgYnl0ZXNbNl0gPDwgMTYgfFxuICAgIGJ5dGVzWzddIDw8IDI0LFxuICAgIHVuc2lnbmVkXG4gICk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBMb25nIGZyb20gaXRzIGJpZyBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvbi5cbiAqIEBwYXJhbSB7IUFycmF5LjxudW1iZXI+fSBieXRlcyBCaWcgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcbiAqIEByZXR1cm5zIHtMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXG4gKi9cbkxvbmcuZnJvbUJ5dGVzQkUgPSBmdW5jdGlvbiBmcm9tQnl0ZXNCRShieXRlcywgdW5zaWduZWQpIHtcbiAgcmV0dXJuIG5ldyBMb25nKFxuICAgIGJ5dGVzWzRdIDw8IDI0IHxcbiAgICBieXRlc1s1XSA8PCAxNiB8XG4gICAgYnl0ZXNbNl0gPDwgOCB8XG4gICAgYnl0ZXNbN10sXG4gICAgYnl0ZXNbMF0gPDwgMjQgfFxuICAgIGJ5dGVzWzFdIDw8IDE2IHxcbiAgICBieXRlc1syXSA8PCA4IHxcbiAgICBieXRlc1szXSxcbiAgICB1bnNpZ25lZFxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgTG9uZztcbiIsICIvLy8gQGZpbGVcbi8vLyBAYWRkdG9ncm91cCBmbGF0YnVmZmVyc19qYXZhc2NyaXB0X2FwaVxuLy8vIEB7XG4vLy8gQGNvbmQgRkxBVEJVRkZFUlNfSU5URVJOQUxcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3XG4gKlxuICogTmVlZCB0byBzdXBwcmVzcyAnZ2xvYmFsIHRoaXMnIGVycm9yIHNvIHRoZSBOb2RlLmpzIGV4cG9ydCBsaW5lIGRvZXNuJ3QgY2F1c2VcbiAqIGNsb3N1cmUgY29tcGlsZSB0byBlcnJvciBvdXQuXG4gKiBAc3VwcHJlc3Mge2dsb2JhbFRoaXN9XG4gKi9cblxuLyoqXG4gKiBAY29uc3RcbiAqIEBuYW1lc3BhY2VcbiAqL1xudmFyIGZsYXRidWZmZXJzID0ge307XG5cbi8qKlxuICogQHR5cGVkZWYge251bWJlcn1cbiAqL1xuZmxhdGJ1ZmZlcnMuT2Zmc2V0O1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiAgIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLFxuICogICBiYl9wb3M6IG51bWJlclxuICogfX1cbiAqL1xuZmxhdGJ1ZmZlcnMuVGFibGU7XG5cbi8qKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdFxuICovXG5mbGF0YnVmZmVycy5TSVpFT0ZfU0hPUlQgPSAyO1xuXG4vKipcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RcbiAqL1xuZmxhdGJ1ZmZlcnMuU0laRU9GX0lOVCA9IDQ7XG5cbi8qKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdFxuICovXG5mbGF0YnVmZmVycy5GSUxFX0lERU5USUZJRVJfTEVOR1RIID0gNDtcblxuLyoqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0XG4gKi9cbmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCA9IDQ7XG5cbi8qKlxuICogQGVudW0ge251bWJlcn1cbiAqL1xuZmxhdGJ1ZmZlcnMuRW5jb2RpbmcgPSB7XG4gIFVURjhfQllURVM6IDEsXG4gIFVURjE2X1NUUklORzogMlxufTtcblxuLyoqXG4gKiBAdHlwZSB7SW50MzJBcnJheX1cbiAqIEBjb25zdFxuICovXG5mbGF0YnVmZmVycy5pbnQzMiA9IG5ldyBJbnQzMkFycmF5KDIpO1xuXG4vKipcbiAqIEB0eXBlIHtGbG9hdDMyQXJyYXl9XG4gKiBAY29uc3RcbiAqL1xuZmxhdGJ1ZmZlcnMuZmxvYXQzMiA9IG5ldyBGbG9hdDMyQXJyYXkoZmxhdGJ1ZmZlcnMuaW50MzIuYnVmZmVyKTtcblxuLyoqXG4gKiBAdHlwZSB7RmxvYXQ2NEFycmF5fVxuICogQGNvbnN0XG4gKi9cbmZsYXRidWZmZXJzLmZsb2F0NjQgPSBuZXcgRmxvYXQ2NEFycmF5KGZsYXRidWZmZXJzLmludDMyLmJ1ZmZlcik7XG5cbi8qKlxuICogQHR5cGUge2Jvb2xlYW59XG4gKiBAY29uc3RcbiAqL1xuZmxhdGJ1ZmZlcnMuaXNMaXR0bGVFbmRpYW4gPSBuZXcgVWludDE2QXJyYXkobmV3IFVpbnQ4QXJyYXkoWzEsIDBdKS5idWZmZXIpWzBdID09PSAxO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtudW1iZXJ9IGxvd1xuICogQHBhcmFtIHtudW1iZXJ9IGhpZ2hcbiAqL1xuZmxhdGJ1ZmZlcnMuTG9uZyA9IGZ1bmN0aW9uKGxvdywgaGlnaCkge1xuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGNvbnN0XG4gICAqL1xuICB0aGlzLmxvdyA9IGxvdyB8IDA7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBjb25zdFxuICAgKi9cbiAgdGhpcy5oaWdoID0gaGlnaCB8IDA7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3dcbiAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoXG4gKiBAcmV0dXJucyB7IWZsYXRidWZmZXJzLkxvbmd9XG4gKi9cbmZsYXRidWZmZXJzLkxvbmcuY3JlYXRlID0gZnVuY3Rpb24obG93LCBoaWdoKSB7XG4gIC8vIFNwZWNpYWwtY2FzZSB6ZXJvIHRvIGF2b2lkIEdDIG92ZXJoZWFkIGZvciBkZWZhdWx0IHZhbHVlc1xuICByZXR1cm4gbG93ID09IDAgJiYgaGlnaCA9PSAwID8gZmxhdGJ1ZmZlcnMuTG9uZy5aRVJPIDogbmV3IGZsYXRidWZmZXJzLkxvbmcobG93LCBoaWdoKTtcbn07XG5cbi8qKlxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZmxhdGJ1ZmZlcnMuTG9uZy5wcm90b3R5cGUudG9GbG9hdDY0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAodGhpcy5sb3cgPj4+IDApICsgdGhpcy5oaWdoICogMHgxMDAwMDAwMDA7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7ZmxhdGJ1ZmZlcnMuTG9uZ30gb3RoZXJcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mbGF0YnVmZmVycy5Mb25nLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihvdGhlcikge1xuICByZXR1cm4gdGhpcy5sb3cgPT0gb3RoZXIubG93ICYmIHRoaXMuaGlnaCA9PSBvdGhlci5oaWdoO1xufTtcblxuLyoqXG4gKiBAdHlwZSB7IWZsYXRidWZmZXJzLkxvbmd9XG4gKiBAY29uc3RcbiAqL1xuZmxhdGJ1ZmZlcnMuTG9uZy5aRVJPID0gbmV3IGZsYXRidWZmZXJzLkxvbmcoMCwgMCk7XG5cbi8vLyBAZW5kY29uZFxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8qKlxuICogQ3JlYXRlIGEgRmxhdEJ1ZmZlckJ1aWxkZXIuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9pbml0aWFsX3NpemVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlciA9IGZ1bmN0aW9uKG9wdF9pbml0aWFsX3NpemUpIHtcbiAgaWYgKCFvcHRfaW5pdGlhbF9zaXplKSB7XG4gICAgdmFyIGluaXRpYWxfc2l6ZSA9IDEwMjQ7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGluaXRpYWxfc2l6ZSA9IG9wdF9pbml0aWFsX3NpemU7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge2ZsYXRidWZmZXJzLkJ5dGVCdWZmZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmJiID0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5hbGxvY2F0ZShpbml0aWFsX3NpemUpO1xuXG4gIC8qKlxuICAgKiBSZW1haW5pbmcgc3BhY2UgaW4gdGhlIEJ5dGVCdWZmZXIuXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnNwYWNlID0gaW5pdGlhbF9zaXplO1xuXG4gIC8qKlxuICAgKiBNaW5pbXVtIGFsaWdubWVudCBlbmNvdW50ZXJlZCBzbyBmYXIuXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLm1pbmFsaWduID0gMTtcblxuICAvKipcbiAgICogVGhlIHZ0YWJsZSBmb3IgdGhlIGN1cnJlbnQgdGFibGUuXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMudnRhYmxlID0gbnVsbDtcblxuICAvKipcbiAgICogVGhlIGFtb3VudCBvZiBmaWVsZHMgd2UncmUgYWN0dWFsbHkgdXNpbmcuXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnZ0YWJsZV9pbl91c2UgPSAwO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHdlIGFyZSBjdXJyZW50bHkgc2VyaWFsaXppbmcgYSB0YWJsZS5cbiAgICpcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmlzTmVzdGVkID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFN0YXJ0aW5nIG9mZnNldCBvZiB0aGUgY3VycmVudCBzdHJ1Y3QvdGFibGUuXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLm9iamVjdF9zdGFydCA9IDA7XG5cbiAgLyoqXG4gICAqIExpc3Qgb2Ygb2Zmc2V0cyBvZiBhbGwgdnRhYmxlcy5cbiAgICpcbiAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy52dGFibGVzID0gW107XG5cbiAgLyoqXG4gICAqIEZvciB0aGUgY3VycmVudCB2ZWN0b3IgYmVpbmcgYnVpbHQuXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnZlY3Rvcl9udW1fZWxlbXMgPSAwO1xuXG4gIC8qKlxuICAgKiBGYWxzZSBvbWl0cyBkZWZhdWx0IHZhbHVlcyBmcm9tIHRoZSBzZXJpYWxpemVkIGRhdGFcbiAgICpcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmZvcmNlX2RlZmF1bHRzID0gZmFsc2U7XG59O1xuXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmJiLmNsZWFyKCk7XG4gIHRoaXMuc3BhY2UgPSB0aGlzLmJiLmNhcGFjaXR5KCk7XG4gIHRoaXMubWluYWxpZ24gPSAxO1xuICB0aGlzLnZ0YWJsZSA9IG51bGw7XG4gIHRoaXMudnRhYmxlX2luX3VzZSA9IDA7XG4gIHRoaXMuaXNOZXN0ZWQgPSBmYWxzZTtcbiAgdGhpcy5vYmplY3Rfc3RhcnQgPSAwO1xuICB0aGlzLnZ0YWJsZXMgPSBbXTtcbiAgdGhpcy52ZWN0b3JfbnVtX2VsZW1zID0gMDtcbiAgdGhpcy5mb3JjZV9kZWZhdWx0cyA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBJbiBvcmRlciB0byBzYXZlIHNwYWNlLCBmaWVsZHMgdGhhdCBhcmUgc2V0IHRvIHRoZWlyIGRlZmF1bHQgdmFsdWVcbiAqIGRvbid0IGdldCBzZXJpYWxpemVkIGludG8gdGhlIGJ1ZmZlci4gRm9yY2luZyBkZWZhdWx0cyBwcm92aWRlcyBhXG4gKiB3YXkgdG8gbWFudWFsbHkgZGlzYWJsZSB0aGlzIG9wdGltaXphdGlvbi5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGZvcmNlRGVmYXVsdHMgdHJ1ZSBhbHdheXMgc2VyaWFsaXplcyBkZWZhdWx0IHZhbHVlc1xuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5mb3JjZURlZmF1bHRzID0gZnVuY3Rpb24oZm9yY2VEZWZhdWx0cykge1xuICB0aGlzLmZvcmNlX2RlZmF1bHRzID0gZm9yY2VEZWZhdWx0cztcbn07XG5cbi8qKlxuICogR2V0IHRoZSBCeXRlQnVmZmVyIHJlcHJlc2VudGluZyB0aGUgRmxhdEJ1ZmZlci4gT25seSBjYWxsIHRoaXMgYWZ0ZXIgeW91J3ZlXG4gKiBjYWxsZWQgZmluaXNoKCkuIFRoZSBhY3R1YWwgZGF0YSBzdGFydHMgYXQgdGhlIEJ5dGVCdWZmZXIncyBjdXJyZW50IHBvc2l0aW9uLFxuICogbm90IG5lY2Vzc2FyaWx5IGF0IDAuXG4gKlxuICogQHJldHVybnMge2ZsYXRidWZmZXJzLkJ5dGVCdWZmZXJ9XG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLmRhdGFCdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuYmI7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgYnl0ZXMgcmVwcmVzZW50aW5nIHRoZSBGbGF0QnVmZmVyLiBPbmx5IGNhbGwgdGhpcyBhZnRlciB5b3UndmVcbiAqIGNhbGxlZCBmaW5pc2goKS5cbiAqXG4gKiBAcmV0dXJucyB7IVVpbnQ4QXJyYXl9XG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLmFzVWludDhBcnJheSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5iYi5ieXRlcygpLnN1YmFycmF5KHRoaXMuYmIucG9zaXRpb24oKSwgdGhpcy5iYi5wb3NpdGlvbigpICsgdGhpcy5vZmZzZXQoKSk7XG59O1xuXG4vLy8gQGNvbmQgRkxBVEJVRkZFUlNfSU5URVJOQUxcbi8qKlxuICogUHJlcGFyZSB0byB3cml0ZSBhbiBlbGVtZW50IG9mIGBzaXplYCBhZnRlciBgYWRkaXRpb25hbF9ieXRlc2AgaGF2ZSBiZWVuXG4gKiB3cml0dGVuLCBlLmcuIGlmIHlvdSB3cml0ZSBhIHN0cmluZywgeW91IG5lZWQgdG8gYWxpZ24gc3VjaCB0aGUgaW50IGxlbmd0aFxuICogZmllbGQgaXMgYWxpZ25lZCB0byA0IGJ5dGVzLCBhbmQgdGhlIHN0cmluZyBkYXRhIGZvbGxvd3MgaXQgZGlyZWN0bHkuIElmIGFsbFxuICogeW91IG5lZWQgdG8gZG8gaXMgYWxpZ25tZW50LCBgYWRkaXRpb25hbF9ieXRlc2Agd2lsbCBiZSAwLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIFRoaXMgaXMgdGhlIG9mIHRoZSBuZXcgZWxlbWVudCB0byB3cml0ZVxuICogQHBhcmFtIHtudW1iZXJ9IGFkZGl0aW9uYWxfYnl0ZXMgVGhlIHBhZGRpbmcgc2l6ZVxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5wcmVwID0gZnVuY3Rpb24oc2l6ZSwgYWRkaXRpb25hbF9ieXRlcykge1xuICAvLyBUcmFjayB0aGUgYmlnZ2VzdCB0aGluZyB3ZSd2ZSBldmVyIGFsaWduZWQgdG8uXG4gIGlmIChzaXplID4gdGhpcy5taW5hbGlnbikge1xuICAgIHRoaXMubWluYWxpZ24gPSBzaXplO1xuICB9XG5cbiAgLy8gRmluZCB0aGUgYW1vdW50IG9mIGFsaWdubWVudCBuZWVkZWQgc3VjaCB0aGF0IGBzaXplYCBpcyBwcm9wZXJseVxuICAvLyBhbGlnbmVkIGFmdGVyIGBhZGRpdGlvbmFsX2J5dGVzYFxuICB2YXIgYWxpZ25fc2l6ZSA9ICgofih0aGlzLmJiLmNhcGFjaXR5KCkgLSB0aGlzLnNwYWNlICsgYWRkaXRpb25hbF9ieXRlcykpICsgMSkgJiAoc2l6ZSAtIDEpO1xuXG4gIC8vIFJlYWxsb2NhdGUgdGhlIGJ1ZmZlciBpZiBuZWVkZWQuXG4gIHdoaWxlICh0aGlzLnNwYWNlIDwgYWxpZ25fc2l6ZSArIHNpemUgKyBhZGRpdGlvbmFsX2J5dGVzKSB7XG4gICAgdmFyIG9sZF9idWZfc2l6ZSA9IHRoaXMuYmIuY2FwYWNpdHkoKTtcbiAgICB0aGlzLmJiID0gZmxhdGJ1ZmZlcnMuQnVpbGRlci5ncm93Qnl0ZUJ1ZmZlcih0aGlzLmJiKTtcbiAgICB0aGlzLnNwYWNlICs9IHRoaXMuYmIuY2FwYWNpdHkoKSAtIG9sZF9idWZfc2l6ZTtcbiAgfVxuXG4gIHRoaXMucGFkKGFsaWduX3NpemUpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gYnl0ZV9zaXplXG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLnBhZCA9IGZ1bmN0aW9uKGJ5dGVfc2l6ZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVfc2l6ZTsgaSsrKSB7XG4gICAgdGhpcy5iYi53cml0ZUludDgoLS10aGlzLnNwYWNlLCAwKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdGhpcy5iYi53cml0ZUludDgodGhpcy5zcGFjZSAtPSAxLCB2YWx1ZSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS53cml0ZUludDE2ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdGhpcy5iYi53cml0ZUludDE2KHRoaXMuc3BhY2UgLT0gMiwgdmFsdWUpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUud3JpdGVJbnQzMiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHRoaXMuYmIud3JpdGVJbnQzMih0aGlzLnNwYWNlIC09IDQsIHZhbHVlKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtmbGF0YnVmZmVycy5Mb25nfSB2YWx1ZVxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS53cml0ZUludDY0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdGhpcy5iYi53cml0ZUludDY0KHRoaXMuc3BhY2UgLT0gOCwgdmFsdWUpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUud3JpdGVGbG9hdDMyID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdGhpcy5iYi53cml0ZUZsb2F0MzIodGhpcy5zcGFjZSAtPSA0LCB2YWx1ZSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS53cml0ZUZsb2F0NjQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICB0aGlzLmJiLndyaXRlRmxvYXQ2NCh0aGlzLnNwYWNlIC09IDgsIHZhbHVlKTtcbn07XG4vLy8gQGVuZGNvbmRcblxuLyoqXG4gKiBBZGQgYW4gYGludDhgIHRvIHRoZSBidWZmZXIsIHByb3Blcmx5IGFsaWduZWQsIGFuZCBncm93cyB0aGUgYnVmZmVyIChpZiBuZWNlc3NhcnkpLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBgaW50OGAgdG8gYWRkIHRoZSB0aGUgYnVmZmVyLlxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5hZGRJbnQ4ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdGhpcy5wcmVwKDEsIDApO1xuICB0aGlzLndyaXRlSW50OCh2YWx1ZSk7XG59O1xuXG4vKipcbiAqIEFkZCBhbiBgaW50MTZgIHRvIHRoZSBidWZmZXIsIHByb3Blcmx5IGFsaWduZWQsIGFuZCBncm93cyB0aGUgYnVmZmVyIChpZiBuZWNlc3NhcnkpLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBgaW50MTZgIHRvIGFkZCB0aGUgdGhlIGJ1ZmZlci5cbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuYWRkSW50MTYgPSBmdW5jdGlvbih2YWx1ZSkge1xuICB0aGlzLnByZXAoMiwgMCk7XG4gIHRoaXMud3JpdGVJbnQxNih2YWx1ZSk7XG59O1xuXG4vKipcbiAqIEFkZCBhbiBgaW50MzJgIHRvIHRoZSBidWZmZXIsIHByb3Blcmx5IGFsaWduZWQsIGFuZCBncm93cyB0aGUgYnVmZmVyIChpZiBuZWNlc3NhcnkpLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBgaW50MzJgIHRvIGFkZCB0aGUgdGhlIGJ1ZmZlci5cbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuYWRkSW50MzIgPSBmdW5jdGlvbih2YWx1ZSkge1xuICB0aGlzLnByZXAoNCwgMCk7XG4gIHRoaXMud3JpdGVJbnQzMih2YWx1ZSk7XG59O1xuXG4vKipcbiAqIEFkZCBhbiBgaW50NjRgIHRvIHRoZSBidWZmZXIsIHByb3Blcmx5IGFsaWduZWQsIGFuZCBncm93cyB0aGUgYnVmZmVyIChpZiBuZWNlc3NhcnkpLlxuICogQHBhcmFtIHtmbGF0YnVmZmVycy5Mb25nfSB2YWx1ZSBUaGUgYGludDY0YCB0byBhZGQgdGhlIHRoZSBidWZmZXIuXG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLmFkZEludDY0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdGhpcy5wcmVwKDgsIDApO1xuICB0aGlzLndyaXRlSW50NjQodmFsdWUpO1xufTtcblxuLyoqXG4gKiBBZGQgYSBgZmxvYXQzMmAgdG8gdGhlIGJ1ZmZlciwgcHJvcGVybHkgYWxpZ25lZCwgYW5kIGdyb3dzIHRoZSBidWZmZXIgKGlmIG5lY2Vzc2FyeSkuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIGBmbG9hdDMyYCB0byBhZGQgdGhlIHRoZSBidWZmZXIuXG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLmFkZEZsb2F0MzIgPSBmdW5jdGlvbih2YWx1ZSkge1xuICB0aGlzLnByZXAoNCwgMCk7XG4gIHRoaXMud3JpdGVGbG9hdDMyKHZhbHVlKTtcbn07XG5cbi8qKlxuICogQWRkIGEgYGZsb2F0NjRgIHRvIHRoZSBidWZmZXIsIHByb3Blcmx5IGFsaWduZWQsIGFuZCBncm93cyB0aGUgYnVmZmVyIChpZiBuZWNlc3NhcnkpLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBgZmxvYXQ2NGAgdG8gYWRkIHRoZSB0aGUgYnVmZmVyLlxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5hZGRGbG9hdDY0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdGhpcy5wcmVwKDgsIDApO1xuICB0aGlzLndyaXRlRmxvYXQ2NCh2YWx1ZSk7XG59O1xuXG4vLy8gQGNvbmQgRkxBVEJVRkZFUlNfSU5URVJOQUxcbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHZvZmZzZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IGRlZmF1bHRWYWx1ZVxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5hZGRGaWVsZEludDggPSBmdW5jdGlvbih2b2Zmc2V0LCB2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICh0aGlzLmZvcmNlX2RlZmF1bHRzIHx8IHZhbHVlICE9IGRlZmF1bHRWYWx1ZSkge1xuICAgIHRoaXMuYWRkSW50OCh2YWx1ZSk7XG4gICAgdGhpcy5zbG90KHZvZmZzZXQpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB2b2Zmc2V0XG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWZhdWx0VmFsdWVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuYWRkRmllbGRJbnQxNiA9IGZ1bmN0aW9uKHZvZmZzZXQsIHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKHRoaXMuZm9yY2VfZGVmYXVsdHMgfHwgdmFsdWUgIT0gZGVmYXVsdFZhbHVlKSB7XG4gICAgdGhpcy5hZGRJbnQxNih2YWx1ZSk7XG4gICAgdGhpcy5zbG90KHZvZmZzZXQpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB2b2Zmc2V0XG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWZhdWx0VmFsdWVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuYWRkRmllbGRJbnQzMiA9IGZ1bmN0aW9uKHZvZmZzZXQsIHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKHRoaXMuZm9yY2VfZGVmYXVsdHMgfHwgdmFsdWUgIT0gZGVmYXVsdFZhbHVlKSB7XG4gICAgdGhpcy5hZGRJbnQzMih2YWx1ZSk7XG4gICAgdGhpcy5zbG90KHZvZmZzZXQpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB2b2Zmc2V0XG4gKiBAcGFyYW0ge2ZsYXRidWZmZXJzLkxvbmd9IHZhbHVlXG4gKiBAcGFyYW0ge2ZsYXRidWZmZXJzLkxvbmd9IGRlZmF1bHRWYWx1ZVxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5hZGRGaWVsZEludDY0ID0gZnVuY3Rpb24odm9mZnNldCwgdmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICBpZiAodGhpcy5mb3JjZV9kZWZhdWx0cyB8fCAhdmFsdWUuZXF1YWxzKGRlZmF1bHRWYWx1ZSkpIHtcbiAgICB0aGlzLmFkZEludDY0KHZhbHVlKTtcbiAgICB0aGlzLnNsb3Qodm9mZnNldCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHZvZmZzZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IGRlZmF1bHRWYWx1ZVxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5hZGRGaWVsZEZsb2F0MzIgPSBmdW5jdGlvbih2b2Zmc2V0LCB2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICh0aGlzLmZvcmNlX2RlZmF1bHRzIHx8IHZhbHVlICE9IGRlZmF1bHRWYWx1ZSkge1xuICAgIHRoaXMuYWRkRmxvYXQzMih2YWx1ZSk7XG4gICAgdGhpcy5zbG90KHZvZmZzZXQpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB2b2Zmc2V0XG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWZhdWx0VmFsdWVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuYWRkRmllbGRGbG9hdDY0ID0gZnVuY3Rpb24odm9mZnNldCwgdmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICBpZiAodGhpcy5mb3JjZV9kZWZhdWx0cyB8fCB2YWx1ZSAhPSBkZWZhdWx0VmFsdWUpIHtcbiAgICB0aGlzLmFkZEZsb2F0NjQodmFsdWUpO1xuICAgIHRoaXMuc2xvdCh2b2Zmc2V0KTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdm9mZnNldFxuICogQHBhcmFtIHtmbGF0YnVmZmVycy5PZmZzZXR9IHZhbHVlXG4gKiBAcGFyYW0ge2ZsYXRidWZmZXJzLk9mZnNldH0gZGVmYXVsdFZhbHVlXG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLmFkZEZpZWxkT2Zmc2V0ID0gZnVuY3Rpb24odm9mZnNldCwgdmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICBpZiAodGhpcy5mb3JjZV9kZWZhdWx0cyB8fCB2YWx1ZSAhPSBkZWZhdWx0VmFsdWUpIHtcbiAgICB0aGlzLmFkZE9mZnNldCh2YWx1ZSk7XG4gICAgdGhpcy5zbG90KHZvZmZzZXQpO1xuICB9XG59O1xuXG4vKipcbiAqIFN0cnVjdHMgYXJlIHN0b3JlZCBpbmxpbmUsIHNvIG5vdGhpbmcgYWRkaXRpb25hbCBpcyBiZWluZyBhZGRlZC4gYGRgIGlzIGFsd2F5cyAwLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB2b2Zmc2V0XG4gKiBAcGFyYW0ge2ZsYXRidWZmZXJzLk9mZnNldH0gdmFsdWVcbiAqIEBwYXJhbSB7ZmxhdGJ1ZmZlcnMuT2Zmc2V0fSBkZWZhdWx0VmFsdWVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuYWRkRmllbGRTdHJ1Y3QgPSBmdW5jdGlvbih2b2Zmc2V0LCB2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICh2YWx1ZSAhPSBkZWZhdWx0VmFsdWUpIHtcbiAgICB0aGlzLm5lc3RlZCh2YWx1ZSk7XG4gICAgdGhpcy5zbG90KHZvZmZzZXQpO1xuICB9XG59O1xuXG4vKipcbiAqIFN0cnVjdHVyZXMgYXJlIGFsd2F5cyBzdG9yZWQgaW5saW5lLCB0aGV5IG5lZWQgdG8gYmUgY3JlYXRlZCByaWdodFxuICogd2hlcmUgdGhleSdyZSB1c2VkLiAgWW91J2xsIGdldCB0aGlzIGFzc2VydGlvbiBmYWlsdXJlIGlmIHlvdVxuICogY3JlYXRlZCBpdCBlbHNld2hlcmUuXG4gKlxuICogQHBhcmFtIHtmbGF0YnVmZmVycy5PZmZzZXR9IG9iaiBUaGUgb2Zmc2V0IG9mIHRoZSBjcmVhdGVkIG9iamVjdFxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5uZXN0ZWQgPSBmdW5jdGlvbihvYmopIHtcbiAgaWYgKG9iaiAhPSB0aGlzLm9mZnNldCgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGbGF0QnVmZmVyczogc3RydWN0IG11c3QgYmUgc2VyaWFsaXplZCBpbmxpbmUuJyk7XG4gIH1cbn07XG5cbi8qKlxuICogU2hvdWxkIG5vdCBiZSBjcmVhdGluZyBhbnkgb3RoZXIgb2JqZWN0LCBzdHJpbmcgb3IgdmVjdG9yXG4gKiB3aGlsZSBhbiBvYmplY3QgaXMgYmVpbmcgY29uc3RydWN0ZWRcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUubm90TmVzdGVkID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmlzTmVzdGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGbGF0QnVmZmVyczogb2JqZWN0IHNlcmlhbGl6YXRpb24gbXVzdCBub3QgYmUgbmVzdGVkLicpO1xuICB9XG59O1xuXG4vKipcbiAqIFNldCB0aGUgY3VycmVudCB2dGFibGUgYXQgYHZvZmZzZXRgIHRvIHRoZSBjdXJyZW50IGxvY2F0aW9uIGluIHRoZSBidWZmZXIuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHZvZmZzZXRcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuc2xvdCA9IGZ1bmN0aW9uKHZvZmZzZXQpIHtcbiAgdGhpcy52dGFibGVbdm9mZnNldF0gPSB0aGlzLm9mZnNldCgpO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7ZmxhdGJ1ZmZlcnMuT2Zmc2V0fSBPZmZzZXQgcmVsYXRpdmUgdG8gdGhlIGVuZCBvZiB0aGUgYnVmZmVyLlxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5vZmZzZXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuYmIuY2FwYWNpdHkoKSAtIHRoaXMuc3BhY2U7XG59O1xuXG4vKipcbiAqIERvdWJsZXMgdGhlIHNpemUgb2YgdGhlIGJhY2tpbmcgQnl0ZUJ1ZmZlciBhbmQgY29waWVzIHRoZSBvbGQgZGF0YSB0b3dhcmRzXG4gKiB0aGUgZW5kIG9mIHRoZSBuZXcgYnVmZmVyIChzaW5jZSB3ZSBidWlsZCB0aGUgYnVmZmVyIGJhY2t3YXJkcykuXG4gKlxuICogQHBhcmFtIHtmbGF0YnVmZmVycy5CeXRlQnVmZmVyfSBiYiBUaGUgY3VycmVudCBidWZmZXIgd2l0aCB0aGUgZXhpc3RpbmcgZGF0YVxuICogQHJldHVybnMgeyFmbGF0YnVmZmVycy5CeXRlQnVmZmVyfSBBIG5ldyBieXRlIGJ1ZmZlciB3aXRoIHRoZSBvbGQgZGF0YSBjb3BpZWRcbiAqIHRvIGl0LiBUaGUgZGF0YSBpcyBsb2NhdGVkIGF0IHRoZSBlbmQgb2YgdGhlIGJ1ZmZlci5cbiAqXG4gKiB1aW50OEFycmF5LnNldCgpIGZvcm1hbGx5IHRha2VzIHtBcnJheTxudW1iZXI+fEFycmF5QnVmZmVyVmlld30sIHNvIHRvIHBhc3NcbiAqIGl0IGEgdWludDhBcnJheSB3ZSBuZWVkIHRvIHN1cHByZXNzIHRoZSB0eXBlIGNoZWNrOlxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfVxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLmdyb3dCeXRlQnVmZmVyID0gZnVuY3Rpb24oYmIpIHtcbiAgdmFyIG9sZF9idWZfc2l6ZSA9IGJiLmNhcGFjaXR5KCk7XG5cbiAgLy8gRW5zdXJlIHdlIGRvbid0IGdyb3cgYmV5b25kIHdoYXQgZml0cyBpbiBhbiBpbnQuXG4gIGlmIChvbGRfYnVmX3NpemUgJiAweEMwMDAwMDAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGbGF0QnVmZmVyczogY2Fubm90IGdyb3cgYnVmZmVyIGJleW9uZCAyIGdpZ2FieXRlcy4nKTtcbiAgfVxuXG4gIHZhciBuZXdfYnVmX3NpemUgPSBvbGRfYnVmX3NpemUgPDwgMTtcbiAgdmFyIG5iYiA9IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIuYWxsb2NhdGUobmV3X2J1Zl9zaXplKTtcbiAgbmJiLnNldFBvc2l0aW9uKG5ld19idWZfc2l6ZSAtIG9sZF9idWZfc2l6ZSk7XG4gIG5iYi5ieXRlcygpLnNldChiYi5ieXRlcygpLCBuZXdfYnVmX3NpemUgLSBvbGRfYnVmX3NpemUpO1xuICByZXR1cm4gbmJiO1xufTtcbi8vLyBAZW5kY29uZFxuXG4vKipcbiAqIEFkZHMgb24gb2Zmc2V0LCByZWxhdGl2ZSB0byB3aGVyZSBpdCB3aWxsIGJlIHdyaXR0ZW4uXG4gKlxuICogQHBhcmFtIHtmbGF0YnVmZmVycy5PZmZzZXR9IG9mZnNldCBUaGUgb2Zmc2V0IHRvIGFkZC5cbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuYWRkT2Zmc2V0ID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG4gIHRoaXMucHJlcChmbGF0YnVmZmVycy5TSVpFT0ZfSU5ULCAwKTsgLy8gRW5zdXJlIGFsaWdubWVudCBpcyBhbHJlYWR5IGRvbmUuXG4gIHRoaXMud3JpdGVJbnQzMih0aGlzLm9mZnNldCgpIC0gb2Zmc2V0ICsgZmxhdGJ1ZmZlcnMuU0laRU9GX0lOVCk7XG59O1xuXG4vLy8gQGNvbmQgRkxBVEJVRkZFUlNfSU5URVJOQUxcbi8qKlxuICogU3RhcnQgZW5jb2RpbmcgYSBuZXcgb2JqZWN0IGluIHRoZSBidWZmZXIuICBVc2VycyB3aWxsIG5vdCB1c3VhbGx5IG5lZWQgdG9cbiAqIGNhbGwgdGhpcyBkaXJlY3RseS4gVGhlIEZsYXRCdWZmZXJzIGNvbXBpbGVyIHdpbGwgZ2VuZXJhdGUgaGVscGVyIG1ldGhvZHNcbiAqIHRoYXQgY2FsbCB0aGlzIG1ldGhvZCBpbnRlcm5hbGx5LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1maWVsZHNcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuc3RhcnRPYmplY3QgPSBmdW5jdGlvbihudW1maWVsZHMpIHtcbiAgdGhpcy5ub3ROZXN0ZWQoKTtcbiAgaWYgKHRoaXMudnRhYmxlID09IG51bGwpIHtcbiAgICB0aGlzLnZ0YWJsZSA9IFtdO1xuICB9XG4gIHRoaXMudnRhYmxlX2luX3VzZSA9IG51bWZpZWxkcztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1maWVsZHM7IGkrKykge1xuICAgIHRoaXMudnRhYmxlW2ldID0gMDsgLy8gVGhpcyB3aWxsIHB1c2ggYWRkaXRpb25hbCBlbGVtZW50cyBhcyBuZWVkZWRcbiAgfVxuICB0aGlzLmlzTmVzdGVkID0gdHJ1ZTtcbiAgdGhpcy5vYmplY3Rfc3RhcnQgPSB0aGlzLm9mZnNldCgpO1xufTtcblxuLyoqXG4gKiBGaW5pc2ggb2ZmIHdyaXRpbmcgdGhlIG9iamVjdCB0aGF0IGlzIHVuZGVyIGNvbnN0cnVjdGlvbi5cbiAqXG4gKiBAcmV0dXJucyB7ZmxhdGJ1ZmZlcnMuT2Zmc2V0fSBUaGUgb2Zmc2V0IHRvIHRoZSBvYmplY3QgaW5zaWRlIGBkYXRhQnVmZmVyYFxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5lbmRPYmplY3QgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMudnRhYmxlID09IG51bGwgfHwgIXRoaXMuaXNOZXN0ZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZsYXRCdWZmZXJzOiBlbmRPYmplY3QgY2FsbGVkIHdpdGhvdXQgc3RhcnRPYmplY3QnKTtcbiAgfVxuXG4gIHRoaXMuYWRkSW50MzIoMCk7XG4gIHZhciB2dGFibGVsb2MgPSB0aGlzLm9mZnNldCgpO1xuXG4gIC8vIFRyaW0gdHJhaWxpbmcgemVyb2VzLlxuICB2YXIgaSA9IHRoaXMudnRhYmxlX2luX3VzZSAtIDE7XG4gIGZvciAoOyBpID49IDAgJiYgdGhpcy52dGFibGVbaV0gPT0gMDsgaS0tKSB7fVxuICB2YXIgdHJpbW1lZF9zaXplID0gaSArIDE7XG5cbiAgLy8gV3JpdGUgb3V0IHRoZSBjdXJyZW50IHZ0YWJsZS5cbiAgZm9yICg7IGkgPj0gMDsgaS0tKSB7XG4gICAgLy8gT2Zmc2V0IHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGUgdGFibGUuXG4gICAgdGhpcy5hZGRJbnQxNih0aGlzLnZ0YWJsZVtpXSAhPSAwID8gdnRhYmxlbG9jIC0gdGhpcy52dGFibGVbaV0gOiAwKTtcbiAgfVxuXG4gIHZhciBzdGFuZGFyZF9maWVsZHMgPSAyOyAvLyBUaGUgZmllbGRzIGJlbG93OlxuICB0aGlzLmFkZEludDE2KHZ0YWJsZWxvYyAtIHRoaXMub2JqZWN0X3N0YXJ0KTtcbiAgdmFyIGxlbiA9ICh0cmltbWVkX3NpemUgKyBzdGFuZGFyZF9maWVsZHMpICogZmxhdGJ1ZmZlcnMuU0laRU9GX1NIT1JUO1xuICB0aGlzLmFkZEludDE2KGxlbik7XG5cbiAgLy8gU2VhcmNoIGZvciBhbiBleGlzdGluZyB2dGFibGUgdGhhdCBtYXRjaGVzIHRoZSBjdXJyZW50IG9uZS5cbiAgdmFyIGV4aXN0aW5nX3Z0YWJsZSA9IDA7XG4gIHZhciB2dDEgPSB0aGlzLnNwYWNlO1xub3V0ZXJfbG9vcDpcbiAgZm9yIChpID0gMDsgaSA8IHRoaXMudnRhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB2dDIgPSB0aGlzLmJiLmNhcGFjaXR5KCkgLSB0aGlzLnZ0YWJsZXNbaV07XG4gICAgaWYgKGxlbiA9PSB0aGlzLmJiLnJlYWRJbnQxNih2dDIpKSB7XG4gICAgICBmb3IgKHZhciBqID0gZmxhdGJ1ZmZlcnMuU0laRU9GX1NIT1JUOyBqIDwgbGVuOyBqICs9IGZsYXRidWZmZXJzLlNJWkVPRl9TSE9SVCkge1xuICAgICAgICBpZiAodGhpcy5iYi5yZWFkSW50MTYodnQxICsgaikgIT0gdGhpcy5iYi5yZWFkSW50MTYodnQyICsgaikpIHtcbiAgICAgICAgICBjb250aW51ZSBvdXRlcl9sb29wO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBleGlzdGluZ192dGFibGUgPSB0aGlzLnZ0YWJsZXNbaV07XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoZXhpc3RpbmdfdnRhYmxlKSB7XG4gICAgLy8gRm91bmQgYSBtYXRjaDpcbiAgICAvLyBSZW1vdmUgdGhlIGN1cnJlbnQgdnRhYmxlLlxuICAgIHRoaXMuc3BhY2UgPSB0aGlzLmJiLmNhcGFjaXR5KCkgLSB2dGFibGVsb2M7XG5cbiAgICAvLyBQb2ludCB0YWJsZSB0byBleGlzdGluZyB2dGFibGUuXG4gICAgdGhpcy5iYi53cml0ZUludDMyKHRoaXMuc3BhY2UsIGV4aXN0aW5nX3Z0YWJsZSAtIHZ0YWJsZWxvYyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTm8gbWF0Y2g6XG4gICAgLy8gQWRkIHRoZSBsb2NhdGlvbiBvZiB0aGUgY3VycmVudCB2dGFibGUgdG8gdGhlIGxpc3Qgb2YgdnRhYmxlcy5cbiAgICB0aGlzLnZ0YWJsZXMucHVzaCh0aGlzLm9mZnNldCgpKTtcblxuICAgIC8vIFBvaW50IHRhYmxlIHRvIGN1cnJlbnQgdnRhYmxlLlxuICAgIHRoaXMuYmIud3JpdGVJbnQzMih0aGlzLmJiLmNhcGFjaXR5KCkgLSB2dGFibGVsb2MsIHRoaXMub2Zmc2V0KCkgLSB2dGFibGVsb2MpO1xuICB9XG5cbiAgdGhpcy5pc05lc3RlZCA9IGZhbHNlO1xuICByZXR1cm4gdnRhYmxlbG9jO1xufTtcbi8vLyBAZW5kY29uZFxuXG4vKipcbiAqIEZpbmFsaXplIGEgYnVmZmVyLCBwb2l0aW5nIHRvIHRoZSBnaXZlbiBgcm9vdF90YWJsZWAuXG4gKlxuICogQHBhcmFtIHtmbGF0YnVmZmVycy5PZmZzZXR9IHJvb3RfdGFibGVcbiAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X2ZpbGVfaWRlbnRpZmllclxuICogQHBhcmFtIHtib29sZWFuPX0gb3B0X3NpemVfcHJlZml4XG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uKHJvb3RfdGFibGUsIG9wdF9maWxlX2lkZW50aWZpZXIsIG9wdF9zaXplX3ByZWZpeCkge1xuICB2YXIgc2l6ZV9wcmVmaXggPSBvcHRfc2l6ZV9wcmVmaXggPyBmbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEggOiAwO1xuICBpZiAob3B0X2ZpbGVfaWRlbnRpZmllcikge1xuICAgIHZhciBmaWxlX2lkZW50aWZpZXIgPSBvcHRfZmlsZV9pZGVudGlmaWVyO1xuICAgIHRoaXMucHJlcCh0aGlzLm1pbmFsaWduLCBmbGF0YnVmZmVycy5TSVpFT0ZfSU5UICtcbiAgICAgIGZsYXRidWZmZXJzLkZJTEVfSURFTlRJRklFUl9MRU5HVEggKyBzaXplX3ByZWZpeCk7XG4gICAgaWYgKGZpbGVfaWRlbnRpZmllci5sZW5ndGggIT0gZmxhdGJ1ZmZlcnMuRklMRV9JREVOVElGSUVSX0xFTkdUSCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGbGF0QnVmZmVyczogZmlsZSBpZGVudGlmaWVyIG11c3QgYmUgbGVuZ3RoICcgK1xuICAgICAgICBmbGF0YnVmZmVycy5GSUxFX0lERU5USUZJRVJfTEVOR1RIKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IGZsYXRidWZmZXJzLkZJTEVfSURFTlRJRklFUl9MRU5HVEggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdGhpcy53cml0ZUludDgoZmlsZV9pZGVudGlmaWVyLmNoYXJDb2RlQXQoaSkpO1xuICAgIH1cbiAgfVxuICB0aGlzLnByZXAodGhpcy5taW5hbGlnbiwgZmxhdGJ1ZmZlcnMuU0laRU9GX0lOVCArIHNpemVfcHJlZml4KTtcbiAgdGhpcy5hZGRPZmZzZXQocm9vdF90YWJsZSk7XG4gIGlmIChzaXplX3ByZWZpeCkge1xuICAgIHRoaXMuYWRkSW50MzIodGhpcy5iYi5jYXBhY2l0eSgpIC0gdGhpcy5zcGFjZSk7XG4gIH1cbiAgdGhpcy5iYi5zZXRQb3NpdGlvbih0aGlzLnNwYWNlKTtcbn07XG5cbi8qKlxuICogRmluYWxpemUgYSBzaXplIHByZWZpeGVkIGJ1ZmZlciwgcG9pbnRpbmcgdG8gdGhlIGdpdmVuIGByb290X3RhYmxlYC5cbiAqXG4gKiBAcGFyYW0ge2ZsYXRidWZmZXJzLk9mZnNldH0gcm9vdF90YWJsZVxuICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfZmlsZV9pZGVudGlmaWVyXG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLmZpbmlzaFNpemVQcmVmaXhlZCA9IGZ1bmN0aW9uIChyb290X3RhYmxlLCBvcHRfZmlsZV9pZGVudGlmaWVyKSB7XG4gIHRoaXMuZmluaXNoKHJvb3RfdGFibGUsIG9wdF9maWxlX2lkZW50aWZpZXIsIHRydWUpO1xufTtcblxuLy8vIEBjb25kIEZMQVRCVUZGRVJTX0lOVEVSTkFMXG4vKipcbiAqIFRoaXMgY2hlY2tzIGEgcmVxdWlyZWQgZmllbGQgaGFzIGJlZW4gc2V0IGluIGEgZ2l2ZW4gdGFibGUgdGhhdCBoYXNcbiAqIGp1c3QgYmVlbiBjb25zdHJ1Y3RlZC5cbiAqXG4gKiBAcGFyYW0ge2ZsYXRidWZmZXJzLk9mZnNldH0gdGFibGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBmaWVsZFxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5yZXF1aXJlZEZpZWxkID0gZnVuY3Rpb24odGFibGUsIGZpZWxkKSB7XG4gIHZhciB0YWJsZV9zdGFydCA9IHRoaXMuYmIuY2FwYWNpdHkoKSAtIHRhYmxlO1xuICB2YXIgdnRhYmxlX3N0YXJ0ID0gdGFibGVfc3RhcnQgLSB0aGlzLmJiLnJlYWRJbnQzMih0YWJsZV9zdGFydCk7XG4gIHZhciBvayA9IHRoaXMuYmIucmVhZEludDE2KHZ0YWJsZV9zdGFydCArIGZpZWxkKSAhPSAwO1xuXG4gIC8vIElmIHRoaXMgZmFpbHMsIHRoZSBjYWxsZXIgd2lsbCBzaG93IHdoYXQgZmllbGQgbmVlZHMgdG8gYmUgc2V0LlxuICBpZiAoIW9rKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGbGF0QnVmZmVyczogZmllbGQgJyArIGZpZWxkICsgJyBtdXN0IGJlIHNldCcpO1xuICB9XG59O1xuXG4vKipcbiAqIFN0YXJ0IGEgbmV3IGFycmF5L3ZlY3RvciBvZiBvYmplY3RzLiAgVXNlcnMgdXN1YWxseSB3aWxsIG5vdCBjYWxsXG4gKiB0aGlzIGRpcmVjdGx5LiBUaGUgRmxhdEJ1ZmZlcnMgY29tcGlsZXIgd2lsbCBjcmVhdGUgYSBzdGFydC9lbmRcbiAqIG1ldGhvZCBmb3IgdmVjdG9yIHR5cGVzIGluIGdlbmVyYXRlZCBjb2RlLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbGVtX3NpemUgVGhlIHNpemUgb2YgZWFjaCBlbGVtZW50IGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtudW1iZXJ9IG51bV9lbGVtcyBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtudW1iZXJ9IGFsaWdubWVudCBUaGUgYWxpZ25tZW50IG9mIHRoZSBhcnJheVxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5zdGFydFZlY3RvciA9IGZ1bmN0aW9uKGVsZW1fc2l6ZSwgbnVtX2VsZW1zLCBhbGlnbm1lbnQpIHtcbiAgdGhpcy5ub3ROZXN0ZWQoKTtcbiAgdGhpcy52ZWN0b3JfbnVtX2VsZW1zID0gbnVtX2VsZW1zO1xuICB0aGlzLnByZXAoZmxhdGJ1ZmZlcnMuU0laRU9GX0lOVCwgZWxlbV9zaXplICogbnVtX2VsZW1zKTtcbiAgdGhpcy5wcmVwKGFsaWdubWVudCwgZWxlbV9zaXplICogbnVtX2VsZW1zKTsgLy8gSnVzdCBpbiBjYXNlIGFsaWdubWVudCA+IGludC5cbn07XG5cbi8qKlxuICogRmluaXNoIG9mZiB0aGUgY3JlYXRpb24gb2YgYW4gYXJyYXkgYW5kIGFsbCBpdHMgZWxlbWVudHMuIFRoZSBhcnJheSBtdXN0IGJlXG4gKiBjcmVhdGVkIHdpdGggYHN0YXJ0VmVjdG9yYC5cbiAqXG4gKiBAcmV0dXJucyB7ZmxhdGJ1ZmZlcnMuT2Zmc2V0fSBUaGUgb2Zmc2V0IGF0IHdoaWNoIHRoZSBuZXdseSBjcmVhdGVkIGFycmF5XG4gKiBzdGFydHMuXG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLmVuZFZlY3RvciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLndyaXRlSW50MzIodGhpcy52ZWN0b3JfbnVtX2VsZW1zKTtcbiAgcmV0dXJuIHRoaXMub2Zmc2V0KCk7XG59O1xuLy8vIEBlbmRjb25kXG5cbi8qKlxuICogRW5jb2RlIHRoZSBzdHJpbmcgYHNgIGluIHRoZSBidWZmZXIgdXNpbmcgVVRGLTguIElmIGEgVWludDhBcnJheSBpcyBwYXNzZWRcbiAqIGluc3RlYWQgb2YgYSBzdHJpbmcsIGl0IGlzIGFzc3VtZWQgdG8gY29udGFpbiB2YWxpZCBVVEYtOCBlbmNvZGVkIGRhdGEuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8VWludDhBcnJheX0gcyBUaGUgc3RyaW5nIHRvIGVuY29kZVxuICogQHJldHVybiB7ZmxhdGJ1ZmZlcnMuT2Zmc2V0fSBUaGUgb2Zmc2V0IGluIHRoZSBidWZmZXIgd2hlcmUgdGhlIGVuY29kZWQgc3RyaW5nIHN0YXJ0c1xuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5jcmVhdGVTdHJpbmcgPSBmdW5jdGlvbihzKSB7XG4gIGlmIChzIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIHZhciB1dGY4ID0gcztcbiAgfSBlbHNlIHtcbiAgICB2YXIgdXRmOCA9IFtdO1xuICAgIHZhciBpID0gMDtcblxuICAgIHdoaWxlIChpIDwgcy5sZW5ndGgpIHtcbiAgICAgIHZhciBjb2RlUG9pbnQ7XG5cbiAgICAgIC8vIERlY29kZSBVVEYtMTZcbiAgICAgIHZhciBhID0gcy5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICBpZiAoYSA8IDB4RDgwMCB8fCBhID49IDB4REMwMCkge1xuICAgICAgICBjb2RlUG9pbnQgPSBhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGIgPSBzLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgY29kZVBvaW50ID0gKGEgPDwgMTApICsgYiArICgweDEwMDAwIC0gKDB4RDgwMCA8PCAxMCkgLSAweERDMDApO1xuICAgICAgfVxuXG4gICAgICAvLyBFbmNvZGUgVVRGLThcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICAgIHV0ZjgucHVzaChjb2RlUG9pbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICAgICAgdXRmOC5wdXNoKCgoY29kZVBvaW50ID4+IDYpICYgMHgxRikgfCAweEMwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgICAgICAgdXRmOC5wdXNoKCgoY29kZVBvaW50ID4+IDEyKSAmIDB4MEYpIHwgMHhFMCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHV0ZjgucHVzaChcbiAgICAgICAgICAgICAgKChjb2RlUG9pbnQgPj4gMTgpICYgMHgwNykgfCAweEYwLFxuICAgICAgICAgICAgICAoKGNvZGVQb2ludCA+PiAxMikgJiAweDNGKSB8IDB4ODApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1dGY4LnB1c2goKChjb2RlUG9pbnQgPj4gNikgJiAweDNGKSB8IDB4ODApO1xuICAgICAgICB9XG4gICAgICAgIHV0ZjgucHVzaCgoY29kZVBvaW50ICYgMHgzRikgfCAweDgwKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0aGlzLmFkZEludDgoMCk7XG4gIHRoaXMuc3RhcnRWZWN0b3IoMSwgdXRmOC5sZW5ndGgsIDEpO1xuICB0aGlzLmJiLnNldFBvc2l0aW9uKHRoaXMuc3BhY2UgLT0gdXRmOC5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMCwgb2Zmc2V0ID0gdGhpcy5zcGFjZSwgYnl0ZXMgPSB0aGlzLmJiLmJ5dGVzKCk7IGkgPCB1dGY4Lmxlbmd0aDsgaSsrKSB7XG4gICAgYnl0ZXNbb2Zmc2V0KytdID0gdXRmOFtpXTtcbiAgfVxuICByZXR1cm4gdGhpcy5lbmRWZWN0b3IoKTtcbn07XG5cbi8qKlxuICogQSBoZWxwZXIgZnVuY3Rpb24gdG8gYXZvaWQgZ2VuZXJhdGVkIGNvZGUgZGVwZW5kaW5nIG9uIHRoaXMgZmlsZSBkaXJlY3RseS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbG93XG4gKiBAcGFyYW0ge251bWJlcn0gaGlnaFxuICogQHJldHVybnMgeyFmbGF0YnVmZmVycy5Mb25nfVxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5jcmVhdGVMb25nID0gZnVuY3Rpb24obG93LCBoaWdoKSB7XG4gIHJldHVybiBmbGF0YnVmZmVycy5Mb25nLmNyZWF0ZShsb3csIGhpZ2gpO1xufTtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8gQGNvbmQgRkxBVEJVRkZFUlNfSU5URVJOQUxcbi8qKlxuICogQ3JlYXRlIGEgbmV3IEJ5dGVCdWZmZXIgd2l0aCBhIGdpdmVuIGFycmF5IG9mIGJ5dGVzIChgVWludDhBcnJheWApLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgLyoqXG4gICAqIEB0eXBlIHtVaW50OEFycmF5fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5ieXRlc18gPSBieXRlcztcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMucG9zaXRpb25fID0gMDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGFuZCBhbGxvY2F0ZSBhIG5ldyBCeXRlQnVmZmVyIHdpdGggYSBnaXZlbiBzaXplLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBieXRlX3NpemVcbiAqIEByZXR1cm5zIHshZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcn1cbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5hbGxvY2F0ZSA9IGZ1bmN0aW9uKGJ5dGVfc2l6ZSkge1xuICByZXR1cm4gbmV3IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIobmV3IFVpbnQ4QXJyYXkoYnl0ZV9zaXplKSk7XG59O1xuXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnBvc2l0aW9uXyA9IDA7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgdW5kZXJseWluZyBgVWludDhBcnJheWAuXG4gKlxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLmJ5dGVzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmJ5dGVzXztcbn07XG5cbi8qKlxuICogR2V0IHRoZSBidWZmZXIncyBwb3NpdGlvbi5cbiAqXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5wb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5wb3NpdGlvbl87XG59O1xuXG4vKipcbiAqIFNldCB0aGUgYnVmZmVyJ3MgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uXG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLnNldFBvc2l0aW9uID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgdGhpcy5wb3NpdGlvbl8gPSBwb3NpdGlvbjtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBidWZmZXIncyBjYXBhY2l0eS5cbiAqXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5jYXBhY2l0eSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5ieXRlc18ubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICByZXR1cm4gdGhpcy5yZWFkVWludDgob2Zmc2V0KSA8PCAyNCA+PiAyNDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQ4ID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG4gIHJldHVybiB0aGlzLmJ5dGVzX1tvZmZzZXRdO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTYgPSBmdW5jdGlvbihvZmZzZXQpIHtcbiAgcmV0dXJuIHRoaXMucmVhZFVpbnQxNihvZmZzZXQpIDw8IDE2ID4+IDE2O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDE2ID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG4gIHJldHVybiB0aGlzLmJ5dGVzX1tvZmZzZXRdIHwgdGhpcy5ieXRlc19bb2Zmc2V0ICsgMV0gPDwgODtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG4gIHJldHVybiB0aGlzLmJ5dGVzX1tvZmZzZXRdIHwgdGhpcy5ieXRlc19bb2Zmc2V0ICsgMV0gPDwgOCB8IHRoaXMuYnl0ZXNfW29mZnNldCArIDJdIDw8IDE2IHwgdGhpcy5ieXRlc19bb2Zmc2V0ICsgM10gPDwgMjQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MzIgPSBmdW5jdGlvbihvZmZzZXQpIHtcbiAgcmV0dXJuIHRoaXMucmVhZEludDMyKG9mZnNldCkgPj4+IDA7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEByZXR1cm5zIHshZmxhdGJ1ZmZlcnMuTG9uZ31cbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5wcm90b3R5cGUucmVhZEludDY0ID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG4gIHJldHVybiBuZXcgZmxhdGJ1ZmZlcnMuTG9uZyh0aGlzLnJlYWRJbnQzMihvZmZzZXQpLCB0aGlzLnJlYWRJbnQzMihvZmZzZXQgKyA0KSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEByZXR1cm5zIHshZmxhdGJ1ZmZlcnMuTG9uZ31cbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQ2NCA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICByZXR1cm4gbmV3IGZsYXRidWZmZXJzLkxvbmcodGhpcy5yZWFkVWludDMyKG9mZnNldCksIHRoaXMucmVhZFVpbnQzMihvZmZzZXQgKyA0KSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdDMyID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG4gIGZsYXRidWZmZXJzLmludDMyWzBdID0gdGhpcy5yZWFkSW50MzIob2Zmc2V0KTtcbiAgcmV0dXJuIGZsYXRidWZmZXJzLmZsb2F0MzJbMF07XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdDY0ID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG4gIGZsYXRidWZmZXJzLmludDMyW2ZsYXRidWZmZXJzLmlzTGl0dGxlRW5kaWFuID8gMCA6IDFdID0gdGhpcy5yZWFkSW50MzIob2Zmc2V0KTtcbiAgZmxhdGJ1ZmZlcnMuaW50MzJbZmxhdGJ1ZmZlcnMuaXNMaXR0bGVFbmRpYW4gPyAxIDogMF0gPSB0aGlzLnJlYWRJbnQzMihvZmZzZXQgKyA0KTtcbiAgcmV0dXJuIGZsYXRidWZmZXJzLmZsb2F0NjRbMF07XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEBwYXJhbSB7bnVtYmVyfGJvb2xlYW59IHZhbHVlXG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uKG9mZnNldCwgdmFsdWUpIHtcbiAgdGhpcy5ieXRlc19bb2Zmc2V0XSA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyh2YWx1ZSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQ4ID0gZnVuY3Rpb24ob2Zmc2V0LCB2YWx1ZSkge1xuICB0aGlzLmJ5dGVzX1tvZmZzZXRdID0gdmFsdWU7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2ID0gZnVuY3Rpb24ob2Zmc2V0LCB2YWx1ZSkge1xuICB0aGlzLmJ5dGVzX1tvZmZzZXRdID0gdmFsdWU7XG4gIHRoaXMuYnl0ZXNfW29mZnNldCArIDFdID0gdmFsdWUgPj4gODtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLndyaXRlVWludDE2ID0gZnVuY3Rpb24ob2Zmc2V0LCB2YWx1ZSkge1xuICAgIHRoaXMuYnl0ZXNfW29mZnNldF0gPSB2YWx1ZTtcbiAgICB0aGlzLmJ5dGVzX1tvZmZzZXQgKyAxXSA9IHZhbHVlID4+IDg7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyID0gZnVuY3Rpb24ob2Zmc2V0LCB2YWx1ZSkge1xuICB0aGlzLmJ5dGVzX1tvZmZzZXRdID0gdmFsdWU7XG4gIHRoaXMuYnl0ZXNfW29mZnNldCArIDFdID0gdmFsdWUgPj4gODtcbiAgdGhpcy5ieXRlc19bb2Zmc2V0ICsgMl0gPSB2YWx1ZSA+PiAxNjtcbiAgdGhpcy5ieXRlc19bb2Zmc2V0ICsgM10gPSB2YWx1ZSA+PiAyNDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLndyaXRlVWludDMyID0gZnVuY3Rpb24ob2Zmc2V0LCB2YWx1ZSkge1xuICAgIHRoaXMuYnl0ZXNfW29mZnNldF0gPSB2YWx1ZTtcbiAgICB0aGlzLmJ5dGVzX1tvZmZzZXQgKyAxXSA9IHZhbHVlID4+IDg7XG4gICAgdGhpcy5ieXRlc19bb2Zmc2V0ICsgMl0gPSB2YWx1ZSA+PiAxNjtcbiAgICB0aGlzLmJ5dGVzX1tvZmZzZXQgKyAzXSA9IHZhbHVlID4+IDI0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcGFyYW0ge2ZsYXRidWZmZXJzLkxvbmd9IHZhbHVlXG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLndyaXRlSW50NjQgPSBmdW5jdGlvbihvZmZzZXQsIHZhbHVlKSB7XG4gIHRoaXMud3JpdGVJbnQzMihvZmZzZXQsIHZhbHVlLmxvdyk7XG4gIHRoaXMud3JpdGVJbnQzMihvZmZzZXQgKyA0LCB2YWx1ZS5oaWdoKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHBhcmFtIHtmbGF0YnVmZmVycy5Mb25nfSB2YWx1ZVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQ2NCA9IGZ1bmN0aW9uKG9mZnNldCwgdmFsdWUpIHtcbiAgICB0aGlzLndyaXRlVWludDMyKG9mZnNldCwgdmFsdWUubG93KTtcbiAgICB0aGlzLndyaXRlVWludDMyKG9mZnNldCArIDQsIHZhbHVlLmhpZ2gpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdDMyID0gZnVuY3Rpb24ob2Zmc2V0LCB2YWx1ZSkge1xuICBmbGF0YnVmZmVycy5mbG9hdDMyWzBdID0gdmFsdWU7XG4gIHRoaXMud3JpdGVJbnQzMihvZmZzZXQsIGZsYXRidWZmZXJzLmludDMyWzBdKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXQ2NCA9IGZ1bmN0aW9uKG9mZnNldCwgdmFsdWUpIHtcbiAgZmxhdGJ1ZmZlcnMuZmxvYXQ2NFswXSA9IHZhbHVlO1xuICB0aGlzLndyaXRlSW50MzIob2Zmc2V0LCBmbGF0YnVmZmVycy5pbnQzMltmbGF0YnVmZmVycy5pc0xpdHRsZUVuZGlhbiA/IDAgOiAxXSk7XG4gIHRoaXMud3JpdGVJbnQzMihvZmZzZXQgKyA0LCBmbGF0YnVmZmVycy5pbnQzMltmbGF0YnVmZmVycy5pc0xpdHRsZUVuZGlhbiA/IDEgOiAwXSk7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgZmlsZSBpZGVudGlmaWVyLiAgIEJlaGF2aW9yIGlzIHVuZGVmaW5lZCBmb3IgRmxhdEJ1ZmZlcnMgd2hvc2VcbiAqIHNjaGVtYSBkb2VzIG5vdCBpbmNsdWRlIGEgZmlsZV9pZGVudGlmaWVyIChsaWtlbHkgcG9pbnRzIGF0IHBhZGRpbmcgb3IgdGhlXG4gKiBzdGFydCBvZiBhIHRoZSByb290IHZ0YWJsZSkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5nZXRCdWZmZXJJZGVudGlmaWVyID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmJ5dGVzXy5sZW5ndGggPCB0aGlzLnBvc2l0aW9uXyArIGZsYXRidWZmZXJzLlNJWkVPRl9JTlQgK1xuICAgICAgZmxhdGJ1ZmZlcnMuRklMRV9JREVOVElGSUVSX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0ZsYXRCdWZmZXJzOiBCeXRlQnVmZmVyIGlzIHRvbyBzaG9ydCB0byBjb250YWluIGFuIGlkZW50aWZpZXIuJyk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFwiXCI7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZmxhdGJ1ZmZlcnMuRklMRV9JREVOVElGSUVSX0xFTkdUSDsgaSsrKSB7XG4gICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoXG4gICAgICAgIHRoaXMucmVhZEludDgodGhpcy5wb3NpdGlvbl8gKyBmbGF0YnVmZmVycy5TSVpFT0ZfSU5UICsgaSkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIExvb2sgdXAgYSBmaWVsZCBpbiB0aGUgdnRhYmxlLCByZXR1cm4gYW4gb2Zmc2V0IGludG8gdGhlIG9iamVjdCwgb3IgMCBpZiB0aGVcbiAqIGZpZWxkIGlzIG5vdCBwcmVzZW50LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBiYl9wb3NcbiAqIEBwYXJhbSB7bnVtYmVyfSB2dGFibGVfb2Zmc2V0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5fX29mZnNldCA9IGZ1bmN0aW9uKGJiX3BvcywgdnRhYmxlX29mZnNldCkge1xuICB2YXIgdnRhYmxlID0gYmJfcG9zIC0gdGhpcy5yZWFkSW50MzIoYmJfcG9zKTtcbiAgcmV0dXJuIHZ0YWJsZV9vZmZzZXQgPCB0aGlzLnJlYWRJbnQxNih2dGFibGUpID8gdGhpcy5yZWFkSW50MTYodnRhYmxlICsgdnRhYmxlX29mZnNldCkgOiAwO1xufTtcblxuLyoqXG4gKiBJbml0aWFsaXplIGFueSBUYWJsZS1kZXJpdmVkIHR5cGUgdG8gcG9pbnQgdG8gdGhlIHVuaW9uIGF0IHRoZSBnaXZlbiBvZmZzZXQuXG4gKlxuICogQHBhcmFtIHtmbGF0YnVmZmVycy5UYWJsZX0gdFxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHJldHVybnMge2ZsYXRidWZmZXJzLlRhYmxlfVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5fX3VuaW9uID0gZnVuY3Rpb24odCwgb2Zmc2V0KSB7XG4gIHQuYmJfcG9zID0gb2Zmc2V0ICsgdGhpcy5yZWFkSW50MzIob2Zmc2V0KTtcbiAgdC5iYiA9IHRoaXM7XG4gIHJldHVybiB0O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBKYXZhU2NyaXB0IHN0cmluZyBmcm9tIFVURi04IGRhdGEgc3RvcmVkIGluc2lkZSB0aGUgRmxhdEJ1ZmZlci5cbiAqIFRoaXMgYWxsb2NhdGVzIGEgbmV3IHN0cmluZyBhbmQgY29udmVydHMgdG8gd2lkZSBjaGFycyB1cG9uIGVhY2ggYWNjZXNzLlxuICpcbiAqIFRvIGF2b2lkIHRoZSBjb252ZXJzaW9uIHRvIFVURi0xNiwgcGFzcyBmbGF0YnVmZmVycy5FbmNvZGluZy5VVEY4X0JZVEVTIGFzXG4gKiB0aGUgXCJvcHRpb25hbEVuY29kaW5nXCIgYXJndW1lbnQuIFRoaXMgaXMgdXNlZnVsIGZvciBhdm9pZGluZyBjb252ZXJzaW9uIHRvXG4gKiBhbmQgZnJvbSBVVEYtMTYgd2hlbiB0aGUgZGF0YSB3aWxsIGp1c3QgYmUgcGFja2FnZWQgYmFjayB1cCBpbiBhbm90aGVyXG4gKiBGbGF0QnVmZmVyIGxhdGVyIG9uLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEBwYXJhbSB7ZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9fSBvcHRfZW5jb2RpbmcgRGVmYXVsdHMgdG8gVVRGMTZfU1RSSU5HXG4gKiBAcmV0dXJucyB7c3RyaW5nfCFVaW50OEFycmF5fVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5fX3N0cmluZyA9IGZ1bmN0aW9uKG9mZnNldCwgb3B0X2VuY29kaW5nKSB7XG4gIG9mZnNldCArPSB0aGlzLnJlYWRJbnQzMihvZmZzZXQpO1xuXG4gIHZhciBsZW5ndGggPSB0aGlzLnJlYWRJbnQzMihvZmZzZXQpO1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIHZhciBpID0gMDtcblxuICBvZmZzZXQgKz0gZmxhdGJ1ZmZlcnMuU0laRU9GX0lOVDtcblxuICBpZiAob3B0X2VuY29kaW5nID09PSBmbGF0YnVmZmVycy5FbmNvZGluZy5VVEY4X0JZVEVTKSB7XG4gICAgcmV0dXJuIHRoaXMuYnl0ZXNfLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgbGVuZ3RoKTtcbiAgfVxuXG4gIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgdmFyIGNvZGVQb2ludDtcblxuICAgIC8vIERlY29kZSBVVEYtOFxuICAgIHZhciBhID0gdGhpcy5yZWFkVWludDgob2Zmc2V0ICsgaSsrKTtcbiAgICBpZiAoYSA8IDB4QzApIHtcbiAgICAgIGNvZGVQb2ludCA9IGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBiID0gdGhpcy5yZWFkVWludDgob2Zmc2V0ICsgaSsrKTtcbiAgICAgIGlmIChhIDwgMHhFMCkge1xuICAgICAgICBjb2RlUG9pbnQgPVxuICAgICAgICAgICgoYSAmIDB4MUYpIDw8IDYpIHxcbiAgICAgICAgICAoYiAmIDB4M0YpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLnJlYWRVaW50OChvZmZzZXQgKyBpKyspO1xuICAgICAgICBpZiAoYSA8IDB4RjApIHtcbiAgICAgICAgICBjb2RlUG9pbnQgPVxuICAgICAgICAgICAgKChhICYgMHgwRikgPDwgMTIpIHxcbiAgICAgICAgICAgICgoYiAmIDB4M0YpIDw8IDYpIHxcbiAgICAgICAgICAgIChjICYgMHgzRik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGQgPSB0aGlzLnJlYWRVaW50OChvZmZzZXQgKyBpKyspO1xuICAgICAgICAgIGNvZGVQb2ludCA9XG4gICAgICAgICAgICAoKGEgJiAweDA3KSA8PCAxOCkgfFxuICAgICAgICAgICAgKChiICYgMHgzRikgPDwgMTIpIHxcbiAgICAgICAgICAgICgoYyAmIDB4M0YpIDw8IDYpIHxcbiAgICAgICAgICAgIChkICYgMHgzRik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFbmNvZGUgVVRGLTE2XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwO1xuICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoXG4gICAgICAgIChjb2RlUG9pbnQgPj4gMTApICsgMHhEODAwLFxuICAgICAgICAoY29kZVBvaW50ICYgKCgxIDw8IDEwKSAtIDEpKSArIDB4REMwMCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIHJlbGF0aXZlIG9mZnNldCBzdG9yZWQgYXQgXCJvZmZzZXRcIlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5wcm90b3R5cGUuX19pbmRpcmVjdCA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICByZXR1cm4gb2Zmc2V0ICsgdGhpcy5yZWFkSW50MzIob2Zmc2V0KTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBzdGFydCBvZiBkYXRhIG9mIGEgdmVjdG9yIHdob3NlIG9mZnNldCBpcyBzdG9yZWQgYXQgXCJvZmZzZXRcIiBpbiB0aGlzIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5fX3ZlY3RvciA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICByZXR1cm4gb2Zmc2V0ICsgdGhpcy5yZWFkSW50MzIob2Zmc2V0KSArIGZsYXRidWZmZXJzLlNJWkVPRl9JTlQ7IC8vIGRhdGEgc3RhcnRzIGFmdGVyIHRoZSBsZW5ndGhcbn07XG5cbi8qKlxuICogR2V0IHRoZSBsZW5ndGggb2YgYSB2ZWN0b3Igd2hvc2Ugb2Zmc2V0IGlzIHN0b3JlZCBhdCBcIm9mZnNldFwiIGluIHRoaXMgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLl9fdmVjdG9yX2xlbiA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICByZXR1cm4gdGhpcy5yZWFkSW50MzIob2Zmc2V0ICsgdGhpcy5yZWFkSW50MzIob2Zmc2V0KSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZGVudFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLl9faGFzX2lkZW50aWZpZXIgPSBmdW5jdGlvbihpZGVudCkge1xuICBpZiAoaWRlbnQubGVuZ3RoICE9IGZsYXRidWZmZXJzLkZJTEVfSURFTlRJRklFUl9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZsYXRCdWZmZXJzOiBmaWxlIGlkZW50aWZpZXIgbXVzdCBiZSBsZW5ndGggJyArXG4gICAgICAgICAgICAgICAgICAgIGZsYXRidWZmZXJzLkZJTEVfSURFTlRJRklFUl9MRU5HVEgpO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZmxhdGJ1ZmZlcnMuRklMRV9JREVOVElGSUVSX0xFTkdUSDsgaSsrKSB7XG4gICAgaWYgKGlkZW50LmNoYXJDb2RlQXQoaSkgIT0gdGhpcy5yZWFkSW50OCh0aGlzLnBvc2l0aW9uXyArIGZsYXRidWZmZXJzLlNJWkVPRl9JTlQgKyBpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQSBoZWxwZXIgZnVuY3Rpb24gdG8gYXZvaWQgZ2VuZXJhdGVkIGNvZGUgZGVwZW5kaW5nIG9uIHRoaXMgZmlsZSBkaXJlY3RseS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbG93XG4gKiBAcGFyYW0ge251bWJlcn0gaGlnaFxuICogQHJldHVybnMgeyFmbGF0YnVmZmVycy5Mb25nfVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5jcmVhdGVMb25nID0gZnVuY3Rpb24obG93LCBoaWdoKSB7XG4gIHJldHVybiBmbGF0YnVmZmVycy5Mb25nLmNyZWF0ZShsb3csIGhpZ2gpO1xufTtcblxuLy8gRXhwb3J0cyBmb3IgTm9kZS5qcyBhbmQgUmVxdWlyZUpTXG5leHBvcnQgeyBmbGF0YnVmZmVycyB9O1xuXG4vLy8gQGVuZGNvbmRcbi8vLyBAfVxuIiwgIi8vIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGJ5IHRoZSBGbGF0QnVmZmVycyBjb21waWxlciwgZG8gbm90IG1vZGlmeVxuLyogZXNsaW50LWRpc2FibGUgKi9cblxuaW1wb3J0IHsgZmxhdGJ1ZmZlcnMgfSBmcm9tICdmbGF0YnVmZmVycyc7XG5cbi8qKlxuICogQGVudW0ge251bWJlcn1cbiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzIHtcbiAgZXhwb3J0IGVudW0gQXR0cmlidXRlVHlwZSB7XG4gICAgVU5ERUZJTkVEID0gMCxcbiAgICBGTE9BVCA9IDEsXG4gICAgSU5UID0gMixcbiAgICBTVFJJTkcgPSAzLFxuICAgIFRFTlNPUiA9IDQsXG4gICAgR1JBUEggPSA1LFxuICAgIEZMT0FUUyA9IDYsXG4gICAgSU5UUyA9IDcsXG4gICAgU1RSSU5HUyA9IDgsXG4gICAgVEVOU09SUyA9IDksXG4gICAgR1JBUEhTID0gMTAsXG4gICAgU1BBUlNFX1RFTlNPUiA9IDExLFxuICAgIFNQQVJTRV9URU5TT1JTID0gMTIsXG4gIH1cbn1cblxuLyoqXG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgZW51bSBEaW1lbnNpb25WYWx1ZVR5cGUge1xuICAgIFVOS05PV04gPSAwLFxuICAgIFZBTFVFID0gMSxcbiAgICBQQVJBTSA9IDIsXG4gIH1cbn1cblxuLyoqXG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgZW51bSBUZW5zb3JEYXRhVHlwZSB7XG4gICAgVU5ERUZJTkVEID0gMCxcbiAgICBGTE9BVCA9IDEsXG4gICAgVUlOVDggPSAyLFxuICAgIElOVDggPSAzLFxuICAgIFVJTlQxNiA9IDQsXG4gICAgSU5UMTYgPSA1LFxuICAgIElOVDMyID0gNixcbiAgICBJTlQ2NCA9IDcsXG4gICAgU1RSSU5HID0gOCxcbiAgICBCT09MID0gOSxcbiAgICBGTE9BVDE2ID0gMTAsXG4gICAgRE9VQkxFID0gMTEsXG4gICAgVUlOVDMyID0gMTIsXG4gICAgVUlOVDY0ID0gMTMsXG4gICAgQ09NUExFWDY0ID0gMTQsXG4gICAgQ09NUExFWDEyOCA9IDE1LFxuICAgIEJGTE9BVDE2ID0gMTYsXG4gICAgRkxPQVQ4RTRNM0ZOID0gMTcsXG4gICAgRkxPQVQ4RTRNM0ZOVVogPSAxOCxcbiAgICBGTE9BVDhFNU0yID0gMTksXG4gICAgRkxPQVQ4RTVNMkZOVVogPSAyMCxcbiAgfVxufVxuXG4vKipcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBuYW1lc3BhY2Ugb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicyB7XG4gIGV4cG9ydCBlbnVtIE5vZGVUeXBlIHtcbiAgICBQcmltaXRpdmUgPSAwLFxuICAgIEZ1c2VkID0gMSxcbiAgfVxufVxuXG4vKipcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBuYW1lc3BhY2Ugb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicyB7XG4gIGV4cG9ydCBlbnVtIFR5cGVJbmZvVmFsdWUge1xuICAgIE5PTkUgPSAwLFxuICAgIHRlbnNvcl90eXBlID0gMSxcbiAgICBzZXF1ZW5jZV90eXBlID0gMixcbiAgICBtYXBfdHlwZSA9IDMsXG4gIH1cbn1cblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzIHtcbiAgZXhwb3J0IGNsYXNzIFNoYXBlIHtcbiAgICBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciB8IG51bGwgPSBudWxsO1xuXG4gICAgYmJfcG9zID0gMDtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGlcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEByZXR1cm5zIFNoYXBlXG4gICAgICovXG4gICAgX19pbml0KGk6IG51bWJlciwgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIpOiBTaGFwZSB7XG4gICAgICB0aGlzLmJiX3BvcyA9IGk7XG4gICAgICB0aGlzLmJiID0gYmI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBTaGFwZT0gb2JqXG4gICAgICogQHJldHVybnMgU2hhcGVcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Um9vdEFzU2hhcGUoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IFNoYXBlKTogU2hhcGUge1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IFNoYXBlKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gU2hhcGU9IG9ialxuICAgICAqIEByZXR1cm5zIFNoYXBlXG4gICAgICovXG4gICAgc3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc1NoYXBlKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBTaGFwZSk6IFNoYXBlIHtcbiAgICAgIGJiLnNldFBvc2l0aW9uKGJiLnBvc2l0aW9uKCkgKyBmbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpO1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IFNoYXBlKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpbmRleFxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkRpbWVuc2lvbj0gb2JqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5EaW1lbnNpb25cbiAgICAgKi9cbiAgICBkaW0oaW5kZXg6IG51bWJlciwgb2JqPzogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5EaW1lbnNpb24pOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkRpbWVuc2lvbiB8IG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgIHJldHVybiBvZmZzZXRcbiAgICAgICAgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkRpbWVuc2lvbigpKS5fX2luaXQoXG4gICAgICAgICAgICB0aGlzLmJiIS5fX2luZGlyZWN0KHRoaXMuYmIhLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSArIGluZGV4ICogNCksXG4gICAgICAgICAgICB0aGlzLmJiISxcbiAgICAgICAgICApXG4gICAgICAgIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBkaW1MZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydFNoYXBlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRPYmplY3QoMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgZGltT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZERpbShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkaW1PZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgwLCBkaW1PZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gQXJyYXkuPGZsYXRidWZmZXJzLk9mZnNldD4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVEaW1WZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogZmxhdGJ1ZmZlcnMuT2Zmc2V0W10pOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBkYXRhLmxlbmd0aCwgNCk7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBidWlsZGVyLmFkZE9mZnNldChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0RGltVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgbnVtRWxlbXMsIDQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZW5kU2hhcGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcik6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gYnVpbGRlci5lbmRPYmplY3QoKTtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZVNoYXBlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRpbU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIFNoYXBlLnN0YXJ0U2hhcGUoYnVpbGRlcik7XG4gICAgICBTaGFwZS5hZGREaW0oYnVpbGRlciwgZGltT2Zmc2V0KTtcbiAgICAgIHJldHVybiBTaGFwZS5lbmRTaGFwZShidWlsZGVyKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBuYW1lc3BhY2Ugb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicyB7XG4gIGV4cG9ydCBjbGFzcyBEaW1lbnNpb24ge1xuICAgIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIHwgbnVsbCA9IG51bGw7XG5cbiAgICBiYl9wb3MgPSAwO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaVxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHJldHVybnMgRGltZW5zaW9uXG4gICAgICovXG4gICAgX19pbml0KGk6IG51bWJlciwgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIpOiBEaW1lbnNpb24ge1xuICAgICAgdGhpcy5iYl9wb3MgPSBpO1xuICAgICAgdGhpcy5iYiA9IGJiO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gRGltZW5zaW9uPSBvYmpcbiAgICAgKiBAcmV0dXJucyBEaW1lbnNpb25cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Um9vdEFzRGltZW5zaW9uKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBEaW1lbnNpb24pOiBEaW1lbnNpb24ge1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IERpbWVuc2lvbigpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIERpbWVuc2lvbj0gb2JqXG4gICAgICogQHJldHVybnMgRGltZW5zaW9uXG4gICAgICovXG4gICAgc3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc0RpbWVuc2lvbihiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogRGltZW5zaW9uKTogRGltZW5zaW9uIHtcbiAgICAgIGJiLnNldFBvc2l0aW9uKGJiLnBvc2l0aW9uKCkgKyBmbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpO1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IERpbWVuc2lvbigpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkRpbWVuc2lvblZhbHVlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkRpbWVuc2lvblZhbHVlfG51bGxcbiAgICAgKi9cbiAgICB2YWx1ZShvYmo/OiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkRpbWVuc2lvblZhbHVlKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5EaW1lbnNpb25WYWx1ZSB8IG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgIHJldHVybiBvZmZzZXRcbiAgICAgICAgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkRpbWVuc2lvblZhbHVlKCkpLl9faW5pdChcbiAgICAgICAgICAgIHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYl9wb3MgKyBvZmZzZXQpLFxuICAgICAgICAgICAgdGhpcy5iYiEsXG4gICAgICAgICAgKVxuICAgICAgICA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbFxuICAgICAqL1xuICAgIGRlbm90YXRpb24oKTogc3RyaW5nIHwgbnVsbDtcbiAgICBkZW5vdGF0aW9uKG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nIHwgVWludDhBcnJheSB8IG51bGw7XG4gICAgZGVub3RhdGlvbihvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nIHwgVWludDhBcnJheSB8IG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiX3BvcyArIG9mZnNldCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnREaW1lbnNpb24oYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcikge1xuICAgICAgYnVpbGRlci5zdGFydE9iamVjdCgyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCB2YWx1ZU9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRWYWx1ZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCB2YWx1ZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDAsIHZhbHVlT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBkZW5vdGF0aW9uT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZERlbm90YXRpb24oYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGVub3RhdGlvbk9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDEsIGRlbm90YXRpb25PZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZW5kRGltZW5zaW9uKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgbGV0IG9mZnNldCA9IGJ1aWxkZXIuZW5kT2JqZWN0KCk7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGVEaW1lbnNpb24oXG4gICAgICBidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLFxuICAgICAgdmFsdWVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgIGRlbm90YXRpb25PZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICApOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgRGltZW5zaW9uLnN0YXJ0RGltZW5zaW9uKGJ1aWxkZXIpO1xuICAgICAgRGltZW5zaW9uLmFkZFZhbHVlKGJ1aWxkZXIsIHZhbHVlT2Zmc2V0KTtcbiAgICAgIERpbWVuc2lvbi5hZGREZW5vdGF0aW9uKGJ1aWxkZXIsIGRlbm90YXRpb25PZmZzZXQpO1xuICAgICAgcmV0dXJuIERpbWVuc2lvbi5lbmREaW1lbnNpb24oYnVpbGRlcik7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgY2xhc3MgRGltZW5zaW9uVmFsdWUge1xuICAgIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIHwgbnVsbCA9IG51bGw7XG5cbiAgICBiYl9wb3MgPSAwO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaVxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHJldHVybnMgRGltZW5zaW9uVmFsdWVcbiAgICAgKi9cbiAgICBfX2luaXQoaTogbnVtYmVyLCBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcik6IERpbWVuc2lvblZhbHVlIHtcbiAgICAgIHRoaXMuYmJfcG9zID0gaTtcbiAgICAgIHRoaXMuYmIgPSBiYjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIERpbWVuc2lvblZhbHVlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBEaW1lbnNpb25WYWx1ZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRSb290QXNEaW1lbnNpb25WYWx1ZShiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogRGltZW5zaW9uVmFsdWUpOiBEaW1lbnNpb25WYWx1ZSB7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgRGltZW5zaW9uVmFsdWUoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBEaW1lbnNpb25WYWx1ZT0gb2JqXG4gICAgICogQHJldHVybnMgRGltZW5zaW9uVmFsdWVcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzRGltZW5zaW9uVmFsdWUoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IERpbWVuc2lvblZhbHVlKTogRGltZW5zaW9uVmFsdWUge1xuICAgICAgYmIuc2V0UG9zaXRpb24oYmIucG9zaXRpb24oKSArIGZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCk7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgRGltZW5zaW9uVmFsdWUoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkRpbWVuc2lvblZhbHVlVHlwZVxuICAgICAqL1xuICAgIGRpbVR5cGUoKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5EaW1lbnNpb25WYWx1ZVR5cGUge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgIHJldHVybiBvZmZzZXRcbiAgICAgICAgPyAvKiogICovIHRoaXMuYmIhLnJlYWRJbnQ4KHRoaXMuYmJfcG9zICsgb2Zmc2V0KVxuICAgICAgICA6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuRGltZW5zaW9uVmFsdWVUeXBlLlVOS05PV047XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuTG9uZ1xuICAgICAqL1xuICAgIGRpbVZhbHVlKCk6IGZsYXRidWZmZXJzLkxvbmcge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5yZWFkSW50NjQodGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogdGhpcy5iYiEuY3JlYXRlTG9uZygwLCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheXxudWxsXG4gICAgICovXG4gICAgZGltUGFyYW0oKTogc3RyaW5nIHwgbnVsbDtcbiAgICBkaW1QYXJhbShvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZyB8IFVpbnQ4QXJyYXkgfCBudWxsO1xuICAgIGRpbVBhcmFtKG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmcgfCBVaW50OEFycmF5IHwgbnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDgpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmJfcG9zICsgb2Zmc2V0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydERpbWVuc2lvblZhbHVlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRPYmplY3QoMyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkRpbWVuc2lvblZhbHVlVHlwZSBkaW1UeXBlXG4gICAgICovXG4gICAgc3RhdGljIGFkZERpbVR5cGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGltVHlwZTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5EaW1lbnNpb25WYWx1ZVR5cGUpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRJbnQ4KDAsIGRpbVR5cGUsIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuRGltZW5zaW9uVmFsdWVUeXBlLlVOS05PV04pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuTG9uZyBkaW1WYWx1ZVxuICAgICAqL1xuICAgIHN0YXRpYyBhZGREaW1WYWx1ZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkaW1WYWx1ZTogZmxhdGJ1ZmZlcnMuTG9uZykge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZEludDY0KDEsIGRpbVZhbHVlLCBidWlsZGVyLmNyZWF0ZUxvbmcoMCwgMCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGRpbVBhcmFtT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZERpbVBhcmFtKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRpbVBhcmFtT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMiwgZGltUGFyYW1PZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZW5kRGltZW5zaW9uVmFsdWUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcik6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gYnVpbGRlci5lbmRPYmplY3QoKTtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZURpbWVuc2lvblZhbHVlKFxuICAgICAgYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcixcbiAgICAgIGRpbVR5cGU6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuRGltZW5zaW9uVmFsdWVUeXBlLFxuICAgICAgZGltVmFsdWU6IGZsYXRidWZmZXJzLkxvbmcsXG4gICAgICBkaW1QYXJhbU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBEaW1lbnNpb25WYWx1ZS5zdGFydERpbWVuc2lvblZhbHVlKGJ1aWxkZXIpO1xuICAgICAgRGltZW5zaW9uVmFsdWUuYWRkRGltVHlwZShidWlsZGVyLCBkaW1UeXBlKTtcbiAgICAgIERpbWVuc2lvblZhbHVlLmFkZERpbVZhbHVlKGJ1aWxkZXIsIGRpbVZhbHVlKTtcbiAgICAgIERpbWVuc2lvblZhbHVlLmFkZERpbVBhcmFtKGJ1aWxkZXIsIGRpbVBhcmFtT2Zmc2V0KTtcbiAgICAgIHJldHVybiBEaW1lbnNpb25WYWx1ZS5lbmREaW1lbnNpb25WYWx1ZShidWlsZGVyKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBuYW1lc3BhY2Ugb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicyB7XG4gIGV4cG9ydCBjbGFzcyBUZW5zb3JUeXBlQW5kU2hhcGUge1xuICAgIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIHwgbnVsbCA9IG51bGw7XG5cbiAgICBiYl9wb3MgPSAwO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaVxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHJldHVybnMgVGVuc29yVHlwZUFuZFNoYXBlXG4gICAgICovXG4gICAgX19pbml0KGk6IG51bWJlciwgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIpOiBUZW5zb3JUeXBlQW5kU2hhcGUge1xuICAgICAgdGhpcy5iYl9wb3MgPSBpO1xuICAgICAgdGhpcy5iYiA9IGJiO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gVGVuc29yVHlwZUFuZFNoYXBlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBUZW5zb3JUeXBlQW5kU2hhcGVcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Um9vdEFzVGVuc29yVHlwZUFuZFNoYXBlKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBUZW5zb3JUeXBlQW5kU2hhcGUpOiBUZW5zb3JUeXBlQW5kU2hhcGUge1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IFRlbnNvclR5cGVBbmRTaGFwZSgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIFRlbnNvclR5cGVBbmRTaGFwZT0gb2JqXG4gICAgICogQHJldHVybnMgVGVuc29yVHlwZUFuZFNoYXBlXG4gICAgICovXG4gICAgc3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc1RlbnNvclR5cGVBbmRTaGFwZShcbiAgICAgIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLFxuICAgICAgb2JqPzogVGVuc29yVHlwZUFuZFNoYXBlLFxuICAgICk6IFRlbnNvclR5cGVBbmRTaGFwZSB7XG4gICAgICBiYi5zZXRQb3NpdGlvbihiYi5wb3NpdGlvbigpICsgZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKTtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBUZW5zb3JUeXBlQW5kU2hhcGUoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvckRhdGFUeXBlXG4gICAgICovXG4gICAgZWxlbVR5cGUoKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZSB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDQpO1xuICAgICAgcmV0dXJuIG9mZnNldFxuICAgICAgICA/IC8qKiAgKi8gdGhpcy5iYiEucmVhZEludDMyKHRoaXMuYmJfcG9zICsgb2Zmc2V0KVxuICAgICAgICA6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGUuVU5ERUZJTkVEO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlNoYXBlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlNoYXBlfG51bGxcbiAgICAgKi9cbiAgICBzaGFwZShvYmo/OiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlNoYXBlKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5TaGFwZSB8IG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgIHJldHVybiBvZmZzZXRcbiAgICAgICAgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlNoYXBlKCkpLl9faW5pdCh0aGlzLmJiIS5fX2luZGlyZWN0KHRoaXMuYmJfcG9zICsgb2Zmc2V0KSwgdGhpcy5iYiEpXG4gICAgICAgIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0VGVuc29yVHlwZUFuZFNoYXBlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRPYmplY3QoMik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvckRhdGFUeXBlIGVsZW1UeXBlXG4gICAgICovXG4gICAgc3RhdGljIGFkZEVsZW1UeXBlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGVsZW1UeXBlOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvckRhdGFUeXBlKSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkSW50MzIoMCwgZWxlbVR5cGUsIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGUuVU5ERUZJTkVEKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBzaGFwZU9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRTaGFwZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBzaGFwZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDEsIHNoYXBlT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGVuZFRlbnNvclR5cGVBbmRTaGFwZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGxldCBvZmZzZXQgPSBidWlsZGVyLmVuZE9iamVjdCgpO1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlVGVuc29yVHlwZUFuZFNoYXBlKFxuICAgICAgYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcixcbiAgICAgIGVsZW1UeXBlOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvckRhdGFUeXBlLFxuICAgICAgc2hhcGVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICApOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgVGVuc29yVHlwZUFuZFNoYXBlLnN0YXJ0VGVuc29yVHlwZUFuZFNoYXBlKGJ1aWxkZXIpO1xuICAgICAgVGVuc29yVHlwZUFuZFNoYXBlLmFkZEVsZW1UeXBlKGJ1aWxkZXIsIGVsZW1UeXBlKTtcbiAgICAgIFRlbnNvclR5cGVBbmRTaGFwZS5hZGRTaGFwZShidWlsZGVyLCBzaGFwZU9mZnNldCk7XG4gICAgICByZXR1cm4gVGVuc29yVHlwZUFuZFNoYXBlLmVuZFRlbnNvclR5cGVBbmRTaGFwZShidWlsZGVyKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBuYW1lc3BhY2Ugb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicyB7XG4gIGV4cG9ydCBjbGFzcyBNYXBUeXBlIHtcbiAgICBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciB8IG51bGwgPSBudWxsO1xuXG4gICAgYmJfcG9zID0gMDtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGlcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEByZXR1cm5zIE1hcFR5cGVcbiAgICAgKi9cbiAgICBfX2luaXQoaTogbnVtYmVyLCBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcik6IE1hcFR5cGUge1xuICAgICAgdGhpcy5iYl9wb3MgPSBpO1xuICAgICAgdGhpcy5iYiA9IGJiO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gTWFwVHlwZT0gb2JqXG4gICAgICogQHJldHVybnMgTWFwVHlwZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRSb290QXNNYXBUeXBlKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBNYXBUeXBlKTogTWFwVHlwZSB7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgTWFwVHlwZSgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIE1hcFR5cGU9IG9ialxuICAgICAqIEByZXR1cm5zIE1hcFR5cGVcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzTWFwVHlwZShiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogTWFwVHlwZSk6IE1hcFR5cGUge1xuICAgICAgYmIuc2V0UG9zaXRpb24oYmIucG9zaXRpb24oKSArIGZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCk7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgTWFwVHlwZSgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGVcbiAgICAgKi9cbiAgICBrZXlUeXBlKCk6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGUge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgIHJldHVybiBvZmZzZXRcbiAgICAgICAgPyAvKiogICovIHRoaXMuYmIhLnJlYWRJbnQzMih0aGlzLmJiX3BvcyArIG9mZnNldClcbiAgICAgICAgOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvckRhdGFUeXBlLlVOREVGSU5FRDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UeXBlSW5mbz0gb2JqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UeXBlSW5mb3xudWxsXG4gICAgICovXG4gICAgdmFsdWVUeXBlKG9iaj86IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVHlwZUluZm8pOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvIHwgbnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDYpO1xuICAgICAgcmV0dXJuIG9mZnNldFxuICAgICAgICA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVHlwZUluZm8oKSkuX19pbml0KFxuICAgICAgICAgICAgdGhpcy5iYiEuX19pbmRpcmVjdCh0aGlzLmJiX3BvcyArIG9mZnNldCksXG4gICAgICAgICAgICB0aGlzLmJiISxcbiAgICAgICAgICApXG4gICAgICAgIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0TWFwVHlwZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0T2JqZWN0KDIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZSBrZXlUeXBlXG4gICAgICovXG4gICAgc3RhdGljIGFkZEtleVR5cGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwga2V5VHlwZTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZSkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZEludDMyKDAsIGtleVR5cGUsIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGUuVU5ERUZJTkVEKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCB2YWx1ZVR5cGVPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkVmFsdWVUeXBlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIHZhbHVlVHlwZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDEsIHZhbHVlVHlwZU9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBlbmRNYXBUeXBlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgbGV0IG9mZnNldCA9IGJ1aWxkZXIuZW5kT2JqZWN0KCk7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGVNYXBUeXBlKFxuICAgICAgYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcixcbiAgICAgIGtleVR5cGU6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGUsXG4gICAgICB2YWx1ZVR5cGVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICApOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgTWFwVHlwZS5zdGFydE1hcFR5cGUoYnVpbGRlcik7XG4gICAgICBNYXBUeXBlLmFkZEtleVR5cGUoYnVpbGRlciwga2V5VHlwZSk7XG4gICAgICBNYXBUeXBlLmFkZFZhbHVlVHlwZShidWlsZGVyLCB2YWx1ZVR5cGVPZmZzZXQpO1xuICAgICAgcmV0dXJuIE1hcFR5cGUuZW5kTWFwVHlwZShidWlsZGVyKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBuYW1lc3BhY2Ugb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicyB7XG4gIGV4cG9ydCBjbGFzcyBTZXF1ZW5jZVR5cGUge1xuICAgIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIHwgbnVsbCA9IG51bGw7XG5cbiAgICBiYl9wb3MgPSAwO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaVxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHJldHVybnMgU2VxdWVuY2VUeXBlXG4gICAgICovXG4gICAgX19pbml0KGk6IG51bWJlciwgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIpOiBTZXF1ZW5jZVR5cGUge1xuICAgICAgdGhpcy5iYl9wb3MgPSBpO1xuICAgICAgdGhpcy5iYiA9IGJiO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gU2VxdWVuY2VUeXBlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBTZXF1ZW5jZVR5cGVcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Um9vdEFzU2VxdWVuY2VUeXBlKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBTZXF1ZW5jZVR5cGUpOiBTZXF1ZW5jZVR5cGUge1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IFNlcXVlbmNlVHlwZSgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIFNlcXVlbmNlVHlwZT0gb2JqXG4gICAgICogQHJldHVybnMgU2VxdWVuY2VUeXBlXG4gICAgICovXG4gICAgc3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc1NlcXVlbmNlVHlwZShiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogU2VxdWVuY2VUeXBlKTogU2VxdWVuY2VUeXBlIHtcbiAgICAgIGJiLnNldFBvc2l0aW9uKGJiLnBvc2l0aW9uKCkgKyBmbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpO1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IFNlcXVlbmNlVHlwZSgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvfG51bGxcbiAgICAgKi9cbiAgICBlbGVtVHlwZShvYmo/OiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UeXBlSW5mbyB8IG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgIHJldHVybiBvZmZzZXRcbiAgICAgICAgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvKCkpLl9faW5pdChcbiAgICAgICAgICAgIHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYl9wb3MgKyBvZmZzZXQpLFxuICAgICAgICAgICAgdGhpcy5iYiEsXG4gICAgICAgICAgKVxuICAgICAgICA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydFNlcXVlbmNlVHlwZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0T2JqZWN0KDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGVsZW1UeXBlT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZEVsZW1UeXBlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGVsZW1UeXBlT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMCwgZWxlbVR5cGVPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZW5kU2VxdWVuY2VUeXBlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgbGV0IG9mZnNldCA9IGJ1aWxkZXIuZW5kT2JqZWN0KCk7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGVTZXF1ZW5jZVR5cGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZWxlbVR5cGVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBTZXF1ZW5jZVR5cGUuc3RhcnRTZXF1ZW5jZVR5cGUoYnVpbGRlcik7XG4gICAgICBTZXF1ZW5jZVR5cGUuYWRkRWxlbVR5cGUoYnVpbGRlciwgZWxlbVR5cGVPZmZzZXQpO1xuICAgICAgcmV0dXJuIFNlcXVlbmNlVHlwZS5lbmRTZXF1ZW5jZVR5cGUoYnVpbGRlcik7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgY2xhc3MgRWRnZUVuZCB7XG4gICAgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgfCBudWxsID0gbnVsbDtcblxuICAgIGJiX3BvcyA9IDA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcmV0dXJucyBFZGdlRW5kXG4gICAgICovXG4gICAgX19pbml0KGk6IG51bWJlciwgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIpOiBFZGdlRW5kIHtcbiAgICAgIHRoaXMuYmJfcG9zID0gaTtcbiAgICAgIHRoaXMuYmIgPSBiYjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIG5vZGVJbmRleCgpOiBudW1iZXIge1xuICAgICAgcmV0dXJuIHRoaXMuYmIhLnJlYWRVaW50MzIodGhpcy5iYl9wb3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIHNyY0FyZ0luZGV4KCk6IG51bWJlciB7XG4gICAgICByZXR1cm4gdGhpcy5iYiEucmVhZEludDMyKHRoaXMuYmJfcG9zICsgNCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgZHN0QXJnSW5kZXgoKTogbnVtYmVyIHtcbiAgICAgIHJldHVybiB0aGlzLmJiIS5yZWFkSW50MzIodGhpcy5iYl9wb3MgKyA4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBub2RlX2luZGV4XG4gICAgICogQHBhcmFtIG51bWJlciBzcmNfYXJnX2luZGV4XG4gICAgICogQHBhcmFtIG51bWJlciBkc3RfYXJnX2luZGV4XG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUVkZ2VFbmQoXG4gICAgICBidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLFxuICAgICAgbm9kZV9pbmRleDogbnVtYmVyLFxuICAgICAgc3JjX2FyZ19pbmRleDogbnVtYmVyLFxuICAgICAgZHN0X2FyZ19pbmRleDogbnVtYmVyLFxuICAgICk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBidWlsZGVyLnByZXAoNCwgMTIpO1xuICAgICAgYnVpbGRlci53cml0ZUludDMyKGRzdF9hcmdfaW5kZXgpO1xuICAgICAgYnVpbGRlci53cml0ZUludDMyKHNyY19hcmdfaW5kZXgpO1xuICAgICAgYnVpbGRlci53cml0ZUludDMyKG5vZGVfaW5kZXgpO1xuICAgICAgcmV0dXJuIGJ1aWxkZXIub2Zmc2V0KCk7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgY2xhc3MgTm9kZUVkZ2Uge1xuICAgIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIHwgbnVsbCA9IG51bGw7XG5cbiAgICBiYl9wb3MgPSAwO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaVxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHJldHVybnMgTm9kZUVkZ2VcbiAgICAgKi9cbiAgICBfX2luaXQoaTogbnVtYmVyLCBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcik6IE5vZGVFZGdlIHtcbiAgICAgIHRoaXMuYmJfcG9zID0gaTtcbiAgICAgIHRoaXMuYmIgPSBiYjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIE5vZGVFZGdlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBOb2RlRWRnZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRSb290QXNOb2RlRWRnZShiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogTm9kZUVkZ2UpOiBOb2RlRWRnZSB7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgTm9kZUVkZ2UoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBOb2RlRWRnZT0gb2JqXG4gICAgICogQHJldHVybnMgTm9kZUVkZ2VcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzTm9kZUVkZ2UoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IE5vZGVFZGdlKTogTm9kZUVkZ2Uge1xuICAgICAgYmIuc2V0UG9zaXRpb24oYmIucG9zaXRpb24oKSArIGZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCk7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgTm9kZUVkZ2UoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBub2RlSW5kZXgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEucmVhZFVpbnQzMih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5FZGdlRW5kPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkVkZ2VFbmRcbiAgICAgKi9cbiAgICBpbnB1dEVkZ2VzKGluZGV4OiBudW1iZXIsIG9iaj86IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuRWRnZUVuZCk6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuRWRnZUVuZCB8IG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgIHJldHVybiBvZmZzZXRcbiAgICAgICAgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkVkZ2VFbmQoKSkuX19pbml0KFxuICAgICAgICAgICAgdGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiAxMixcbiAgICAgICAgICAgIHRoaXMuYmIhLFxuICAgICAgICAgIClcbiAgICAgICAgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIGlucHV0RWRnZXNMZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpbmRleFxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkVkZ2VFbmQ9IG9ialxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuRWRnZUVuZFxuICAgICAqL1xuICAgIG91dHB1dEVkZ2VzKFxuICAgICAgaW5kZXg6IG51bWJlcixcbiAgICAgIG9iaj86IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuRWRnZUVuZCxcbiAgICApOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkVkZ2VFbmQgfCBudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgOCk7XG4gICAgICByZXR1cm4gb2Zmc2V0XG4gICAgICAgID8gKG9iaiB8fCBuZXcgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5FZGdlRW5kKCkpLl9faW5pdChcbiAgICAgICAgICAgIHRoaXMuYmIhLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSArIGluZGV4ICogMTIsXG4gICAgICAgICAgICB0aGlzLmJiISxcbiAgICAgICAgICApXG4gICAgICAgIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBvdXRwdXRFZGdlc0xlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA4KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0Tm9kZUVkZ2UoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcikge1xuICAgICAgYnVpbGRlci5zdGFydE9iamVjdCgzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBub2RlSW5kZXhcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkTm9kZUluZGV4KGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG5vZGVJbmRleDogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkSW50MzIoMCwgbm9kZUluZGV4LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBpbnB1dEVkZ2VzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZElucHV0RWRnZXMoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgaW5wdXRFZGdlc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDEsIGlucHV0RWRnZXNPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0SW5wdXRFZGdlc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDEyLCBudW1FbGVtcywgNCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgb3V0cHV0RWRnZXNPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkT3V0cHV0RWRnZXMoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgb3V0cHV0RWRnZXNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgyLCBvdXRwdXRFZGdlc09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbnVtRWxlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRPdXRwdXRFZGdlc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDEyLCBudW1FbGVtcywgNCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBlbmROb2RlRWRnZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGxldCBvZmZzZXQgPSBidWlsZGVyLmVuZE9iamVjdCgpO1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlTm9kZUVkZ2UoXG4gICAgICBidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLFxuICAgICAgbm9kZUluZGV4OiBudW1iZXIsXG4gICAgICBpbnB1dEVkZ2VzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICBvdXRwdXRFZGdlc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBOb2RlRWRnZS5zdGFydE5vZGVFZGdlKGJ1aWxkZXIpO1xuICAgICAgTm9kZUVkZ2UuYWRkTm9kZUluZGV4KGJ1aWxkZXIsIG5vZGVJbmRleCk7XG4gICAgICBOb2RlRWRnZS5hZGRJbnB1dEVkZ2VzKGJ1aWxkZXIsIGlucHV0RWRnZXNPZmZzZXQpO1xuICAgICAgTm9kZUVkZ2UuYWRkT3V0cHV0RWRnZXMoYnVpbGRlciwgb3V0cHV0RWRnZXNPZmZzZXQpO1xuICAgICAgcmV0dXJuIE5vZGVFZGdlLmVuZE5vZGVFZGdlKGJ1aWxkZXIpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzIHtcbiAgZXhwb3J0IGNsYXNzIE5vZGUge1xuICAgIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIHwgbnVsbCA9IG51bGw7XG5cbiAgICBiYl9wb3MgPSAwO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaVxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHJldHVybnMgTm9kZVxuICAgICAqL1xuICAgIF9faW5pdChpOiBudW1iZXIsIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyKTogTm9kZSB7XG4gICAgICB0aGlzLmJiX3BvcyA9IGk7XG4gICAgICB0aGlzLmJiID0gYmI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBOb2RlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBOb2RlXG4gICAgICovXG4gICAgc3RhdGljIGdldFJvb3RBc05vZGUoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IE5vZGUpOiBOb2RlIHtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBOb2RlKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gTm9kZT0gb2JqXG4gICAgICogQHJldHVybnMgTm9kZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNOb2RlKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBOb2RlKTogTm9kZSB7XG4gICAgICBiYi5zZXRQb3NpdGlvbihiYi5wb3NpdGlvbigpICsgZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKTtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBOb2RlKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbFxuICAgICAqL1xuICAgIG5hbWUoKTogc3RyaW5nIHwgbnVsbDtcbiAgICBuYW1lKG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nIHwgVWludDhBcnJheSB8IG51bGw7XG4gICAgbmFtZShvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nIHwgVWludDhBcnJheSB8IG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiX3BvcyArIG9mZnNldCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5FbmNvZGluZz0gb3B0aW9uYWxFbmNvZGluZ1xuICAgICAqIEByZXR1cm5zIHN0cmluZ3xVaW50OEFycmF5fG51bGxcbiAgICAgKi9cbiAgICBkb2NTdHJpbmcoKTogc3RyaW5nIHwgbnVsbDtcbiAgICBkb2NTdHJpbmcob3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmcgfCBVaW50OEFycmF5IHwgbnVsbDtcbiAgICBkb2NTdHJpbmcob3B0aW9uYWxFbmNvZGluZz86IGFueSk6IHN0cmluZyB8IFVpbnQ4QXJyYXkgfCBudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX19zdHJpbmcodGhpcy5iYl9wb3MgKyBvZmZzZXQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheXxudWxsXG4gICAgICovXG4gICAgZG9tYWluKCk6IHN0cmluZyB8IG51bGw7XG4gICAgZG9tYWluKG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nIHwgVWludDhBcnJheSB8IG51bGw7XG4gICAgZG9tYWluKG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmcgfCBVaW50OEFycmF5IHwgbnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDgpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmJfcG9zICsgb2Zmc2V0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgc2luY2VWZXJzaW9uKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDEwKTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5yZWFkSW50MzIodGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBpbmRleCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxMik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEucmVhZFVpbnQzMih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5FbmNvZGluZz0gb3B0aW9uYWxFbmNvZGluZ1xuICAgICAqIEByZXR1cm5zIHN0cmluZ3xVaW50OEFycmF5fG51bGxcbiAgICAgKi9cbiAgICBvcFR5cGUoKTogc3RyaW5nIHwgbnVsbDtcbiAgICBvcFR5cGUob3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmcgfCBVaW50OEFycmF5IHwgbnVsbDtcbiAgICBvcFR5cGUob3B0aW9uYWxFbmNvZGluZz86IGFueSk6IHN0cmluZyB8IFVpbnQ4QXJyYXkgfCBudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmJfcG9zICsgb2Zmc2V0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5Ob2RlVHlwZVxuICAgICAqL1xuICAgIHR5cGUoKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5Ob2RlVHlwZSB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDE2KTtcbiAgICAgIHJldHVybiBvZmZzZXRcbiAgICAgICAgPyAvKiogICovIHRoaXMuYmIhLnJlYWRJbnQzMih0aGlzLmJiX3BvcyArIG9mZnNldClcbiAgICAgICAgOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLk5vZGVUeXBlLlByaW1pdGl2ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheXxudWxsXG4gICAgICovXG4gICAgZXhlY3V0aW9uUHJvdmlkZXJUeXBlKCk6IHN0cmluZyB8IG51bGw7XG4gICAgZXhlY3V0aW9uUHJvdmlkZXJUeXBlKG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nIHwgVWludDhBcnJheSB8IG51bGw7XG4gICAgZXhlY3V0aW9uUHJvdmlkZXJUeXBlKG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmcgfCBVaW50OEFycmF5IHwgbnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDE4KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiX3BvcyArIG9mZnNldCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheVxuICAgICAqL1xuICAgIGlucHV0cyhpbmRleDogbnVtYmVyKTogc3RyaW5nO1xuICAgIGlucHV0cyhpbmRleDogbnVtYmVyLCBvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZyB8IFVpbnQ4QXJyYXk7XG4gICAgaW5wdXRzKGluZGV4OiBudW1iZXIsIG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmcgfCBVaW50OEFycmF5IHwgbnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDIwKTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCkgKyBpbmRleCAqIDQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBpbnB1dHNMZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMjApO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheVxuICAgICAqL1xuICAgIG91dHB1dHMoaW5kZXg6IG51bWJlcik6IHN0cmluZztcbiAgICBvdXRwdXRzKGluZGV4OiBudW1iZXIsIG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nIHwgVWludDhBcnJheTtcbiAgICBvdXRwdXRzKGluZGV4OiBudW1iZXIsIG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmcgfCBVaW50OEFycmF5IHwgbnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDIyKTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCkgKyBpbmRleCAqIDQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBvdXRwdXRzTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDIyKTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4XG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuQXR0cmlidXRlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkF0dHJpYnV0ZVxuICAgICAqL1xuICAgIGF0dHJpYnV0ZXMoXG4gICAgICBpbmRleDogbnVtYmVyLFxuICAgICAgb2JqPzogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5BdHRyaWJ1dGUsXG4gICAgKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5BdHRyaWJ1dGUgfCBudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMjQpO1xuICAgICAgcmV0dXJuIG9mZnNldFxuICAgICAgICA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuQXR0cmlidXRlKCkpLl9faW5pdChcbiAgICAgICAgICAgIHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA0KSxcbiAgICAgICAgICAgIHRoaXMuYmIhLFxuICAgICAgICAgIClcbiAgICAgICAgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIGF0dHJpYnV0ZXNMZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMjQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBpbnB1dEFyZ0NvdW50cyhpbmRleDogbnVtYmVyKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDI2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5yZWFkSW50MzIodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgaW5wdXRBcmdDb3VudHNMZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMjYpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIEludDMyQXJyYXlcbiAgICAgKi9cbiAgICBpbnB1dEFyZ0NvdW50c0FycmF5KCk6IEludDMyQXJyYXkgfCBudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMjYpO1xuICAgICAgcmV0dXJuIG9mZnNldFxuICAgICAgICA/IG5ldyBJbnQzMkFycmF5KFxuICAgICAgICAgICAgdGhpcy5iYiEuYnl0ZXMoKS5idWZmZXIsXG4gICAgICAgICAgICB0aGlzLmJiIS5ieXRlcygpLmJ5dGVPZmZzZXQgKyB0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCksXG4gICAgICAgICAgICB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpLFxuICAgICAgICAgIClcbiAgICAgICAgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheVxuICAgICAqL1xuICAgIGltcGxpY2l0SW5wdXRzKGluZGV4OiBudW1iZXIpOiBzdHJpbmc7XG4gICAgaW1wbGljaXRJbnB1dHMoaW5kZXg6IG51bWJlciwgb3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmcgfCBVaW50OEFycmF5O1xuICAgIGltcGxpY2l0SW5wdXRzKGluZGV4OiBudW1iZXIsIG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmcgfCBVaW50OEFycmF5IHwgbnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDI4KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCkgKyBpbmRleCAqIDQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBpbXBsaWNpdElucHV0c0xlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAyOCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydE5vZGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcikge1xuICAgICAgYnVpbGRlci5zdGFydE9iamVjdCgxMyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgbmFtZU9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGROYW1lKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG5hbWVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgwLCBuYW1lT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBkb2NTdHJpbmdPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkRG9jU3RyaW5nKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRvY1N0cmluZ09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDEsIGRvY1N0cmluZ09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgZG9tYWluT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZERvbWFpbihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkb21haW5PZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgyLCBkb21haW5PZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIHNpbmNlVmVyc2lvblxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRTaW5jZVZlcnNpb24oYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgc2luY2VWZXJzaW9uOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRJbnQzMigzLCBzaW5jZVZlcnNpb24sIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4XG4gICAgICovXG4gICAgc3RhdGljIGFkZEluZGV4KGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGluZGV4OiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRJbnQzMig0LCBpbmRleCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgb3BUeXBlT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZE9wVHlwZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBvcFR5cGVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCg1LCBvcFR5cGVPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5Ob2RlVHlwZSB0eXBlXG4gICAgICovXG4gICAgc3RhdGljIGFkZFR5cGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgdHlwZTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5Ob2RlVHlwZSkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZEludDMyKDYsIHR5cGUsIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuTm9kZVR5cGUuUHJpbWl0aXZlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBleGVjdXRpb25Qcm92aWRlclR5cGVPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkRXhlY3V0aW9uUHJvdmlkZXJUeXBlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGV4ZWN1dGlvblByb3ZpZGVyVHlwZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDcsIGV4ZWN1dGlvblByb3ZpZGVyVHlwZU9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgaW5wdXRzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZElucHV0cyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBpbnB1dHNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCg4LCBpbnB1dHNPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gQXJyYXkuPGZsYXRidWZmZXJzLk9mZnNldD4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVJbnB1dHNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogZmxhdGJ1ZmZlcnMuT2Zmc2V0W10pOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBkYXRhLmxlbmd0aCwgNCk7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBidWlsZGVyLmFkZE9mZnNldChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0SW5wdXRzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgbnVtRWxlbXMsIDQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IG91dHB1dHNPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkT3V0cHV0cyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBvdXRwdXRzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoOSwgb3V0cHV0c09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBBcnJheS48ZmxhdGJ1ZmZlcnMuT2Zmc2V0PiBkYXRhXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZU91dHB1dHNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogZmxhdGJ1ZmZlcnMuT2Zmc2V0W10pOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBkYXRhLmxlbmd0aCwgNCk7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBidWlsZGVyLmFkZE9mZnNldChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0T3V0cHV0c1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIG51bUVsZW1zLCA0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBhdHRyaWJ1dGVzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZEF0dHJpYnV0ZXMoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgYXR0cmlidXRlc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDEwLCBhdHRyaWJ1dGVzT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIEFycmF5LjxmbGF0YnVmZmVycy5PZmZzZXQ+IGRhdGFcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlQXR0cmlidXRlc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkYXRhOiBmbGF0YnVmZmVycy5PZmZzZXRbXSk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIGRhdGEubGVuZ3RoLCA0KTtcbiAgICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGJ1aWxkZXIuYWRkT2Zmc2V0KGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWxkZXIuZW5kVmVjdG9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbnVtRWxlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRBdHRyaWJ1dGVzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgbnVtRWxlbXMsIDQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGlucHV0QXJnQ291bnRzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZElucHV0QXJnQ291bnRzKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGlucHV0QXJnQ291bnRzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMTEsIGlucHV0QXJnQ291bnRzT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIEFycmF5LjxudW1iZXI+IGRhdGFcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlSW5wdXRBcmdDb3VudHNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogbnVtYmVyW10gfCBVaW50OEFycmF5KTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgZGF0YS5sZW5ndGgsIDQpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRJbnQzMihkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0SW5wdXRBcmdDb3VudHNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbnVtRWxlbXM6IG51bWJlcikge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBudW1FbGVtcywgNCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgaW1wbGljaXRJbnB1dHNPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkSW1wbGljaXRJbnB1dHMoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgaW1wbGljaXRJbnB1dHNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgxMiwgaW1wbGljaXRJbnB1dHNPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gQXJyYXkuPGZsYXRidWZmZXJzLk9mZnNldD4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVJbXBsaWNpdElucHV0c1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkYXRhOiBmbGF0YnVmZmVycy5PZmZzZXRbXSk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIGRhdGEubGVuZ3RoLCA0KTtcbiAgICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGJ1aWxkZXIuYWRkT2Zmc2V0KGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWxkZXIuZW5kVmVjdG9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbnVtRWxlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRJbXBsaWNpdElucHV0c1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIG51bUVsZW1zLCA0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGVuZE5vZGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcik6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gYnVpbGRlci5lbmRPYmplY3QoKTtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZU5vZGUoXG4gICAgICBidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLFxuICAgICAgbmFtZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgZG9jU3RyaW5nT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICBkb21haW5PZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgIHNpbmNlVmVyc2lvbjogbnVtYmVyLFxuICAgICAgaW5kZXg6IG51bWJlcixcbiAgICAgIG9wVHlwZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgdHlwZTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5Ob2RlVHlwZSxcbiAgICAgIGV4ZWN1dGlvblByb3ZpZGVyVHlwZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgaW5wdXRzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICBvdXRwdXRzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICBhdHRyaWJ1dGVzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICBpbnB1dEFyZ0NvdW50c09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgaW1wbGljaXRJbnB1dHNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICApOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgTm9kZS5zdGFydE5vZGUoYnVpbGRlcik7XG4gICAgICBOb2RlLmFkZE5hbWUoYnVpbGRlciwgbmFtZU9mZnNldCk7XG4gICAgICBOb2RlLmFkZERvY1N0cmluZyhidWlsZGVyLCBkb2NTdHJpbmdPZmZzZXQpO1xuICAgICAgTm9kZS5hZGREb21haW4oYnVpbGRlciwgZG9tYWluT2Zmc2V0KTtcbiAgICAgIE5vZGUuYWRkU2luY2VWZXJzaW9uKGJ1aWxkZXIsIHNpbmNlVmVyc2lvbik7XG4gICAgICBOb2RlLmFkZEluZGV4KGJ1aWxkZXIsIGluZGV4KTtcbiAgICAgIE5vZGUuYWRkT3BUeXBlKGJ1aWxkZXIsIG9wVHlwZU9mZnNldCk7XG4gICAgICBOb2RlLmFkZFR5cGUoYnVpbGRlciwgdHlwZSk7XG4gICAgICBOb2RlLmFkZEV4ZWN1dGlvblByb3ZpZGVyVHlwZShidWlsZGVyLCBleGVjdXRpb25Qcm92aWRlclR5cGVPZmZzZXQpO1xuICAgICAgTm9kZS5hZGRJbnB1dHMoYnVpbGRlciwgaW5wdXRzT2Zmc2V0KTtcbiAgICAgIE5vZGUuYWRkT3V0cHV0cyhidWlsZGVyLCBvdXRwdXRzT2Zmc2V0KTtcbiAgICAgIE5vZGUuYWRkQXR0cmlidXRlcyhidWlsZGVyLCBhdHRyaWJ1dGVzT2Zmc2V0KTtcbiAgICAgIE5vZGUuYWRkSW5wdXRBcmdDb3VudHMoYnVpbGRlciwgaW5wdXRBcmdDb3VudHNPZmZzZXQpO1xuICAgICAgTm9kZS5hZGRJbXBsaWNpdElucHV0cyhidWlsZGVyLCBpbXBsaWNpdElucHV0c09mZnNldCk7XG4gICAgICByZXR1cm4gTm9kZS5lbmROb2RlKGJ1aWxkZXIpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzIHtcbiAgZXhwb3J0IGNsYXNzIFZhbHVlSW5mbyB7XG4gICAgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgfCBudWxsID0gbnVsbDtcblxuICAgIGJiX3BvcyA9IDA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcmV0dXJucyBWYWx1ZUluZm9cbiAgICAgKi9cbiAgICBfX2luaXQoaTogbnVtYmVyLCBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcik6IFZhbHVlSW5mbyB7XG4gICAgICB0aGlzLmJiX3BvcyA9IGk7XG4gICAgICB0aGlzLmJiID0gYmI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBWYWx1ZUluZm89IG9ialxuICAgICAqIEByZXR1cm5zIFZhbHVlSW5mb1xuICAgICAqL1xuICAgIHN0YXRpYyBnZXRSb290QXNWYWx1ZUluZm8oYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IFZhbHVlSW5mbyk6IFZhbHVlSW5mbyB7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgVmFsdWVJbmZvKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gVmFsdWVJbmZvPSBvYmpcbiAgICAgKiBAcmV0dXJucyBWYWx1ZUluZm9cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzVmFsdWVJbmZvKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBWYWx1ZUluZm8pOiBWYWx1ZUluZm8ge1xuICAgICAgYmIuc2V0UG9zaXRpb24oYmIucG9zaXRpb24oKSArIGZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCk7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgVmFsdWVJbmZvKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbFxuICAgICAqL1xuICAgIG5hbWUoKTogc3RyaW5nIHwgbnVsbDtcbiAgICBuYW1lKG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nIHwgVWludDhBcnJheSB8IG51bGw7XG4gICAgbmFtZShvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nIHwgVWludDhBcnJheSB8IG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiX3BvcyArIG9mZnNldCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5FbmNvZGluZz0gb3B0aW9uYWxFbmNvZGluZ1xuICAgICAqIEByZXR1cm5zIHN0cmluZ3xVaW50OEFycmF5fG51bGxcbiAgICAgKi9cbiAgICBkb2NTdHJpbmcoKTogc3RyaW5nIHwgbnVsbDtcbiAgICBkb2NTdHJpbmcob3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmcgfCBVaW50OEFycmF5IHwgbnVsbDtcbiAgICBkb2NTdHJpbmcob3B0aW9uYWxFbmNvZGluZz86IGFueSk6IHN0cmluZyB8IFVpbnQ4QXJyYXkgfCBudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX19zdHJpbmcodGhpcy5iYl9wb3MgKyBvZmZzZXQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UeXBlSW5mbz0gb2JqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UeXBlSW5mb3xudWxsXG4gICAgICovXG4gICAgdHlwZShvYmo/OiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UeXBlSW5mbyB8IG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA4KTtcbiAgICAgIHJldHVybiBvZmZzZXRcbiAgICAgICAgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvKCkpLl9faW5pdChcbiAgICAgICAgICAgIHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYl9wb3MgKyBvZmZzZXQpLFxuICAgICAgICAgICAgdGhpcy5iYiEsXG4gICAgICAgICAgKVxuICAgICAgICA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydFZhbHVlSW5mbyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0T2JqZWN0KDMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IG5hbWVPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkTmFtZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBuYW1lT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMCwgbmFtZU9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgZG9jU3RyaW5nT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZERvY1N0cmluZyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkb2NTdHJpbmdPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgxLCBkb2NTdHJpbmdPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IHR5cGVPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkVHlwZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCB0eXBlT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMiwgdHlwZU9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBlbmRWYWx1ZUluZm8oYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcik6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gYnVpbGRlci5lbmRPYmplY3QoKTtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZVZhbHVlSW5mbyhcbiAgICAgIGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsXG4gICAgICBuYW1lT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICBkb2NTdHJpbmdPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgIHR5cGVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICApOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgVmFsdWVJbmZvLnN0YXJ0VmFsdWVJbmZvKGJ1aWxkZXIpO1xuICAgICAgVmFsdWVJbmZvLmFkZE5hbWUoYnVpbGRlciwgbmFtZU9mZnNldCk7XG4gICAgICBWYWx1ZUluZm8uYWRkRG9jU3RyaW5nKGJ1aWxkZXIsIGRvY1N0cmluZ09mZnNldCk7XG4gICAgICBWYWx1ZUluZm8uYWRkVHlwZShidWlsZGVyLCB0eXBlT2Zmc2V0KTtcbiAgICAgIHJldHVybiBWYWx1ZUluZm8uZW5kVmFsdWVJbmZvKGJ1aWxkZXIpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzIHtcbiAgZXhwb3J0IGNsYXNzIFR5cGVJbmZvIHtcbiAgICBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciB8IG51bGwgPSBudWxsO1xuXG4gICAgYmJfcG9zID0gMDtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGlcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEByZXR1cm5zIFR5cGVJbmZvXG4gICAgICovXG4gICAgX19pbml0KGk6IG51bWJlciwgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIpOiBUeXBlSW5mbyB7XG4gICAgICB0aGlzLmJiX3BvcyA9IGk7XG4gICAgICB0aGlzLmJiID0gYmI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBUeXBlSW5mbz0gb2JqXG4gICAgICogQHJldHVybnMgVHlwZUluZm9cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Um9vdEFzVHlwZUluZm8oYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IFR5cGVJbmZvKTogVHlwZUluZm8ge1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IFR5cGVJbmZvKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gVHlwZUluZm89IG9ialxuICAgICAqIEByZXR1cm5zIFR5cGVJbmZvXG4gICAgICovXG4gICAgc3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc1R5cGVJbmZvKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBUeXBlSW5mbyk6IFR5cGVJbmZvIHtcbiAgICAgIGJiLnNldFBvc2l0aW9uKGJiLnBvc2l0aW9uKCkgKyBmbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpO1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IFR5cGVJbmZvKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbFxuICAgICAqL1xuICAgIGRlbm90YXRpb24oKTogc3RyaW5nIHwgbnVsbDtcbiAgICBkZW5vdGF0aW9uKG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nIHwgVWludDhBcnJheSB8IG51bGw7XG4gICAgZGVub3RhdGlvbihvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nIHwgVWludDhBcnJheSB8IG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiX3BvcyArIG9mZnNldCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVHlwZUluZm9WYWx1ZVxuICAgICAqL1xuICAgIHZhbHVlVHlwZSgpOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvVmFsdWUge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgIHJldHVybiBvZmZzZXRcbiAgICAgICAgPyAvKiogICovIHRoaXMuYmIhLnJlYWRVaW50OCh0aGlzLmJiX3BvcyArIG9mZnNldClcbiAgICAgICAgOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvVmFsdWUuTk9ORTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuVGFibGUgb2JqXG4gICAgICogQHJldHVybnMgP2ZsYXRidWZmZXJzLlRhYmxlXG4gICAgICovXG4gICAgdmFsdWU8VCBleHRlbmRzIGZsYXRidWZmZXJzLlRhYmxlPihvYmo6IFQpOiBUIHwgbnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDgpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fdW5pb24ob2JqLCB0aGlzLmJiX3BvcyArIG9mZnNldCkgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRUeXBlSW5mbyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0T2JqZWN0KDMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGRlbm90YXRpb25PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkRGVub3RhdGlvbihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkZW5vdGF0aW9uT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMCwgZGVub3RhdGlvbk9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvVmFsdWUgdmFsdWVUeXBlXG4gICAgICovXG4gICAgc3RhdGljIGFkZFZhbHVlVHlwZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCB2YWx1ZVR5cGU6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVHlwZUluZm9WYWx1ZSkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZEludDgoMSwgdmFsdWVUeXBlLCBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvVmFsdWUuTk9ORSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgdmFsdWVPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkVmFsdWUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgdmFsdWVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgyLCB2YWx1ZU9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBlbmRUeXBlSW5mbyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGxldCBvZmZzZXQgPSBidWlsZGVyLmVuZE9iamVjdCgpO1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlVHlwZUluZm8oXG4gICAgICBidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLFxuICAgICAgZGVub3RhdGlvbk9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgdmFsdWVUeXBlOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvVmFsdWUsXG4gICAgICB2YWx1ZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBUeXBlSW5mby5zdGFydFR5cGVJbmZvKGJ1aWxkZXIpO1xuICAgICAgVHlwZUluZm8uYWRkRGVub3RhdGlvbihidWlsZGVyLCBkZW5vdGF0aW9uT2Zmc2V0KTtcbiAgICAgIFR5cGVJbmZvLmFkZFZhbHVlVHlwZShidWlsZGVyLCB2YWx1ZVR5cGUpO1xuICAgICAgVHlwZUluZm8uYWRkVmFsdWUoYnVpbGRlciwgdmFsdWVPZmZzZXQpO1xuICAgICAgcmV0dXJuIFR5cGVJbmZvLmVuZFR5cGVJbmZvKGJ1aWxkZXIpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzIHtcbiAgZXhwb3J0IGNsYXNzIE9wZXJhdG9yU2V0SWQge1xuICAgIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIHwgbnVsbCA9IG51bGw7XG5cbiAgICBiYl9wb3MgPSAwO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaVxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHJldHVybnMgT3BlcmF0b3JTZXRJZFxuICAgICAqL1xuICAgIF9faW5pdChpOiBudW1iZXIsIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyKTogT3BlcmF0b3JTZXRJZCB7XG4gICAgICB0aGlzLmJiX3BvcyA9IGk7XG4gICAgICB0aGlzLmJiID0gYmI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBPcGVyYXRvclNldElkPSBvYmpcbiAgICAgKiBAcmV0dXJucyBPcGVyYXRvclNldElkXG4gICAgICovXG4gICAgc3RhdGljIGdldFJvb3RBc09wZXJhdG9yU2V0SWQoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IE9wZXJhdG9yU2V0SWQpOiBPcGVyYXRvclNldElkIHtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBPcGVyYXRvclNldElkKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gT3BlcmF0b3JTZXRJZD0gb2JqXG4gICAgICogQHJldHVybnMgT3BlcmF0b3JTZXRJZFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNPcGVyYXRvclNldElkKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBPcGVyYXRvclNldElkKTogT3BlcmF0b3JTZXRJZCB7XG4gICAgICBiYi5zZXRQb3NpdGlvbihiYi5wb3NpdGlvbigpICsgZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKTtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBPcGVyYXRvclNldElkKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbFxuICAgICAqL1xuICAgIGRvbWFpbigpOiBzdHJpbmcgfCBudWxsO1xuICAgIGRvbWFpbihvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZyB8IFVpbnQ4QXJyYXkgfCBudWxsO1xuICAgIGRvbWFpbihvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nIHwgVWludDhBcnJheSB8IG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiX3BvcyArIG9mZnNldCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLkxvbmdcbiAgICAgKi9cbiAgICB2ZXJzaW9uKCk6IGZsYXRidWZmZXJzLkxvbmcge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5yZWFkSW50NjQodGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogdGhpcy5iYiEuY3JlYXRlTG9uZygwLCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0T3BlcmF0b3JTZXRJZChidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0T2JqZWN0KDIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGRvbWFpbk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGREb21haW4oYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZG9tYWluT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMCwgZG9tYWluT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkxvbmcgdmVyc2lvblxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRWZXJzaW9uKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIHZlcnNpb246IGZsYXRidWZmZXJzLkxvbmcpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRJbnQ2NCgxLCB2ZXJzaW9uLCBidWlsZGVyLmNyZWF0ZUxvbmcoMCwgMCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZW5kT3BlcmF0b3JTZXRJZChidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGxldCBvZmZzZXQgPSBidWlsZGVyLmVuZE9iamVjdCgpO1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlT3BlcmF0b3JTZXRJZChcbiAgICAgIGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsXG4gICAgICBkb21haW5PZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgIHZlcnNpb246IGZsYXRidWZmZXJzLkxvbmcsXG4gICAgKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIE9wZXJhdG9yU2V0SWQuc3RhcnRPcGVyYXRvclNldElkKGJ1aWxkZXIpO1xuICAgICAgT3BlcmF0b3JTZXRJZC5hZGREb21haW4oYnVpbGRlciwgZG9tYWluT2Zmc2V0KTtcbiAgICAgIE9wZXJhdG9yU2V0SWQuYWRkVmVyc2lvbihidWlsZGVyLCB2ZXJzaW9uKTtcbiAgICAgIHJldHVybiBPcGVyYXRvclNldElkLmVuZE9wZXJhdG9yU2V0SWQoYnVpbGRlcik7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgY2xhc3MgVGVuc29yIHtcbiAgICBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciB8IG51bGwgPSBudWxsO1xuXG4gICAgYmJfcG9zID0gMDtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGlcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEByZXR1cm5zIFRlbnNvclxuICAgICAqL1xuICAgIF9faW5pdChpOiBudW1iZXIsIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyKTogVGVuc29yIHtcbiAgICAgIHRoaXMuYmJfcG9zID0gaTtcbiAgICAgIHRoaXMuYmIgPSBiYjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIFRlbnNvcj0gb2JqXG4gICAgICogQHJldHVybnMgVGVuc29yXG4gICAgICovXG4gICAgc3RhdGljIGdldFJvb3RBc1RlbnNvcihiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogVGVuc29yKTogVGVuc29yIHtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBUZW5zb3IoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBUZW5zb3I9IG9ialxuICAgICAqIEByZXR1cm5zIFRlbnNvclxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNUZW5zb3IoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IFRlbnNvcik6IFRlbnNvciB7XG4gICAgICBiYi5zZXRQb3NpdGlvbihiYi5wb3NpdGlvbigpICsgZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKTtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBUZW5zb3IoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheXxudWxsXG4gICAgICovXG4gICAgbmFtZSgpOiBzdHJpbmcgfCBudWxsO1xuICAgIG5hbWUob3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmcgfCBVaW50OEFycmF5IHwgbnVsbDtcbiAgICBuYW1lKG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmcgfCBVaW50OEFycmF5IHwgbnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmJfcG9zICsgb2Zmc2V0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbFxuICAgICAqL1xuICAgIGRvY1N0cmluZygpOiBzdHJpbmcgfCBudWxsO1xuICAgIGRvY1N0cmluZyhvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZyB8IFVpbnQ4QXJyYXkgfCBudWxsO1xuICAgIGRvY1N0cmluZyhvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nIHwgVWludDhBcnJheSB8IG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiX3BvcyArIG9mZnNldCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5Mb25nXG4gICAgICovXG4gICAgZGltcyhpbmRleDogbnVtYmVyKTogZmxhdGJ1ZmZlcnMuTG9uZyB8IG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA4KTtcbiAgICAgIHJldHVybiBvZmZzZXRcbiAgICAgICAgPyB0aGlzLmJiIS5yZWFkSW50NjQodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA4KVxuICAgICAgICA6IHRoaXMuYmIhLmNyZWF0ZUxvbmcoMCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgZGltc0xlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA4KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvckRhdGFUeXBlXG4gICAgICovXG4gICAgZGF0YVR5cGUoKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZSB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDEwKTtcbiAgICAgIHJldHVybiBvZmZzZXRcbiAgICAgICAgPyAvKiogICovIHRoaXMuYmIhLnJlYWRJbnQzMih0aGlzLmJiX3BvcyArIG9mZnNldClcbiAgICAgICAgOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvckRhdGFUeXBlLlVOREVGSU5FRDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4XG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgcmF3RGF0YShpbmRleDogbnVtYmVyKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDEyKTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5yZWFkVWludDgodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXgpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICByYXdEYXRhTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDEyKTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBVaW50OEFycmF5XG4gICAgICovXG4gICAgcmF3RGF0YUFycmF5KCk6IFVpbnQ4QXJyYXkgfCBudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTIpO1xuICAgICAgcmV0dXJuIG9mZnNldFxuICAgICAgICA/IG5ldyBVaW50OEFycmF5KFxuICAgICAgICAgICAgdGhpcy5iYiEuYnl0ZXMoKS5idWZmZXIsXG4gICAgICAgICAgICB0aGlzLmJiIS5ieXRlcygpLmJ5dGVPZmZzZXQgKyB0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCksXG4gICAgICAgICAgICB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpLFxuICAgICAgICAgIClcbiAgICAgICAgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheVxuICAgICAqL1xuICAgIHN0cmluZ0RhdGEoaW5kZXg6IG51bWJlcik6IHN0cmluZztcbiAgICBzdHJpbmdEYXRhKGluZGV4OiBudW1iZXIsIG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nIHwgVWludDhBcnJheTtcbiAgICBzdHJpbmdEYXRhKGluZGV4OiBudW1iZXIsIG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmcgfCBVaW50OEFycmF5IHwgbnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDE0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCkgKyBpbmRleCAqIDQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBzdHJpbmdEYXRhTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDE0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0VGVuc29yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRPYmplY3QoNik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgbmFtZU9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGROYW1lKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG5hbWVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgwLCBuYW1lT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBkb2NTdHJpbmdPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkRG9jU3RyaW5nKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRvY1N0cmluZ09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDEsIGRvY1N0cmluZ09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgZGltc09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGREaW1zKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRpbXNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgyLCBkaW1zT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIEFycmF5LjxmbGF0YnVmZmVycy5Mb25nPiBkYXRhXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZURpbXNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogZmxhdGJ1ZmZlcnMuTG9uZ1tdKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoOCwgZGF0YS5sZW5ndGgsIDgpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRJbnQ2NChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0RGltc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDgsIG51bUVsZW1zLCA4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGUgZGF0YVR5cGVcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkRGF0YVR5cGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YVR5cGU6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGUpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRJbnQzMigzLCBkYXRhVHlwZSwgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZS5VTkRFRklORUQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IHJhd0RhdGFPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkUmF3RGF0YShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCByYXdEYXRhT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoNCwgcmF3RGF0YU9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBBcnJheS48bnVtYmVyPiBkYXRhXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVJhd0RhdGFWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogbnVtYmVyW10gfCBVaW50OEFycmF5KTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoMSwgZGF0YS5sZW5ndGgsIDEpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRJbnQ4KGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWxkZXIuZW5kVmVjdG9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbnVtRWxlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRSYXdEYXRhVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoMSwgbnVtRWxlbXMsIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IHN0cmluZ0RhdGFPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkU3RyaW5nRGF0YShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBzdHJpbmdEYXRhT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoNSwgc3RyaW5nRGF0YU9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBBcnJheS48ZmxhdGJ1ZmZlcnMuT2Zmc2V0PiBkYXRhXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVN0cmluZ0RhdGFWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogZmxhdGJ1ZmZlcnMuT2Zmc2V0W10pOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBkYXRhLmxlbmd0aCwgNCk7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBidWlsZGVyLmFkZE9mZnNldChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0U3RyaW5nRGF0YVZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIG51bUVsZW1zLCA0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGVuZFRlbnNvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGxldCBvZmZzZXQgPSBidWlsZGVyLmVuZE9iamVjdCgpO1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlVGVuc29yKFxuICAgICAgYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcixcbiAgICAgIG5hbWVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgIGRvY1N0cmluZ09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgZGltc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgZGF0YVR5cGU6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGUsXG4gICAgICByYXdEYXRhT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICBzdHJpbmdEYXRhT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIFRlbnNvci5zdGFydFRlbnNvcihidWlsZGVyKTtcbiAgICAgIFRlbnNvci5hZGROYW1lKGJ1aWxkZXIsIG5hbWVPZmZzZXQpO1xuICAgICAgVGVuc29yLmFkZERvY1N0cmluZyhidWlsZGVyLCBkb2NTdHJpbmdPZmZzZXQpO1xuICAgICAgVGVuc29yLmFkZERpbXMoYnVpbGRlciwgZGltc09mZnNldCk7XG4gICAgICBUZW5zb3IuYWRkRGF0YVR5cGUoYnVpbGRlciwgZGF0YVR5cGUpO1xuICAgICAgVGVuc29yLmFkZFJhd0RhdGEoYnVpbGRlciwgcmF3RGF0YU9mZnNldCk7XG4gICAgICBUZW5zb3IuYWRkU3RyaW5nRGF0YShidWlsZGVyLCBzdHJpbmdEYXRhT2Zmc2V0KTtcbiAgICAgIHJldHVybiBUZW5zb3IuZW5kVGVuc29yKGJ1aWxkZXIpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzIHtcbiAgZXhwb3J0IGNsYXNzIFNwYXJzZVRlbnNvciB7XG4gICAgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgfCBudWxsID0gbnVsbDtcblxuICAgIGJiX3BvcyA9IDA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcmV0dXJucyBTcGFyc2VUZW5zb3JcbiAgICAgKi9cbiAgICBfX2luaXQoaTogbnVtYmVyLCBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcik6IFNwYXJzZVRlbnNvciB7XG4gICAgICB0aGlzLmJiX3BvcyA9IGk7XG4gICAgICB0aGlzLmJiID0gYmI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBTcGFyc2VUZW5zb3I9IG9ialxuICAgICAqIEByZXR1cm5zIFNwYXJzZVRlbnNvclxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRSb290QXNTcGFyc2VUZW5zb3IoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IFNwYXJzZVRlbnNvcik6IFNwYXJzZVRlbnNvciB7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgU3BhcnNlVGVuc29yKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gU3BhcnNlVGVuc29yPSBvYmpcbiAgICAgKiBAcmV0dXJucyBTcGFyc2VUZW5zb3JcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzU3BhcnNlVGVuc29yKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBTcGFyc2VUZW5zb3IpOiBTcGFyc2VUZW5zb3Ige1xuICAgICAgYmIuc2V0UG9zaXRpb24oYmIucG9zaXRpb24oKSArIGZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCk7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgU3BhcnNlVGVuc29yKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvcnxudWxsXG4gICAgICovXG4gICAgdmFsdWVzKG9iaj86IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3IgfCBudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0XG4gICAgICAgID8gKG9iaiB8fCBuZXcgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3IoKSkuX19pbml0KHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYl9wb3MgKyBvZmZzZXQpLCB0aGlzLmJiISlcbiAgICAgICAgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvcj0gb2JqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3J8bnVsbFxuICAgICAqL1xuICAgIGluZGljZXMob2JqPzogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3IpOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvciB8IG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgIHJldHVybiBvZmZzZXRcbiAgICAgICAgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvcigpKS5fX2luaXQodGhpcy5iYiEuX19pbmRpcmVjdCh0aGlzLmJiX3BvcyArIG9mZnNldCksIHRoaXMuYmIhKVxuICAgICAgICA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpbmRleFxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLkxvbmdcbiAgICAgKi9cbiAgICBkaW1zKGluZGV4OiBudW1iZXIpOiBmbGF0YnVmZmVycy5Mb25nIHwgbnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDgpO1xuICAgICAgcmV0dXJuIG9mZnNldFxuICAgICAgICA/IHRoaXMuYmIhLnJlYWRJbnQ2NCh0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCkgKyBpbmRleCAqIDgpXG4gICAgICAgIDogdGhpcy5iYiEuY3JlYXRlTG9uZygwLCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBkaW1zTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDgpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRTcGFyc2VUZW5zb3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcikge1xuICAgICAgYnVpbGRlci5zdGFydE9iamVjdCgzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCB2YWx1ZXNPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkVmFsdWVzKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIHZhbHVlc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDAsIHZhbHVlc09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgaW5kaWNlc09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRJbmRpY2VzKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGluZGljZXNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgxLCBpbmRpY2VzT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBkaW1zT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZERpbXMoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGltc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDIsIGRpbXNPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gQXJyYXkuPGZsYXRidWZmZXJzLkxvbmc+IGRhdGFcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlRGltc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkYXRhOiBmbGF0YnVmZmVycy5Mb25nW10pOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig4LCBkYXRhLmxlbmd0aCwgOCk7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBidWlsZGVyLmFkZEludDY0KGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWxkZXIuZW5kVmVjdG9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbnVtRWxlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnREaW1zVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoOCwgbnVtRWxlbXMsIDgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZW5kU3BhcnNlVGVuc29yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgbGV0IG9mZnNldCA9IGJ1aWxkZXIuZW5kT2JqZWN0KCk7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGVTcGFyc2VUZW5zb3IoXG4gICAgICBidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLFxuICAgICAgdmFsdWVzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICBpbmRpY2VzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICBkaW1zT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIFNwYXJzZVRlbnNvci5zdGFydFNwYXJzZVRlbnNvcihidWlsZGVyKTtcbiAgICAgIFNwYXJzZVRlbnNvci5hZGRWYWx1ZXMoYnVpbGRlciwgdmFsdWVzT2Zmc2V0KTtcbiAgICAgIFNwYXJzZVRlbnNvci5hZGRJbmRpY2VzKGJ1aWxkZXIsIGluZGljZXNPZmZzZXQpO1xuICAgICAgU3BhcnNlVGVuc29yLmFkZERpbXMoYnVpbGRlciwgZGltc09mZnNldCk7XG4gICAgICByZXR1cm4gU3BhcnNlVGVuc29yLmVuZFNwYXJzZVRlbnNvcihidWlsZGVyKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBuYW1lc3BhY2Ugb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicyB7XG4gIGV4cG9ydCBjbGFzcyBBdHRyaWJ1dGUge1xuICAgIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIHwgbnVsbCA9IG51bGw7XG5cbiAgICBiYl9wb3MgPSAwO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaVxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHJldHVybnMgQXR0cmlidXRlXG4gICAgICovXG4gICAgX19pbml0KGk6IG51bWJlciwgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIpOiBBdHRyaWJ1dGUge1xuICAgICAgdGhpcy5iYl9wb3MgPSBpO1xuICAgICAgdGhpcy5iYiA9IGJiO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gQXR0cmlidXRlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBBdHRyaWJ1dGVcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Um9vdEFzQXR0cmlidXRlKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBBdHRyaWJ1dGUpOiBBdHRyaWJ1dGUge1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IEF0dHJpYnV0ZSgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIEF0dHJpYnV0ZT0gb2JqXG4gICAgICogQHJldHVybnMgQXR0cmlidXRlXG4gICAgICovXG4gICAgc3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc0F0dHJpYnV0ZShiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogQXR0cmlidXRlKTogQXR0cmlidXRlIHtcbiAgICAgIGJiLnNldFBvc2l0aW9uKGJiLnBvc2l0aW9uKCkgKyBmbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpO1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IEF0dHJpYnV0ZSgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5FbmNvZGluZz0gb3B0aW9uYWxFbmNvZGluZ1xuICAgICAqIEByZXR1cm5zIHN0cmluZ3xVaW50OEFycmF5fG51bGxcbiAgICAgKi9cbiAgICBuYW1lKCk6IHN0cmluZyB8IG51bGw7XG4gICAgbmFtZShvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZyB8IFVpbnQ4QXJyYXkgfCBudWxsO1xuICAgIG5hbWUob3B0aW9uYWxFbmNvZGluZz86IGFueSk6IHN0cmluZyB8IFVpbnQ4QXJyYXkgfCBudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX19zdHJpbmcodGhpcy5iYl9wb3MgKyBvZmZzZXQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheXxudWxsXG4gICAgICovXG4gICAgZG9jU3RyaW5nKCk6IHN0cmluZyB8IG51bGw7XG4gICAgZG9jU3RyaW5nKG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nIHwgVWludDhBcnJheSB8IG51bGw7XG4gICAgZG9jU3RyaW5nKG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmcgfCBVaW50OEFycmF5IHwgbnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDYpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmJfcG9zICsgb2Zmc2V0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5BdHRyaWJ1dGVUeXBlXG4gICAgICovXG4gICAgdHlwZSgpOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkF0dHJpYnV0ZVR5cGUge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA4KTtcbiAgICAgIHJldHVybiBvZmZzZXRcbiAgICAgICAgPyAvKiogICovIHRoaXMuYmIhLnJlYWRJbnQzMih0aGlzLmJiX3BvcyArIG9mZnNldClcbiAgICAgICAgOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkF0dHJpYnV0ZVR5cGUuVU5ERUZJTkVEO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIGYoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTApO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLnJlYWRGbG9hdDMyKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDAuMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5Mb25nXG4gICAgICovXG4gICAgaSgpOiBmbGF0YnVmZmVycy5Mb25nIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTIpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLnJlYWRJbnQ2NCh0aGlzLmJiX3BvcyArIG9mZnNldCkgOiB0aGlzLmJiIS5jcmVhdGVMb25nKDAsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5FbmNvZGluZz0gb3B0aW9uYWxFbmNvZGluZ1xuICAgICAqIEByZXR1cm5zIHN0cmluZ3xVaW50OEFycmF5fG51bGxcbiAgICAgKi9cbiAgICBzKCk6IHN0cmluZyB8IG51bGw7XG4gICAgcyhvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZyB8IFVpbnQ4QXJyYXkgfCBudWxsO1xuICAgIHMob3B0aW9uYWxFbmNvZGluZz86IGFueSk6IHN0cmluZyB8IFVpbnQ4QXJyYXkgfCBudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmJfcG9zICsgb2Zmc2V0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvcnxudWxsXG4gICAgICovXG4gICAgdChvYmo/OiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvcik6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yIHwgbnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDE2KTtcbiAgICAgIHJldHVybiBvZmZzZXRcbiAgICAgICAgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvcigpKS5fX2luaXQodGhpcy5iYiEuX19pbmRpcmVjdCh0aGlzLmJiX3BvcyArIG9mZnNldCksIHRoaXMuYmIhKVxuICAgICAgICA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuR3JhcGg9IG9ialxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuR3JhcGh8bnVsbFxuICAgICAqL1xuICAgIGcob2JqPzogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5HcmFwaCk6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuR3JhcGggfCBudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTgpO1xuICAgICAgcmV0dXJuIG9mZnNldFxuICAgICAgICA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuR3JhcGgoKSkuX19pbml0KHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYl9wb3MgKyBvZmZzZXQpLCB0aGlzLmJiISlcbiAgICAgICAgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBmbG9hdHMoaW5kZXg6IG51bWJlcik6IG51bWJlciB8IG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAyMCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEucmVhZEZsb2F0MzIodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgZmxvYXRzTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDIwKTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBGbG9hdDMyQXJyYXlcbiAgICAgKi9cbiAgICBmbG9hdHNBcnJheSgpOiBGbG9hdDMyQXJyYXkgfCBudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMjApO1xuICAgICAgcmV0dXJuIG9mZnNldFxuICAgICAgICA/IG5ldyBGbG9hdDMyQXJyYXkoXG4gICAgICAgICAgICB0aGlzLmJiIS5ieXRlcygpLmJ1ZmZlcixcbiAgICAgICAgICAgIHRoaXMuYmIhLmJ5dGVzKCkuYnl0ZU9mZnNldCArIHRoaXMuYmIhLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSxcbiAgICAgICAgICAgIHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCksXG4gICAgICAgICAgKVxuICAgICAgICA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpbmRleFxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLkxvbmdcbiAgICAgKi9cbiAgICBpbnRzKGluZGV4OiBudW1iZXIpOiBmbGF0YnVmZmVycy5Mb25nIHwgbnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDIyKTtcbiAgICAgIHJldHVybiBvZmZzZXRcbiAgICAgICAgPyB0aGlzLmJiIS5yZWFkSW50NjQodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA4KVxuICAgICAgICA6IHRoaXMuYmIhLmNyZWF0ZUxvbmcoMCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgaW50c0xlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAyMik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpbmRleFxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5FbmNvZGluZz0gb3B0aW9uYWxFbmNvZGluZ1xuICAgICAqIEByZXR1cm5zIHN0cmluZ3xVaW50OEFycmF5XG4gICAgICovXG4gICAgc3RyaW5ncyhpbmRleDogbnVtYmVyKTogc3RyaW5nO1xuICAgIHN0cmluZ3MoaW5kZXg6IG51bWJlciwgb3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmcgfCBVaW50OEFycmF5O1xuICAgIHN0cmluZ3MoaW5kZXg6IG51bWJlciwgb3B0aW9uYWxFbmNvZGluZz86IGFueSk6IHN0cmluZyB8IFVpbnQ4QXJyYXkgfCBudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMjQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmIhLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSArIGluZGV4ICogNCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIHN0cmluZ3NMZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMjQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3I9IG9ialxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yXG4gICAgICovXG4gICAgdGVuc29ycyhpbmRleDogbnVtYmVyLCBvYmo/OiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvcik6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yIHwgbnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDI2KTtcbiAgICAgIHJldHVybiBvZmZzZXRcbiAgICAgICAgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvcigpKS5fX2luaXQoXG4gICAgICAgICAgICB0aGlzLmJiIS5fX2luZGlyZWN0KHRoaXMuYmIhLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSArIGluZGV4ICogNCksXG4gICAgICAgICAgICB0aGlzLmJiISxcbiAgICAgICAgICApXG4gICAgICAgIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICB0ZW5zb3JzTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDI2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4XG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuR3JhcGg9IG9ialxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuR3JhcGhcbiAgICAgKi9cbiAgICBncmFwaHMoaW5kZXg6IG51bWJlciwgb2JqPzogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5HcmFwaCk6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuR3JhcGggfCBudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMjgpO1xuICAgICAgcmV0dXJuIG9mZnNldFxuICAgICAgICA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuR3JhcGgoKSkuX19pbml0KFxuICAgICAgICAgICAgdGhpcy5iYiEuX19pbmRpcmVjdCh0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCkgKyBpbmRleCAqIDQpLFxuICAgICAgICAgICAgdGhpcy5iYiEsXG4gICAgICAgICAgKVxuICAgICAgICA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgZ3JhcGhzTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDI4KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0QXR0cmlidXRlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRPYmplY3QoMTMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IG5hbWVPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkTmFtZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBuYW1lT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMCwgbmFtZU9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgZG9jU3RyaW5nT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZERvY1N0cmluZyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkb2NTdHJpbmdPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgxLCBkb2NTdHJpbmdPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5BdHRyaWJ1dGVUeXBlIHR5cGVcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkVHlwZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCB0eXBlOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkF0dHJpYnV0ZVR5cGUpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRJbnQzMigyLCB0eXBlLCBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkF0dHJpYnV0ZVR5cGUuVU5ERUZJTkVEKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBmXG4gICAgICovXG4gICAgc3RhdGljIGFkZEYoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZjogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkRmxvYXQzMigzLCBmLCAwLjApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuTG9uZyBpXG4gICAgICovXG4gICAgc3RhdGljIGFkZEkoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgaTogZmxhdGJ1ZmZlcnMuTG9uZykge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZEludDY0KDQsIGksIGJ1aWxkZXIuY3JlYXRlTG9uZygwLCAwKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgc09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRTKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIHNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCg1LCBzT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCB0T2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZFQoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgdE9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDYsIHRPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGdPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkRyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBnT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoNywgZ09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgZmxvYXRzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZEZsb2F0cyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBmbG9hdHNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCg4LCBmbG9hdHNPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gQXJyYXkuPG51bWJlcj4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVGbG9hdHNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogbnVtYmVyW10gfCBVaW50OEFycmF5KTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgZGF0YS5sZW5ndGgsIDQpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRGbG9hdDMyKGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWxkZXIuZW5kVmVjdG9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbnVtRWxlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRGbG9hdHNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbnVtRWxlbXM6IG51bWJlcikge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBudW1FbGVtcywgNCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgaW50c09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRJbnRzKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGludHNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCg5LCBpbnRzT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIEFycmF5LjxmbGF0YnVmZmVycy5Mb25nPiBkYXRhXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUludHNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogZmxhdGJ1ZmZlcnMuTG9uZ1tdKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoOCwgZGF0YS5sZW5ndGgsIDgpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRJbnQ2NChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0SW50c1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDgsIG51bUVsZW1zLCA4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBzdHJpbmdzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZFN0cmluZ3MoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgc3RyaW5nc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDEwLCBzdHJpbmdzT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIEFycmF5LjxmbGF0YnVmZmVycy5PZmZzZXQ+IGRhdGFcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlU3RyaW5nc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkYXRhOiBmbGF0YnVmZmVycy5PZmZzZXRbXSk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIGRhdGEubGVuZ3RoLCA0KTtcbiAgICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGJ1aWxkZXIuYWRkT2Zmc2V0KGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWxkZXIuZW5kVmVjdG9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbnVtRWxlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRTdHJpbmdzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgbnVtRWxlbXMsIDQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IHRlbnNvcnNPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkVGVuc29ycyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCB0ZW5zb3JzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMTEsIHRlbnNvcnNPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gQXJyYXkuPGZsYXRidWZmZXJzLk9mZnNldD4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVUZW5zb3JzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRhdGE6IGZsYXRidWZmZXJzLk9mZnNldFtdKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgZGF0YS5sZW5ndGgsIDQpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRPZmZzZXQoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVpbGRlci5lbmRWZWN0b3IoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBudW1FbGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydFRlbnNvcnNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbnVtRWxlbXM6IG51bWJlcikge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBudW1FbGVtcywgNCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgZ3JhcGhzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZEdyYXBocyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBncmFwaHNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgxMiwgZ3JhcGhzT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIEFycmF5LjxmbGF0YnVmZmVycy5PZmZzZXQ+IGRhdGFcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlR3JhcGhzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRhdGE6IGZsYXRidWZmZXJzLk9mZnNldFtdKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgZGF0YS5sZW5ndGgsIDQpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRPZmZzZXQoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVpbGRlci5lbmRWZWN0b3IoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBudW1FbGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydEdyYXBoc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIG51bUVsZW1zLCA0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGVuZEF0dHJpYnV0ZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGxldCBvZmZzZXQgPSBidWlsZGVyLmVuZE9iamVjdCgpO1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlQXR0cmlidXRlKFxuICAgICAgYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcixcbiAgICAgIG5hbWVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgIGRvY1N0cmluZ09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgdHlwZTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5BdHRyaWJ1dGVUeXBlLFxuICAgICAgZjogbnVtYmVyLFxuICAgICAgaTogZmxhdGJ1ZmZlcnMuTG9uZyxcbiAgICAgIHNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgIHRPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgIGdPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgIGZsb2F0c09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgaW50c09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgc3RyaW5nc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgdGVuc29yc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgZ3JhcGhzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIEF0dHJpYnV0ZS5zdGFydEF0dHJpYnV0ZShidWlsZGVyKTtcbiAgICAgIEF0dHJpYnV0ZS5hZGROYW1lKGJ1aWxkZXIsIG5hbWVPZmZzZXQpO1xuICAgICAgQXR0cmlidXRlLmFkZERvY1N0cmluZyhidWlsZGVyLCBkb2NTdHJpbmdPZmZzZXQpO1xuICAgICAgQXR0cmlidXRlLmFkZFR5cGUoYnVpbGRlciwgdHlwZSk7XG4gICAgICBBdHRyaWJ1dGUuYWRkRihidWlsZGVyLCBmKTtcbiAgICAgIEF0dHJpYnV0ZS5hZGRJKGJ1aWxkZXIsIGkpO1xuICAgICAgQXR0cmlidXRlLmFkZFMoYnVpbGRlciwgc09mZnNldCk7XG4gICAgICBBdHRyaWJ1dGUuYWRkVChidWlsZGVyLCB0T2Zmc2V0KTtcbiAgICAgIEF0dHJpYnV0ZS5hZGRHKGJ1aWxkZXIsIGdPZmZzZXQpO1xuICAgICAgQXR0cmlidXRlLmFkZEZsb2F0cyhidWlsZGVyLCBmbG9hdHNPZmZzZXQpO1xuICAgICAgQXR0cmlidXRlLmFkZEludHMoYnVpbGRlciwgaW50c09mZnNldCk7XG4gICAgICBBdHRyaWJ1dGUuYWRkU3RyaW5ncyhidWlsZGVyLCBzdHJpbmdzT2Zmc2V0KTtcbiAgICAgIEF0dHJpYnV0ZS5hZGRUZW5zb3JzKGJ1aWxkZXIsIHRlbnNvcnNPZmZzZXQpO1xuICAgICAgQXR0cmlidXRlLmFkZEdyYXBocyhidWlsZGVyLCBncmFwaHNPZmZzZXQpO1xuICAgICAgcmV0dXJuIEF0dHJpYnV0ZS5lbmRBdHRyaWJ1dGUoYnVpbGRlcik7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgY2xhc3MgR3JhcGgge1xuICAgIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIHwgbnVsbCA9IG51bGw7XG5cbiAgICBiYl9wb3MgPSAwO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaVxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHJldHVybnMgR3JhcGhcbiAgICAgKi9cbiAgICBfX2luaXQoaTogbnVtYmVyLCBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcik6IEdyYXBoIHtcbiAgICAgIHRoaXMuYmJfcG9zID0gaTtcbiAgICAgIHRoaXMuYmIgPSBiYjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIEdyYXBoPSBvYmpcbiAgICAgKiBAcmV0dXJucyBHcmFwaFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRSb290QXNHcmFwaChiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogR3JhcGgpOiBHcmFwaCB7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgR3JhcGgoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBHcmFwaD0gb2JqXG4gICAgICogQHJldHVybnMgR3JhcGhcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzR3JhcGgoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IEdyYXBoKTogR3JhcGgge1xuICAgICAgYmIuc2V0UG9zaXRpb24oYmIucG9zaXRpb24oKSArIGZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCk7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgR3JhcGgoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4XG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvclxuICAgICAqL1xuICAgIGluaXRpYWxpemVycyhpbmRleDogbnVtYmVyLCBvYmo/OiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvcik6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yIHwgbnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDQpO1xuICAgICAgcmV0dXJuIG9mZnNldFxuICAgICAgICA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yKCkpLl9faW5pdChcbiAgICAgICAgICAgIHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA0KSxcbiAgICAgICAgICAgIHRoaXMuYmIhLFxuICAgICAgICAgIClcbiAgICAgICAgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIGluaXRpYWxpemVyc0xlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4XG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVmFsdWVJbmZvPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlZhbHVlSW5mb1xuICAgICAqL1xuICAgIG5vZGVBcmdzKFxuICAgICAgaW5kZXg6IG51bWJlcixcbiAgICAgIG9iaj86IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVmFsdWVJbmZvLFxuICAgICk6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVmFsdWVJbmZvIHwgbnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDYpO1xuICAgICAgcmV0dXJuIG9mZnNldFxuICAgICAgICA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVmFsdWVJbmZvKCkpLl9faW5pdChcbiAgICAgICAgICAgIHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA0KSxcbiAgICAgICAgICAgIHRoaXMuYmIhLFxuICAgICAgICAgIClcbiAgICAgICAgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIG5vZGVBcmdzTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDYpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5Ob2RlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLk5vZGVcbiAgICAgKi9cbiAgICBub2RlcyhpbmRleDogbnVtYmVyLCBvYmo/OiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLk5vZGUpOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLk5vZGUgfCBudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgOCk7XG4gICAgICByZXR1cm4gb2Zmc2V0XG4gICAgICAgID8gKG9iaiB8fCBuZXcgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5Ob2RlKCkpLl9faW5pdChcbiAgICAgICAgICAgIHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA0KSxcbiAgICAgICAgICAgIHRoaXMuYmIhLFxuICAgICAgICAgIClcbiAgICAgICAgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIG5vZGVzTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDgpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIG1heE5vZGVJbmRleCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxMCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEucmVhZFVpbnQzMih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5Ob2RlRWRnZT0gb2JqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5Ob2RlRWRnZVxuICAgICAqL1xuICAgIG5vZGVFZGdlcyhcbiAgICAgIGluZGV4OiBudW1iZXIsXG4gICAgICBvYmo/OiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLk5vZGVFZGdlLFxuICAgICk6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuTm9kZUVkZ2UgfCBudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTIpO1xuICAgICAgcmV0dXJuIG9mZnNldFxuICAgICAgICA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuTm9kZUVkZ2UoKSkuX19pbml0KFxuICAgICAgICAgICAgdGhpcy5iYiEuX19pbmRpcmVjdCh0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCkgKyBpbmRleCAqIDQpLFxuICAgICAgICAgICAgdGhpcy5iYiEsXG4gICAgICAgICAgKVxuICAgICAgICA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgbm9kZUVkZ2VzTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDEyKTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4XG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXlcbiAgICAgKi9cbiAgICBpbnB1dHMoaW5kZXg6IG51bWJlcik6IHN0cmluZztcbiAgICBpbnB1dHMoaW5kZXg6IG51bWJlciwgb3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmcgfCBVaW50OEFycmF5O1xuICAgIGlucHV0cyhpbmRleDogbnVtYmVyLCBvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nIHwgVWludDhBcnJheSB8IG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX19zdHJpbmcodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgaW5wdXRzTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDE0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4XG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXlcbiAgICAgKi9cbiAgICBvdXRwdXRzKGluZGV4OiBudW1iZXIpOiBzdHJpbmc7XG4gICAgb3V0cHV0cyhpbmRleDogbnVtYmVyLCBvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZyB8IFVpbnQ4QXJyYXk7XG4gICAgb3V0cHV0cyhpbmRleDogbnVtYmVyLCBvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nIHwgVWludDhBcnJheSB8IG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxNik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX19zdHJpbmcodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgb3V0cHV0c0xlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxNik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpbmRleFxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlNwYXJzZVRlbnNvcj0gb2JqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5TcGFyc2VUZW5zb3JcbiAgICAgKi9cbiAgICBzcGFyc2VJbml0aWFsaXplcnMoXG4gICAgICBpbmRleDogbnVtYmVyLFxuICAgICAgb2JqPzogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5TcGFyc2VUZW5zb3IsXG4gICAgKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5TcGFyc2VUZW5zb3IgfCBudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTgpO1xuICAgICAgcmV0dXJuIG9mZnNldFxuICAgICAgICA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuU3BhcnNlVGVuc29yKCkpLl9faW5pdChcbiAgICAgICAgICAgIHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA0KSxcbiAgICAgICAgICAgIHRoaXMuYmIhLFxuICAgICAgICAgIClcbiAgICAgICAgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIHNwYXJzZUluaXRpYWxpemVyc0xlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxOCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydEdyYXBoKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRPYmplY3QoOCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgaW5pdGlhbGl6ZXJzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZEluaXRpYWxpemVycyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBpbml0aWFsaXplcnNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgwLCBpbml0aWFsaXplcnNPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gQXJyYXkuPGZsYXRidWZmZXJzLk9mZnNldD4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVJbml0aWFsaXplcnNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogZmxhdGJ1ZmZlcnMuT2Zmc2V0W10pOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBkYXRhLmxlbmd0aCwgNCk7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBidWlsZGVyLmFkZE9mZnNldChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0SW5pdGlhbGl6ZXJzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgbnVtRWxlbXMsIDQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IG5vZGVBcmdzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZE5vZGVBcmdzKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG5vZGVBcmdzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMSwgbm9kZUFyZ3NPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gQXJyYXkuPGZsYXRidWZmZXJzLk9mZnNldD4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVOb2RlQXJnc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkYXRhOiBmbGF0YnVmZmVycy5PZmZzZXRbXSk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIGRhdGEubGVuZ3RoLCA0KTtcbiAgICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGJ1aWxkZXIuYWRkT2Zmc2V0KGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWxkZXIuZW5kVmVjdG9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbnVtRWxlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnROb2RlQXJnc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIG51bUVsZW1zLCA0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBub2Rlc09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGROb2RlcyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBub2Rlc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDIsIG5vZGVzT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIEFycmF5LjxmbGF0YnVmZmVycy5PZmZzZXQ+IGRhdGFcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlTm9kZXNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogZmxhdGJ1ZmZlcnMuT2Zmc2V0W10pOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBkYXRhLmxlbmd0aCwgNCk7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBidWlsZGVyLmFkZE9mZnNldChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0Tm9kZXNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbnVtRWxlbXM6IG51bWJlcikge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBudW1FbGVtcywgNCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbWF4Tm9kZUluZGV4XG4gICAgICovXG4gICAgc3RhdGljIGFkZE1heE5vZGVJbmRleChidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBtYXhOb2RlSW5kZXg6IG51bWJlcikge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZEludDMyKDMsIG1heE5vZGVJbmRleCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgbm9kZUVkZ2VzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZE5vZGVFZGdlcyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBub2RlRWRnZXNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCg0LCBub2RlRWRnZXNPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gQXJyYXkuPGZsYXRidWZmZXJzLk9mZnNldD4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVOb2RlRWRnZXNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogZmxhdGJ1ZmZlcnMuT2Zmc2V0W10pOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBkYXRhLmxlbmd0aCwgNCk7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBidWlsZGVyLmFkZE9mZnNldChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0Tm9kZUVkZ2VzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgbnVtRWxlbXMsIDQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGlucHV0c09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRJbnB1dHMoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgaW5wdXRzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoNSwgaW5wdXRzT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIEFycmF5LjxmbGF0YnVmZmVycy5PZmZzZXQ+IGRhdGFcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlSW5wdXRzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRhdGE6IGZsYXRidWZmZXJzLk9mZnNldFtdKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgZGF0YS5sZW5ndGgsIDQpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRPZmZzZXQoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVpbGRlci5lbmRWZWN0b3IoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBudW1FbGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydElucHV0c1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIG51bUVsZW1zLCA0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBvdXRwdXRzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZE91dHB1dHMoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgb3V0cHV0c09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDYsIG91dHB1dHNPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gQXJyYXkuPGZsYXRidWZmZXJzLk9mZnNldD4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVPdXRwdXRzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRhdGE6IGZsYXRidWZmZXJzLk9mZnNldFtdKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgZGF0YS5sZW5ndGgsIDQpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRPZmZzZXQoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVpbGRlci5lbmRWZWN0b3IoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBudW1FbGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydE91dHB1dHNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbnVtRWxlbXM6IG51bWJlcikge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBudW1FbGVtcywgNCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgc3BhcnNlSW5pdGlhbGl6ZXJzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZFNwYXJzZUluaXRpYWxpemVycyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBzcGFyc2VJbml0aWFsaXplcnNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCg3LCBzcGFyc2VJbml0aWFsaXplcnNPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gQXJyYXkuPGZsYXRidWZmZXJzLk9mZnNldD4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVTcGFyc2VJbml0aWFsaXplcnNWZWN0b3IoXG4gICAgICBidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLFxuICAgICAgZGF0YTogZmxhdGJ1ZmZlcnMuT2Zmc2V0W10sXG4gICAgKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgZGF0YS5sZW5ndGgsIDQpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRPZmZzZXQoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVpbGRlci5lbmRWZWN0b3IoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBudW1FbGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydFNwYXJzZUluaXRpYWxpemVyc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIG51bUVsZW1zLCA0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGVuZEdyYXBoKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgbGV0IG9mZnNldCA9IGJ1aWxkZXIuZW5kT2JqZWN0KCk7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGVHcmFwaChcbiAgICAgIGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsXG4gICAgICBpbml0aWFsaXplcnNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgIG5vZGVBcmdzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICBub2Rlc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgbWF4Tm9kZUluZGV4OiBudW1iZXIsXG4gICAgICBub2RlRWRnZXNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgIGlucHV0c09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgb3V0cHV0c09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgc3BhcnNlSW5pdGlhbGl6ZXJzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIEdyYXBoLnN0YXJ0R3JhcGgoYnVpbGRlcik7XG4gICAgICBHcmFwaC5hZGRJbml0aWFsaXplcnMoYnVpbGRlciwgaW5pdGlhbGl6ZXJzT2Zmc2V0KTtcbiAgICAgIEdyYXBoLmFkZE5vZGVBcmdzKGJ1aWxkZXIsIG5vZGVBcmdzT2Zmc2V0KTtcbiAgICAgIEdyYXBoLmFkZE5vZGVzKGJ1aWxkZXIsIG5vZGVzT2Zmc2V0KTtcbiAgICAgIEdyYXBoLmFkZE1heE5vZGVJbmRleChidWlsZGVyLCBtYXhOb2RlSW5kZXgpO1xuICAgICAgR3JhcGguYWRkTm9kZUVkZ2VzKGJ1aWxkZXIsIG5vZGVFZGdlc09mZnNldCk7XG4gICAgICBHcmFwaC5hZGRJbnB1dHMoYnVpbGRlciwgaW5wdXRzT2Zmc2V0KTtcbiAgICAgIEdyYXBoLmFkZE91dHB1dHMoYnVpbGRlciwgb3V0cHV0c09mZnNldCk7XG4gICAgICBHcmFwaC5hZGRTcGFyc2VJbml0aWFsaXplcnMoYnVpbGRlciwgc3BhcnNlSW5pdGlhbGl6ZXJzT2Zmc2V0KTtcbiAgICAgIHJldHVybiBHcmFwaC5lbmRHcmFwaChidWlsZGVyKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBuYW1lc3BhY2Ugb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicyB7XG4gIGV4cG9ydCBjbGFzcyBNb2RlbCB7XG4gICAgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgfCBudWxsID0gbnVsbDtcblxuICAgIGJiX3BvcyA9IDA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcmV0dXJucyBNb2RlbFxuICAgICAqL1xuICAgIF9faW5pdChpOiBudW1iZXIsIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyKTogTW9kZWwge1xuICAgICAgdGhpcy5iYl9wb3MgPSBpO1xuICAgICAgdGhpcy5iYiA9IGJiO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gTW9kZWw9IG9ialxuICAgICAqIEByZXR1cm5zIE1vZGVsXG4gICAgICovXG4gICAgc3RhdGljIGdldFJvb3RBc01vZGVsKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBNb2RlbCk6IE1vZGVsIHtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBNb2RlbCgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIE1vZGVsPSBvYmpcbiAgICAgKiBAcmV0dXJucyBNb2RlbFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNNb2RlbChiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogTW9kZWwpOiBNb2RlbCB7XG4gICAgICBiYi5zZXRQb3NpdGlvbihiYi5wb3NpdGlvbigpICsgZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKTtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBNb2RlbCgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLkxvbmdcbiAgICAgKi9cbiAgICBpclZlcnNpb24oKTogZmxhdGJ1ZmZlcnMuTG9uZyB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLnJlYWRJbnQ2NCh0aGlzLmJiX3BvcyArIG9mZnNldCkgOiB0aGlzLmJiIS5jcmVhdGVMb25nKDAsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5PcGVyYXRvclNldElkPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLk9wZXJhdG9yU2V0SWRcbiAgICAgKi9cbiAgICBvcHNldEltcG9ydChcbiAgICAgIGluZGV4OiBudW1iZXIsXG4gICAgICBvYmo/OiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLk9wZXJhdG9yU2V0SWQsXG4gICAgKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5PcGVyYXRvclNldElkIHwgbnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDYpO1xuICAgICAgcmV0dXJuIG9mZnNldFxuICAgICAgICA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuT3BlcmF0b3JTZXRJZCgpKS5fX2luaXQoXG4gICAgICAgICAgICB0aGlzLmJiIS5fX2luZGlyZWN0KHRoaXMuYmIhLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSArIGluZGV4ICogNCksXG4gICAgICAgICAgICB0aGlzLmJiISxcbiAgICAgICAgICApXG4gICAgICAgIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBvcHNldEltcG9ydExlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheXxudWxsXG4gICAgICovXG4gICAgcHJvZHVjZXJOYW1lKCk6IHN0cmluZyB8IG51bGw7XG4gICAgcHJvZHVjZXJOYW1lKG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nIHwgVWludDhBcnJheSB8IG51bGw7XG4gICAgcHJvZHVjZXJOYW1lKG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmcgfCBVaW50OEFycmF5IHwgbnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDgpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmJfcG9zICsgb2Zmc2V0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbFxuICAgICAqL1xuICAgIHByb2R1Y2VyVmVyc2lvbigpOiBzdHJpbmcgfCBudWxsO1xuICAgIHByb2R1Y2VyVmVyc2lvbihvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZyB8IFVpbnQ4QXJyYXkgfCBudWxsO1xuICAgIHByb2R1Y2VyVmVyc2lvbihvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nIHwgVWludDhBcnJheSB8IG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxMCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX19zdHJpbmcodGhpcy5iYl9wb3MgKyBvZmZzZXQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheXxudWxsXG4gICAgICovXG4gICAgZG9tYWluKCk6IHN0cmluZyB8IG51bGw7XG4gICAgZG9tYWluKG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nIHwgVWludDhBcnJheSB8IG51bGw7XG4gICAgZG9tYWluKG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmcgfCBVaW50OEFycmF5IHwgbnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDEyKTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiX3BvcyArIG9mZnNldCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLkxvbmdcbiAgICAgKi9cbiAgICBtb2RlbFZlcnNpb24oKTogZmxhdGJ1ZmZlcnMuTG9uZyB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDE0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5yZWFkSW50NjQodGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogdGhpcy5iYiEuY3JlYXRlTG9uZygwLCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheXxudWxsXG4gICAgICovXG4gICAgZG9jU3RyaW5nKCk6IHN0cmluZyB8IG51bGw7XG4gICAgZG9jU3RyaW5nKG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nIHwgVWludDhBcnJheSB8IG51bGw7XG4gICAgZG9jU3RyaW5nKG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmcgfCBVaW50OEFycmF5IHwgbnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDE2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiX3BvcyArIG9mZnNldCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkdyYXBoPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkdyYXBofG51bGxcbiAgICAgKi9cbiAgICBncmFwaChvYmo/OiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkdyYXBoKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5HcmFwaCB8IG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxOCk7XG4gICAgICByZXR1cm4gb2Zmc2V0XG4gICAgICAgID8gKG9iaiB8fCBuZXcgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5HcmFwaCgpKS5fX2luaXQodGhpcy5iYiEuX19pbmRpcmVjdCh0aGlzLmJiX3BvcyArIG9mZnNldCksIHRoaXMuYmIhKVxuICAgICAgICA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbFxuICAgICAqL1xuICAgIGdyYXBoRG9jU3RyaW5nKCk6IHN0cmluZyB8IG51bGw7XG4gICAgZ3JhcGhEb2NTdHJpbmcob3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmcgfCBVaW50OEFycmF5IHwgbnVsbDtcbiAgICBncmFwaERvY1N0cmluZyhvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nIHwgVWludDhBcnJheSB8IG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAyMCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX19zdHJpbmcodGhpcy5iYl9wb3MgKyBvZmZzZXQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0TW9kZWwoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcikge1xuICAgICAgYnVpbGRlci5zdGFydE9iamVjdCg5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkxvbmcgaXJWZXJzaW9uXG4gICAgICovXG4gICAgc3RhdGljIGFkZElyVmVyc2lvbihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBpclZlcnNpb246IGZsYXRidWZmZXJzLkxvbmcpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRJbnQ2NCgwLCBpclZlcnNpb24sIGJ1aWxkZXIuY3JlYXRlTG9uZygwLCAwKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgb3BzZXRJbXBvcnRPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkT3BzZXRJbXBvcnQoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgb3BzZXRJbXBvcnRPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgxLCBvcHNldEltcG9ydE9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBBcnJheS48ZmxhdGJ1ZmZlcnMuT2Zmc2V0PiBkYXRhXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZU9wc2V0SW1wb3J0VmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRhdGE6IGZsYXRidWZmZXJzLk9mZnNldFtdKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgZGF0YS5sZW5ndGgsIDQpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRPZmZzZXQoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVpbGRlci5lbmRWZWN0b3IoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBudW1FbGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydE9wc2V0SW1wb3J0VmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgbnVtRWxlbXMsIDQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IHByb2R1Y2VyTmFtZU9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRQcm9kdWNlck5hbWUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgcHJvZHVjZXJOYW1lT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMiwgcHJvZHVjZXJOYW1lT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBwcm9kdWNlclZlcnNpb25PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkUHJvZHVjZXJWZXJzaW9uKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIHByb2R1Y2VyVmVyc2lvbk9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDMsIHByb2R1Y2VyVmVyc2lvbk9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgZG9tYWluT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZERvbWFpbihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkb21haW5PZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCg0LCBkb21haW5PZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuTG9uZyBtb2RlbFZlcnNpb25cbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkTW9kZWxWZXJzaW9uKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG1vZGVsVmVyc2lvbjogZmxhdGJ1ZmZlcnMuTG9uZykge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZEludDY0KDUsIG1vZGVsVmVyc2lvbiwgYnVpbGRlci5jcmVhdGVMb25nKDAsIDApKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBkb2NTdHJpbmdPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkRG9jU3RyaW5nKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRvY1N0cmluZ09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDYsIGRvY1N0cmluZ09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgZ3JhcGhPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkR3JhcGgoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZ3JhcGhPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCg3LCBncmFwaE9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgZ3JhcGhEb2NTdHJpbmdPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkR3JhcGhEb2NTdHJpbmcoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZ3JhcGhEb2NTdHJpbmdPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCg4LCBncmFwaERvY1N0cmluZ09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBlbmRNb2RlbChidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGxldCBvZmZzZXQgPSBidWlsZGVyLmVuZE9iamVjdCgpO1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlTW9kZWwoXG4gICAgICBidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLFxuICAgICAgaXJWZXJzaW9uOiBmbGF0YnVmZmVycy5Mb25nLFxuICAgICAgb3BzZXRJbXBvcnRPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgIHByb2R1Y2VyTmFtZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgcHJvZHVjZXJWZXJzaW9uT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICBkb21haW5PZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgIG1vZGVsVmVyc2lvbjogZmxhdGJ1ZmZlcnMuTG9uZyxcbiAgICAgIGRvY1N0cmluZ09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgZ3JhcGhPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgIGdyYXBoRG9jU3RyaW5nT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIE1vZGVsLnN0YXJ0TW9kZWwoYnVpbGRlcik7XG4gICAgICBNb2RlbC5hZGRJclZlcnNpb24oYnVpbGRlciwgaXJWZXJzaW9uKTtcbiAgICAgIE1vZGVsLmFkZE9wc2V0SW1wb3J0KGJ1aWxkZXIsIG9wc2V0SW1wb3J0T2Zmc2V0KTtcbiAgICAgIE1vZGVsLmFkZFByb2R1Y2VyTmFtZShidWlsZGVyLCBwcm9kdWNlck5hbWVPZmZzZXQpO1xuICAgICAgTW9kZWwuYWRkUHJvZHVjZXJWZXJzaW9uKGJ1aWxkZXIsIHByb2R1Y2VyVmVyc2lvbk9mZnNldCk7XG4gICAgICBNb2RlbC5hZGREb21haW4oYnVpbGRlciwgZG9tYWluT2Zmc2V0KTtcbiAgICAgIE1vZGVsLmFkZE1vZGVsVmVyc2lvbihidWlsZGVyLCBtb2RlbFZlcnNpb24pO1xuICAgICAgTW9kZWwuYWRkRG9jU3RyaW5nKGJ1aWxkZXIsIGRvY1N0cmluZ09mZnNldCk7XG4gICAgICBNb2RlbC5hZGRHcmFwaChidWlsZGVyLCBncmFwaE9mZnNldCk7XG4gICAgICBNb2RlbC5hZGRHcmFwaERvY1N0cmluZyhidWlsZGVyLCBncmFwaERvY1N0cmluZ09mZnNldCk7XG4gICAgICByZXR1cm4gTW9kZWwuZW5kTW9kZWwoYnVpbGRlcik7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgY2xhc3MgS2VybmVsQ3JlYXRlSW5mb3Mge1xuICAgIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIHwgbnVsbCA9IG51bGw7XG5cbiAgICBiYl9wb3MgPSAwO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaVxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHJldHVybnMgS2VybmVsQ3JlYXRlSW5mb3NcbiAgICAgKi9cbiAgICBfX2luaXQoaTogbnVtYmVyLCBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcik6IEtlcm5lbENyZWF0ZUluZm9zIHtcbiAgICAgIHRoaXMuYmJfcG9zID0gaTtcbiAgICAgIHRoaXMuYmIgPSBiYjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIEtlcm5lbENyZWF0ZUluZm9zPSBvYmpcbiAgICAgKiBAcmV0dXJucyBLZXJuZWxDcmVhdGVJbmZvc1xuICAgICAqL1xuICAgIHN0YXRpYyBnZXRSb290QXNLZXJuZWxDcmVhdGVJbmZvcyhiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogS2VybmVsQ3JlYXRlSW5mb3MpOiBLZXJuZWxDcmVhdGVJbmZvcyB7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgS2VybmVsQ3JlYXRlSW5mb3MoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBLZXJuZWxDcmVhdGVJbmZvcz0gb2JqXG4gICAgICogQHJldHVybnMgS2VybmVsQ3JlYXRlSW5mb3NcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzS2VybmVsQ3JlYXRlSW5mb3MoXG4gICAgICBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcixcbiAgICAgIG9iaj86IEtlcm5lbENyZWF0ZUluZm9zLFxuICAgICk6IEtlcm5lbENyZWF0ZUluZm9zIHtcbiAgICAgIGJiLnNldFBvc2l0aW9uKGJiLnBvc2l0aW9uKCkgKyBmbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpO1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IEtlcm5lbENyZWF0ZUluZm9zKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpbmRleFxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIG5vZGVJbmRpY2VzKGluZGV4OiBudW1iZXIpOiBudW1iZXIgfCBudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEucmVhZFVpbnQzMih0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCkgKyBpbmRleCAqIDQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBub2RlSW5kaWNlc0xlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBVaW50MzJBcnJheVxuICAgICAqL1xuICAgIG5vZGVJbmRpY2VzQXJyYXkoKTogVWludDMyQXJyYXkgfCBudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0XG4gICAgICAgID8gbmV3IFVpbnQzMkFycmF5KFxuICAgICAgICAgICAgdGhpcy5iYiEuYnl0ZXMoKS5idWZmZXIsXG4gICAgICAgICAgICB0aGlzLmJiIS5ieXRlcygpLmJ5dGVPZmZzZXQgKyB0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCksXG4gICAgICAgICAgICB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpLFxuICAgICAgICAgIClcbiAgICAgICAgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5Mb25nXG4gICAgICovXG4gICAga2VybmVsRGVmSGFzaGVzKGluZGV4OiBudW1iZXIpOiBmbGF0YnVmZmVycy5Mb25nIHwgbnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDYpO1xuICAgICAgcmV0dXJuIG9mZnNldFxuICAgICAgICA/IHRoaXMuYmIhLnJlYWRVaW50NjQodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA4KVxuICAgICAgICA6IHRoaXMuYmIhLmNyZWF0ZUxvbmcoMCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAga2VybmVsRGVmSGFzaGVzTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDYpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRLZXJuZWxDcmVhdGVJbmZvcyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0T2JqZWN0KDIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IG5vZGVJbmRpY2VzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZE5vZGVJbmRpY2VzKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG5vZGVJbmRpY2VzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMCwgbm9kZUluZGljZXNPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gQXJyYXkuPG51bWJlcj4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVOb2RlSW5kaWNlc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkYXRhOiBudW1iZXJbXSB8IFVpbnQ4QXJyYXkpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBkYXRhLmxlbmd0aCwgNCk7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBidWlsZGVyLmFkZEludDMyKGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWxkZXIuZW5kVmVjdG9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbnVtRWxlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnROb2RlSW5kaWNlc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIG51bUVsZW1zLCA0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBrZXJuZWxEZWZIYXNoZXNPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkS2VybmVsRGVmSGFzaGVzKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGtlcm5lbERlZkhhc2hlc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDEsIGtlcm5lbERlZkhhc2hlc09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBBcnJheS48ZmxhdGJ1ZmZlcnMuTG9uZz4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVLZXJuZWxEZWZIYXNoZXNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogZmxhdGJ1ZmZlcnMuTG9uZ1tdKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoOCwgZGF0YS5sZW5ndGgsIDgpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRJbnQ2NChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0S2VybmVsRGVmSGFzaGVzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoOCwgbnVtRWxlbXMsIDgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZW5kS2VybmVsQ3JlYXRlSW5mb3MoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcik6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gYnVpbGRlci5lbmRPYmplY3QoKTtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZUtlcm5lbENyZWF0ZUluZm9zKFxuICAgICAgYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcixcbiAgICAgIG5vZGVJbmRpY2VzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICBrZXJuZWxEZWZIYXNoZXNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICApOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgS2VybmVsQ3JlYXRlSW5mb3Muc3RhcnRLZXJuZWxDcmVhdGVJbmZvcyhidWlsZGVyKTtcbiAgICAgIEtlcm5lbENyZWF0ZUluZm9zLmFkZE5vZGVJbmRpY2VzKGJ1aWxkZXIsIG5vZGVJbmRpY2VzT2Zmc2V0KTtcbiAgICAgIEtlcm5lbENyZWF0ZUluZm9zLmFkZEtlcm5lbERlZkhhc2hlcyhidWlsZGVyLCBrZXJuZWxEZWZIYXNoZXNPZmZzZXQpO1xuICAgICAgcmV0dXJuIEtlcm5lbENyZWF0ZUluZm9zLmVuZEtlcm5lbENyZWF0ZUluZm9zKGJ1aWxkZXIpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzIHtcbiAgZXhwb3J0IGNsYXNzIFN1YkdyYXBoU2Vzc2lvblN0YXRlIHtcbiAgICBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciB8IG51bGwgPSBudWxsO1xuXG4gICAgYmJfcG9zID0gMDtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGlcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEByZXR1cm5zIFN1YkdyYXBoU2Vzc2lvblN0YXRlXG4gICAgICovXG4gICAgX19pbml0KGk6IG51bWJlciwgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIpOiBTdWJHcmFwaFNlc3Npb25TdGF0ZSB7XG4gICAgICB0aGlzLmJiX3BvcyA9IGk7XG4gICAgICB0aGlzLmJiID0gYmI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBTdWJHcmFwaFNlc3Npb25TdGF0ZT0gb2JqXG4gICAgICogQHJldHVybnMgU3ViR3JhcGhTZXNzaW9uU3RhdGVcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Um9vdEFzU3ViR3JhcGhTZXNzaW9uU3RhdGUoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IFN1YkdyYXBoU2Vzc2lvblN0YXRlKTogU3ViR3JhcGhTZXNzaW9uU3RhdGUge1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IFN1YkdyYXBoU2Vzc2lvblN0YXRlKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gU3ViR3JhcGhTZXNzaW9uU3RhdGU9IG9ialxuICAgICAqIEByZXR1cm5zIFN1YkdyYXBoU2Vzc2lvblN0YXRlXG4gICAgICovXG4gICAgc3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc1N1YkdyYXBoU2Vzc2lvblN0YXRlKFxuICAgICAgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsXG4gICAgICBvYmo/OiBTdWJHcmFwaFNlc3Npb25TdGF0ZSxcbiAgICApOiBTdWJHcmFwaFNlc3Npb25TdGF0ZSB7XG4gICAgICBiYi5zZXRQb3NpdGlvbihiYi5wb3NpdGlvbigpICsgZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKTtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBTdWJHcmFwaFNlc3Npb25TdGF0ZSgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5FbmNvZGluZz0gb3B0aW9uYWxFbmNvZGluZ1xuICAgICAqIEByZXR1cm5zIHN0cmluZ3xVaW50OEFycmF5fG51bGxcbiAgICAgKi9cbiAgICBncmFwaElkKCk6IHN0cmluZyB8IG51bGw7XG4gICAgZ3JhcGhJZChvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZyB8IFVpbnQ4QXJyYXkgfCBudWxsO1xuICAgIGdyYXBoSWQob3B0aW9uYWxFbmNvZGluZz86IGFueSk6IHN0cmluZyB8IFVpbnQ4QXJyYXkgfCBudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX19zdHJpbmcodGhpcy5iYl9wb3MgKyBvZmZzZXQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5TZXNzaW9uU3RhdGU9IG9ialxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuU2Vzc2lvblN0YXRlfG51bGxcbiAgICAgKi9cbiAgICBzZXNzaW9uU3RhdGUob2JqPzogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5TZXNzaW9uU3RhdGUpOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlNlc3Npb25TdGF0ZSB8IG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgIHJldHVybiBvZmZzZXRcbiAgICAgICAgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlNlc3Npb25TdGF0ZSgpKS5fX2luaXQoXG4gICAgICAgICAgICB0aGlzLmJiIS5fX2luZGlyZWN0KHRoaXMuYmJfcG9zICsgb2Zmc2V0KSxcbiAgICAgICAgICAgIHRoaXMuYmIhLFxuICAgICAgICAgIClcbiAgICAgICAgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRTdWJHcmFwaFNlc3Npb25TdGF0ZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0T2JqZWN0KDIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGdyYXBoSWRPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkR3JhcGhJZChidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBncmFwaElkT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMCwgZ3JhcGhJZE9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgc2Vzc2lvblN0YXRlT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZFNlc3Npb25TdGF0ZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBzZXNzaW9uU3RhdGVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgxLCBzZXNzaW9uU3RhdGVPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZW5kU3ViR3JhcGhTZXNzaW9uU3RhdGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcik6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gYnVpbGRlci5lbmRPYmplY3QoKTtcbiAgICAgIGJ1aWxkZXIucmVxdWlyZWRGaWVsZChvZmZzZXQsIDQpOyAvLyBncmFwaF9pZFxuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlU3ViR3JhcGhTZXNzaW9uU3RhdGUoXG4gICAgICBidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLFxuICAgICAgZ3JhcGhJZE9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgc2Vzc2lvblN0YXRlT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIFN1YkdyYXBoU2Vzc2lvblN0YXRlLnN0YXJ0U3ViR3JhcGhTZXNzaW9uU3RhdGUoYnVpbGRlcik7XG4gICAgICBTdWJHcmFwaFNlc3Npb25TdGF0ZS5hZGRHcmFwaElkKGJ1aWxkZXIsIGdyYXBoSWRPZmZzZXQpO1xuICAgICAgU3ViR3JhcGhTZXNzaW9uU3RhdGUuYWRkU2Vzc2lvblN0YXRlKGJ1aWxkZXIsIHNlc3Npb25TdGF0ZU9mZnNldCk7XG4gICAgICByZXR1cm4gU3ViR3JhcGhTZXNzaW9uU3RhdGUuZW5kU3ViR3JhcGhTZXNzaW9uU3RhdGUoYnVpbGRlcik7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgY2xhc3MgU2Vzc2lvblN0YXRlIHtcbiAgICBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciB8IG51bGwgPSBudWxsO1xuXG4gICAgYmJfcG9zID0gMDtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGlcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEByZXR1cm5zIFNlc3Npb25TdGF0ZVxuICAgICAqL1xuICAgIF9faW5pdChpOiBudW1iZXIsIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyKTogU2Vzc2lvblN0YXRlIHtcbiAgICAgIHRoaXMuYmJfcG9zID0gaTtcbiAgICAgIHRoaXMuYmIgPSBiYjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIFNlc3Npb25TdGF0ZT0gb2JqXG4gICAgICogQHJldHVybnMgU2Vzc2lvblN0YXRlXG4gICAgICovXG4gICAgc3RhdGljIGdldFJvb3RBc1Nlc3Npb25TdGF0ZShiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogU2Vzc2lvblN0YXRlKTogU2Vzc2lvblN0YXRlIHtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBTZXNzaW9uU3RhdGUoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBTZXNzaW9uU3RhdGU9IG9ialxuICAgICAqIEByZXR1cm5zIFNlc3Npb25TdGF0ZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNTZXNzaW9uU3RhdGUoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IFNlc3Npb25TdGF0ZSk6IFNlc3Npb25TdGF0ZSB7XG4gICAgICBiYi5zZXRQb3NpdGlvbihiYi5wb3NpdGlvbigpICsgZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKTtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBTZXNzaW9uU3RhdGUoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5LZXJuZWxDcmVhdGVJbmZvcz0gb2JqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5LZXJuZWxDcmVhdGVJbmZvc3xudWxsXG4gICAgICovXG4gICAga2VybmVscyhcbiAgICAgIG9iaj86IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuS2VybmVsQ3JlYXRlSW5mb3MsXG4gICAgKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5LZXJuZWxDcmVhdGVJbmZvcyB8IG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgIHJldHVybiBvZmZzZXRcbiAgICAgICAgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLktlcm5lbENyZWF0ZUluZm9zKCkpLl9faW5pdChcbiAgICAgICAgICAgIHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYl9wb3MgKyBvZmZzZXQpLFxuICAgICAgICAgICAgdGhpcy5iYiEsXG4gICAgICAgICAgKVxuICAgICAgICA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpbmRleFxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlN1YkdyYXBoU2Vzc2lvblN0YXRlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlN1YkdyYXBoU2Vzc2lvblN0YXRlXG4gICAgICovXG4gICAgc3ViR3JhcGhTZXNzaW9uU3RhdGVzKFxuICAgICAgaW5kZXg6IG51bWJlcixcbiAgICAgIG9iaj86IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuU3ViR3JhcGhTZXNzaW9uU3RhdGUsXG4gICAgKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5TdWJHcmFwaFNlc3Npb25TdGF0ZSB8IG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgIHJldHVybiBvZmZzZXRcbiAgICAgICAgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlN1YkdyYXBoU2Vzc2lvblN0YXRlKCkpLl9faW5pdChcbiAgICAgICAgICAgIHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA0KSxcbiAgICAgICAgICAgIHRoaXMuYmIhLFxuICAgICAgICAgIClcbiAgICAgICAgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIHN1YkdyYXBoU2Vzc2lvblN0YXRlc0xlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0U2Vzc2lvblN0YXRlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRPYmplY3QoMik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQga2VybmVsc09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRLZXJuZWxzKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGtlcm5lbHNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgwLCBrZXJuZWxzT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBzdWJHcmFwaFNlc3Npb25TdGF0ZXNPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkU3ViR3JhcGhTZXNzaW9uU3RhdGVzKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIHN1YkdyYXBoU2Vzc2lvblN0YXRlc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDEsIHN1YkdyYXBoU2Vzc2lvblN0YXRlc09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBBcnJheS48ZmxhdGJ1ZmZlcnMuT2Zmc2V0PiBkYXRhXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVN1YkdyYXBoU2Vzc2lvblN0YXRlc1ZlY3RvcihcbiAgICAgIGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsXG4gICAgICBkYXRhOiBmbGF0YnVmZmVycy5PZmZzZXRbXSxcbiAgICApOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBkYXRhLmxlbmd0aCwgNCk7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBidWlsZGVyLmFkZE9mZnNldChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0U3ViR3JhcGhTZXNzaW9uU3RhdGVzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgbnVtRWxlbXMsIDQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZW5kU2Vzc2lvblN0YXRlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgbGV0IG9mZnNldCA9IGJ1aWxkZXIuZW5kT2JqZWN0KCk7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGVTZXNzaW9uU3RhdGUoXG4gICAgICBidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLFxuICAgICAga2VybmVsc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgc3ViR3JhcGhTZXNzaW9uU3RhdGVzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIFNlc3Npb25TdGF0ZS5zdGFydFNlc3Npb25TdGF0ZShidWlsZGVyKTtcbiAgICAgIFNlc3Npb25TdGF0ZS5hZGRLZXJuZWxzKGJ1aWxkZXIsIGtlcm5lbHNPZmZzZXQpO1xuICAgICAgU2Vzc2lvblN0YXRlLmFkZFN1YkdyYXBoU2Vzc2lvblN0YXRlcyhidWlsZGVyLCBzdWJHcmFwaFNlc3Npb25TdGF0ZXNPZmZzZXQpO1xuICAgICAgcmV0dXJuIFNlc3Npb25TdGF0ZS5lbmRTZXNzaW9uU3RhdGUoYnVpbGRlcik7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgY2xhc3MgSW5mZXJlbmNlU2Vzc2lvbiB7XG4gICAgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgfCBudWxsID0gbnVsbDtcblxuICAgIGJiX3BvcyA9IDA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcmV0dXJucyBJbmZlcmVuY2VTZXNzaW9uXG4gICAgICovXG4gICAgX19pbml0KGk6IG51bWJlciwgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIpOiBJbmZlcmVuY2VTZXNzaW9uIHtcbiAgICAgIHRoaXMuYmJfcG9zID0gaTtcbiAgICAgIHRoaXMuYmIgPSBiYjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIEluZmVyZW5jZVNlc3Npb249IG9ialxuICAgICAqIEByZXR1cm5zIEluZmVyZW5jZVNlc3Npb25cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Um9vdEFzSW5mZXJlbmNlU2Vzc2lvbihiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogSW5mZXJlbmNlU2Vzc2lvbik6IEluZmVyZW5jZVNlc3Npb24ge1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IEluZmVyZW5jZVNlc3Npb24oKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBJbmZlcmVuY2VTZXNzaW9uPSBvYmpcbiAgICAgKiBAcmV0dXJucyBJbmZlcmVuY2VTZXNzaW9uXG4gICAgICovXG4gICAgc3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc0luZmVyZW5jZVNlc3Npb24oYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IEluZmVyZW5jZVNlc3Npb24pOiBJbmZlcmVuY2VTZXNzaW9uIHtcbiAgICAgIGJiLnNldFBvc2l0aW9uKGJiLnBvc2l0aW9uKCkgKyBmbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpO1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IEluZmVyZW5jZVNlc3Npb24oKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEByZXR1cm5zIGJvb2xlYW5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnVmZmVySGFzSWRlbnRpZmllcihiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcik6IGJvb2xlYW4ge1xuICAgICAgcmV0dXJuIGJiLl9faGFzX2lkZW50aWZpZXIoJ09SVE0nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheXxudWxsXG4gICAgICovXG4gICAgb3J0VmVyc2lvbigpOiBzdHJpbmcgfCBudWxsO1xuICAgIG9ydFZlcnNpb24ob3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmcgfCBVaW50OEFycmF5IHwgbnVsbDtcbiAgICBvcnRWZXJzaW9uKG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmcgfCBVaW50OEFycmF5IHwgbnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmJfcG9zICsgb2Zmc2V0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuTW9kZWw9IG9ialxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuTW9kZWx8bnVsbFxuICAgICAqL1xuICAgIG1vZGVsKG9iaj86IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuTW9kZWwpOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLk1vZGVsIHwgbnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDYpO1xuICAgICAgcmV0dXJuIG9mZnNldFxuICAgICAgICA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuTW9kZWwoKSkuX19pbml0KHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYl9wb3MgKyBvZmZzZXQpLCB0aGlzLmJiISlcbiAgICAgICAgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlNlc3Npb25TdGF0ZT0gb2JqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5TZXNzaW9uU3RhdGV8bnVsbFxuICAgICAqL1xuICAgIHNlc3Npb25TdGF0ZShvYmo/OiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlNlc3Npb25TdGF0ZSk6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuU2Vzc2lvblN0YXRlIHwgbnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDgpO1xuICAgICAgcmV0dXJuIG9mZnNldFxuICAgICAgICA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuU2Vzc2lvblN0YXRlKCkpLl9faW5pdChcbiAgICAgICAgICAgIHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYl9wb3MgKyBvZmZzZXQpLFxuICAgICAgICAgICAgdGhpcy5iYiEsXG4gICAgICAgICAgKVxuICAgICAgICA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydEluZmVyZW5jZVNlc3Npb24oYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcikge1xuICAgICAgYnVpbGRlci5zdGFydE9iamVjdCgzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBvcnRWZXJzaW9uT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZE9ydFZlcnNpb24oYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgb3J0VmVyc2lvbk9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDAsIG9ydFZlcnNpb25PZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IG1vZGVsT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZE1vZGVsKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG1vZGVsT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMSwgbW9kZWxPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IHNlc3Npb25TdGF0ZU9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRTZXNzaW9uU3RhdGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgc2Vzc2lvblN0YXRlT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMiwgc2Vzc2lvblN0YXRlT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGVuZEluZmVyZW5jZVNlc3Npb24oYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcik6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gYnVpbGRlci5lbmRPYmplY3QoKTtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgb2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGZpbmlzaEluZmVyZW5jZVNlc3Npb25CdWZmZXIoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgb2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuZmluaXNoKG9mZnNldCwgJ09SVE0nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBvZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZmluaXNoU2l6ZVByZWZpeGVkSW5mZXJlbmNlU2Vzc2lvbkJ1ZmZlcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBvZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5maW5pc2gob2Zmc2V0LCAnT1JUTScsIHRydWUpO1xuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGVJbmZlcmVuY2VTZXNzaW9uKFxuICAgICAgYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcixcbiAgICAgIG9ydFZlcnNpb25PZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgIG1vZGVsT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICBzZXNzaW9uU3RhdGVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICApOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgSW5mZXJlbmNlU2Vzc2lvbi5zdGFydEluZmVyZW5jZVNlc3Npb24oYnVpbGRlcik7XG4gICAgICBJbmZlcmVuY2VTZXNzaW9uLmFkZE9ydFZlcnNpb24oYnVpbGRlciwgb3J0VmVyc2lvbk9mZnNldCk7XG4gICAgICBJbmZlcmVuY2VTZXNzaW9uLmFkZE1vZGVsKGJ1aWxkZXIsIG1vZGVsT2Zmc2V0KTtcbiAgICAgIEluZmVyZW5jZVNlc3Npb24uYWRkU2Vzc2lvblN0YXRlKGJ1aWxkZXIsIHNlc3Npb25TdGF0ZU9mZnNldCk7XG4gICAgICByZXR1cm4gSW5mZXJlbmNlU2Vzc2lvbi5lbmRJbmZlcmVuY2VTZXNzaW9uKGJ1aWxkZXIpO1xuICAgIH1cbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGFzUHJvbWlzZTtcclxuXHJcbi8qKlxyXG4gKiBDYWxsYmFjayBhcyB1c2VkIGJ5IHtAbGluayB1dGlsLmFzUHJvbWlzZX0uXHJcbiAqIEB0eXBlZGVmIGFzUHJvbWlzZUNhbGxiYWNrXHJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cclxuICogQHBhcmFtIHtFcnJvcnxudWxsfSBlcnJvciBFcnJvciwgaWYgYW55XHJcbiAqIEBwYXJhbSB7Li4uKn0gcGFyYW1zIEFkZGl0aW9uYWwgYXJndW1lbnRzXHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBwcm9taXNlIGZyb20gYSBub2RlLXN0eWxlIGNhbGxiYWNrIGZ1bmN0aW9uLlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAcGFyYW0ge2FzUHJvbWlzZUNhbGxiYWNrfSBmbiBGdW5jdGlvbiB0byBjYWxsXHJcbiAqIEBwYXJhbSB7Kn0gY3R4IEZ1bmN0aW9uIGNvbnRleHRcclxuICogQHBhcmFtIHsuLi4qfSBwYXJhbXMgRnVuY3Rpb24gYXJndW1lbnRzXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPCo+fSBQcm9taXNpZmllZCBmdW5jdGlvblxyXG4gKi9cclxuZnVuY3Rpb24gYXNQcm9taXNlKGZuLCBjdHgvKiwgdmFyYXJncyAqLykge1xyXG4gICAgdmFyIHBhcmFtcyAgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpLFxyXG4gICAgICAgIG9mZnNldCAgPSAwLFxyXG4gICAgICAgIGluZGV4ICAgPSAyLFxyXG4gICAgICAgIHBlbmRpbmcgPSB0cnVlO1xyXG4gICAgd2hpbGUgKGluZGV4IDwgYXJndW1lbnRzLmxlbmd0aClcclxuICAgICAgICBwYXJhbXNbb2Zmc2V0KytdID0gYXJndW1lbnRzW2luZGV4KytdO1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIGV4ZWN1dG9yKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIHBhcmFtc1tvZmZzZXRdID0gZnVuY3Rpb24gY2FsbGJhY2soZXJyLyosIHZhcmFyZ3MgKi8pIHtcclxuICAgICAgICAgICAgaWYgKHBlbmRpbmcpIHtcclxuICAgICAgICAgICAgICAgIHBlbmRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGlmIChlcnIpXHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAob2Zmc2V0IDwgcGFyYW1zLmxlbmd0aClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zW29mZnNldCsrXSA9IGFyZ3VtZW50c1tvZmZzZXRdO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUuYXBwbHkobnVsbCwgcGFyYW1zKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgZm4uYXBwbHkoY3R4IHx8IG51bGwsIHBhcmFtcyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgIGlmIChwZW5kaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBwZW5kaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbiIsICJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8qKlxyXG4gKiBBIG1pbmltYWwgYmFzZTY0IGltcGxlbWVudGF0aW9uIGZvciBudW1iZXIgYXJyYXlzLlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAbmFtZXNwYWNlXHJcbiAqL1xyXG52YXIgYmFzZTY0ID0gZXhwb3J0cztcclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBieXRlIGxlbmd0aCBvZiBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZy5cclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBCYXNlNjQgZW5jb2RlZCBzdHJpbmdcclxuICogQHJldHVybnMge251bWJlcn0gQnl0ZSBsZW5ndGhcclxuICovXHJcbmJhc2U2NC5sZW5ndGggPSBmdW5jdGlvbiBsZW5ndGgoc3RyaW5nKSB7XHJcbiAgICB2YXIgcCA9IHN0cmluZy5sZW5ndGg7XHJcbiAgICBpZiAoIXApXHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB2YXIgbiA9IDA7XHJcbiAgICB3aGlsZSAoLS1wICUgNCA+IDEgJiYgc3RyaW5nLmNoYXJBdChwKSA9PT0gXCI9XCIpXHJcbiAgICAgICAgKytuO1xyXG4gICAgcmV0dXJuIE1hdGguY2VpbChzdHJpbmcubGVuZ3RoICogMykgLyA0IC0gbjtcclxufTtcclxuXHJcbi8vIEJhc2U2NCBlbmNvZGluZyB0YWJsZVxyXG52YXIgYjY0ID0gbmV3IEFycmF5KDY0KTtcclxuXHJcbi8vIEJhc2U2NCBkZWNvZGluZyB0YWJsZVxyXG52YXIgczY0ID0gbmV3IEFycmF5KDEyMyk7XHJcblxyXG4vLyA2NS4uOTAsIDk3Li4xMjIsIDQ4Li41NywgNDMsIDQ3XHJcbmZvciAodmFyIGkgPSAwOyBpIDwgNjQ7KVxyXG4gICAgczY0W2I2NFtpXSA9IGkgPCAyNiA/IGkgKyA2NSA6IGkgPCA1MiA/IGkgKyA3MSA6IGkgPCA2MiA/IGkgLSA0IDogaSAtIDU5IHwgNDNdID0gaSsrO1xyXG5cclxuLyoqXHJcbiAqIEVuY29kZXMgYSBidWZmZXIgdG8gYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmZmVyIFNvdXJjZSBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFNvdXJjZSBzdGFydFxyXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIFNvdXJjZSBlbmRcclxuICogQHJldHVybnMge3N0cmluZ30gQmFzZTY0IGVuY29kZWQgc3RyaW5nXHJcbiAqL1xyXG5iYXNlNjQuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKGJ1ZmZlciwgc3RhcnQsIGVuZCkge1xyXG4gICAgdmFyIHBhcnRzID0gbnVsbCxcclxuICAgICAgICBjaHVuayA9IFtdO1xyXG4gICAgdmFyIGkgPSAwLCAvLyBvdXRwdXQgaW5kZXhcclxuICAgICAgICBqID0gMCwgLy8gZ290byBpbmRleFxyXG4gICAgICAgIHQ7ICAgICAvLyB0ZW1wb3JhcnlcclxuICAgIHdoaWxlIChzdGFydCA8IGVuZCkge1xyXG4gICAgICAgIHZhciBiID0gYnVmZmVyW3N0YXJ0KytdO1xyXG4gICAgICAgIHN3aXRjaCAoaikge1xyXG4gICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICBjaHVua1tpKytdID0gYjY0W2IgPj4gMl07XHJcbiAgICAgICAgICAgICAgICB0ID0gKGIgJiAzKSA8PCA0O1xyXG4gICAgICAgICAgICAgICAgaiA9IDE7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgY2h1bmtbaSsrXSA9IGI2NFt0IHwgYiA+PiA0XTtcclxuICAgICAgICAgICAgICAgIHQgPSAoYiAmIDE1KSA8PCAyO1xyXG4gICAgICAgICAgICAgICAgaiA9IDI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgY2h1bmtbaSsrXSA9IGI2NFt0IHwgYiA+PiA2XTtcclxuICAgICAgICAgICAgICAgIGNodW5rW2krK10gPSBiNjRbYiAmIDYzXTtcclxuICAgICAgICAgICAgICAgIGogPSAwO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpID4gODE5MSkge1xyXG4gICAgICAgICAgICAocGFydHMgfHwgKHBhcnRzID0gW10pKS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaHVuaykpO1xyXG4gICAgICAgICAgICBpID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoaikge1xyXG4gICAgICAgIGNodW5rW2krK10gPSBiNjRbdF07XHJcbiAgICAgICAgY2h1bmtbaSsrXSA9IDYxO1xyXG4gICAgICAgIGlmIChqID09PSAxKVxyXG4gICAgICAgICAgICBjaHVua1tpKytdID0gNjE7XHJcbiAgICB9XHJcbiAgICBpZiAocGFydHMpIHtcclxuICAgICAgICBpZiAoaSlcclxuICAgICAgICAgICAgcGFydHMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2h1bmsuc2xpY2UoMCwgaSkpKTtcclxuICAgICAgICByZXR1cm4gcGFydHMuam9pbihcIlwiKTtcclxuICAgIH1cclxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2h1bmsuc2xpY2UoMCwgaSkpO1xyXG59O1xyXG5cclxudmFyIGludmFsaWRFbmNvZGluZyA9IFwiaW52YWxpZCBlbmNvZGluZ1wiO1xyXG5cclxuLyoqXHJcbiAqIERlY29kZXMgYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcgdG8gYSBidWZmZXIuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgU291cmNlIHN0cmluZ1xyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZmZlciBEZXN0aW5hdGlvbiBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBEZXN0aW5hdGlvbiBvZmZzZXRcclxuICogQHJldHVybnMge251bWJlcn0gTnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW5cclxuICogQHRocm93cyB7RXJyb3J9IElmIGVuY29kaW5nIGlzIGludmFsaWRcclxuICovXHJcbmJhc2U2NC5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUoc3RyaW5nLCBidWZmZXIsIG9mZnNldCkge1xyXG4gICAgdmFyIHN0YXJ0ID0gb2Zmc2V0O1xyXG4gICAgdmFyIGogPSAwLCAvLyBnb3RvIGluZGV4XHJcbiAgICAgICAgdDsgICAgIC8vIHRlbXBvcmFyeVxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOykge1xyXG4gICAgICAgIHZhciBjID0gc3RyaW5nLmNoYXJDb2RlQXQoaSsrKTtcclxuICAgICAgICBpZiAoYyA9PT0gNjEgJiYgaiA+IDEpXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGlmICgoYyA9IHM2NFtjXSkgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoaW52YWxpZEVuY29kaW5nKTtcclxuICAgICAgICBzd2l0Y2ggKGopIHtcclxuICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgdCA9IGM7XHJcbiAgICAgICAgICAgICAgICBqID0gMTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gdCA8PCAyIHwgKGMgJiA0OCkgPj4gNDtcclxuICAgICAgICAgICAgICAgIHQgPSBjO1xyXG4gICAgICAgICAgICAgICAgaiA9IDI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9ICh0ICYgMTUpIDw8IDQgfCAoYyAmIDYwKSA+PiAyO1xyXG4gICAgICAgICAgICAgICAgdCA9IGM7XHJcbiAgICAgICAgICAgICAgICBqID0gMztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gKHQgJiAzKSA8PCA2IHwgYztcclxuICAgICAgICAgICAgICAgIGogPSAwO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGogPT09IDEpXHJcbiAgICAgICAgdGhyb3cgRXJyb3IoaW52YWxpZEVuY29kaW5nKTtcclxuICAgIHJldHVybiBvZmZzZXQgLSBzdGFydDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIHN0cmluZyBhcHBlYXJzIHRvIGJlIGJhc2U2NCBlbmNvZGVkLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFN0cmluZyB0byB0ZXN0XHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgcHJvYmFibHkgYmFzZTY0IGVuY29kZWQsIG90aGVyd2lzZSBmYWxzZVxyXG4gKi9cclxuYmFzZTY0LnRlc3QgPSBmdW5jdGlvbiB0ZXN0KHN0cmluZykge1xyXG4gICAgcmV0dXJuIC9eKD86W0EtWmEtejAtOSsvXXs0fSkqKD86W0EtWmEtejAtOSsvXXsyfT09fFtBLVphLXowLTkrL117M309KT8kLy50ZXN0KHN0cmluZyk7XHJcbn07XHJcbiIsICJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XHJcblxyXG4vKipcclxuICogQ29uc3RydWN0cyBhIG5ldyBldmVudCBlbWl0dGVyIGluc3RhbmNlLlxyXG4gKiBAY2xhc3NkZXNjIEEgbWluaW1hbCBldmVudCBlbWl0dGVyLlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVyZWQgbGlzdGVuZXJzLlxyXG4gICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCo+fVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge307XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBldnQgRXZlbnQgbmFtZVxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBMaXN0ZW5lclxyXG4gKiBAcGFyYW0geyp9IFtjdHhdIExpc3RlbmVyIGNvbnRleHRcclxuICogQHJldHVybnMge3V0aWwuRXZlbnRFbWl0dGVyfSBgdGhpc2BcclxuICovXHJcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbihldnQsIGZuLCBjdHgpIHtcclxuICAgICh0aGlzLl9saXN0ZW5lcnNbZXZ0XSB8fCAodGhpcy5fbGlzdGVuZXJzW2V2dF0gPSBbXSkpLnB1c2goe1xyXG4gICAgICAgIGZuICA6IGZuLFxyXG4gICAgICAgIGN0eCA6IGN0eCB8fCB0aGlzXHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZXMgYW4gZXZlbnQgbGlzdGVuZXIgb3IgYW55IG1hdGNoaW5nIGxpc3RlbmVycyBpZiBhcmd1bWVudHMgYXJlIG9taXR0ZWQuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZXZ0XSBFdmVudCBuYW1lLiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMgaWYgb21pdHRlZC5cclxuICogQHBhcmFtIHtmdW5jdGlvbn0gW2ZuXSBMaXN0ZW5lciB0byByZW1vdmUuIFJlbW92ZXMgYWxsIGxpc3RlbmVycyBvZiBgZXZ0YCBpZiBvbWl0dGVkLlxyXG4gKiBAcmV0dXJucyB7dXRpbC5FdmVudEVtaXR0ZXJ9IGB0aGlzYFxyXG4gKi9cclxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiBvZmYoZXZ0LCBmbikge1xyXG4gICAgaWYgKGV2dCA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKGZuID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVyc1tldnRdID0gW107XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnNbZXZ0XTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOylcclxuICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lcnNbaV0uZm4gPT09IGZuKVxyXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgKytpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEVtaXRzIGFuIGV2ZW50IGJ5IGNhbGxpbmcgaXRzIGxpc3RlbmVycyB3aXRoIHRoZSBzcGVjaWZpZWQgYXJndW1lbnRzLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZ0IEV2ZW50IG5hbWVcclxuICogQHBhcmFtIHsuLi4qfSBhcmdzIEFyZ3VtZW50c1xyXG4gKiBAcmV0dXJucyB7dXRpbC5FdmVudEVtaXR0ZXJ9IGB0aGlzYFxyXG4gKi9cclxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdChldnQpIHtcclxuICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnNbZXZ0XTtcclxuICAgIGlmIChsaXN0ZW5lcnMpIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdLFxyXG4gICAgICAgICAgICBpID0gMTtcclxuICAgICAgICBmb3IgKDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7KVxyXG4gICAgICAgICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOylcclxuICAgICAgICAgICAgbGlzdGVuZXJzW2ldLmZuLmFwcGx5KGxpc3RlbmVyc1tpKytdLmN0eCwgYXJncyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuIiwgIlwidXNlIHN0cmljdFwiO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KGZhY3RvcnkpO1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIC8gd3JpdGVzIGZsb2F0cyAvIGRvdWJsZXMgZnJvbSAvIHRvIGJ1ZmZlcnMuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXRcclxuICogQG5hbWVzcGFjZVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYSAzMiBiaXQgZmxvYXQgdG8gYSBidWZmZXIgdXNpbmcgbGl0dGxlIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LndyaXRlRmxvYXRMRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBUYXJnZXQgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgVGFyZ2V0IGJ1ZmZlciBvZmZzZXRcclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICovXHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgMzIgYml0IGZsb2F0IHRvIGEgYnVmZmVyIHVzaW5nIGJpZyBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC53cml0ZUZsb2F0QkVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgVmFsdWUgdG8gd3JpdGVcclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgVGFyZ2V0IGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFRhcmdldCBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIGEgMzIgYml0IGZsb2F0IGZyb20gYSBidWZmZXIgdXNpbmcgbGl0dGxlIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LnJlYWRGbG9hdExFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBTb3VyY2UgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgU291cmNlIGJ1ZmZlciBvZmZzZXRcclxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBhIDMyIGJpdCBmbG9hdCBmcm9tIGEgYnVmZmVyIHVzaW5nIGJpZyBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC5yZWFkRmxvYXRCRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgU291cmNlIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFNvdXJjZSBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICovXHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgNjQgYml0IGRvdWJsZSB0byBhIGJ1ZmZlciB1c2luZyBsaXR0bGUgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQud3JpdGVEb3VibGVMRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBUYXJnZXQgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgVGFyZ2V0IGJ1ZmZlciBvZmZzZXRcclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICovXHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgNjQgYml0IGRvdWJsZSB0byBhIGJ1ZmZlciB1c2luZyBiaWcgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQud3JpdGVEb3VibGVCRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBUYXJnZXQgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgVGFyZ2V0IGJ1ZmZlciBvZmZzZXRcclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICovXHJcblxyXG4vKipcclxuICogUmVhZHMgYSA2NCBiaXQgZG91YmxlIGZyb20gYSBidWZmZXIgdXNpbmcgbGl0dGxlIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LnJlYWREb3VibGVMRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgU291cmNlIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFNvdXJjZSBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICovXHJcblxyXG4vKipcclxuICogUmVhZHMgYSA2NCBiaXQgZG91YmxlIGZyb20gYSBidWZmZXIgdXNpbmcgYmlnIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LnJlYWREb3VibGVCRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgU291cmNlIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFNvdXJjZSBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICovXHJcblxyXG4vLyBGYWN0b3J5IGZ1bmN0aW9uIGZvciB0aGUgcHVycG9zZSBvZiBub2RlLWJhc2VkIHRlc3RpbmcgaW4gbW9kaWZpZWQgZ2xvYmFsIGVudmlyb25tZW50c1xyXG5mdW5jdGlvbiBmYWN0b3J5KGV4cG9ydHMpIHtcclxuXHJcbiAgICAvLyBmbG9hdDogdHlwZWQgYXJyYXlcclxuICAgIGlmICh0eXBlb2YgRmxvYXQzMkFycmF5ICE9PSBcInVuZGVmaW5lZFwiKSAoZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIHZhciBmMzIgPSBuZXcgRmxvYXQzMkFycmF5KFsgLTAgXSksXHJcbiAgICAgICAgICAgIGY4YiA9IG5ldyBVaW50OEFycmF5KGYzMi5idWZmZXIpLFxyXG4gICAgICAgICAgICBsZSAgPSBmOGJbM10gPT09IDEyODtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVGbG9hdF9mMzJfY3B5KHZhbCwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjMyWzBdID0gdmFsO1xyXG4gICAgICAgICAgICBidWZbcG9zICAgIF0gPSBmOGJbMF07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAxXSA9IGY4YlsxXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDJdID0gZjhiWzJdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgM10gPSBmOGJbM107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiB3cml0ZUZsb2F0X2YzMl9yZXYodmFsLCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmMzJbMF0gPSB2YWw7XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgICAgXSA9IGY4YlszXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDFdID0gZjhiWzJdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMl0gPSBmOGJbMV07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAzXSA9IGY4YlswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy53cml0ZUZsb2F0TEUgPSBsZSA/IHdyaXRlRmxvYXRfZjMyX2NweSA6IHdyaXRlRmxvYXRfZjMyX3JldjtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMud3JpdGVGbG9hdEJFID0gbGUgPyB3cml0ZUZsb2F0X2YzMl9yZXYgOiB3cml0ZUZsb2F0X2YzMl9jcHk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRGbG9hdF9mMzJfY3B5KGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGY4YlswXSA9IGJ1Zltwb3MgICAgXTtcclxuICAgICAgICAgICAgZjhiWzFdID0gYnVmW3BvcyArIDFdO1xyXG4gICAgICAgICAgICBmOGJbMl0gPSBidWZbcG9zICsgMl07XHJcbiAgICAgICAgICAgIGY4YlszXSA9IGJ1Zltwb3MgKyAzXTtcclxuICAgICAgICAgICAgcmV0dXJuIGYzMlswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRGbG9hdF9mMzJfcmV2KGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGY4YlszXSA9IGJ1Zltwb3MgICAgXTtcclxuICAgICAgICAgICAgZjhiWzJdID0gYnVmW3BvcyArIDFdO1xyXG4gICAgICAgICAgICBmOGJbMV0gPSBidWZbcG9zICsgMl07XHJcbiAgICAgICAgICAgIGY4YlswXSA9IGJ1Zltwb3MgKyAzXTtcclxuICAgICAgICAgICAgcmV0dXJuIGYzMlswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRmxvYXRMRSA9IGxlID8gcmVhZEZsb2F0X2YzMl9jcHkgOiByZWFkRmxvYXRfZjMyX3JldjtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMucmVhZEZsb2F0QkUgPSBsZSA/IHJlYWRGbG9hdF9mMzJfcmV2IDogcmVhZEZsb2F0X2YzMl9jcHk7XHJcblxyXG4gICAgLy8gZmxvYXQ6IGllZWU3NTRcclxuICAgIH0pKCk7IGVsc2UgKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICBmdW5jdGlvbiB3cml0ZUZsb2F0X2llZWU3NTQod3JpdGVVaW50LCB2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIHZhciBzaWduID0gdmFsIDwgMCA/IDEgOiAwO1xyXG4gICAgICAgICAgICBpZiAoc2lnbilcclxuICAgICAgICAgICAgICAgIHZhbCA9IC12YWw7XHJcbiAgICAgICAgICAgIGlmICh2YWwgPT09IDApXHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoMSAvIHZhbCA+IDAgPyAvKiBwb3NpdGl2ZSAqLyAwIDogLyogbmVnYXRpdmUgMCAqLyAyMTQ3NDgzNjQ4LCBidWYsIHBvcyk7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzTmFOKHZhbCkpXHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoMjE0MzI4OTM0NCwgYnVmLCBwb3MpO1xyXG4gICAgICAgICAgICBlbHNlIGlmICh2YWwgPiAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KSAvLyArLUluZmluaXR5XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoKHNpZ24gPDwgMzEgfCAyMTM5MDk1MDQwKSA+Pj4gMCwgYnVmLCBwb3MpO1xyXG4gICAgICAgICAgICBlbHNlIGlmICh2YWwgPCAxLjE3NTQ5NDM1MDgyMjI4NzVlLTM4KSAvLyBkZW5vcm1hbFxyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KChzaWduIDw8IDMxIHwgTWF0aC5yb3VuZCh2YWwgLyAxLjQwMTI5ODQ2NDMyNDgxN2UtNDUpKSA+Pj4gMCwgYnVmLCBwb3MpO1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBleHBvbmVudCA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsKSAvIE1hdGguTE4yKSxcclxuICAgICAgICAgICAgICAgICAgICBtYW50aXNzYSA9IE1hdGgucm91bmQodmFsICogTWF0aC5wb3coMiwgLWV4cG9uZW50KSAqIDgzODg2MDgpICYgODM4ODYwNztcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgoc2lnbiA8PCAzMSB8IGV4cG9uZW50ICsgMTI3IDw8IDIzIHwgbWFudGlzc2EpID4+PiAwLCBidWYsIHBvcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGV4cG9ydHMud3JpdGVGbG9hdExFID0gd3JpdGVGbG9hdF9pZWVlNzU0LmJpbmQobnVsbCwgd3JpdGVVaW50TEUpO1xyXG4gICAgICAgIGV4cG9ydHMud3JpdGVGbG9hdEJFID0gd3JpdGVGbG9hdF9pZWVlNzU0LmJpbmQobnVsbCwgd3JpdGVVaW50QkUpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiByZWFkRmxvYXRfaWVlZTc1NChyZWFkVWludCwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgdmFyIHVpbnQgPSByZWFkVWludChidWYsIHBvcyksXHJcbiAgICAgICAgICAgICAgICBzaWduID0gKHVpbnQgPj4gMzEpICogMiArIDEsXHJcbiAgICAgICAgICAgICAgICBleHBvbmVudCA9IHVpbnQgPj4+IDIzICYgMjU1LFxyXG4gICAgICAgICAgICAgICAgbWFudGlzc2EgPSB1aW50ICYgODM4ODYwNztcclxuICAgICAgICAgICAgcmV0dXJuIGV4cG9uZW50ID09PSAyNTVcclxuICAgICAgICAgICAgICAgID8gbWFudGlzc2FcclxuICAgICAgICAgICAgICAgID8gTmFOXHJcbiAgICAgICAgICAgICAgICA6IHNpZ24gKiBJbmZpbml0eVxyXG4gICAgICAgICAgICAgICAgOiBleHBvbmVudCA9PT0gMCAvLyBkZW5vcm1hbFxyXG4gICAgICAgICAgICAgICAgPyBzaWduICogMS40MDEyOTg0NjQzMjQ4MTdlLTQ1ICogbWFudGlzc2FcclxuICAgICAgICAgICAgICAgIDogc2lnbiAqIE1hdGgucG93KDIsIGV4cG9uZW50IC0gMTUwKSAqIChtYW50aXNzYSArIDgzODg2MDgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRmxvYXRMRSA9IHJlYWRGbG9hdF9pZWVlNzU0LmJpbmQobnVsbCwgcmVhZFVpbnRMRSk7XHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRmxvYXRCRSA9IHJlYWRGbG9hdF9pZWVlNzU0LmJpbmQobnVsbCwgcmVhZFVpbnRCRSk7XHJcblxyXG4gICAgfSkoKTtcclxuXHJcbiAgICAvLyBkb3VibGU6IHR5cGVkIGFycmF5XHJcbiAgICBpZiAodHlwZW9mIEZsb2F0NjRBcnJheSAhPT0gXCJ1bmRlZmluZWRcIikgKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICB2YXIgZjY0ID0gbmV3IEZsb2F0NjRBcnJheShbLTBdKSxcclxuICAgICAgICAgICAgZjhiID0gbmV3IFVpbnQ4QXJyYXkoZjY0LmJ1ZmZlciksXHJcbiAgICAgICAgICAgIGxlICA9IGY4Yls3XSA9PT0gMTI4O1xyXG5cclxuICAgICAgICBmdW5jdGlvbiB3cml0ZURvdWJsZV9mNjRfY3B5KHZhbCwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjY0WzBdID0gdmFsO1xyXG4gICAgICAgICAgICBidWZbcG9zICAgIF0gPSBmOGJbMF07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAxXSA9IGY4YlsxXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDJdID0gZjhiWzJdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgM10gPSBmOGJbM107XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA0XSA9IGY4Yls0XTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDVdID0gZjhiWzVdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgNl0gPSBmOGJbNl07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA3XSA9IGY4Yls3XTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlRG91YmxlX2Y2NF9yZXYodmFsLCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmNjRbMF0gPSB2YWw7XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgICAgXSA9IGY4Yls3XTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDFdID0gZjhiWzZdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMl0gPSBmOGJbNV07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAzXSA9IGY4Yls0XTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDRdID0gZjhiWzNdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgNV0gPSBmOGJbMl07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA2XSA9IGY4YlsxXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDddID0gZjhiWzBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLndyaXRlRG91YmxlTEUgPSBsZSA/IHdyaXRlRG91YmxlX2Y2NF9jcHkgOiB3cml0ZURvdWJsZV9mNjRfcmV2O1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy53cml0ZURvdWJsZUJFID0gbGUgPyB3cml0ZURvdWJsZV9mNjRfcmV2IDogd3JpdGVEb3VibGVfZjY0X2NweTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVhZERvdWJsZV9mNjRfY3B5KGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGY4YlswXSA9IGJ1Zltwb3MgICAgXTtcclxuICAgICAgICAgICAgZjhiWzFdID0gYnVmW3BvcyArIDFdO1xyXG4gICAgICAgICAgICBmOGJbMl0gPSBidWZbcG9zICsgMl07XHJcbiAgICAgICAgICAgIGY4YlszXSA9IGJ1Zltwb3MgKyAzXTtcclxuICAgICAgICAgICAgZjhiWzRdID0gYnVmW3BvcyArIDRdO1xyXG4gICAgICAgICAgICBmOGJbNV0gPSBidWZbcG9zICsgNV07XHJcbiAgICAgICAgICAgIGY4Yls2XSA9IGJ1Zltwb3MgKyA2XTtcclxuICAgICAgICAgICAgZjhiWzddID0gYnVmW3BvcyArIDddO1xyXG4gICAgICAgICAgICByZXR1cm4gZjY0WzBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVhZERvdWJsZV9mNjRfcmV2KGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGY4Yls3XSA9IGJ1Zltwb3MgICAgXTtcclxuICAgICAgICAgICAgZjhiWzZdID0gYnVmW3BvcyArIDFdO1xyXG4gICAgICAgICAgICBmOGJbNV0gPSBidWZbcG9zICsgMl07XHJcbiAgICAgICAgICAgIGY4Yls0XSA9IGJ1Zltwb3MgKyAzXTtcclxuICAgICAgICAgICAgZjhiWzNdID0gYnVmW3BvcyArIDRdO1xyXG4gICAgICAgICAgICBmOGJbMl0gPSBidWZbcG9zICsgNV07XHJcbiAgICAgICAgICAgIGY4YlsxXSA9IGJ1Zltwb3MgKyA2XTtcclxuICAgICAgICAgICAgZjhiWzBdID0gYnVmW3BvcyArIDddO1xyXG4gICAgICAgICAgICByZXR1cm4gZjY0WzBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLnJlYWREb3VibGVMRSA9IGxlID8gcmVhZERvdWJsZV9mNjRfY3B5IDogcmVhZERvdWJsZV9mNjRfcmV2O1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRG91YmxlQkUgPSBsZSA/IHJlYWREb3VibGVfZjY0X3JldiA6IHJlYWREb3VibGVfZjY0X2NweTtcclxuXHJcbiAgICAvLyBkb3VibGU6IGllZWU3NTRcclxuICAgIH0pKCk7IGVsc2UgKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICBmdW5jdGlvbiB3cml0ZURvdWJsZV9pZWVlNzU0KHdyaXRlVWludCwgb2ZmMCwgb2ZmMSwgdmFsLCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICB2YXIgc2lnbiA9IHZhbCA8IDAgPyAxIDogMDtcclxuICAgICAgICAgICAgaWYgKHNpZ24pXHJcbiAgICAgICAgICAgICAgICB2YWwgPSAtdmFsO1xyXG4gICAgICAgICAgICBpZiAodmFsID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoMCwgYnVmLCBwb3MgKyBvZmYwKTtcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgxIC8gdmFsID4gMCA/IC8qIHBvc2l0aXZlICovIDAgOiAvKiBuZWdhdGl2ZSAwICovIDIxNDc0ODM2NDgsIGJ1ZiwgcG9zICsgb2ZmMSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNOYU4odmFsKSkge1xyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KDAsIGJ1ZiwgcG9zICsgb2ZmMCk7XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoMjE0Njk1OTM2MCwgYnVmLCBwb3MgKyBvZmYxKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWwgPiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOCkgeyAvLyArLUluZmluaXR5XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoMCwgYnVmLCBwb3MgKyBvZmYwKTtcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgoc2lnbiA8PCAzMSB8IDIxNDY0MzUwNzIpID4+PiAwLCBidWYsIHBvcyArIG9mZjEpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1hbnRpc3NhO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbCA8IDIuMjI1MDczODU4NTA3MjAxNGUtMzA4KSB7IC8vIGRlbm9ybWFsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFudGlzc2EgPSB2YWwgLyA1ZS0zMjQ7XHJcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVVaW50KG1hbnRpc3NhID4+PiAwLCBidWYsIHBvcyArIG9mZjApO1xyXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlVWludCgoc2lnbiA8PCAzMSB8IG1hbnRpc3NhIC8gNDI5NDk2NzI5NikgPj4+IDAsIGJ1ZiwgcG9zICsgb2ZmMSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBleHBvbmVudCA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsKSAvIE1hdGguTE4yKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXhwb25lbnQgPT09IDEwMjQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9uZW50ID0gMTAyMztcclxuICAgICAgICAgICAgICAgICAgICBtYW50aXNzYSA9IHZhbCAqIE1hdGgucG93KDIsIC1leHBvbmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVVaW50KG1hbnRpc3NhICogNDUwMzU5OTYyNzM3MDQ5NiA+Pj4gMCwgYnVmLCBwb3MgKyBvZmYwKTtcclxuICAgICAgICAgICAgICAgICAgICB3cml0ZVVpbnQoKHNpZ24gPDwgMzEgfCBleHBvbmVudCArIDEwMjMgPDwgMjAgfCBtYW50aXNzYSAqIDEwNDg1NzYgJiAxMDQ4NTc1KSA+Pj4gMCwgYnVmLCBwb3MgKyBvZmYxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZXhwb3J0cy53cml0ZURvdWJsZUxFID0gd3JpdGVEb3VibGVfaWVlZTc1NC5iaW5kKG51bGwsIHdyaXRlVWludExFLCAwLCA0KTtcclxuICAgICAgICBleHBvcnRzLndyaXRlRG91YmxlQkUgPSB3cml0ZURvdWJsZV9pZWVlNzU0LmJpbmQobnVsbCwgd3JpdGVVaW50QkUsIDQsIDApO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiByZWFkRG91YmxlX2llZWU3NTQocmVhZFVpbnQsIG9mZjAsIG9mZjEsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIHZhciBsbyA9IHJlYWRVaW50KGJ1ZiwgcG9zICsgb2ZmMCksXHJcbiAgICAgICAgICAgICAgICBoaSA9IHJlYWRVaW50KGJ1ZiwgcG9zICsgb2ZmMSk7XHJcbiAgICAgICAgICAgIHZhciBzaWduID0gKGhpID4+IDMxKSAqIDIgKyAxLFxyXG4gICAgICAgICAgICAgICAgZXhwb25lbnQgPSBoaSA+Pj4gMjAgJiAyMDQ3LFxyXG4gICAgICAgICAgICAgICAgbWFudGlzc2EgPSA0Mjk0OTY3Mjk2ICogKGhpICYgMTA0ODU3NSkgKyBsbztcclxuICAgICAgICAgICAgcmV0dXJuIGV4cG9uZW50ID09PSAyMDQ3XHJcbiAgICAgICAgICAgICAgICA/IG1hbnRpc3NhXHJcbiAgICAgICAgICAgICAgICA/IE5hTlxyXG4gICAgICAgICAgICAgICAgOiBzaWduICogSW5maW5pdHlcclxuICAgICAgICAgICAgICAgIDogZXhwb25lbnQgPT09IDAgLy8gZGVub3JtYWxcclxuICAgICAgICAgICAgICAgID8gc2lnbiAqIDVlLTMyNCAqIG1hbnRpc3NhXHJcbiAgICAgICAgICAgICAgICA6IHNpZ24gKiBNYXRoLnBvdygyLCBleHBvbmVudCAtIDEwNzUpICogKG1hbnRpc3NhICsgNDUwMzU5OTYyNzM3MDQ5Nik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBleHBvcnRzLnJlYWREb3VibGVMRSA9IHJlYWREb3VibGVfaWVlZTc1NC5iaW5kKG51bGwsIHJlYWRVaW50TEUsIDAsIDQpO1xyXG4gICAgICAgIGV4cG9ydHMucmVhZERvdWJsZUJFID0gcmVhZERvdWJsZV9pZWVlNzU0LmJpbmQobnVsbCwgcmVhZFVpbnRCRSwgNCwgMCk7XHJcblxyXG4gICAgfSkoKTtcclxuXHJcbiAgICByZXR1cm4gZXhwb3J0cztcclxufVxyXG5cclxuLy8gdWludCBoZWxwZXJzXHJcblxyXG5mdW5jdGlvbiB3cml0ZVVpbnRMRSh2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICBidWZbcG9zICAgIF0gPSAgdmFsICAgICAgICAmIDI1NTtcclxuICAgIGJ1Zltwb3MgKyAxXSA9ICB2YWwgPj4+IDggICYgMjU1O1xyXG4gICAgYnVmW3BvcyArIDJdID0gIHZhbCA+Pj4gMTYgJiAyNTU7XHJcbiAgICBidWZbcG9zICsgM10gPSAgdmFsID4+PiAyNDtcclxufVxyXG5cclxuZnVuY3Rpb24gd3JpdGVVaW50QkUodmFsLCBidWYsIHBvcykge1xyXG4gICAgYnVmW3BvcyAgICBdID0gIHZhbCA+Pj4gMjQ7XHJcbiAgICBidWZbcG9zICsgMV0gPSAgdmFsID4+PiAxNiAmIDI1NTtcclxuICAgIGJ1Zltwb3MgKyAyXSA9ICB2YWwgPj4+IDggICYgMjU1O1xyXG4gICAgYnVmW3BvcyArIDNdID0gIHZhbCAgICAgICAgJiAyNTU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlYWRVaW50TEUoYnVmLCBwb3MpIHtcclxuICAgIHJldHVybiAoYnVmW3BvcyAgICBdXHJcbiAgICAgICAgICB8IGJ1Zltwb3MgKyAxXSA8PCA4XHJcbiAgICAgICAgICB8IGJ1Zltwb3MgKyAyXSA8PCAxNlxyXG4gICAgICAgICAgfCBidWZbcG9zICsgM10gPDwgMjQpID4+PiAwO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZWFkVWludEJFKGJ1ZiwgcG9zKSB7XHJcbiAgICByZXR1cm4gKGJ1Zltwb3MgICAgXSA8PCAyNFxyXG4gICAgICAgICAgfCBidWZbcG9zICsgMV0gPDwgMTZcclxuICAgICAgICAgIHwgYnVmW3BvcyArIDJdIDw8IDhcclxuICAgICAgICAgIHwgYnVmW3BvcyArIDNdKSA+Pj4gMDtcclxufVxyXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gaW5xdWlyZTtcclxuXHJcbi8qKlxyXG4gKiBSZXF1aXJlcyBhIG1vZHVsZSBvbmx5IGlmIGF2YWlsYWJsZS5cclxuICogQG1lbWJlcm9mIHV0aWxcclxuICogQHBhcmFtIHtzdHJpbmd9IG1vZHVsZU5hbWUgTW9kdWxlIHRvIHJlcXVpcmVcclxuICogQHJldHVybnMgez9PYmplY3R9IFJlcXVpcmVkIG1vZHVsZSBpZiBhdmFpbGFibGUgYW5kIG5vdCBlbXB0eSwgb3RoZXJ3aXNlIGBudWxsYFxyXG4gKi9cclxuZnVuY3Rpb24gaW5xdWlyZShtb2R1bGVOYW1lKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHZhciBtb2QgPSBldmFsKFwicXVpcmVcIi5yZXBsYWNlKC9eLyxcInJlXCIpKShtb2R1bGVOYW1lKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1ldmFsXHJcbiAgICAgICAgaWYgKG1vZCAmJiAobW9kLmxlbmd0aCB8fCBPYmplY3Qua2V5cyhtb2QpLmxlbmd0aCkpXHJcbiAgICAgICAgICAgIHJldHVybiBtb2Q7XHJcbiAgICB9IGNhdGNoIChlKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVtcHR5XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vKipcclxuICogQSBtaW5pbWFsIFVURjggaW1wbGVtZW50YXRpb24gZm9yIG51bWJlciBhcnJheXMuXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBuYW1lc3BhY2VcclxuICovXHJcbnZhciB1dGY4ID0gZXhwb3J0cztcclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBVVEY4IGJ5dGUgbGVuZ3RoIG9mIGEgc3RyaW5nLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFN0cmluZ1xyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBCeXRlIGxlbmd0aFxyXG4gKi9cclxudXRmOC5sZW5ndGggPSBmdW5jdGlvbiB1dGY4X2xlbmd0aChzdHJpbmcpIHtcclxuICAgIHZhciBsZW4gPSAwLFxyXG4gICAgICAgIGMgPSAwO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBjID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgaWYgKGMgPCAxMjgpXHJcbiAgICAgICAgICAgIGxlbiArPSAxO1xyXG4gICAgICAgIGVsc2UgaWYgKGMgPCAyMDQ4KVxyXG4gICAgICAgICAgICBsZW4gKz0gMjtcclxuICAgICAgICBlbHNlIGlmICgoYyAmIDB4RkMwMCkgPT09IDB4RDgwMCAmJiAoc3RyaW5nLmNoYXJDb2RlQXQoaSArIDEpICYgMHhGQzAwKSA9PT0gMHhEQzAwKSB7XHJcbiAgICAgICAgICAgICsraTtcclxuICAgICAgICAgICAgbGVuICs9IDQ7XHJcbiAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgIGxlbiArPSAzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxlbjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBVVEY4IGJ5dGVzIGFzIGEgc3RyaW5nLlxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZmZlciBTb3VyY2UgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBTb3VyY2Ugc3RhcnRcclxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBTb3VyY2UgZW5kXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFN0cmluZyByZWFkXHJcbiAqL1xyXG51dGY4LnJlYWQgPSBmdW5jdGlvbiB1dGY4X3JlYWQoYnVmZmVyLCBzdGFydCwgZW5kKSB7XHJcbiAgICB2YXIgbGVuID0gZW5kIC0gc3RhcnQ7XHJcbiAgICBpZiAobGVuIDwgMSlcclxuICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgIHZhciBwYXJ0cyA9IG51bGwsXHJcbiAgICAgICAgY2h1bmsgPSBbXSxcclxuICAgICAgICBpID0gMCwgLy8gY2hhciBvZmZzZXRcclxuICAgICAgICB0OyAgICAgLy8gdGVtcG9yYXJ5XHJcbiAgICB3aGlsZSAoc3RhcnQgPCBlbmQpIHtcclxuICAgICAgICB0ID0gYnVmZmVyW3N0YXJ0KytdO1xyXG4gICAgICAgIGlmICh0IDwgMTI4KVxyXG4gICAgICAgICAgICBjaHVua1tpKytdID0gdDtcclxuICAgICAgICBlbHNlIGlmICh0ID4gMTkxICYmIHQgPCAyMjQpXHJcbiAgICAgICAgICAgIGNodW5rW2krK10gPSAodCAmIDMxKSA8PCA2IHwgYnVmZmVyW3N0YXJ0KytdICYgNjM7XHJcbiAgICAgICAgZWxzZSBpZiAodCA+IDIzOSAmJiB0IDwgMzY1KSB7XHJcbiAgICAgICAgICAgIHQgPSAoKHQgJiA3KSA8PCAxOCB8IChidWZmZXJbc3RhcnQrK10gJiA2MykgPDwgMTIgfCAoYnVmZmVyW3N0YXJ0KytdICYgNjMpIDw8IDYgfCBidWZmZXJbc3RhcnQrK10gJiA2MykgLSAweDEwMDAwO1xyXG4gICAgICAgICAgICBjaHVua1tpKytdID0gMHhEODAwICsgKHQgPj4gMTApO1xyXG4gICAgICAgICAgICBjaHVua1tpKytdID0gMHhEQzAwICsgKHQgJiAxMDIzKTtcclxuICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgY2h1bmtbaSsrXSA9ICh0ICYgMTUpIDw8IDEyIHwgKGJ1ZmZlcltzdGFydCsrXSAmIDYzKSA8PCA2IHwgYnVmZmVyW3N0YXJ0KytdICYgNjM7XHJcbiAgICAgICAgaWYgKGkgPiA4MTkxKSB7XHJcbiAgICAgICAgICAgIChwYXJ0cyB8fCAocGFydHMgPSBbXSkpLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNodW5rKSk7XHJcbiAgICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChwYXJ0cykge1xyXG4gICAgICAgIGlmIChpKVxyXG4gICAgICAgICAgICBwYXJ0cy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaHVuay5zbGljZSgwLCBpKSkpO1xyXG4gICAgICAgIHJldHVybiBwYXJ0cy5qb2luKFwiXCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaHVuay5zbGljZSgwLCBpKSk7XHJcbn07XHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgc3RyaW5nIGFzIFVURjggYnl0ZXMuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgU291cmNlIHN0cmluZ1xyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZmZlciBEZXN0aW5hdGlvbiBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBEZXN0aW5hdGlvbiBvZmZzZXRcclxuICogQHJldHVybnMge251bWJlcn0gQnl0ZXMgd3JpdHRlblxyXG4gKi9cclxudXRmOC53cml0ZSA9IGZ1bmN0aW9uIHV0Zjhfd3JpdGUoc3RyaW5nLCBidWZmZXIsIG9mZnNldCkge1xyXG4gICAgdmFyIHN0YXJ0ID0gb2Zmc2V0LFxyXG4gICAgICAgIGMxLCAvLyBjaGFyYWN0ZXIgMVxyXG4gICAgICAgIGMyOyAvLyBjaGFyYWN0ZXIgMlxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBjMSA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgIGlmIChjMSA8IDEyOCkge1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzE7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjMSA8IDIwNDgpIHtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxID4+IDYgICAgICAgfCAxOTI7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSAgICAgICAmIDYzIHwgMTI4O1xyXG4gICAgICAgIH0gZWxzZSBpZiAoKGMxICYgMHhGQzAwKSA9PT0gMHhEODAwICYmICgoYzIgPSBzdHJpbmcuY2hhckNvZGVBdChpICsgMSkpICYgMHhGQzAwKSA9PT0gMHhEQzAwKSB7XHJcbiAgICAgICAgICAgIGMxID0gMHgxMDAwMCArICgoYzEgJiAweDAzRkYpIDw8IDEwKSArIChjMiAmIDB4MDNGRik7XHJcbiAgICAgICAgICAgICsraTtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxID4+IDE4ICAgICAgfCAyNDA7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSA+PiAxMiAmIDYzIHwgMTI4O1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgPj4gNiAgJiA2MyB8IDEyODtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxICAgICAgICYgNjMgfCAxMjg7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxID4+IDEyICAgICAgfCAyMjQ7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSA+PiA2ICAmIDYzIHwgMTI4O1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgICAgICAgJiA2MyB8IDEyODtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb2Zmc2V0IC0gc3RhcnQ7XHJcbn07XHJcbiIsICJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSBwb29sO1xyXG5cclxuLyoqXHJcbiAqIEFuIGFsbG9jYXRvciBhcyB1c2VkIGJ5IHtAbGluayB1dGlsLnBvb2x9LlxyXG4gKiBAdHlwZWRlZiBQb29sQWxsb2NhdG9yXHJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cclxuICogQHBhcmFtIHtudW1iZXJ9IHNpemUgQnVmZmVyIHNpemVcclxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IEJ1ZmZlclxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBBIHNsaWNlciBhcyB1c2VkIGJ5IHtAbGluayB1dGlsLnBvb2x9LlxyXG4gKiBAdHlwZWRlZiBQb29sU2xpY2VyXHJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cclxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFN0YXJ0IG9mZnNldFxyXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZCBvZmZzZXRcclxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IEJ1ZmZlciBzbGljZVxyXG4gKiBAdGhpcyB7VWludDhBcnJheX1cclxuICovXHJcblxyXG4vKipcclxuICogQSBnZW5lcmFsIHB1cnBvc2UgYnVmZmVyIHBvb2wuXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge1Bvb2xBbGxvY2F0b3J9IGFsbG9jIEFsbG9jYXRvclxyXG4gKiBAcGFyYW0ge1Bvb2xTbGljZXJ9IHNsaWNlIFNsaWNlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gW3NpemU9ODE5Ml0gU2xhYiBzaXplXHJcbiAqIEByZXR1cm5zIHtQb29sQWxsb2NhdG9yfSBQb29sZWQgYWxsb2NhdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBwb29sKGFsbG9jLCBzbGljZSwgc2l6ZSkge1xyXG4gICAgdmFyIFNJWkUgICA9IHNpemUgfHwgODE5MjtcclxuICAgIHZhciBNQVggICAgPSBTSVpFID4+PiAxO1xyXG4gICAgdmFyIHNsYWIgICA9IG51bGw7XHJcbiAgICB2YXIgb2Zmc2V0ID0gU0laRTtcclxuICAgIHJldHVybiBmdW5jdGlvbiBwb29sX2FsbG9jKHNpemUpIHtcclxuICAgICAgICBpZiAoc2l6ZSA8IDEgfHwgc2l6ZSA+IE1BWClcclxuICAgICAgICAgICAgcmV0dXJuIGFsbG9jKHNpemUpO1xyXG4gICAgICAgIGlmIChvZmZzZXQgKyBzaXplID4gU0laRSkge1xyXG4gICAgICAgICAgICBzbGFiID0gYWxsb2MoU0laRSk7XHJcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBidWYgPSBzbGljZS5jYWxsKHNsYWIsIG9mZnNldCwgb2Zmc2V0ICs9IHNpemUpO1xyXG4gICAgICAgIGlmIChvZmZzZXQgJiA3KSAvLyBhbGlnbiB0byAzMiBiaXRcclxuICAgICAgICAgICAgb2Zmc2V0ID0gKG9mZnNldCB8IDcpICsgMTtcclxuICAgICAgICByZXR1cm4gYnVmO1xyXG4gICAgfTtcclxufVxyXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IExvbmdCaXRzO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsL21pbmltYWxcIik7XG5cbi8qKlxuICogQ29uc3RydWN0cyBuZXcgbG9uZyBiaXRzLlxuICogQGNsYXNzZGVzYyBIZWxwZXIgY2xhc3MgZm9yIHdvcmtpbmcgd2l0aCB0aGUgbG93IGFuZCBoaWdoIGJpdHMgb2YgYSA2NCBiaXQgdmFsdWUuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge251bWJlcn0gbG8gTG93IDMyIGJpdHMsIHVuc2lnbmVkXG4gKiBAcGFyYW0ge251bWJlcn0gaGkgSGlnaCAzMiBiaXRzLCB1bnNpZ25lZFxuICovXG5mdW5jdGlvbiBMb25nQml0cyhsbywgaGkpIHtcblxuICAgIC8vIG5vdGUgdGhhdCB0aGUgY2FzdHMgYmVsb3cgYXJlIHRoZW9yZXRpY2FsbHkgdW5uZWNlc3NhcnkgYXMgb2YgdG9kYXksIGJ1dCBvbGRlciBzdGF0aWNhbGx5XG4gICAgLy8gZ2VuZXJhdGVkIGNvbnZlcnRlciBjb2RlIG1pZ2h0IHN0aWxsIGNhbGwgdGhlIGN0b3Igd2l0aCBzaWduZWQgMzJiaXRzLiBrZXB0IGZvciBjb21wYXQuXG5cbiAgICAvKipcbiAgICAgKiBMb3cgYml0cy5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubG8gPSBsbyA+Pj4gMDtcblxuICAgIC8qKlxuICAgICAqIEhpZ2ggYml0cy5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaGkgPSBoaSA+Pj4gMDtcbn1cblxuLyoqXG4gKiBaZXJvIGJpdHMuXG4gKiBAbWVtYmVyb2YgdXRpbC5Mb25nQml0c1xuICogQHR5cGUge3V0aWwuTG9uZ0JpdHN9XG4gKi9cbnZhciB6ZXJvID0gTG9uZ0JpdHMuemVybyA9IG5ldyBMb25nQml0cygwLCAwKTtcblxuemVyby50b051bWJlciA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbnplcm8uenpFbmNvZGUgPSB6ZXJvLnp6RGVjb2RlID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9O1xuemVyby5sZW5ndGggPSBmdW5jdGlvbigpIHsgcmV0dXJuIDE7IH07XG5cbi8qKlxuICogWmVybyBoYXNoLlxuICogQG1lbWJlcm9mIHV0aWwuTG9uZ0JpdHNcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbnZhciB6ZXJvSGFzaCA9IExvbmdCaXRzLnplcm9IYXNoID0gXCJcXDBcXDBcXDBcXDBcXDBcXDBcXDBcXDBcIjtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIG5ldyBsb25nIGJpdHMgZnJvbSB0aGUgc3BlY2lmaWVkIG51bWJlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZVxuICogQHJldHVybnMge3V0aWwuTG9uZ0JpdHN9IEluc3RhbmNlXG4gKi9cbkxvbmdCaXRzLmZyb21OdW1iZXIgPSBmdW5jdGlvbiBmcm9tTnVtYmVyKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSAwKVxuICAgICAgICByZXR1cm4gemVybztcbiAgICB2YXIgc2lnbiA9IHZhbHVlIDwgMDtcbiAgICBpZiAoc2lnbilcbiAgICAgICAgdmFsdWUgPSAtdmFsdWU7XG4gICAgdmFyIGxvID0gdmFsdWUgPj4+IDAsXG4gICAgICAgIGhpID0gKHZhbHVlIC0gbG8pIC8gNDI5NDk2NzI5NiA+Pj4gMDtcbiAgICBpZiAoc2lnbikge1xuICAgICAgICBoaSA9IH5oaSA+Pj4gMDtcbiAgICAgICAgbG8gPSB+bG8gPj4+IDA7XG4gICAgICAgIGlmICgrK2xvID4gNDI5NDk2NzI5NSkge1xuICAgICAgICAgICAgbG8gPSAwO1xuICAgICAgICAgICAgaWYgKCsraGkgPiA0Mjk0OTY3Mjk1KVxuICAgICAgICAgICAgICAgIGhpID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IExvbmdCaXRzKGxvLCBoaSk7XG59O1xuXG4vKipcbiAqIENvbnN0cnVjdHMgbmV3IGxvbmcgYml0cyBmcm9tIGEgbnVtYmVyLCBsb25nIG9yIHN0cmluZy5cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZVxuICogQHJldHVybnMge3V0aWwuTG9uZ0JpdHN9IEluc3RhbmNlXG4gKi9cbkxvbmdCaXRzLmZyb20gPSBmdW5jdGlvbiBmcm9tKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgcmV0dXJuIExvbmdCaXRzLmZyb21OdW1iZXIodmFsdWUpO1xuICAgIGlmICh1dGlsLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAodXRpbC5Mb25nKVxuICAgICAgICAgICAgdmFsdWUgPSB1dGlsLkxvbmcuZnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBMb25nQml0cy5mcm9tTnVtYmVyKHBhcnNlSW50KHZhbHVlLCAxMCkpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUubG93IHx8IHZhbHVlLmhpZ2ggPyBuZXcgTG9uZ0JpdHModmFsdWUubG93ID4+PiAwLCB2YWx1ZS5oaWdoID4+PiAwKSA6IHplcm87XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgbG9uZyBiaXRzIHRvIGEgcG9zc2libHkgdW5zYWZlIEphdmFTY3JpcHQgbnVtYmVyLlxuICogQHBhcmFtIHtib29sZWFufSBbdW5zaWduZWQ9ZmFsc2VdIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBQb3NzaWJseSB1bnNhZmUgbnVtYmVyXG4gKi9cbkxvbmdCaXRzLnByb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uIHRvTnVtYmVyKHVuc2lnbmVkKSB7XG4gICAgaWYgKCF1bnNpZ25lZCAmJiB0aGlzLmhpID4+PiAzMSkge1xuICAgICAgICB2YXIgbG8gPSB+dGhpcy5sbyArIDEgPj4+IDAsXG4gICAgICAgICAgICBoaSA9IH50aGlzLmhpICAgICA+Pj4gMDtcbiAgICAgICAgaWYgKCFsbylcbiAgICAgICAgICAgIGhpID0gaGkgKyAxID4+PiAwO1xuICAgICAgICByZXR1cm4gLShsbyArIGhpICogNDI5NDk2NzI5Nik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxvICsgdGhpcy5oaSAqIDQyOTQ5NjcyOTY7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgbG9uZyBiaXRzIHRvIGEgbG9uZy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Vuc2lnbmVkPWZhbHNlXSBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdFxuICogQHJldHVybnMge0xvbmd9IExvbmdcbiAqL1xuTG9uZ0JpdHMucHJvdG90eXBlLnRvTG9uZyA9IGZ1bmN0aW9uIHRvTG9uZyh1bnNpZ25lZCkge1xuICAgIHJldHVybiB1dGlsLkxvbmdcbiAgICAgICAgPyBuZXcgdXRpbC5Mb25nKHRoaXMubG8gfCAwLCB0aGlzLmhpIHwgMCwgQm9vbGVhbih1bnNpZ25lZCkpXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIDogeyBsb3c6IHRoaXMubG8gfCAwLCBoaWdoOiB0aGlzLmhpIHwgMCwgdW5zaWduZWQ6IEJvb2xlYW4odW5zaWduZWQpIH07XG59O1xuXG52YXIgY2hhckNvZGVBdCA9IFN0cmluZy5wcm90b3R5cGUuY2hhckNvZGVBdDtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIG5ldyBsb25nIGJpdHMgZnJvbSB0aGUgc3BlY2lmaWVkIDggY2hhcmFjdGVycyBsb25nIGhhc2guXG4gKiBAcGFyYW0ge3N0cmluZ30gaGFzaCBIYXNoXG4gKiBAcmV0dXJucyB7dXRpbC5Mb25nQml0c30gQml0c1xuICovXG5Mb25nQml0cy5mcm9tSGFzaCA9IGZ1bmN0aW9uIGZyb21IYXNoKGhhc2gpIHtcbiAgICBpZiAoaGFzaCA9PT0gemVyb0hhc2gpXG4gICAgICAgIHJldHVybiB6ZXJvO1xuICAgIHJldHVybiBuZXcgTG9uZ0JpdHMoXG4gICAgICAgICggY2hhckNvZGVBdC5jYWxsKGhhc2gsIDApXG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDEpIDw8IDhcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgMikgPDwgMTZcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgMykgPDwgMjQpID4+PiAwXG4gICAgLFxuICAgICAgICAoIGNoYXJDb2RlQXQuY2FsbChoYXNoLCA0KVxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCA1KSA8PCA4XG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDYpIDw8IDE2XG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDcpIDw8IDI0KSA+Pj4gMFxuICAgICk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgbG9uZyBiaXRzIHRvIGEgOCBjaGFyYWN0ZXJzIGxvbmcgaGFzaC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IEhhc2hcbiAqL1xuTG9uZ0JpdHMucHJvdG90eXBlLnRvSGFzaCA9IGZ1bmN0aW9uIHRvSGFzaCgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShcbiAgICAgICAgdGhpcy5sbyAgICAgICAgJiAyNTUsXG4gICAgICAgIHRoaXMubG8gPj4+IDggICYgMjU1LFxuICAgICAgICB0aGlzLmxvID4+PiAxNiAmIDI1NSxcbiAgICAgICAgdGhpcy5sbyA+Pj4gMjQgICAgICAsXG4gICAgICAgIHRoaXMuaGkgICAgICAgICYgMjU1LFxuICAgICAgICB0aGlzLmhpID4+PiA4ICAmIDI1NSxcbiAgICAgICAgdGhpcy5oaSA+Pj4gMTYgJiAyNTUsXG4gICAgICAgIHRoaXMuaGkgPj4+IDI0XG4gICAgKTtcbn07XG5cbi8qKlxuICogWmlnLXphZyBlbmNvZGVzIHRoaXMgbG9uZyBiaXRzLlxuICogQHJldHVybnMge3V0aWwuTG9uZ0JpdHN9IGB0aGlzYFxuICovXG5Mb25nQml0cy5wcm90b3R5cGUuenpFbmNvZGUgPSBmdW5jdGlvbiB6ekVuY29kZSgpIHtcbiAgICB2YXIgbWFzayA9ICAgdGhpcy5oaSA+PiAzMTtcbiAgICB0aGlzLmhpICA9ICgodGhpcy5oaSA8PCAxIHwgdGhpcy5sbyA+Pj4gMzEpIF4gbWFzaykgPj4+IDA7XG4gICAgdGhpcy5sbyAgPSAoIHRoaXMubG8gPDwgMSAgICAgICAgICAgICAgICAgICBeIG1hc2spID4+PiAwO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBaaWctemFnIGRlY29kZXMgdGhpcyBsb25nIGJpdHMuXG4gKiBAcmV0dXJucyB7dXRpbC5Mb25nQml0c30gYHRoaXNgXG4gKi9cbkxvbmdCaXRzLnByb3RvdHlwZS56ekRlY29kZSA9IGZ1bmN0aW9uIHp6RGVjb2RlKCkge1xuICAgIHZhciBtYXNrID0gLSh0aGlzLmxvICYgMSk7XG4gICAgdGhpcy5sbyAgPSAoKHRoaXMubG8gPj4+IDEgfCB0aGlzLmhpIDw8IDMxKSBeIG1hc2spID4+PiAwO1xuICAgIHRoaXMuaGkgID0gKCB0aGlzLmhpID4+PiAxICAgICAgICAgICAgICAgICAgXiBtYXNrKSA+Pj4gMDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIHRoaXMgbG9uZ2JpdHMgd2hlbiBlbmNvZGVkIGFzIGEgdmFyaW50LlxuICogQHJldHVybnMge251bWJlcn0gTGVuZ3RoXG4gKi9cbkxvbmdCaXRzLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiBsZW5ndGgoKSB7XG4gICAgdmFyIHBhcnQwID0gIHRoaXMubG8sXG4gICAgICAgIHBhcnQxID0gKHRoaXMubG8gPj4+IDI4IHwgdGhpcy5oaSA8PCA0KSA+Pj4gMCxcbiAgICAgICAgcGFydDIgPSAgdGhpcy5oaSA+Pj4gMjQ7XG4gICAgcmV0dXJuIHBhcnQyID09PSAwXG4gICAgICAgICA/IHBhcnQxID09PSAwXG4gICAgICAgICAgID8gcGFydDAgPCAxNjM4NFxuICAgICAgICAgICAgID8gcGFydDAgPCAxMjggPyAxIDogMlxuICAgICAgICAgICAgIDogcGFydDAgPCAyMDk3MTUyID8gMyA6IDRcbiAgICAgICAgICAgOiBwYXJ0MSA8IDE2Mzg0XG4gICAgICAgICAgICAgPyBwYXJ0MSA8IDEyOCA/IDUgOiA2XG4gICAgICAgICAgICAgOiBwYXJ0MSA8IDIwOTcxNTIgPyA3IDogOFxuICAgICAgICAgOiBwYXJ0MiA8IDEyOCA/IDkgOiAxMDtcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgdXRpbCA9IGV4cG9ydHM7XG5cbi8vIHVzZWQgdG8gcmV0dXJuIGEgUHJvbWlzZSB3aGVyZSBjYWxsYmFjayBpcyBvbWl0dGVkXG51dGlsLmFzUHJvbWlzZSA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9hc3Byb21pc2VcIik7XG5cbi8vIGNvbnZlcnRzIHRvIC8gZnJvbSBiYXNlNjQgZW5jb2RlZCBzdHJpbmdzXG51dGlsLmJhc2U2NCA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9iYXNlNjRcIik7XG5cbi8vIGJhc2UgY2xhc3Mgb2YgcnBjLlNlcnZpY2VcbnV0aWwuRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL2V2ZW50ZW1pdHRlclwiKTtcblxuLy8gZmxvYXQgaGFuZGxpbmcgYWNjcm9zcyBicm93c2Vyc1xudXRpbC5mbG9hdCA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9mbG9hdFwiKTtcblxuLy8gcmVxdWlyZXMgbW9kdWxlcyBvcHRpb25hbGx5IGFuZCBoaWRlcyB0aGUgY2FsbCBmcm9tIGJ1bmRsZXJzXG51dGlsLmlucXVpcmUgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvaW5xdWlyZVwiKTtcblxuLy8gY29udmVydHMgdG8gLyBmcm9tIHV0ZjggZW5jb2RlZCBzdHJpbmdzXG51dGlsLnV0ZjggPSByZXF1aXJlKFwiQHByb3RvYnVmanMvdXRmOFwiKTtcblxuLy8gcHJvdmlkZXMgYSBub2RlLWxpa2UgYnVmZmVyIHBvb2wgaW4gdGhlIGJyb3dzZXJcbnV0aWwucG9vbCA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9wb29sXCIpO1xuXG4vLyB1dGlsaXR5IHRvIHdvcmsgd2l0aCB0aGUgbG93IGFuZCBoaWdoIGJpdHMgb2YgYSA2NCBiaXQgdmFsdWVcbnV0aWwuTG9uZ0JpdHMgPSByZXF1aXJlKFwiLi9sb25nYml0c1wiKTtcblxuLyoqXG4gKiBXaGV0aGVyIHJ1bm5pbmcgd2l0aGluIG5vZGUgb3Igbm90LlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEB0eXBlIHtib29sZWFufVxuICovXG51dGlsLmlzTm9kZSA9IEJvb2xlYW4odHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIlxuICAgICAgICAgICAgICAgICAgICYmIGdsb2JhbFxuICAgICAgICAgICAgICAgICAgICYmIGdsb2JhbC5wcm9jZXNzXG4gICAgICAgICAgICAgICAgICAgJiYgZ2xvYmFsLnByb2Nlc3MudmVyc2lvbnNcbiAgICAgICAgICAgICAgICAgICAmJiBnbG9iYWwucHJvY2Vzcy52ZXJzaW9ucy5ub2RlKTtcblxuLyoqXG4gKiBHbG9iYWwgb2JqZWN0IHJlZmVyZW5jZS5cbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG51dGlsLmdsb2JhbCA9IHV0aWwuaXNOb2RlICYmIGdsb2JhbFxuICAgICAgICAgICB8fCB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvd1xuICAgICAgICAgICB8fCB0eXBlb2Ygc2VsZiAgICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGZcbiAgICAgICAgICAgfHwgdGhpczsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1pbnZhbGlkLXRoaXNcblxuLyoqXG4gKiBBbiBpbW11YWJsZSBlbXB0eSBhcnJheS5cbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAdHlwZSB7QXJyYXkuPCo+fVxuICogQGNvbnN0XG4gKi9cbnV0aWwuZW1wdHlBcnJheSA9IE9iamVjdC5mcmVlemUgPyBPYmplY3QuZnJlZXplKFtdKSA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIFtdOyAvLyB1c2VkIG9uIHByb3RvdHlwZXNcblxuLyoqXG4gKiBBbiBpbW11dGFibGUgZW1wdHkgb2JqZWN0LlxuICogQHR5cGUge09iamVjdH1cbiAqIEBjb25zdFxuICovXG51dGlsLmVtcHR5T2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSA/IE9iamVjdC5mcmVlemUoe30pIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8ge307IC8vIHVzZWQgb24gcHJvdG90eXBlc1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYW4gaW50ZWdlci5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBhbiBpbnRlZ2VyXG4gKi9cbnV0aWwuaXNJbnRlZ2VyID0gTnVtYmVyLmlzSW50ZWdlciB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBmdW5jdGlvbiBpc0ludGVnZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiICYmIGlzRmluaXRlKHZhbHVlKSAmJiBNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWU7XG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYSBzdHJpbmcuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIGEgc3RyaW5nXG4gKi9cbnV0aWwuaXNTdHJpbmcgPSBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdmFsdWUgaW5zdGFuY2VvZiBTdHJpbmc7XG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYSBub24tbnVsbCBvYmplY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIGEgbm9uLW51bGwgb2JqZWN0XG4gKi9cbnV0aWwuaXNPYmplY3QgPSBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCI7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIHByb3BlcnR5IG9uIGEgbWVzc2FnZSBpcyBjb25zaWRlcmVkIHRvIGJlIHByZXNlbnQuXG4gKiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayB1dGlsLmlzU2V0fS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBQbGFpbiBvYmplY3Qgb3IgbWVzc2FnZSBpbnN0YW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IHByb3AgUHJvcGVydHkgbmFtZVxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiBjb25zaWRlcmVkIHRvIGJlIHByZXNlbnQsIG90aGVyd2lzZSBgZmFsc2VgXG4gKi9cbnV0aWwuaXNzZXQgPVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIHByb3BlcnR5IG9uIGEgbWVzc2FnZSBpcyBjb25zaWRlcmVkIHRvIGJlIHByZXNlbnQuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFBsYWluIG9iamVjdCBvciBtZXNzYWdlIGluc3RhbmNlXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSBuYW1lXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIGNvbnNpZGVyZWQgdG8gYmUgcHJlc2VudCwgb3RoZXJ3aXNlIGBmYWxzZWBcbiAqL1xudXRpbC5pc1NldCA9IGZ1bmN0aW9uIGlzU2V0KG9iaiwgcHJvcCkge1xuICAgIHZhciB2YWx1ZSA9IG9ialtwcm9wXTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiBvYmouaGFzT3duUHJvcGVydHkocHJvcCkpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxLCBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5sZW5ndGggOiBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoKSA+IDA7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBBbnkgY29tcGF0aWJsZSBCdWZmZXIgaW5zdGFuY2UuXG4gKiBUaGlzIGlzIGEgbWluaW1hbCBzdGFuZC1hbG9uZSBkZWZpbml0aW9uIG9mIGEgQnVmZmVyIGluc3RhbmNlLiBUaGUgYWN0dWFsIHR5cGUgaXMgdGhhdCBleHBvcnRlZCBieSBub2RlJ3MgdHlwaW5ncy5cbiAqIEBpbnRlcmZhY2UgQnVmZmVyXG4gKiBAZXh0ZW5kcyBVaW50OEFycmF5XG4gKi9cblxuLyoqXG4gKiBOb2RlJ3MgQnVmZmVyIGNsYXNzIGlmIGF2YWlsYWJsZS5cbiAqIEB0eXBlIHtDb25zdHJ1Y3RvcjxCdWZmZXI+fVxuICovXG51dGlsLkJ1ZmZlciA9IChmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgICB2YXIgQnVmZmVyID0gdXRpbC5pbnF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcjtcbiAgICAgICAgLy8gcmVmdXNlIHRvIHVzZSBub24tbm9kZSBidWZmZXJzIGlmIG5vdCBleHBsaWNpdGx5IGFzc2lnbmVkIChwZXJmIHJlYXNvbnMpOlxuICAgICAgICByZXR1cm4gQnVmZmVyLnByb3RvdHlwZS51dGY4V3JpdGUgPyBCdWZmZXIgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBudWxsO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufSkoKTtcblxuLy8gSW50ZXJuYWwgYWxpYXMgb2Ygb3IgcG9seWZ1bGwgZm9yIEJ1ZmZlci5mcm9tLlxudXRpbC5fQnVmZmVyX2Zyb20gPSBudWxsO1xuXG4vLyBJbnRlcm5hbCBhbGlhcyBvZiBvciBwb2x5ZmlsbCBmb3IgQnVmZmVyLmFsbG9jVW5zYWZlLlxudXRpbC5fQnVmZmVyX2FsbG9jVW5zYWZlID0gbnVsbDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGJ1ZmZlciBvZiB3aGF0ZXZlciB0eXBlIHN1cHBvcnRlZCBieSB0aGUgZW52aXJvbm1lbnQuXG4gKiBAcGFyYW0ge251bWJlcnxudW1iZXJbXX0gW3NpemVPckFycmF5PTBdIEJ1ZmZlciBzaXplIG9yIG51bWJlciBhcnJheVxuICogQHJldHVybnMge1VpbnQ4QXJyYXl8QnVmZmVyfSBCdWZmZXJcbiAqL1xudXRpbC5uZXdCdWZmZXIgPSBmdW5jdGlvbiBuZXdCdWZmZXIoc2l6ZU9yQXJyYXkpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiB0eXBlb2Ygc2l6ZU9yQXJyYXkgPT09IFwibnVtYmVyXCJcbiAgICAgICAgPyB1dGlsLkJ1ZmZlclxuICAgICAgICAgICAgPyB1dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmUoc2l6ZU9yQXJyYXkpXG4gICAgICAgICAgICA6IG5ldyB1dGlsLkFycmF5KHNpemVPckFycmF5KVxuICAgICAgICA6IHV0aWwuQnVmZmVyXG4gICAgICAgICAgICA/IHV0aWwuX0J1ZmZlcl9mcm9tKHNpemVPckFycmF5KVxuICAgICAgICAgICAgOiB0eXBlb2YgVWludDhBcnJheSA9PT0gXCJ1bmRlZmluZWRcIlxuICAgICAgICAgICAgICAgID8gc2l6ZU9yQXJyYXlcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KHNpemVPckFycmF5KTtcbn07XG5cbi8qKlxuICogQXJyYXkgaW1wbGVtZW50YXRpb24gdXNlZCBpbiB0aGUgYnJvd3Nlci4gYFVpbnQ4QXJyYXlgIGlmIHN1cHBvcnRlZCwgb3RoZXJ3aXNlIGBBcnJheWAuXG4gKiBAdHlwZSB7Q29uc3RydWN0b3I8VWludDhBcnJheT59XG4gKi9cbnV0aWwuQXJyYXkgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gXCJ1bmRlZmluZWRcIiA/IFVpbnQ4QXJyYXkgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gOiBBcnJheTtcblxuLyoqXG4gKiBBbnkgY29tcGF0aWJsZSBMb25nIGluc3RhbmNlLlxuICogVGhpcyBpcyBhIG1pbmltYWwgc3RhbmQtYWxvbmUgZGVmaW5pdGlvbiBvZiBhIExvbmcgaW5zdGFuY2UuIFRoZSBhY3R1YWwgdHlwZSBpcyB0aGF0IGV4cG9ydGVkIGJ5IGxvbmcuanMuXG4gKiBAaW50ZXJmYWNlIExvbmdcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsb3cgTG93IGJpdHNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoaWdoIEhpZ2ggYml0c1xuICogQHByb3BlcnR5IHtib29sZWFufSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdFxuICovXG5cbi8qKlxuICogTG9uZy5qcydzIExvbmcgY2xhc3MgaWYgYXZhaWxhYmxlLlxuICogQHR5cGUge0NvbnN0cnVjdG9yPExvbmc+fVxuICovXG51dGlsLkxvbmcgPSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB1dGlsLmdsb2JhbC5kY29kZUlPICYmIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHV0aWwuZ2xvYmFsLmRjb2RlSU8uTG9uZ1xuICAgICAgICAgfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gdXRpbC5nbG9iYWwuTG9uZ1xuICAgICAgICAgfHwgdXRpbC5pbnF1aXJlKFwibG9uZ1wiKTtcblxuLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gdXNlZCB0byB2ZXJpZnkgMiBiaXQgKGBib29sYCkgbWFwIGtleXMuXG4gKiBAdHlwZSB7UmVnRXhwfVxuICogQGNvbnN0XG4gKi9cbnV0aWwua2V5MlJlID0gL150cnVlfGZhbHNlfDB8MSQvO1xuXG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIHZlcmlmeSAzMiBiaXQgKGBpbnQzMmAgZXRjLikgbWFwIGtleXMuXG4gKiBAdHlwZSB7UmVnRXhwfVxuICogQGNvbnN0XG4gKi9cbnV0aWwua2V5MzJSZSA9IC9eLT8oPzowfFsxLTldWzAtOV0qKSQvO1xuXG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIHZlcmlmeSA2NCBiaXQgKGBpbnQ2NGAgZXRjLikgbWFwIGtleXMuXG4gKiBAdHlwZSB7UmVnRXhwfVxuICogQGNvbnN0XG4gKi9cbnV0aWwua2V5NjRSZSA9IC9eKD86W1xcXFx4MDAtXFxcXHhmZl17OH18LT8oPzowfFsxLTldWzAtOV0qKSkkLztcblxuLyoqXG4gKiBDb252ZXJ0cyBhIG51bWJlciBvciBsb25nIHRvIGFuIDggY2hhcmFjdGVycyBsb25nIGhhc2ggc3RyaW5nLlxuICogQHBhcmFtIHtMb25nfG51bWJlcn0gdmFsdWUgVmFsdWUgdG8gY29udmVydFxuICogQHJldHVybnMge3N0cmluZ30gSGFzaFxuICovXG51dGlsLmxvbmdUb0hhc2ggPSBmdW5jdGlvbiBsb25nVG9IYXNoKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gICAgICAgID8gdXRpbC5Mb25nQml0cy5mcm9tKHZhbHVlKS50b0hhc2goKVxuICAgICAgICA6IHV0aWwuTG9uZ0JpdHMuemVyb0hhc2g7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIDggY2hhcmFjdGVycyBsb25nIGhhc2ggc3RyaW5nIHRvIGEgbG9uZyBvciBudW1iZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gaGFzaCBIYXNoXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1bnNpZ25lZD1mYWxzZV0gV2hldGhlciB1bnNpZ25lZCBvciBub3RcbiAqIEByZXR1cm5zIHtMb25nfG51bWJlcn0gT3JpZ2luYWwgdmFsdWVcbiAqL1xudXRpbC5sb25nRnJvbUhhc2ggPSBmdW5jdGlvbiBsb25nRnJvbUhhc2goaGFzaCwgdW5zaWduZWQpIHtcbiAgICB2YXIgYml0cyA9IHV0aWwuTG9uZ0JpdHMuZnJvbUhhc2goaGFzaCk7XG4gICAgaWYgKHV0aWwuTG9uZylcbiAgICAgICAgcmV0dXJuIHV0aWwuTG9uZy5mcm9tQml0cyhiaXRzLmxvLCBiaXRzLmhpLCB1bnNpZ25lZCk7XG4gICAgcmV0dXJuIGJpdHMudG9OdW1iZXIoQm9vbGVhbih1bnNpZ25lZCkpO1xufTtcblxuLyoqXG4gKiBNZXJnZXMgdGhlIHByb3BlcnRpZXMgb2YgdGhlIHNvdXJjZSBvYmplY3QgaW50byB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IGRzdCBEZXN0aW5hdGlvbiBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IHNyYyBTb3VyY2Ugb2JqZWN0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpZk5vdFNldD1mYWxzZV0gTWVyZ2VzIG9ubHkgaWYgdGhlIGtleSBpcyBub3QgYWxyZWFkeSBzZXRcbiAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gRGVzdGluYXRpb24gb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIG1lcmdlKGRzdCwgc3JjLCBpZk5vdFNldCkgeyAvLyB1c2VkIGJ5IGNvbnZlcnRlcnNcbiAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMoc3JjKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICBpZiAoZHN0W2tleXNbaV1dID09PSB1bmRlZmluZWQgfHwgIWlmTm90U2V0KVxuICAgICAgICAgICAgZHN0W2tleXNbaV1dID0gc3JjW2tleXNbaV1dO1xuICAgIHJldHVybiBkc3Q7XG59XG5cbnV0aWwubWVyZ2UgPSBtZXJnZTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGEgc3RyaW5nIHRvIGxvd2VyIGNhc2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyB7c3RyaW5nfSBDb252ZXJ0ZWQgc3RyaW5nXG4gKi9cbnV0aWwubGNGaXJzdCA9IGZ1bmN0aW9uIGxjRmlyc3Qoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSArIHN0ci5zdWJzdHJpbmcoMSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjdXN0b20gZXJyb3IgY29uc3RydWN0b3IuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRXJyb3IgbmFtZVxuICogQHJldHVybnMge0NvbnN0cnVjdG9yPEVycm9yPn0gQ3VzdG9tIGVycm9yIGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIG5ld0Vycm9yKG5hbWUpIHtcblxuICAgIGZ1bmN0aW9uIEN1c3RvbUVycm9yKG1lc3NhZ2UsIHByb3BlcnRpZXMpIHtcblxuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ3VzdG9tRXJyb3IpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDdXN0b21FcnJvcihtZXNzYWdlLCBwcm9wZXJ0aWVzKTtcblxuICAgICAgICAvLyBFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuICAgICAgICAvLyBeIGp1c3QgcmV0dXJucyBhIG5ldyBlcnJvciBpbnN0YW5jZSBiZWNhdXNlIHRoZSBjdG9yIGNhbiBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvblxuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1lc3NhZ2VcIiwgeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbWVzc2FnZTsgfSB9KTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIC8vIG5vZGVcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEN1c3RvbUVycm9yKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhY2tcIiwgeyB2YWx1ZTogbmV3IEVycm9yKCkuc3RhY2sgfHwgXCJcIiB9KTtcblxuICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICAgIG1lcmdlKHRoaXMsIHByb3BlcnRpZXMpO1xuICAgIH1cblxuICAgIEN1c3RvbUVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogQ3VzdG9tRXJyb3IsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgICBuYW1lOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHsgcmV0dXJuIG5hbWU7IH0sXG4gICAgICAgICAgICBzZXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgLy8gY29uZmlndXJhYmxlOiBmYWxzZSB3b3VsZCBhY2N1cmF0ZWx5IHByZXNlcnZlIHRoZSBiZWhhdmlvciBvZlxuICAgICAgICAgICAgLy8gdGhlIG9yaWdpbmFsLCBidXQgSSdtIGd1ZXNzaW5nIHRoYXQgd2FzIG5vdCBpbnRlbnRpb25hbC5cbiAgICAgICAgICAgIC8vIEZvciBhbiBhY3R1YWwgZXJyb3Igc3ViY2xhc3MsIHRoaXMgcHJvcGVydHkgd291bGRcbiAgICAgICAgICAgIC8vIGJlIGNvbmZpZ3VyYWJsZS5cbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgICAgdG9TdHJpbmc6IHtcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHsgcmV0dXJuIHRoaXMubmFtZSArIFwiOiBcIiArIHRoaXMubWVzc2FnZTsgfSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICByZXR1cm4gQ3VzdG9tRXJyb3I7XG59XG5cbnV0aWwubmV3RXJyb3IgPSBuZXdFcnJvcjtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHByb3RvY29sIGVycm9yLlxuICogQGNsYXNzZGVzYyBFcnJvciBzdWJjbGFzcyBpbmRpY2F0aW5nIGEgcHJvdG9jb2wgc3BlY2lmYyBlcnJvci5cbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAZXh0ZW5kcyBFcnJvclxuICogQHRlbXBsYXRlIFQgZXh0ZW5kcyBNZXNzYWdlPFQ+XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIEVycm9yIG1lc3NhZ2VcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IFtwcm9wZXJ0aWVzXSBBZGRpdGlvbmFsIHByb3BlcnRpZXNcbiAqIEBleGFtcGxlXG4gKiB0cnkge1xuICogICAgIE15TWVzc2FnZS5kZWNvZGUoc29tZUJ1ZmZlcik7IC8vIHRocm93cyBpZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAqIH0gY2F0Y2ggKGUpIHtcbiAqICAgICBpZiAoZSBpbnN0YW5jZW9mIFByb3RvY29sRXJyb3IgJiYgZS5pbnN0YW5jZSlcbiAqICAgICAgICAgY29uc29sZS5sb2coXCJkZWNvZGVkIHNvIGZhcjogXCIgKyBKU09OLnN0cmluZ2lmeShlLmluc3RhbmNlKSk7XG4gKiB9XG4gKi9cbnV0aWwuUHJvdG9jb2xFcnJvciA9IG5ld0Vycm9yKFwiUHJvdG9jb2xFcnJvclwiKTtcblxuLyoqXG4gKiBTbyBmYXIgZGVjb2RlZCBtZXNzYWdlIGluc3RhbmNlLlxuICogQG5hbWUgdXRpbC5Qcm90b2NvbEVycm9yI2luc3RhbmNlXG4gKiBAdHlwZSB7TWVzc2FnZTxUPn1cbiAqL1xuXG4vKipcbiAqIEEgT25lT2YgZ2V0dGVyIGFzIHJldHVybmVkIGJ5IHtAbGluayB1dGlsLm9uZU9mR2V0dGVyfS5cbiAqIEB0eXBlZGVmIE9uZU9mR2V0dGVyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gU2V0IGZpZWxkIG5hbWUsIGlmIGFueVxuICovXG5cbi8qKlxuICogQnVpbGRzIGEgZ2V0dGVyIGZvciBhIG9uZW9mJ3MgcHJlc2VudCBmaWVsZCBuYW1lLlxuICogQHBhcmFtIHtzdHJpbmdbXX0gZmllbGROYW1lcyBGaWVsZCBuYW1lc1xuICogQHJldHVybnMge09uZU9mR2V0dGVyfSBVbmJvdW5kIGdldHRlclxuICovXG51dGlsLm9uZU9mR2V0dGVyID0gZnVuY3Rpb24gZ2V0T25lT2YoZmllbGROYW1lcykge1xuICAgIHZhciBmaWVsZE1hcCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGROYW1lcy5sZW5ndGg7ICsraSlcbiAgICAgICAgZmllbGRNYXBbZmllbGROYW1lc1tpXV0gPSAxO1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFNldCBmaWVsZCBuYW1lLCBpZiBhbnlcbiAgICAgKiBAdGhpcyBPYmplY3RcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKSwgaSA9IGtleXMubGVuZ3RoIC0gMTsgaSA+IC0xOyAtLWkpXG4gICAgICAgICAgICBpZiAoZmllbGRNYXBba2V5c1tpXV0gPT09IDEgJiYgdGhpc1trZXlzW2ldXSAhPT0gdW5kZWZpbmVkICYmIHRoaXNba2V5c1tpXV0gIT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleXNbaV07XG4gICAgfTtcbn07XG5cbi8qKlxuICogQSBPbmVPZiBzZXR0ZXIgYXMgcmV0dXJuZWQgYnkge0BsaW5rIHV0aWwub25lT2ZTZXR0ZXJ9LlxuICogQHR5cGVkZWYgT25lT2ZTZXR0ZXJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gdmFsdWUgRmllbGQgbmFtZVxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuXG4vKipcbiAqIEJ1aWxkcyBhIHNldHRlciBmb3IgYSBvbmVvZidzIHByZXNlbnQgZmllbGQgbmFtZS5cbiAqIEBwYXJhbSB7c3RyaW5nW119IGZpZWxkTmFtZXMgRmllbGQgbmFtZXNcbiAqIEByZXR1cm5zIHtPbmVPZlNldHRlcn0gVW5ib3VuZCBzZXR0ZXJcbiAqL1xudXRpbC5vbmVPZlNldHRlciA9IGZ1bmN0aW9uIHNldE9uZU9mKGZpZWxkTmFtZXMpIHtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEZpZWxkIG5hbWVcbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICAqIEB0aGlzIE9iamVjdFxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICByZXR1cm4gZnVuY3Rpb24obmFtZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkTmFtZXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICBpZiAoZmllbGROYW1lc1tpXSAhPT0gbmFtZSlcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpc1tmaWVsZE5hbWVzW2ldXTtcbiAgICB9O1xufTtcblxuLyoqXG4gKiBEZWZhdWx0IGNvbnZlcnNpb24gb3B0aW9ucyB1c2VkIGZvciB7QGxpbmsgTWVzc2FnZSN0b0pTT059IGltcGxlbWVudGF0aW9ucy5cbiAqXG4gKiBUaGVzZSBvcHRpb25zIGFyZSBjbG9zZSB0byBwcm90bzMncyBKU09OIG1hcHBpbmcgd2l0aCB0aGUgZXhjZXB0aW9uIHRoYXQgaW50ZXJuYWwgdHlwZXMgbGlrZSBBbnkgYXJlIGhhbmRsZWQganVzdCBsaWtlIG1lc3NhZ2VzLiBNb3JlIHByZWNpc2VseTpcbiAqXG4gKiAtIExvbmdzIGJlY29tZSBzdHJpbmdzXG4gKiAtIEVudW1zIGJlY29tZSBzdHJpbmcga2V5c1xuICogLSBCeXRlcyBiZWNvbWUgYmFzZTY0IGVuY29kZWQgc3RyaW5nc1xuICogLSAoU3ViLSlNZXNzYWdlcyBiZWNvbWUgcGxhaW4gb2JqZWN0c1xuICogLSBNYXBzIGJlY29tZSBwbGFpbiBvYmplY3RzIHdpdGggYWxsIHN0cmluZyBrZXlzXG4gKiAtIFJlcGVhdGVkIGZpZWxkcyBiZWNvbWUgYXJyYXlzXG4gKiAtIE5hTiBhbmQgSW5maW5pdHkgZm9yIGZsb2F0IGFuZCBkb3VibGUgZmllbGRzIGJlY29tZSBzdHJpbmdzXG4gKlxuICogQHR5cGUge0lDb252ZXJzaW9uT3B0aW9uc31cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vcHJvdG9jb2wtYnVmZmVycy9kb2NzL3Byb3RvMz9obD1lbiNqc29uXG4gKi9cbnV0aWwudG9KU09OT3B0aW9ucyA9IHtcbiAgICBsb25nczogU3RyaW5nLFxuICAgIGVudW1zOiBTdHJpbmcsXG4gICAgYnl0ZXM6IFN0cmluZyxcbiAgICBqc29uOiB0cnVlXG59O1xuXG4vLyBTZXRzIHVwIGJ1ZmZlciB1dGlsaXR5IGFjY29yZGluZyB0byB0aGUgZW52aXJvbm1lbnQgKGNhbGxlZCBpbiBpbmRleC1taW5pbWFsKVxudXRpbC5fY29uZmlndXJlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIEJ1ZmZlciA9IHV0aWwuQnVmZmVyO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghQnVmZmVyKSB7XG4gICAgICAgIHV0aWwuX0J1ZmZlcl9mcm9tID0gdXRpbC5fQnVmZmVyX2FsbG9jVW5zYWZlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBiZWNhdXNlIG5vZGUgNC54IGJ1ZmZlcnMgYXJlIGluY29tcGF0aWJsZSAmIGltbXV0YWJsZVxuICAgIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Rjb2RlSU8vcHJvdG9idWYuanMvcHVsbC82NjVcbiAgICB1dGlsLl9CdWZmZXJfZnJvbSA9IEJ1ZmZlci5mcm9tICE9PSBVaW50OEFycmF5LmZyb20gJiYgQnVmZmVyLmZyb20gfHxcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgZnVuY3Rpb24gQnVmZmVyX2Zyb20odmFsdWUsIGVuY29kaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmcpO1xuICAgICAgICB9O1xuICAgIHV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSB8fFxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBmdW5jdGlvbiBCdWZmZXJfYWxsb2NVbnNhZmUoc2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoc2l6ZSk7XG4gICAgICAgIH07XG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBXcml0ZXI7XG5cbnZhciB1dGlsICAgICAgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XG5cbnZhciBCdWZmZXJXcml0ZXI7IC8vIGN5Y2xpY1xuXG52YXIgTG9uZ0JpdHMgID0gdXRpbC5Mb25nQml0cyxcbiAgICBiYXNlNjQgICAgPSB1dGlsLmJhc2U2NCxcbiAgICB1dGY4ICAgICAgPSB1dGlsLnV0Zjg7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyB3cml0ZXIgb3BlcmF0aW9uIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBTY2hlZHVsZWQgd3JpdGVyIG9wZXJhdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBVaW50OEFycmF5LCBudW1iZXIpfSBmbiBGdW5jdGlvbiB0byBjYWxsXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuIFZhbHVlIGJ5dGUgbGVuZ3RoXG4gKiBAcGFyYW0geyp9IHZhbCBWYWx1ZSB0byB3cml0ZVxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBPcChmbiwgbGVuLCB2YWwpIHtcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRvIGNhbGwuXG4gICAgICogQHR5cGUge2Z1bmN0aW9uKFVpbnQ4QXJyYXksIG51bWJlciwgKil9XG4gICAgICovXG4gICAgdGhpcy5mbiA9IGZuO1xuXG4gICAgLyoqXG4gICAgICogVmFsdWUgYnl0ZSBsZW5ndGguXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxlbiA9IGxlbjtcblxuICAgIC8qKlxuICAgICAqIE5leHQgb3BlcmF0aW9uLlxuICAgICAqIEB0eXBlIHtXcml0ZXIuT3B8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMubmV4dCA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIFZhbHVlIHRvIHdyaXRlLlxuICAgICAqIEB0eXBlIHsqfVxuICAgICAqL1xuICAgIHRoaXMudmFsID0gdmFsOyAvLyB0eXBlIHZhcmllc1xufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gbm9vcCgpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHktZnVuY3Rpb25cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHdyaXRlciBzdGF0ZSBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgQ29waWVkIHdyaXRlciBzdGF0ZS5cbiAqIEBtZW1iZXJvZiBXcml0ZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtXcml0ZXJ9IHdyaXRlciBXcml0ZXIgdG8gY29weSBzdGF0ZSBmcm9tXG4gKiBAaWdub3JlXG4gKi9cbmZ1bmN0aW9uIFN0YXRlKHdyaXRlcikge1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBoZWFkLlxuICAgICAqIEB0eXBlIHtXcml0ZXIuT3B9XG4gICAgICovXG4gICAgdGhpcy5oZWFkID0gd3JpdGVyLmhlYWQ7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IHRhaWwuXG4gICAgICogQHR5cGUge1dyaXRlci5PcH1cbiAgICAgKi9cbiAgICB0aGlzLnRhaWwgPSB3cml0ZXIudGFpbDtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgYnVmZmVyIGxlbmd0aC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGVuID0gd3JpdGVyLmxlbjtcblxuICAgIC8qKlxuICAgICAqIE5leHQgc3RhdGUuXG4gICAgICogQHR5cGUge1N0YXRlfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5uZXh0ID0gd3JpdGVyLnN0YXRlcztcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHdyaXRlciBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgV2lyZSBmb3JtYXQgd3JpdGVyIHVzaW5nIGBVaW50OEFycmF5YCBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBgQXJyYXlgLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFdyaXRlcigpIHtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgbGVuZ3RoLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sZW4gPSAwO1xuXG4gICAgLyoqXG4gICAgICogT3BlcmF0aW9ucyBoZWFkLlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5oZWFkID0gbmV3IE9wKG5vb3AsIDAsIDApO1xuXG4gICAgLyoqXG4gICAgICogT3BlcmF0aW9ucyB0YWlsXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLnRhaWwgPSB0aGlzLmhlYWQ7XG5cbiAgICAvKipcbiAgICAgKiBMaW5rZWQgZm9ya2VkIHN0YXRlcy5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5zdGF0ZXMgPSBudWxsO1xuXG4gICAgLy8gV2hlbiBhIHZhbHVlIGlzIHdyaXR0ZW4sIHRoZSB3cml0ZXIgY2FsY3VsYXRlcyBpdHMgYnl0ZSBsZW5ndGggYW5kIHB1dHMgaXQgaW50byBhIGxpbmtlZFxuICAgIC8vIGxpc3Qgb2Ygb3BlcmF0aW9ucyB0byBwZXJmb3JtIHdoZW4gZmluaXNoKCkgaXMgY2FsbGVkLiBUaGlzIGJvdGggYWxsb3dzIHVzIHRvIGFsbG9jYXRlXG4gICAgLy8gYnVmZmVycyBvZiB0aGUgZXhhY3QgcmVxdWlyZWQgc2l6ZSBhbmQgcmVkdWNlcyB0aGUgYW1vdW50IG9mIHdvcmsgd2UgaGF2ZSB0byBkbyBjb21wYXJlZFxuICAgIC8vIHRvIGZpcnN0IGNhbGN1bGF0aW5nIG92ZXIgb2JqZWN0cyBhbmQgdGhlbiBlbmNvZGluZyBvdmVyIG9iamVjdHMuIEluIG91ciBjYXNlLCB0aGUgZW5jb2RpbmdcbiAgICAvLyBwYXJ0IGlzIGp1c3QgYSBsaW5rZWQgbGlzdCB3YWxrIGNhbGxpbmcgb3BlcmF0aW9ucyB3aXRoIGFscmVhZHkgcHJlcGFyZWQgdmFsdWVzLlxufVxuXG52YXIgY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgIHJldHVybiB1dGlsLkJ1ZmZlclxuICAgICAgICA/IGZ1bmN0aW9uIGNyZWF0ZV9idWZmZXJfc2V0dXAoKSB7XG4gICAgICAgICAgICByZXR1cm4gKFdyaXRlci5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGVfYnVmZmVyKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyV3JpdGVyKCk7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIDogZnVuY3Rpb24gY3JlYXRlX2FycmF5KCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBXcml0ZXIoKTtcbiAgICAgICAgfTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB3cml0ZXIuXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtCdWZmZXJXcml0ZXJ8V3JpdGVyfSBBIHtAbGluayBCdWZmZXJXcml0ZXJ9IHdoZW4gQnVmZmVycyBhcmUgc3VwcG9ydGVkLCBvdGhlcndpc2UgYSB7QGxpbmsgV3JpdGVyfVxuICovXG5Xcml0ZXIuY3JlYXRlID0gY3JlYXRlKCk7XG5cbi8qKlxuICogQWxsb2NhdGVzIGEgYnVmZmVyIG9mIHRoZSBzcGVjaWZpZWQgc2l6ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIEJ1ZmZlciBzaXplXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX0gQnVmZmVyXG4gKi9cbldyaXRlci5hbGxvYyA9IGZ1bmN0aW9uIGFsbG9jKHNpemUpIHtcbiAgICByZXR1cm4gbmV3IHV0aWwuQXJyYXkoc2l6ZSk7XG59O1xuXG4vLyBVc2UgVWludDhBcnJheSBidWZmZXIgcG9vbCBpbiB0aGUgYnJvd3NlciwganVzdCBsaWtlIG5vZGUgZG9lcyB3aXRoIGJ1ZmZlcnNcbi8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG5pZiAodXRpbC5BcnJheSAhPT0gQXJyYXkpXG4gICAgV3JpdGVyLmFsbG9jID0gdXRpbC5wb29sKFdyaXRlci5hbGxvYywgdXRpbC5BcnJheS5wcm90b3R5cGUuc3ViYXJyYXkpO1xuXG4vKipcbiAqIFB1c2hlcyBhIG5ldyBvcGVyYXRpb24gdG8gdGhlIHF1ZXVlLlxuICogQHBhcmFtIHtmdW5jdGlvbihVaW50OEFycmF5LCBudW1iZXIsICopfSBmbiBGdW5jdGlvbiB0byBjYWxsXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuIFZhbHVlIGJ5dGUgbGVuZ3RoXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqIEBwcml2YXRlXG4gKi9cbldyaXRlci5wcm90b3R5cGUuX3B1c2ggPSBmdW5jdGlvbiBwdXNoKGZuLCBsZW4sIHZhbCkge1xuICAgIHRoaXMudGFpbCA9IHRoaXMudGFpbC5uZXh0ID0gbmV3IE9wKGZuLCBsZW4sIHZhbCk7XG4gICAgdGhpcy5sZW4gKz0gbGVuO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gd3JpdGVCeXRlKHZhbCwgYnVmLCBwb3MpIHtcbiAgICBidWZbcG9zXSA9IHZhbCAmIDI1NTtcbn1cblxuZnVuY3Rpb24gd3JpdGVWYXJpbnQzMih2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgd2hpbGUgKHZhbCA+IDEyNykge1xuICAgICAgICBidWZbcG9zKytdID0gdmFsICYgMTI3IHwgMTI4O1xuICAgICAgICB2YWwgPj4+PSA3O1xuICAgIH1cbiAgICBidWZbcG9zXSA9IHZhbDtcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHZhcmludCB3cml0ZXIgb3BlcmF0aW9uIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBTY2hlZHVsZWQgdmFyaW50IHdyaXRlciBvcGVyYXRpb24uXG4gKiBAZXh0ZW5kcyBPcFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuIFZhbHVlIGJ5dGUgbGVuZ3RoXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIFZhbHVlIHRvIHdyaXRlXG4gKiBAaWdub3JlXG4gKi9cbmZ1bmN0aW9uIFZhcmludE9wKGxlbiwgdmFsKSB7XG4gICAgdGhpcy5sZW4gPSBsZW47XG4gICAgdGhpcy5uZXh0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudmFsID0gdmFsO1xufVxuXG5WYXJpbnRPcC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE9wLnByb3RvdHlwZSk7XG5WYXJpbnRPcC5wcm90b3R5cGUuZm4gPSB3cml0ZVZhcmludDMyO1xuXG4vKipcbiAqIFdyaXRlcyBhbiB1bnNpZ25lZCAzMiBiaXQgdmFsdWUgYXMgYSB2YXJpbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLnVpbnQzMiA9IGZ1bmN0aW9uIHdyaXRlX3VpbnQzMih2YWx1ZSkge1xuICAgIC8vIGhlcmUsIHRoZSBjYWxsIHRvIHRoaXMucHVzaCBoYXMgYmVlbiBpbmxpbmVkIGFuZCBhIHZhcmludCBzcGVjaWZpYyBPcCBzdWJjbGFzcyBpcyB1c2VkLlxuICAgIC8vIHVpbnQzMiBpcyBieSBmYXIgdGhlIG1vc3QgZnJlcXVlbnRseSB1c2VkIG9wZXJhdGlvbiBhbmQgYmVuZWZpdHMgc2lnbmlmaWNhbnRseSBmcm9tIHRoaXMuXG4gICAgdGhpcy5sZW4gKz0gKHRoaXMudGFpbCA9IHRoaXMudGFpbC5uZXh0ID0gbmV3IFZhcmludE9wKFxuICAgICAgICAodmFsdWUgPSB2YWx1ZSA+Pj4gMClcbiAgICAgICAgICAgICAgICA8IDEyOCAgICAgICA/IDFcbiAgICAgICAgOiB2YWx1ZSA8IDE2Mzg0ICAgICA/IDJcbiAgICAgICAgOiB2YWx1ZSA8IDIwOTcxNTIgICA/IDNcbiAgICAgICAgOiB2YWx1ZSA8IDI2ODQzNTQ1NiA/IDRcbiAgICAgICAgOiAgICAgICAgICAgICAgICAgICAgIDUsXG4gICAgdmFsdWUpKS5sZW47XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHNpZ25lZCAzMiBiaXQgdmFsdWUgYXMgYSB2YXJpbnQuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuaW50MzIgPSBmdW5jdGlvbiB3cml0ZV9pbnQzMih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA8IDBcbiAgICAgICAgPyB0aGlzLl9wdXNoKHdyaXRlVmFyaW50NjQsIDEwLCBMb25nQml0cy5mcm9tTnVtYmVyKHZhbHVlKSkgLy8gMTAgYnl0ZXMgcGVyIHNwZWNcbiAgICAgICAgOiB0aGlzLnVpbnQzMih2YWx1ZSk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIDMyIGJpdCB2YWx1ZSBhcyBhIHZhcmludCwgemlnLXphZyBlbmNvZGVkLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5zaW50MzIgPSBmdW5jdGlvbiB3cml0ZV9zaW50MzIodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy51aW50MzIoKHZhbHVlIDw8IDEgXiB2YWx1ZSA+PiAzMSkgPj4+IDApO1xufTtcblxuZnVuY3Rpb24gd3JpdGVWYXJpbnQ2NCh2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgd2hpbGUgKHZhbC5oaSkge1xuICAgICAgICBidWZbcG9zKytdID0gdmFsLmxvICYgMTI3IHwgMTI4O1xuICAgICAgICB2YWwubG8gPSAodmFsLmxvID4+PiA3IHwgdmFsLmhpIDw8IDI1KSA+Pj4gMDtcbiAgICAgICAgdmFsLmhpID4+Pj0gNztcbiAgICB9XG4gICAgd2hpbGUgKHZhbC5sbyA+IDEyNykge1xuICAgICAgICBidWZbcG9zKytdID0gdmFsLmxvICYgMTI3IHwgMTI4O1xuICAgICAgICB2YWwubG8gPSB2YWwubG8gPj4+IDc7XG4gICAgfVxuICAgIGJ1Zltwb3MrK10gPSB2YWwubG87XG59XG5cbi8qKlxuICogV3JpdGVzIGFuIHVuc2lnbmVkIDY0IGJpdCB2YWx1ZSBhcyBhIHZhcmludC5cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGB2YWx1ZWAgaXMgYSBzdHJpbmcgYW5kIG5vIGxvbmcgbGlicmFyeSBpcyBwcmVzZW50LlxuICovXG5Xcml0ZXIucHJvdG90eXBlLnVpbnQ2NCA9IGZ1bmN0aW9uIHdyaXRlX3VpbnQ2NCh2YWx1ZSkge1xuICAgIHZhciBiaXRzID0gTG9uZ0JpdHMuZnJvbSh2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVWYXJpbnQ2NCwgYml0cy5sZW5ndGgoKSwgYml0cyk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHNpZ25lZCA2NCBiaXQgdmFsdWUgYXMgYSB2YXJpbnQuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGB2YWx1ZWAgaXMgYSBzdHJpbmcgYW5kIG5vIGxvbmcgbGlicmFyeSBpcyBwcmVzZW50LlxuICovXG5Xcml0ZXIucHJvdG90eXBlLmludDY0ID0gV3JpdGVyLnByb3RvdHlwZS51aW50NjQ7XG5cbi8qKlxuICogV3JpdGVzIGEgc2lnbmVkIDY0IGJpdCB2YWx1ZSBhcyBhIHZhcmludCwgemlnLXphZyBlbmNvZGVkLlxuICogQHBhcmFtIHtMb25nfG51bWJlcnxzdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYHZhbHVlYCBpcyBhIHN0cmluZyBhbmQgbm8gbG9uZyBsaWJyYXJ5IGlzIHByZXNlbnQuXG4gKi9cbldyaXRlci5wcm90b3R5cGUuc2ludDY0ID0gZnVuY3Rpb24gd3JpdGVfc2ludDY0KHZhbHVlKSB7XG4gICAgdmFyIGJpdHMgPSBMb25nQml0cy5mcm9tKHZhbHVlKS56ekVuY29kZSgpO1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlVmFyaW50NjQsIGJpdHMubGVuZ3RoKCksIGJpdHMpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBib29saXNoIHZhbHVlIGFzIGEgdmFyaW50LlxuICogQHBhcmFtIHtib29sZWFufSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuYm9vbCA9IGZ1bmN0aW9uIHdyaXRlX2Jvb2wodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZUJ5dGUsIDEsIHZhbHVlID8gMSA6IDApO1xufTtcblxuZnVuY3Rpb24gd3JpdGVGaXhlZDMyKHZhbCwgYnVmLCBwb3MpIHtcbiAgICBidWZbcG9zICAgIF0gPSAgdmFsICAgICAgICAgJiAyNTU7XG4gICAgYnVmW3BvcyArIDFdID0gIHZhbCA+Pj4gOCAgICYgMjU1O1xuICAgIGJ1Zltwb3MgKyAyXSA9ICB2YWwgPj4+IDE2ICAmIDI1NTtcbiAgICBidWZbcG9zICsgM10gPSAgdmFsID4+PiAyNDtcbn1cblxuLyoqXG4gKiBXcml0ZXMgYW4gdW5zaWduZWQgMzIgYml0IHZhbHVlIGFzIGZpeGVkIDMyIGJpdHMuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmZpeGVkMzIgPSBmdW5jdGlvbiB3cml0ZV9maXhlZDMyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVGaXhlZDMyLCA0LCB2YWx1ZSA+Pj4gMCk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHNpZ25lZCAzMiBiaXQgdmFsdWUgYXMgZml4ZWQgMzIgYml0cy5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5zZml4ZWQzMiA9IFdyaXRlci5wcm90b3R5cGUuZml4ZWQzMjtcblxuLyoqXG4gKiBXcml0ZXMgYW4gdW5zaWduZWQgNjQgYml0IHZhbHVlIGFzIGZpeGVkIDY0IGJpdHMuXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgdmFsdWVgIGlzIGEgc3RyaW5nIGFuZCBubyBsb25nIGxpYnJhcnkgaXMgcHJlc2VudC5cbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5maXhlZDY0ID0gZnVuY3Rpb24gd3JpdGVfZml4ZWQ2NCh2YWx1ZSkge1xuICAgIHZhciBiaXRzID0gTG9uZ0JpdHMuZnJvbSh2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVGaXhlZDMyLCA0LCBiaXRzLmxvKS5fcHVzaCh3cml0ZUZpeGVkMzIsIDQsIGJpdHMuaGkpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBzaWduZWQgNjQgYml0IHZhbHVlIGFzIGZpeGVkIDY0IGJpdHMuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGB2YWx1ZWAgaXMgYSBzdHJpbmcgYW5kIG5vIGxvbmcgbGlicmFyeSBpcyBwcmVzZW50LlxuICovXG5Xcml0ZXIucHJvdG90eXBlLnNmaXhlZDY0ID0gV3JpdGVyLnByb3RvdHlwZS5maXhlZDY0O1xuXG4vKipcbiAqIFdyaXRlcyBhIGZsb2F0ICgzMiBiaXQpLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmZsb2F0ID0gZnVuY3Rpb24gd3JpdGVfZmxvYXQodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh1dGlsLmZsb2F0LndyaXRlRmxvYXRMRSwgNCwgdmFsdWUpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBkb3VibGUgKDY0IGJpdCBmbG9hdCkuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuZG91YmxlID0gZnVuY3Rpb24gd3JpdGVfZG91YmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2godXRpbC5mbG9hdC53cml0ZURvdWJsZUxFLCA4LCB2YWx1ZSk7XG59O1xuXG52YXIgd3JpdGVCeXRlcyA9IHV0aWwuQXJyYXkucHJvdG90eXBlLnNldFxuICAgID8gZnVuY3Rpb24gd3JpdGVCeXRlc19zZXQodmFsLCBidWYsIHBvcykge1xuICAgICAgICBidWYuc2V0KHZhbCwgcG9zKTsgLy8gYWxzbyB3b3JrcyBmb3IgcGxhaW4gYXJyYXkgdmFsdWVzXG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgOiBmdW5jdGlvbiB3cml0ZUJ5dGVzX2Zvcih2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgYnVmW3BvcyArIGldID0gdmFsW2ldO1xuICAgIH07XG5cbi8qKlxuICogV3JpdGVzIGEgc2VxdWVuY2Ugb2YgYnl0ZXMuXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl8c3RyaW5nfSB2YWx1ZSBCdWZmZXIgb3IgYmFzZTY0IGVuY29kZWQgc3RyaW5nIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5ieXRlcyA9IGZ1bmN0aW9uIHdyaXRlX2J5dGVzKHZhbHVlKSB7XG4gICAgdmFyIGxlbiA9IHZhbHVlLmxlbmd0aCA+Pj4gMDtcbiAgICBpZiAoIWxlbilcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVCeXRlLCAxLCAwKTtcbiAgICBpZiAodXRpbC5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgdmFyIGJ1ZiA9IFdyaXRlci5hbGxvYyhsZW4gPSBiYXNlNjQubGVuZ3RoKHZhbHVlKSk7XG4gICAgICAgIGJhc2U2NC5kZWNvZGUodmFsdWUsIGJ1ZiwgMCk7XG4gICAgICAgIHZhbHVlID0gYnVmO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy51aW50MzIobGVuKS5fcHVzaCh3cml0ZUJ5dGVzLCBsZW4sIHZhbHVlKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgc3RyaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5zdHJpbmcgPSBmdW5jdGlvbiB3cml0ZV9zdHJpbmcodmFsdWUpIHtcbiAgICB2YXIgbGVuID0gdXRmOC5sZW5ndGgodmFsdWUpO1xuICAgIHJldHVybiBsZW5cbiAgICAgICAgPyB0aGlzLnVpbnQzMihsZW4pLl9wdXNoKHV0Zjgud3JpdGUsIGxlbiwgdmFsdWUpXG4gICAgICAgIDogdGhpcy5fcHVzaCh3cml0ZUJ5dGUsIDEsIDApO1xufTtcblxuLyoqXG4gKiBGb3JrcyB0aGlzIHdyaXRlcidzIHN0YXRlIGJ5IHB1c2hpbmcgaXQgdG8gYSBzdGFjay5cbiAqIENhbGxpbmcge0BsaW5rIFdyaXRlciNyZXNldHxyZXNldH0gb3Ige0BsaW5rIFdyaXRlciNsZGVsaW18bGRlbGltfSByZXNldHMgdGhlIHdyaXRlciB0byB0aGUgcHJldmlvdXMgc3RhdGUuXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5mb3JrID0gZnVuY3Rpb24gZm9yaygpIHtcbiAgICB0aGlzLnN0YXRlcyA9IG5ldyBTdGF0ZSh0aGlzKTtcbiAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBuZXcgT3Aobm9vcCwgMCwgMCk7XG4gICAgdGhpcy5sZW4gPSAwO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXNldHMgdGhpcyBpbnN0YW5jZSB0byB0aGUgbGFzdCBzdGF0ZS5cbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGVzKSB7XG4gICAgICAgIHRoaXMuaGVhZCAgID0gdGhpcy5zdGF0ZXMuaGVhZDtcbiAgICAgICAgdGhpcy50YWlsICAgPSB0aGlzLnN0YXRlcy50YWlsO1xuICAgICAgICB0aGlzLmxlbiAgICA9IHRoaXMuc3RhdGVzLmxlbjtcbiAgICAgICAgdGhpcy5zdGF0ZXMgPSB0aGlzLnN0YXRlcy5uZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG5ldyBPcChub29wLCAwLCAwKTtcbiAgICAgICAgdGhpcy5sZW4gID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlc2V0cyB0byB0aGUgbGFzdCBzdGF0ZSBhbmQgYXBwZW5kcyB0aGUgZm9yayBzdGF0ZSdzIGN1cnJlbnQgd3JpdGUgbGVuZ3RoIGFzIGEgdmFyaW50IGZvbGxvd2VkIGJ5IGl0cyBvcGVyYXRpb25zLlxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUubGRlbGltID0gZnVuY3Rpb24gbGRlbGltKCkge1xuICAgIHZhciBoZWFkID0gdGhpcy5oZWFkLFxuICAgICAgICB0YWlsID0gdGhpcy50YWlsLFxuICAgICAgICBsZW4gID0gdGhpcy5sZW47XG4gICAgdGhpcy5yZXNldCgpLnVpbnQzMihsZW4pO1xuICAgIGlmIChsZW4pIHtcbiAgICAgICAgdGhpcy50YWlsLm5leHQgPSBoZWFkLm5leHQ7IC8vIHNraXAgbm9vcFxuICAgICAgICB0aGlzLnRhaWwgPSB0YWlsO1xuICAgICAgICB0aGlzLmxlbiArPSBsZW47XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBGaW5pc2hlcyB0aGUgd3JpdGUgb3BlcmF0aW9uLlxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IEZpbmlzaGVkIGJ1ZmZlclxuICovXG5Xcml0ZXIucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uIGZpbmlzaCgpIHtcbiAgICB2YXIgaGVhZCA9IHRoaXMuaGVhZC5uZXh0LCAvLyBza2lwIG5vb3BcbiAgICAgICAgYnVmICA9IHRoaXMuY29uc3RydWN0b3IuYWxsb2ModGhpcy5sZW4pLFxuICAgICAgICBwb3MgID0gMDtcbiAgICB3aGlsZSAoaGVhZCkge1xuICAgICAgICBoZWFkLmZuKGhlYWQudmFsLCBidWYsIHBvcyk7XG4gICAgICAgIHBvcyArPSBoZWFkLmxlbjtcbiAgICAgICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgICB9XG4gICAgLy8gdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICByZXR1cm4gYnVmO1xufTtcblxuV3JpdGVyLl9jb25maWd1cmUgPSBmdW5jdGlvbihCdWZmZXJXcml0ZXJfKSB7XG4gICAgQnVmZmVyV3JpdGVyID0gQnVmZmVyV3JpdGVyXztcbiAgICBXcml0ZXIuY3JlYXRlID0gY3JlYXRlKCk7XG4gICAgQnVmZmVyV3JpdGVyLl9jb25maWd1cmUoKTtcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlcldyaXRlcjtcblxuLy8gZXh0ZW5kcyBXcml0ZXJcbnZhciBXcml0ZXIgPSByZXF1aXJlKFwiLi93cml0ZXJcIik7XG4oQnVmZmVyV3JpdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoV3JpdGVyLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gQnVmZmVyV3JpdGVyO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWwvbWluaW1hbFwiKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IGJ1ZmZlciB3cml0ZXIgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFdpcmUgZm9ybWF0IHdyaXRlciB1c2luZyBub2RlIGJ1ZmZlcnMuXG4gKiBAZXh0ZW5kcyBXcml0ZXJcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBCdWZmZXJXcml0ZXIoKSB7XG4gICAgV3JpdGVyLmNhbGwodGhpcyk7XG59XG5cbkJ1ZmZlcldyaXRlci5fY29uZmlndXJlID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEFsbG9jYXRlcyBhIGJ1ZmZlciBvZiB0aGUgc3BlY2lmaWVkIHNpemUuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgQnVmZmVyIHNpemVcbiAgICAgKiBAcmV0dXJucyB7QnVmZmVyfSBCdWZmZXJcbiAgICAgKi9cbiAgICBCdWZmZXJXcml0ZXIuYWxsb2MgPSB1dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmU7XG5cbiAgICBCdWZmZXJXcml0ZXIud3JpdGVCeXRlc0J1ZmZlciA9IHV0aWwuQnVmZmVyICYmIHV0aWwuQnVmZmVyLnByb3RvdHlwZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgdXRpbC5CdWZmZXIucHJvdG90eXBlLnNldC5uYW1lID09PSBcInNldFwiXG4gICAgICAgID8gZnVuY3Rpb24gd3JpdGVCeXRlc0J1ZmZlcl9zZXQodmFsLCBidWYsIHBvcykge1xuICAgICAgICAgIGJ1Zi5zZXQodmFsLCBwb3MpOyAvLyBmYXN0ZXIgdGhhbiBjb3B5IChyZXF1aXJlcyBub2RlID49IDQgd2hlcmUgQnVmZmVycyBleHRlbmQgVWludDhBcnJheSBhbmQgc2V0IGlzIHByb3Blcmx5IGluaGVyaXRlZClcbiAgICAgICAgICAvLyBhbHNvIHdvcmtzIGZvciBwbGFpbiBhcnJheSB2YWx1ZXNcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICA6IGZ1bmN0aW9uIHdyaXRlQnl0ZXNCdWZmZXJfY29weSh2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgICAgICAgaWYgKHZhbC5jb3B5KSAvLyBCdWZmZXIgdmFsdWVzXG4gICAgICAgICAgICB2YWwuY29weShidWYsIHBvcywgMCwgdmFsLmxlbmd0aCk7XG4gICAgICAgICAgZWxzZSBmb3IgKHZhciBpID0gMDsgaSA8IHZhbC5sZW5ndGg7KSAvLyBwbGFpbiBhcnJheSB2YWx1ZXNcbiAgICAgICAgICAgIGJ1Zltwb3MrK10gPSB2YWxbaSsrXTtcbiAgICAgICAgfTtcbn07XG5cblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuQnVmZmVyV3JpdGVyLnByb3RvdHlwZS5ieXRlcyA9IGZ1bmN0aW9uIHdyaXRlX2J5dGVzX2J1ZmZlcih2YWx1ZSkge1xuICAgIGlmICh1dGlsLmlzU3RyaW5nKHZhbHVlKSlcbiAgICAgICAgdmFsdWUgPSB1dGlsLl9CdWZmZXJfZnJvbSh2YWx1ZSwgXCJiYXNlNjRcIik7XG4gICAgdmFyIGxlbiA9IHZhbHVlLmxlbmd0aCA+Pj4gMDtcbiAgICB0aGlzLnVpbnQzMihsZW4pO1xuICAgIGlmIChsZW4pXG4gICAgICAgIHRoaXMuX3B1c2goQnVmZmVyV3JpdGVyLndyaXRlQnl0ZXNCdWZmZXIsIGxlbiwgdmFsdWUpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gd3JpdGVTdHJpbmdCdWZmZXIodmFsLCBidWYsIHBvcykge1xuICAgIGlmICh2YWwubGVuZ3RoIDwgNDApIC8vIHBsYWluIGpzIGlzIGZhc3RlciBmb3Igc2hvcnQgc3RyaW5ncyAocHJvYmFibHkgZHVlIHRvIHJlZHVuZGFudCBhc3NlcnRpb25zKVxuICAgICAgICB1dGlsLnV0Zjgud3JpdGUodmFsLCBidWYsIHBvcyk7XG4gICAgZWxzZSBpZiAoYnVmLnV0ZjhXcml0ZSlcbiAgICAgICAgYnVmLnV0ZjhXcml0ZSh2YWwsIHBvcyk7XG4gICAgZWxzZVxuICAgICAgICBidWYud3JpdGUodmFsLCBwb3MpO1xufVxuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5CdWZmZXJXcml0ZXIucHJvdG90eXBlLnN0cmluZyA9IGZ1bmN0aW9uIHdyaXRlX3N0cmluZ19idWZmZXIodmFsdWUpIHtcbiAgICB2YXIgbGVuID0gdXRpbC5CdWZmZXIuYnl0ZUxlbmd0aCh2YWx1ZSk7XG4gICAgdGhpcy51aW50MzIobGVuKTtcbiAgICBpZiAobGVuKVxuICAgICAgICB0aGlzLl9wdXNoKHdyaXRlU3RyaW5nQnVmZmVyLCBsZW4sIHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqXG4gKiBGaW5pc2hlcyB0aGUgd3JpdGUgb3BlcmF0aW9uLlxuICogQG5hbWUgQnVmZmVyV3JpdGVyI2ZpbmlzaFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBGaW5pc2hlZCBidWZmZXJcbiAqL1xuXG5CdWZmZXJXcml0ZXIuX2NvbmZpZ3VyZSgpO1xuIiwgIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBSZWFkZXI7XG5cbnZhciB1dGlsICAgICAgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XG5cbnZhciBCdWZmZXJSZWFkZXI7IC8vIGN5Y2xpY1xuXG52YXIgTG9uZ0JpdHMgID0gdXRpbC5Mb25nQml0cyxcbiAgICB1dGY4ICAgICAgPSB1dGlsLnV0Zjg7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBpbmRleE91dE9mUmFuZ2UocmVhZGVyLCB3cml0ZUxlbmd0aCkge1xuICAgIHJldHVybiBSYW5nZUVycm9yKFwiaW5kZXggb3V0IG9mIHJhbmdlOiBcIiArIHJlYWRlci5wb3MgKyBcIiArIFwiICsgKHdyaXRlTGVuZ3RoIHx8IDEpICsgXCIgPiBcIiArIHJlYWRlci5sZW4pO1xufVxuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgcmVhZGVyIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgYnVmZmVyLlxuICogQGNsYXNzZGVzYyBXaXJlIGZvcm1hdCByZWFkZXIgdXNpbmcgYFVpbnQ4QXJyYXlgIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGBBcnJheWAuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmZmVyIEJ1ZmZlciB0byByZWFkIGZyb21cbiAqL1xuZnVuY3Rpb24gUmVhZGVyKGJ1ZmZlcikge1xuXG4gICAgLyoqXG4gICAgICogUmVhZCBidWZmZXIuXG4gICAgICogQHR5cGUge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5idWYgPSBidWZmZXI7XG5cbiAgICAvKipcbiAgICAgKiBSZWFkIGJ1ZmZlciBwb3NpdGlvbi5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucG9zID0gMDtcblxuICAgIC8qKlxuICAgICAqIFJlYWQgYnVmZmVyIGxlbmd0aC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGVuID0gYnVmZmVyLmxlbmd0aDtcbn1cblxudmFyIGNyZWF0ZV9hcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSBcInVuZGVmaW5lZFwiXG4gICAgPyBmdW5jdGlvbiBjcmVhdGVfdHlwZWRfYXJyYXkoYnVmZmVyKSB7XG4gICAgICAgIGlmIChidWZmZXIgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IEFycmF5LmlzQXJyYXkoYnVmZmVyKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVhZGVyKGJ1ZmZlcik7XG4gICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBidWZmZXJcIik7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgOiBmdW5jdGlvbiBjcmVhdGVfYXJyYXkoYnVmZmVyKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGJ1ZmZlcikpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlYWRlcihidWZmZXIpO1xuICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgYnVmZmVyXCIpO1xuICAgIH07XG5cbnZhciBjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgcmV0dXJuIHV0aWwuQnVmZmVyXG4gICAgICAgID8gZnVuY3Rpb24gY3JlYXRlX2J1ZmZlcl9zZXR1cChidWZmZXIpIHtcbiAgICAgICAgICAgIHJldHVybiAoUmVhZGVyLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZV9idWZmZXIoYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWwuQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcilcbiAgICAgICAgICAgICAgICAgICAgPyBuZXcgQnVmZmVyUmVhZGVyKGJ1ZmZlcilcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICAgICAgOiBjcmVhdGVfYXJyYXkoYnVmZmVyKTtcbiAgICAgICAgICAgIH0pKGJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgOiBjcmVhdGVfYXJyYXk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgcmVhZGVyIHVzaW5nIHRoZSBzcGVjaWZpZWQgYnVmZmVyLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl8QnVmZmVyfSBidWZmZXIgQnVmZmVyIHRvIHJlYWQgZnJvbVxuICogQHJldHVybnMge1JlYWRlcnxCdWZmZXJSZWFkZXJ9IEEge0BsaW5rIEJ1ZmZlclJlYWRlcn0gaWYgYGJ1ZmZlcmAgaXMgYSBCdWZmZXIsIG90aGVyd2lzZSBhIHtAbGluayBSZWFkZXJ9XG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgYGJ1ZmZlcmAgaXMgbm90IGEgdmFsaWQgYnVmZmVyXG4gKi9cblJlYWRlci5jcmVhdGUgPSBjcmVhdGUoKTtcblxuUmVhZGVyLnByb3RvdHlwZS5fc2xpY2UgPSB1dGlsLkFycmF5LnByb3RvdHlwZS5zdWJhcnJheSB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB1dGlsLkFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuLyoqXG4gKiBSZWFkcyBhIHZhcmludCBhcyBhbiB1bnNpZ25lZCAzMiBiaXQgdmFsdWUuXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS51aW50MzIgPSAoZnVuY3Rpb24gcmVhZF91aW50MzJfc2V0dXAoKSB7XG4gICAgdmFyIHZhbHVlID0gNDI5NDk2NzI5NTsgLy8gb3B0aW1pemVyIHR5cGUtaGludCwgdGVuZHMgdG8gZGVvcHQgb3RoZXJ3aXNlICg/ISlcbiAgICByZXR1cm4gZnVuY3Rpb24gcmVhZF91aW50MzIoKSB7XG4gICAgICAgIHZhbHVlID0gKCAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNyAgICAgICApID4+PiAwOyBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCAgNykgPj4+IDA7IGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIHZhbHVlO1xuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IDE0KSA+Pj4gMDsgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gdmFsdWU7XG4gICAgICAgIHZhbHVlID0gKHZhbHVlIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgMjEpID4+PiAwOyBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgIDE1KSA8PCAyOCkgPj4+IDA7IGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIHZhbHVlO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoKHRoaXMucG9zICs9IDUpID4gdGhpcy5sZW4pIHtcbiAgICAgICAgICAgIHRoaXMucG9zID0gdGhpcy5sZW47XG4gICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgMTApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xufSkoKTtcblxuLyoqXG4gKiBSZWFkcyBhIHZhcmludCBhcyBhIHNpZ25lZCAzMiBiaXQgdmFsdWUuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuaW50MzIgPSBmdW5jdGlvbiByZWFkX2ludDMyKCkge1xuICAgIHJldHVybiB0aGlzLnVpbnQzMigpIHwgMDtcbn07XG5cbi8qKlxuICogUmVhZHMgYSB6aWctemFnIGVuY29kZWQgdmFyaW50IGFzIGEgc2lnbmVkIDMyIGJpdCB2YWx1ZS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5zaW50MzIgPSBmdW5jdGlvbiByZWFkX3NpbnQzMigpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLnVpbnQzMigpO1xuICAgIHJldHVybiB2YWx1ZSA+Pj4gMSBeIC0odmFsdWUgJiAxKSB8IDA7XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1pbnZhbGlkLXRoaXMgKi9cblxuZnVuY3Rpb24gcmVhZExvbmdWYXJpbnQoKSB7XG4gICAgLy8gdGVuZHMgdG8gZGVvcHQgd2l0aCBsb2NhbCB2YXJzIGZvciBvY3RldCBldGMuXG4gICAgdmFyIGJpdHMgPSBuZXcgTG9uZ0JpdHMoMCwgMCk7XG4gICAgdmFyIGkgPSAwO1xuICAgIGlmICh0aGlzLmxlbiAtIHRoaXMucG9zID4gNCkgeyAvLyBmYXN0IHJvdXRlIChsbylcbiAgICAgICAgZm9yICg7IGkgPCA0OyArK2kpIHtcbiAgICAgICAgICAgIC8vIDFzdC4uNHRoXG4gICAgICAgICAgICBiaXRzLmxvID0gKGJpdHMubG8gfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCBpICogNykgPj4+IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNXRoXG4gICAgICAgIGJpdHMubG8gPSAoYml0cy5sbyB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IDI4KSA+Pj4gMDtcbiAgICAgICAgYml0cy5oaSA9IChiaXRzLmhpIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPj4gIDQpID4+PiAwO1xuICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpXG4gICAgICAgICAgICByZXR1cm4gYml0cztcbiAgICAgICAgaSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICg7IGkgPCAzOyArK2kpIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMubGVuKVxuICAgICAgICAgICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzKTtcbiAgICAgICAgICAgIC8vIDFzdC4uM3RoXG4gICAgICAgICAgICBiaXRzLmxvID0gKGJpdHMubG8gfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCBpICogNykgPj4+IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNHRoXG4gICAgICAgIGJpdHMubG8gPSAoYml0cy5sbyB8ICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSAmIDEyNykgPDwgaSAqIDcpID4+PiAwO1xuICAgICAgICByZXR1cm4gYml0cztcbiAgICB9XG4gICAgaWYgKHRoaXMubGVuIC0gdGhpcy5wb3MgPiA0KSB7IC8vIGZhc3Qgcm91dGUgKGhpKVxuICAgICAgICBmb3IgKDsgaSA8IDU7ICsraSkge1xuICAgICAgICAgICAgLy8gNnRoLi4xMHRoXG4gICAgICAgICAgICBiaXRzLmhpID0gKGJpdHMuaGkgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCBpICogNyArIDMpID4+PiAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxuICAgICAgICAgICAgICAgIHJldHVybiBiaXRzO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICg7IGkgPCA1OyArK2kpIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMubGVuKVxuICAgICAgICAgICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzKTtcbiAgICAgICAgICAgIC8vIDZ0aC4uMTB0aFxuICAgICAgICAgICAgYml0cy5oaSA9IChiaXRzLmhpIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgaSAqIDcgKyAzKSA+Pj4gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOClcbiAgICAgICAgICAgICAgICByZXR1cm4gYml0cztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHRocm93IEVycm9yKFwiaW52YWxpZCB2YXJpbnQgZW5jb2RpbmdcIik7XG59XG5cbi8qIGVzbGludC1lbmFibGUgbm8taW52YWxpZC10aGlzICovXG5cbi8qKlxuICogUmVhZHMgYSB2YXJpbnQgYXMgYSBzaWduZWQgNjQgYml0IHZhbHVlLlxuICogQG5hbWUgUmVhZGVyI2ludDY0XG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtMb25nfSBWYWx1ZSByZWFkXG4gKi9cblxuLyoqXG4gKiBSZWFkcyBhIHZhcmludCBhcyBhbiB1bnNpZ25lZCA2NCBiaXQgdmFsdWUuXG4gKiBAbmFtZSBSZWFkZXIjdWludDY0XG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtMb25nfSBWYWx1ZSByZWFkXG4gKi9cblxuLyoqXG4gKiBSZWFkcyBhIHppZy16YWcgZW5jb2RlZCB2YXJpbnQgYXMgYSBzaWduZWQgNjQgYml0IHZhbHVlLlxuICogQG5hbWUgUmVhZGVyI3NpbnQ2NFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxuICovXG5cbi8qKlxuICogUmVhZHMgYSB2YXJpbnQgYXMgYSBib29sZWFuLlxuICogQHJldHVybnMge2Jvb2xlYW59IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5ib29sID0gZnVuY3Rpb24gcmVhZF9ib29sKCkge1xuICAgIHJldHVybiB0aGlzLnVpbnQzMigpICE9PSAwO1xufTtcblxuZnVuY3Rpb24gcmVhZEZpeGVkMzJfZW5kKGJ1ZiwgZW5kKSB7IC8vIG5vdGUgdGhhdCB0aGlzIHVzZXMgYGVuZGAsIG5vdCBgcG9zYFxuICAgIHJldHVybiAoYnVmW2VuZCAtIDRdXG4gICAgICAgICAgfCBidWZbZW5kIC0gM10gPDwgOFxuICAgICAgICAgIHwgYnVmW2VuZCAtIDJdIDw8IDE2XG4gICAgICAgICAgfCBidWZbZW5kIC0gMV0gPDwgMjQpID4+PiAwO1xufVxuXG4vKipcbiAqIFJlYWRzIGZpeGVkIDMyIGJpdHMgYXMgYW4gdW5zaWduZWQgMzIgYml0IGludGVnZXIuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuZml4ZWQzMiA9IGZ1bmN0aW9uIHJlYWRfZml4ZWQzMigpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0aGlzLnBvcyArIDQgPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDQpO1xuXG4gICAgcmV0dXJuIHJlYWRGaXhlZDMyX2VuZCh0aGlzLmJ1ZiwgdGhpcy5wb3MgKz0gNCk7XG59O1xuXG4vKipcbiAqIFJlYWRzIGZpeGVkIDMyIGJpdHMgYXMgYSBzaWduZWQgMzIgYml0IGludGVnZXIuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuc2ZpeGVkMzIgPSBmdW5jdGlvbiByZWFkX3NmaXhlZDMyKCkge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHRoaXMucG9zICsgNCA+IHRoaXMubGVuKVxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgNCk7XG5cbiAgICByZXR1cm4gcmVhZEZpeGVkMzJfZW5kKHRoaXMuYnVmLCB0aGlzLnBvcyArPSA0KSB8IDA7XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1pbnZhbGlkLXRoaXMgKi9cblxuZnVuY3Rpb24gcmVhZEZpeGVkNjQoLyogdGhpczogUmVhZGVyICovKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodGhpcy5wb3MgKyA4ID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA4KTtcblxuICAgIHJldHVybiBuZXcgTG9uZ0JpdHMocmVhZEZpeGVkMzJfZW5kKHRoaXMuYnVmLCB0aGlzLnBvcyArPSA0KSwgcmVhZEZpeGVkMzJfZW5kKHRoaXMuYnVmLCB0aGlzLnBvcyArPSA0KSk7XG59XG5cbi8qIGVzbGludC1lbmFibGUgbm8taW52YWxpZC10aGlzICovXG5cbi8qKlxuICogUmVhZHMgZml4ZWQgNjQgYml0cy5cbiAqIEBuYW1lIFJlYWRlciNmaXhlZDY0XG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtMb25nfSBWYWx1ZSByZWFkXG4gKi9cblxuLyoqXG4gKiBSZWFkcyB6aWctemFnIGVuY29kZWQgZml4ZWQgNjQgYml0cy5cbiAqIEBuYW1lIFJlYWRlciNzZml4ZWQ2NFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxuICovXG5cbi8qKlxuICogUmVhZHMgYSBmbG9hdCAoMzIgYml0KSBhcyBhIG51bWJlci5cbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLmZsb2F0ID0gZnVuY3Rpb24gcmVhZF9mbG9hdCgpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0aGlzLnBvcyArIDQgPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDQpO1xuXG4gICAgdmFyIHZhbHVlID0gdXRpbC5mbG9hdC5yZWFkRmxvYXRMRSh0aGlzLmJ1ZiwgdGhpcy5wb3MpO1xuICAgIHRoaXMucG9zICs9IDQ7XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcblxuLyoqXG4gKiBSZWFkcyBhIGRvdWJsZSAoNjQgYml0IGZsb2F0KSBhcyBhIG51bWJlci5cbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLmRvdWJsZSA9IGZ1bmN0aW9uIHJlYWRfZG91YmxlKCkge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHRoaXMucG9zICsgOCA+IHRoaXMubGVuKVxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgNCk7XG5cbiAgICB2YXIgdmFsdWUgPSB1dGlsLmZsb2F0LnJlYWREb3VibGVMRSh0aGlzLmJ1ZiwgdGhpcy5wb3MpO1xuICAgIHRoaXMucG9zICs9IDg7XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcblxuLyoqXG4gKiBSZWFkcyBhIHNlcXVlbmNlIG9mIGJ5dGVzIHByZWNlZWRlZCBieSBpdHMgbGVuZ3RoIGFzIGEgdmFyaW50LlxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5ieXRlcyA9IGZ1bmN0aW9uIHJlYWRfYnl0ZXMoKSB7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMudWludDMyKCksXG4gICAgICAgIHN0YXJ0ICA9IHRoaXMucG9zLFxuICAgICAgICBlbmQgICAgPSB0aGlzLnBvcyArIGxlbmd0aDtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChlbmQgPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIGxlbmd0aCk7XG5cbiAgICB0aGlzLnBvcyArPSBsZW5ndGg7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5idWYpKSAvLyBwbGFpbiBhcnJheVxuICAgICAgICByZXR1cm4gdGhpcy5idWYuc2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBpZiAoc3RhcnQgPT09IGVuZCkgeyAvLyBmaXggZm9yIElFIDEwL1dpbjggYW5kIG90aGVycycgc3ViYXJyYXkgcmV0dXJuaW5nIGFycmF5IG9mIHNpemUgMVxuICAgICAgICB2YXIgbmF0aXZlQnVmZmVyID0gdXRpbC5CdWZmZXI7XG4gICAgICAgIHJldHVybiBuYXRpdmVCdWZmZXJcbiAgICAgICAgICAgID8gbmF0aXZlQnVmZmVyLmFsbG9jKDApXG4gICAgICAgICAgICA6IG5ldyB0aGlzLmJ1Zi5jb25zdHJ1Y3RvcigwKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NsaWNlLmNhbGwodGhpcy5idWYsIHN0YXJ0LCBlbmQpO1xufTtcblxuLyoqXG4gKiBSZWFkcyBhIHN0cmluZyBwcmVjZWVkZWQgYnkgaXRzIGJ5dGUgbGVuZ3RoIGFzIGEgdmFyaW50LlxuICogQHJldHVybnMge3N0cmluZ30gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLnN0cmluZyA9IGZ1bmN0aW9uIHJlYWRfc3RyaW5nKCkge1xuICAgIHZhciBieXRlcyA9IHRoaXMuYnl0ZXMoKTtcbiAgICByZXR1cm4gdXRmOC5yZWFkKGJ5dGVzLCAwLCBieXRlcy5sZW5ndGgpO1xufTtcblxuLyoqXG4gKiBTa2lwcyB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBieXRlcyBpZiBzcGVjaWZpZWQsIG90aGVyd2lzZSBza2lwcyBhIHZhcmludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBMZW5ndGggaWYga25vd24sIG90aGVyd2lzZSBhIHZhcmludCBpcyBhc3N1bWVkXG4gKiBAcmV0dXJucyB7UmVhZGVyfSBgdGhpc2BcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5za2lwID0gZnVuY3Rpb24gc2tpcChsZW5ndGgpIHtcbiAgICBpZiAodHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHRoaXMucG9zICsgbGVuZ3RoID4gdGhpcy5sZW4pXG4gICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgbGVuZ3RoKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gbGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMubGVuKVxuICAgICAgICAgICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzKTtcbiAgICAgICAgfSB3aGlsZSAodGhpcy5idWZbdGhpcy5wb3MrK10gJiAxMjgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2tpcHMgdGhlIG5leHQgZWxlbWVudCBvZiB0aGUgc3BlY2lmaWVkIHdpcmUgdHlwZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB3aXJlVHlwZSBXaXJlIHR5cGUgcmVjZWl2ZWRcbiAqIEByZXR1cm5zIHtSZWFkZXJ9IGB0aGlzYFxuICovXG5SZWFkZXIucHJvdG90eXBlLnNraXBUeXBlID0gZnVuY3Rpb24od2lyZVR5cGUpIHtcbiAgICBzd2l0Y2ggKHdpcmVUeXBlKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHRoaXMuc2tpcCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHRoaXMuc2tpcCg4KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICB0aGlzLnNraXAodGhpcy51aW50MzIoKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgd2hpbGUgKCh3aXJlVHlwZSA9IHRoaXMudWludDMyKCkgJiA3KSAhPT0gNCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2tpcFR5cGUod2lyZVR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHRoaXMuc2tpcCg0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcImludmFsaWQgd2lyZSB0eXBlIFwiICsgd2lyZVR5cGUgKyBcIiBhdCBvZmZzZXQgXCIgKyB0aGlzLnBvcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuUmVhZGVyLl9jb25maWd1cmUgPSBmdW5jdGlvbihCdWZmZXJSZWFkZXJfKSB7XG4gICAgQnVmZmVyUmVhZGVyID0gQnVmZmVyUmVhZGVyXztcbiAgICBSZWFkZXIuY3JlYXRlID0gY3JlYXRlKCk7XG4gICAgQnVmZmVyUmVhZGVyLl9jb25maWd1cmUoKTtcblxuICAgIHZhciBmbiA9IHV0aWwuTG9uZyA/IFwidG9Mb25nXCIgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBcInRvTnVtYmVyXCI7XG4gICAgdXRpbC5tZXJnZShSZWFkZXIucHJvdG90eXBlLCB7XG5cbiAgICAgICAgaW50NjQ6IGZ1bmN0aW9uIHJlYWRfaW50NjQoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhZExvbmdWYXJpbnQuY2FsbCh0aGlzKVtmbl0oZmFsc2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVpbnQ2NDogZnVuY3Rpb24gcmVhZF91aW50NjQoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhZExvbmdWYXJpbnQuY2FsbCh0aGlzKVtmbl0odHJ1ZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2ludDY0OiBmdW5jdGlvbiByZWFkX3NpbnQ2NCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkTG9uZ1ZhcmludC5jYWxsKHRoaXMpLnp6RGVjb2RlKClbZm5dKGZhbHNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBmaXhlZDY0OiBmdW5jdGlvbiByZWFkX2ZpeGVkNjQoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhZEZpeGVkNjQuY2FsbCh0aGlzKVtmbl0odHJ1ZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2ZpeGVkNjQ6IGZ1bmN0aW9uIHJlYWRfc2ZpeGVkNjQoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhZEZpeGVkNjQuY2FsbCh0aGlzKVtmbl0oZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICB9KTtcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlclJlYWRlcjtcblxuLy8gZXh0ZW5kcyBSZWFkZXJcbnZhciBSZWFkZXIgPSByZXF1aXJlKFwiLi9yZWFkZXJcIik7XG4oQnVmZmVyUmVhZGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUmVhZGVyLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gQnVmZmVyUmVhZGVyO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWwvbWluaW1hbFwiKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IGJ1ZmZlciByZWFkZXIgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFdpcmUgZm9ybWF0IHJlYWRlciB1c2luZyBub2RlIGJ1ZmZlcnMuXG4gKiBAZXh0ZW5kcyBSZWFkZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBCdWZmZXIgdG8gcmVhZCBmcm9tXG4gKi9cbmZ1bmN0aW9uIEJ1ZmZlclJlYWRlcihidWZmZXIpIHtcbiAgICBSZWFkZXIuY2FsbCh0aGlzLCBidWZmZXIpO1xuXG4gICAgLyoqXG4gICAgICogUmVhZCBidWZmZXIuXG4gICAgICogQG5hbWUgQnVmZmVyUmVhZGVyI2J1ZlxuICAgICAqIEB0eXBlIHtCdWZmZXJ9XG4gICAgICovXG59XG5cbkJ1ZmZlclJlYWRlci5fY29uZmlndXJlID0gZnVuY3Rpb24gKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHV0aWwuQnVmZmVyKVxuICAgICAgICBCdWZmZXJSZWFkZXIucHJvdG90eXBlLl9zbGljZSA9IHV0aWwuQnVmZmVyLnByb3RvdHlwZS5zbGljZTtcbn07XG5cblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5zdHJpbmcgPSBmdW5jdGlvbiByZWFkX3N0cmluZ19idWZmZXIoKSB7XG4gICAgdmFyIGxlbiA9IHRoaXMudWludDMyKCk7IC8vIG1vZGlmaWVzIHBvc1xuICAgIHJldHVybiB0aGlzLmJ1Zi51dGY4U2xpY2VcbiAgICAgICAgPyB0aGlzLmJ1Zi51dGY4U2xpY2UodGhpcy5wb3MsIHRoaXMucG9zID0gTWF0aC5taW4odGhpcy5wb3MgKyBsZW4sIHRoaXMubGVuKSlcbiAgICAgICAgOiB0aGlzLmJ1Zi50b1N0cmluZyhcInV0Zi04XCIsIHRoaXMucG9zLCB0aGlzLnBvcyA9IE1hdGgubWluKHRoaXMucG9zICsgbGVuLCB0aGlzLmxlbikpO1xufTtcblxuLyoqXG4gKiBSZWFkcyBhIHNlcXVlbmNlIG9mIGJ5dGVzIHByZWNlZWRlZCBieSBpdHMgbGVuZ3RoIGFzIGEgdmFyaW50LlxuICogQG5hbWUgQnVmZmVyUmVhZGVyI2J5dGVzXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtCdWZmZXJ9IFZhbHVlIHJlYWRcbiAqL1xuXG5CdWZmZXJSZWFkZXIuX2NvbmZpZ3VyZSgpO1xuIiwgIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBTZXJ2aWNlO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsL21pbmltYWxcIik7XG5cbi8vIEV4dGVuZHMgRXZlbnRFbWl0dGVyXG4oU2VydmljZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHV0aWwuRXZlbnRFbWl0dGVyLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gU2VydmljZTtcblxuLyoqXG4gKiBBIHNlcnZpY2UgbWV0aG9kIGNhbGxiYWNrIGFzIHVzZWQgYnkge0BsaW5rIHJwYy5TZXJ2aWNlTWV0aG9kfFNlcnZpY2VNZXRob2R9LlxuICpcbiAqIERpZmZlcnMgZnJvbSB7QGxpbmsgUlBDSW1wbENhbGxiYWNrfSBpbiB0aGF0IGl0IGlzIGFuIGFjdHVhbCBjYWxsYmFjayBvZiBhIHNlcnZpY2UgbWV0aG9kIHdoaWNoIG1heSBub3QgcmV0dXJuIGByZXNwb25zZSA9IG51bGxgLlxuICogQHR5cGVkZWYgcnBjLlNlcnZpY2VNZXRob2RDYWxsYmFja1xuICogQHRlbXBsYXRlIFRSZXMgZXh0ZW5kcyBNZXNzYWdlPFRSZXM+XG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge0Vycm9yfG51bGx9IGVycm9yIEVycm9yLCBpZiBhbnlcbiAqIEBwYXJhbSB7VFJlc30gW3Jlc3BvbnNlXSBSZXNwb25zZSBtZXNzYWdlXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5cbi8qKlxuICogQSBzZXJ2aWNlIG1ldGhvZCBwYXJ0IG9mIGEge0BsaW5rIHJwYy5TZXJ2aWNlfSBhcyBjcmVhdGVkIGJ5IHtAbGluayBTZXJ2aWNlLmNyZWF0ZX0uXG4gKiBAdHlwZWRlZiBycGMuU2VydmljZU1ldGhvZFxuICogQHRlbXBsYXRlIFRSZXEgZXh0ZW5kcyBNZXNzYWdlPFRSZXE+XG4gKiBAdGVtcGxhdGUgVFJlcyBleHRlbmRzIE1lc3NhZ2U8VFJlcz5cbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7VFJlcXxQcm9wZXJ0aWVzPFRSZXE+fSByZXF1ZXN0IFJlcXVlc3QgbWVzc2FnZSBvciBwbGFpbiBvYmplY3RcbiAqIEBwYXJhbSB7cnBjLlNlcnZpY2VNZXRob2RDYWxsYmFjazxUUmVzPn0gW2NhbGxiYWNrXSBOb2RlLXN0eWxlIGNhbGxiYWNrIGNhbGxlZCB3aXRoIHRoZSBlcnJvciwgaWYgYW55LCBhbmQgdGhlIHJlc3BvbnNlIG1lc3NhZ2VcbiAqIEByZXR1cm5zIHtQcm9taXNlPE1lc3NhZ2U8VFJlcz4+fSBQcm9taXNlIGlmIGBjYWxsYmFja2AgaGFzIGJlZW4gb21pdHRlZCwgb3RoZXJ3aXNlIGB1bmRlZmluZWRgXG4gKi9cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IFJQQyBzZXJ2aWNlIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBBbiBSUEMgc2VydmljZSBhcyByZXR1cm5lZCBieSB7QGxpbmsgU2VydmljZSNjcmVhdGV9LlxuICogQGV4cG9ydHMgcnBjLlNlcnZpY2VcbiAqIEBleHRlbmRzIHV0aWwuRXZlbnRFbWl0dGVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7UlBDSW1wbH0gcnBjSW1wbCBSUEMgaW1wbGVtZW50YXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlcXVlc3REZWxpbWl0ZWQ9ZmFsc2VdIFdoZXRoZXIgcmVxdWVzdHMgYXJlIGxlbmd0aC1kZWxpbWl0ZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Jlc3BvbnNlRGVsaW1pdGVkPWZhbHNlXSBXaGV0aGVyIHJlc3BvbnNlcyBhcmUgbGVuZ3RoLWRlbGltaXRlZFxuICovXG5mdW5jdGlvbiBTZXJ2aWNlKHJwY0ltcGwsIHJlcXVlc3REZWxpbWl0ZWQsIHJlc3BvbnNlRGVsaW1pdGVkKSB7XG5cbiAgICBpZiAodHlwZW9mIHJwY0ltcGwgIT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwicnBjSW1wbCBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG5cbiAgICB1dGlsLkV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogUlBDIGltcGxlbWVudGF0aW9uLiBCZWNvbWVzIGBudWxsYCBvbmNlIHRoZSBzZXJ2aWNlIGlzIGVuZGVkLlxuICAgICAqIEB0eXBlIHtSUENJbXBsfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5ycGNJbXBsID0gcnBjSW1wbDtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgcmVxdWVzdHMgYXJlIGxlbmd0aC1kZWxpbWl0ZWQuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZXF1ZXN0RGVsaW1pdGVkID0gQm9vbGVhbihyZXF1ZXN0RGVsaW1pdGVkKTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgcmVzcG9uc2VzIGFyZSBsZW5ndGgtZGVsaW1pdGVkLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucmVzcG9uc2VEZWxpbWl0ZWQgPSBCb29sZWFuKHJlc3BvbnNlRGVsaW1pdGVkKTtcbn1cblxuLyoqXG4gKiBDYWxscyBhIHNlcnZpY2UgbWV0aG9kIHRocm91Z2gge0BsaW5rIHJwYy5TZXJ2aWNlI3JwY0ltcGx8cnBjSW1wbH0uXG4gKiBAcGFyYW0ge01ldGhvZHxycGMuU2VydmljZU1ldGhvZDxUUmVxLFRSZXM+fSBtZXRob2QgUmVmbGVjdGVkIG9yIHN0YXRpYyBtZXRob2RcbiAqIEBwYXJhbSB7Q29uc3RydWN0b3I8VFJlcT59IHJlcXVlc3RDdG9yIFJlcXVlc3QgY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Q29uc3RydWN0b3I8VFJlcz59IHJlc3BvbnNlQ3RvciBSZXNwb25zZSBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtUUmVxfFByb3BlcnRpZXM8VFJlcT59IHJlcXVlc3QgUmVxdWVzdCBtZXNzYWdlIG9yIHBsYWluIG9iamVjdFxuICogQHBhcmFtIHtycGMuU2VydmljZU1ldGhvZENhbGxiYWNrPFRSZXM+fSBjYWxsYmFjayBTZXJ2aWNlIGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogQHRlbXBsYXRlIFRSZXEgZXh0ZW5kcyBNZXNzYWdlPFRSZXE+XG4gKiBAdGVtcGxhdGUgVFJlcyBleHRlbmRzIE1lc3NhZ2U8VFJlcz5cbiAqL1xuU2VydmljZS5wcm90b3R5cGUucnBjQ2FsbCA9IGZ1bmN0aW9uIHJwY0NhbGwobWV0aG9kLCByZXF1ZXN0Q3RvciwgcmVzcG9uc2VDdG9yLCByZXF1ZXN0LCBjYWxsYmFjaykge1xuXG4gICAgaWYgKCFyZXF1ZXN0KVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJyZXF1ZXN0IG11c3QgYmUgc3BlY2lmaWVkXCIpO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmICghY2FsbGJhY2spXG4gICAgICAgIHJldHVybiB1dGlsLmFzUHJvbWlzZShycGNDYWxsLCBzZWxmLCBtZXRob2QsIHJlcXVlc3RDdG9yLCByZXNwb25zZUN0b3IsIHJlcXVlc3QpO1xuXG4gICAgaWYgKCFzZWxmLnJwY0ltcGwpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgY2FsbGJhY2soRXJyb3IoXCJhbHJlYWR5IGVuZGVkXCIpKTsgfSwgMCk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHNlbGYucnBjSW1wbChcbiAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgIHJlcXVlc3RDdG9yW3NlbGYucmVxdWVzdERlbGltaXRlZCA/IFwiZW5jb2RlRGVsaW1pdGVkXCIgOiBcImVuY29kZVwiXShyZXF1ZXN0KS5maW5pc2goKSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJwY0NhbGxiYWNrKGVyciwgcmVzcG9uc2UpIHtcblxuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5lbWl0KFwiZXJyb3JcIiwgZXJyLCBtZXRob2QpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5lbmQoLyogZW5kZWRCeVJQQyAqLyB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIShyZXNwb25zZSBpbnN0YW5jZW9mIHJlc3BvbnNlQ3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gcmVzcG9uc2VDdG9yW3NlbGYucmVzcG9uc2VEZWxpbWl0ZWQgPyBcImRlY29kZURlbGltaXRlZFwiIDogXCJkZWNvZGVcIl0ocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZW1pdChcImVycm9yXCIsIGVyciwgbWV0aG9kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2VsZi5lbWl0KFwiZGF0YVwiLCByZXNwb25zZSwgbWV0aG9kKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBzZWxmLmVtaXQoXCJlcnJvclwiLCBlcnIsIG1ldGhvZCk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGNhbGxiYWNrKGVycik7IH0sIDApO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn07XG5cbi8qKlxuICogRW5kcyB0aGlzIHNlcnZpY2UgYW5kIGVtaXRzIHRoZSBgZW5kYCBldmVudC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2VuZGVkQnlSUEM9ZmFsc2VdIFdoZXRoZXIgdGhlIHNlcnZpY2UgaGFzIGJlZW4gZW5kZWQgYnkgdGhlIFJQQyBpbXBsZW1lbnRhdGlvbi5cbiAqIEByZXR1cm5zIHtycGMuU2VydmljZX0gYHRoaXNgXG4gKi9cblNlcnZpY2UucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIGVuZChlbmRlZEJ5UlBDKSB7XG4gICAgaWYgKHRoaXMucnBjSW1wbCkge1xuICAgICAgICBpZiAoIWVuZGVkQnlSUEMpIC8vIHNpZ25hbCBlbmQgdG8gcnBjSW1wbFxuICAgICAgICAgICAgdGhpcy5ycGNJbXBsKG51bGwsIG51bGwsIG51bGwpO1xuICAgICAgICB0aGlzLnJwY0ltcGwgPSBudWxsO1xuICAgICAgICB0aGlzLmVtaXQoXCJlbmRcIikub2ZmKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBTdHJlYW1pbmcgUlBDIGhlbHBlcnMuXG4gKiBAbmFtZXNwYWNlXG4gKi9cbnZhciBycGMgPSBleHBvcnRzO1xuXG4vKipcbiAqIFJQQyBpbXBsZW1lbnRhdGlvbiBwYXNzZWQgdG8ge0BsaW5rIFNlcnZpY2UjY3JlYXRlfSBwZXJmb3JtaW5nIGEgc2VydmljZSByZXF1ZXN0IG9uIG5ldHdvcmsgbGV2ZWwsIGkuZS4gYnkgdXRpbGl6aW5nIGh0dHAgcmVxdWVzdHMgb3Igd2Vic29ja2V0cy5cbiAqIEB0eXBlZGVmIFJQQ0ltcGxcbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7TWV0aG9kfHJwYy5TZXJ2aWNlTWV0aG9kPE1lc3NhZ2U8e30+LE1lc3NhZ2U8e30+Pn0gbWV0aG9kIFJlZmxlY3RlZCBvciBzdGF0aWMgbWV0aG9kIGJlaW5nIGNhbGxlZFxuICogQHBhcmFtIHtVaW50OEFycmF5fSByZXF1ZXN0RGF0YSBSZXF1ZXN0IGRhdGFcbiAqIEBwYXJhbSB7UlBDSW1wbENhbGxiYWNrfSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqIEBleGFtcGxlXG4gKiBmdW5jdGlvbiBycGNJbXBsKG1ldGhvZCwgcmVxdWVzdERhdGEsIGNhbGxiYWNrKSB7XG4gKiAgICAgaWYgKHByb3RvYnVmLnV0aWwubGNGaXJzdChtZXRob2QubmFtZSkgIT09IFwibXlNZXRob2RcIikgLy8gY29tcGF0aWJsZSB3aXRoIHN0YXRpYyBjb2RlXG4gKiAgICAgICAgIHRocm93IEVycm9yKFwibm8gc3VjaCBtZXRob2RcIik7XG4gKiAgICAgYXN5bmNocm9ub3VzbHlPYnRhaW5BUmVzcG9uc2UocmVxdWVzdERhdGEsIGZ1bmN0aW9uKGVyciwgcmVzcG9uc2VEYXRhKSB7XG4gKiAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzcG9uc2VEYXRhKTtcbiAqICAgICB9KTtcbiAqIH1cbiAqL1xuXG4vKipcbiAqIE5vZGUtc3R5bGUgY2FsbGJhY2sgYXMgdXNlZCBieSB7QGxpbmsgUlBDSW1wbH0uXG4gKiBAdHlwZWRlZiBSUENJbXBsQ2FsbGJhY2tcbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7RXJyb3J8bnVsbH0gZXJyb3IgRXJyb3IsIGlmIGFueSwgb3RoZXJ3aXNlIGBudWxsYFxuICogQHBhcmFtIHtVaW50OEFycmF5fG51bGx9IFtyZXNwb25zZV0gUmVzcG9uc2UgZGF0YSBvciBgbnVsbGAgdG8gc2lnbmFsIGVuZCBvZiBzdHJlYW0sIGlmIHRoZXJlIGhhc24ndCBiZWVuIGFuIGVycm9yXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5cbnJwYy5TZXJ2aWNlID0gcmVxdWlyZShcIi4vcnBjL3NlcnZpY2VcIik7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vKipcbiAqIE5hbWVkIHJvb3RzLlxuICogVGhpcyBpcyB3aGVyZSBwYmpzIHN0b3JlcyBnZW5lcmF0ZWQgc3RydWN0dXJlcyAodGhlIG9wdGlvbiBgLXIsIC0tcm9vdGAgc3BlY2lmaWVzIGEgbmFtZSkuXG4gKiBDYW4gYWxzbyBiZSB1c2VkIG1hbnVhbGx5IHRvIG1ha2Ugcm9vdHMgYXZhaWxhYmxlIGFjcm9zcyBtb2R1bGVzLlxuICogQG5hbWUgcm9vdHNcbiAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxSb290Pn1cbiAqIEBleGFtcGxlXG4gKiAvLyBwYmpzIC1yIG15cm9vdCAtbyBjb21waWxlZC5qcyAuLi5cbiAqXG4gKiAvLyBpbiBhbm90aGVyIG1vZHVsZTpcbiAqIHJlcXVpcmUoXCIuL2NvbXBpbGVkLmpzXCIpO1xuICpcbiAqIC8vIGluIGFueSBzdWJzZXF1ZW50IG1vZHVsZTpcbiAqIHZhciByb290ID0gcHJvdG9idWYucm9vdHNbXCJteXJvb3RcIl07XG4gKi9cbiIsICJcInVzZSBzdHJpY3RcIjtcbnZhciBwcm90b2J1ZiA9IGV4cG9ydHM7XG5cbi8qKlxuICogQnVpbGQgdHlwZSwgb25lIG9mIGBcImZ1bGxcImAsIGBcImxpZ2h0XCJgIG9yIGBcIm1pbmltYWxcImAuXG4gKiBAbmFtZSBidWlsZFxuICogQHR5cGUge3N0cmluZ31cbiAqIEBjb25zdFxuICovXG5wcm90b2J1Zi5idWlsZCA9IFwibWluaW1hbFwiO1xuXG4vLyBTZXJpYWxpemF0aW9uXG5wcm90b2J1Zi5Xcml0ZXIgICAgICAgPSByZXF1aXJlKFwiLi93cml0ZXJcIik7XG5wcm90b2J1Zi5CdWZmZXJXcml0ZXIgPSByZXF1aXJlKFwiLi93cml0ZXJfYnVmZmVyXCIpO1xucHJvdG9idWYuUmVhZGVyICAgICAgID0gcmVxdWlyZShcIi4vcmVhZGVyXCIpO1xucHJvdG9idWYuQnVmZmVyUmVhZGVyID0gcmVxdWlyZShcIi4vcmVhZGVyX2J1ZmZlclwiKTtcblxuLy8gVXRpbGl0eVxucHJvdG9idWYudXRpbCAgICAgICAgID0gcmVxdWlyZShcIi4vdXRpbC9taW5pbWFsXCIpO1xucHJvdG9idWYucnBjICAgICAgICAgID0gcmVxdWlyZShcIi4vcnBjXCIpO1xucHJvdG9idWYucm9vdHMgICAgICAgID0gcmVxdWlyZShcIi4vcm9vdHNcIik7XG5wcm90b2J1Zi5jb25maWd1cmUgICAgPSBjb25maWd1cmU7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4vKipcbiAqIFJlY29uZmlndXJlcyB0aGUgbGlicmFyeSBhY2NvcmRpbmcgdG8gdGhlIGVudmlyb25tZW50LlxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gY29uZmlndXJlKCkge1xuICAgIHByb3RvYnVmLnV0aWwuX2NvbmZpZ3VyZSgpO1xuICAgIHByb3RvYnVmLldyaXRlci5fY29uZmlndXJlKHByb3RvYnVmLkJ1ZmZlcldyaXRlcik7XG4gICAgcHJvdG9idWYuUmVhZGVyLl9jb25maWd1cmUocHJvdG9idWYuQnVmZmVyUmVhZGVyKTtcbn1cblxuLy8gU2V0IHVwIGJ1ZmZlciB1dGlsaXR5IGFjY29yZGluZyB0byB0aGUgZW52aXJvbm1lbnRcbmNvbmZpZ3VyZSgpO1xuIiwgIi8vIG1pbmltYWwgbGlicmFyeSBlbnRyeSBwb2ludC5cblxuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3NyYy9pbmRleC1taW5pbWFsXCIpO1xuIiwgIi8qZXNsaW50LWRpc2FibGUgYmxvY2stc2NvcGVkLXZhciwgaWQtbGVuZ3RoLCBuby1jb250cm9sLXJlZ2V4LCBuby1tYWdpYy1udW1iZXJzLCBuby1wcm90b3R5cGUtYnVpbHRpbnMsIG5vLXJlZGVjbGFyZSwgbm8tc2hhZG93LCBuby12YXIsIHNvcnQtdmFycyovXG4ndXNlIHN0cmljdCc7XG5cbnZhciAkcHJvdG9idWYgPSByZXF1aXJlKCdwcm90b2J1ZmpzL21pbmltYWwnKTtcblxuLy8gQ29tbW9uIGFsaWFzZXNcbnZhciAkUmVhZGVyID0gJHByb3RvYnVmLlJlYWRlcixcbiAgJFdyaXRlciA9ICRwcm90b2J1Zi5Xcml0ZXIsXG4gICR1dGlsID0gJHByb3RvYnVmLnV0aWw7XG5cbi8vIEV4cG9ydGVkIHJvb3QgbmFtZXNwYWNlXG52YXIgJHJvb3QgPSAkcHJvdG9idWYucm9vdHNbJ2RlZmF1bHQnXSB8fCAoJHByb3RvYnVmLnJvb3RzWydkZWZhdWx0J10gPSB7fSk7XG5cbiRyb290Lm9ubnggPSAoZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogTmFtZXNwYWNlIG9ubnguXG4gICAqIEBleHBvcnRzIG9ubnhcbiAgICogQG5hbWVzcGFjZVxuICAgKi9cbiAgdmFyIG9ubnggPSB7fTtcblxuICAvKipcbiAgICogVmVyc2lvbiBlbnVtLlxuICAgKiBAbmFtZSBvbm54LlZlcnNpb25cbiAgICogQGVudW0ge251bWJlcn1cbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IF9TVEFSVF9WRVJTSU9OPTAgX1NUQVJUX1ZFUlNJT04gdmFsdWVcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IElSX1ZFUlNJT05fMjAxN18xMF8xMD0xIElSX1ZFUlNJT05fMjAxN18xMF8xMCB2YWx1ZVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gSVJfVkVSU0lPTl8yMDE3XzEwXzMwPTIgSVJfVkVSU0lPTl8yMDE3XzEwXzMwIHZhbHVlXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBJUl9WRVJTSU9OXzIwMTdfMTFfMz0zIElSX1ZFUlNJT05fMjAxN18xMV8zIHZhbHVlXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBJUl9WRVJTSU9OXzIwMTlfMV8yMj00IElSX1ZFUlNJT05fMjAxOV8xXzIyIHZhbHVlXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBJUl9WRVJTSU9OXzIwMTlfM18xOD01IElSX1ZFUlNJT05fMjAxOV8zXzE4IHZhbHVlXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBJUl9WRVJTSU9OXzIwMTlfOV8xOT02IElSX1ZFUlNJT05fMjAxOV85XzE5IHZhbHVlXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBJUl9WRVJTSU9OXzIwMjBfNV84PTcgSVJfVkVSU0lPTl8yMDIwXzVfOCB2YWx1ZVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gSVJfVkVSU0lPTl8yMDIxXzdfMzA9OCBJUl9WRVJTSU9OXzIwMjFfN18zMCB2YWx1ZVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gSVJfVkVSU0lPTj05IElSX1ZFUlNJT04gdmFsdWVcbiAgICovXG4gIG9ubnguVmVyc2lvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhbHVlc0J5SWQgPSB7fSxcbiAgICAgIHZhbHVlcyA9IE9iamVjdC5jcmVhdGUodmFsdWVzQnlJZCk7XG4gICAgdmFsdWVzWyh2YWx1ZXNCeUlkWzBdID0gJ19TVEFSVF9WRVJTSU9OJyldID0gMDtcbiAgICB2YWx1ZXNbKHZhbHVlc0J5SWRbMV0gPSAnSVJfVkVSU0lPTl8yMDE3XzEwXzEwJyldID0gMTtcbiAgICB2YWx1ZXNbKHZhbHVlc0J5SWRbMl0gPSAnSVJfVkVSU0lPTl8yMDE3XzEwXzMwJyldID0gMjtcbiAgICB2YWx1ZXNbKHZhbHVlc0J5SWRbM10gPSAnSVJfVkVSU0lPTl8yMDE3XzExXzMnKV0gPSAzO1xuICAgIHZhbHVlc1sodmFsdWVzQnlJZFs0XSA9ICdJUl9WRVJTSU9OXzIwMTlfMV8yMicpXSA9IDQ7XG4gICAgdmFsdWVzWyh2YWx1ZXNCeUlkWzVdID0gJ0lSX1ZFUlNJT05fMjAxOV8zXzE4JyldID0gNTtcbiAgICB2YWx1ZXNbKHZhbHVlc0J5SWRbNl0gPSAnSVJfVkVSU0lPTl8yMDE5XzlfMTknKV0gPSA2O1xuICAgIHZhbHVlc1sodmFsdWVzQnlJZFs3XSA9ICdJUl9WRVJTSU9OXzIwMjBfNV84JyldID0gNztcbiAgICB2YWx1ZXNbKHZhbHVlc0J5SWRbOF0gPSAnSVJfVkVSU0lPTl8yMDIxXzdfMzAnKV0gPSA4O1xuICAgIHZhbHVlc1sodmFsdWVzQnlJZFs5XSA9ICdJUl9WRVJTSU9OJyldID0gOTtcbiAgICByZXR1cm4gdmFsdWVzO1xuICB9KSgpO1xuXG4gIG9ubnguQXR0cmlidXRlUHJvdG8gPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgb2YgYW4gQXR0cmlidXRlUHJvdG8uXG4gICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgKiBAaW50ZXJmYWNlIElBdHRyaWJ1dGVQcm90b1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtuYW1lXSBBdHRyaWJ1dGVQcm90byBuYW1lXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW3JlZkF0dHJOYW1lXSBBdHRyaWJ1dGVQcm90byByZWZBdHRyTmFtZVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtkb2NTdHJpbmddIEF0dHJpYnV0ZVByb3RvIGRvY1N0cmluZ1xuICAgICAqIEBwcm9wZXJ0eSB7b25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlfG51bGx9IFt0eXBlXSBBdHRyaWJ1dGVQcm90byB0eXBlXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ8bnVsbH0gW2ZdIEF0dHJpYnV0ZVByb3RvIGZcbiAgICAgKiBAcHJvcGVydHkge251bWJlcnxMb25nfG51bGx9IFtpXSBBdHRyaWJ1dGVQcm90byBpXG4gICAgICogQHByb3BlcnR5IHtVaW50OEFycmF5fG51bGx9IFtzXSBBdHRyaWJ1dGVQcm90byBzXG4gICAgICogQHByb3BlcnR5IHtvbm54LklUZW5zb3JQcm90b3xudWxsfSBbdF0gQXR0cmlidXRlUHJvdG8gdFxuICAgICAqIEBwcm9wZXJ0eSB7b25ueC5JR3JhcGhQcm90b3xudWxsfSBbZ10gQXR0cmlidXRlUHJvdG8gZ1xuICAgICAqIEBwcm9wZXJ0eSB7b25ueC5JU3BhcnNlVGVuc29yUHJvdG98bnVsbH0gW3NwYXJzZVRlbnNvcl0gQXR0cmlidXRlUHJvdG8gc3BhcnNlVGVuc29yXG4gICAgICogQHByb3BlcnR5IHtvbm54LklUeXBlUHJvdG98bnVsbH0gW3RwXSBBdHRyaWJ1dGVQcm90byB0cFxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG51bWJlcj58bnVsbH0gW2Zsb2F0c10gQXR0cmlidXRlUHJvdG8gZmxvYXRzXG4gICAgICogQHByb3BlcnR5IHtBcnJheS48bnVtYmVyfExvbmc+fG51bGx9IFtpbnRzXSBBdHRyaWJ1dGVQcm90byBpbnRzXG4gICAgICogQHByb3BlcnR5IHtBcnJheS48VWludDhBcnJheT58bnVsbH0gW3N0cmluZ3NdIEF0dHJpYnV0ZVByb3RvIHN0cmluZ3NcbiAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LklUZW5zb3JQcm90bz58bnVsbH0gW3RlbnNvcnNdIEF0dHJpYnV0ZVByb3RvIHRlbnNvcnNcbiAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LklHcmFwaFByb3RvPnxudWxsfSBbZ3JhcGhzXSBBdHRyaWJ1dGVQcm90byBncmFwaHNcbiAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LklTcGFyc2VUZW5zb3JQcm90bz58bnVsbH0gW3NwYXJzZVRlbnNvcnNdIEF0dHJpYnV0ZVByb3RvIHNwYXJzZVRlbnNvcnNcbiAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LklUeXBlUHJvdG8+fG51bGx9IFt0eXBlUHJvdG9zXSBBdHRyaWJ1dGVQcm90byB0eXBlUHJvdG9zXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IEF0dHJpYnV0ZVByb3RvLlxuICAgICAqIEBtZW1iZXJvZiBvbm54XG4gICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGFuIEF0dHJpYnV0ZVByb3RvLlxuICAgICAqIEBpbXBsZW1lbnRzIElBdHRyaWJ1dGVQcm90b1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7b25ueC5JQXR0cmlidXRlUHJvdG89fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBdHRyaWJ1dGVQcm90byhwcm9wZXJ0aWVzKSB7XG4gICAgICB0aGlzLmZsb2F0cyA9IFtdO1xuICAgICAgdGhpcy5pbnRzID0gW107XG4gICAgICB0aGlzLnN0cmluZ3MgPSBbXTtcbiAgICAgIHRoaXMudGVuc29ycyA9IFtdO1xuICAgICAgdGhpcy5ncmFwaHMgPSBbXTtcbiAgICAgIHRoaXMuc3BhcnNlVGVuc29ycyA9IFtdO1xuICAgICAgdGhpcy50eXBlUHJvdG9zID0gW107XG4gICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbCkgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXR0cmlidXRlUHJvdG8gbmFtZS5cbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5BdHRyaWJ1dGVQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIEF0dHJpYnV0ZVByb3RvLnByb3RvdHlwZS5uYW1lID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBBdHRyaWJ1dGVQcm90byByZWZBdHRyTmFtZS5cbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IHJlZkF0dHJOYW1lXG4gICAgICogQG1lbWJlcm9mIG9ubnguQXR0cmlidXRlUHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBBdHRyaWJ1dGVQcm90by5wcm90b3R5cGUucmVmQXR0ck5hbWUgPSAnJztcblxuICAgIC8qKlxuICAgICAqIEF0dHJpYnV0ZVByb3RvIGRvY1N0cmluZy5cbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IGRvY1N0cmluZ1xuICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgQXR0cmlidXRlUHJvdG8ucHJvdG90eXBlLmRvY1N0cmluZyA9ICcnO1xuXG4gICAgLyoqXG4gICAgICogQXR0cmlidXRlUHJvdG8gdHlwZS5cbiAgICAgKiBAbWVtYmVyIHtvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGV9IHR5cGVcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5BdHRyaWJ1dGVQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIEF0dHJpYnV0ZVByb3RvLnByb3RvdHlwZS50eXBlID0gMDtcblxuICAgIC8qKlxuICAgICAqIEF0dHJpYnV0ZVByb3RvIGYuXG4gICAgICogQG1lbWJlciB7bnVtYmVyfSBmXG4gICAgICogQG1lbWJlcm9mIG9ubnguQXR0cmlidXRlUHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBBdHRyaWJ1dGVQcm90by5wcm90b3R5cGUuZiA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBBdHRyaWJ1dGVQcm90byBpLlxuICAgICAqIEBtZW1iZXIge251bWJlcnxMb25nfSBpXG4gICAgICogQG1lbWJlcm9mIG9ubnguQXR0cmlidXRlUHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBBdHRyaWJ1dGVQcm90by5wcm90b3R5cGUuaSA9ICR1dGlsLkxvbmcgPyAkdXRpbC5Mb25nLmZyb21CaXRzKDAsIDAsIGZhbHNlKSA6IDA7XG5cbiAgICAvKipcbiAgICAgKiBBdHRyaWJ1dGVQcm90byBzLlxuICAgICAqIEBtZW1iZXIge1VpbnQ4QXJyYXl9IHNcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5BdHRyaWJ1dGVQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIEF0dHJpYnV0ZVByb3RvLnByb3RvdHlwZS5zID0gJHV0aWwubmV3QnVmZmVyKFtdKTtcblxuICAgIC8qKlxuICAgICAqIEF0dHJpYnV0ZVByb3RvIHQuXG4gICAgICogQG1lbWJlciB7b25ueC5JVGVuc29yUHJvdG98bnVsbHx1bmRlZmluZWR9IHRcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5BdHRyaWJ1dGVQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIEF0dHJpYnV0ZVByb3RvLnByb3RvdHlwZS50ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEF0dHJpYnV0ZVByb3RvIGcuXG4gICAgICogQG1lbWJlciB7b25ueC5JR3JhcGhQcm90b3xudWxsfHVuZGVmaW5lZH0gZ1xuICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgQXR0cmlidXRlUHJvdG8ucHJvdG90eXBlLmcgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQXR0cmlidXRlUHJvdG8gc3BhcnNlVGVuc29yLlxuICAgICAqIEBtZW1iZXIge29ubnguSVNwYXJzZVRlbnNvclByb3RvfG51bGx8dW5kZWZpbmVkfSBzcGFyc2VUZW5zb3JcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5BdHRyaWJ1dGVQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIEF0dHJpYnV0ZVByb3RvLnByb3RvdHlwZS5zcGFyc2VUZW5zb3IgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQXR0cmlidXRlUHJvdG8gdHAuXG4gICAgICogQG1lbWJlciB7b25ueC5JVHlwZVByb3RvfG51bGx8dW5kZWZpbmVkfSB0cFxuICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgQXR0cmlidXRlUHJvdG8ucHJvdG90eXBlLnRwID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEF0dHJpYnV0ZVByb3RvIGZsb2F0cy5cbiAgICAgKiBAbWVtYmVyIHtBcnJheS48bnVtYmVyPn0gZmxvYXRzXG4gICAgICogQG1lbWJlcm9mIG9ubnguQXR0cmlidXRlUHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBBdHRyaWJ1dGVQcm90by5wcm90b3R5cGUuZmxvYXRzID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgIC8qKlxuICAgICAqIEF0dHJpYnV0ZVByb3RvIGludHMuXG4gICAgICogQG1lbWJlciB7QXJyYXkuPG51bWJlcnxMb25nPn0gaW50c1xuICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgQXR0cmlidXRlUHJvdG8ucHJvdG90eXBlLmludHMgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgLyoqXG4gICAgICogQXR0cmlidXRlUHJvdG8gc3RyaW5ncy5cbiAgICAgKiBAbWVtYmVyIHtBcnJheS48VWludDhBcnJheT59IHN0cmluZ3NcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5BdHRyaWJ1dGVQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIEF0dHJpYnV0ZVByb3RvLnByb3RvdHlwZS5zdHJpbmdzID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgIC8qKlxuICAgICAqIEF0dHJpYnV0ZVByb3RvIHRlbnNvcnMuXG4gICAgICogQG1lbWJlciB7QXJyYXkuPG9ubnguSVRlbnNvclByb3RvPn0gdGVuc29yc1xuICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgQXR0cmlidXRlUHJvdG8ucHJvdG90eXBlLnRlbnNvcnMgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgLyoqXG4gICAgICogQXR0cmlidXRlUHJvdG8gZ3JhcGhzLlxuICAgICAqIEBtZW1iZXIge0FycmF5Ljxvbm54LklHcmFwaFByb3RvPn0gZ3JhcGhzXG4gICAgICogQG1lbWJlcm9mIG9ubnguQXR0cmlidXRlUHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBBdHRyaWJ1dGVQcm90by5wcm90b3R5cGUuZ3JhcGhzID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgIC8qKlxuICAgICAqIEF0dHJpYnV0ZVByb3RvIHNwYXJzZVRlbnNvcnMuXG4gICAgICogQG1lbWJlciB7QXJyYXkuPG9ubnguSVNwYXJzZVRlbnNvclByb3RvPn0gc3BhcnNlVGVuc29yc1xuICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgQXR0cmlidXRlUHJvdG8ucHJvdG90eXBlLnNwYXJzZVRlbnNvcnMgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgLyoqXG4gICAgICogQXR0cmlidXRlUHJvdG8gdHlwZVByb3Rvcy5cbiAgICAgKiBAbWVtYmVyIHtBcnJheS48b25ueC5JVHlwZVByb3RvPn0gdHlwZVByb3Rvc1xuICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgQXR0cmlidXRlUHJvdG8ucHJvdG90eXBlLnR5cGVQcm90b3MgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBBdHRyaWJ1dGVQcm90byBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxuICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7b25ueC5JQXR0cmlidXRlUHJvdG89fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgKiBAcmV0dXJucyB7b25ueC5BdHRyaWJ1dGVQcm90b30gQXR0cmlidXRlUHJvdG8gaW5zdGFuY2VcbiAgICAgKi9cbiAgICBBdHRyaWJ1dGVQcm90by5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgcmV0dXJuIG5ldyBBdHRyaWJ1dGVQcm90byhwcm9wZXJ0aWVzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIEF0dHJpYnV0ZVByb3RvIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguQXR0cmlidXRlUHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICogQGZ1bmN0aW9uIGVuY29kZVxuICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7b25ueC5JQXR0cmlidXRlUHJvdG99IG1lc3NhZ2UgQXR0cmlidXRlUHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAqL1xuICAgIEF0dHJpYnV0ZVByb3RvLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgIGlmICghd3JpdGVyKSB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgaWYgKG1lc3NhZ2UubmFtZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsICduYW1lJykpXG4gICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki8gMTApLnN0cmluZyhtZXNzYWdlLm5hbWUpO1xuICAgICAgaWYgKG1lc3NhZ2UuZiAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsICdmJykpXG4gICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMiwgd2lyZVR5cGUgNSA9Ki8gMjEpLmZsb2F0KG1lc3NhZ2UuZik7XG4gICAgICBpZiAobWVzc2FnZS5pICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgJ2knKSlcbiAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAzLCB3aXJlVHlwZSAwID0qLyAyNCkuaW50NjQobWVzc2FnZS5pKTtcbiAgICAgIGlmIChtZXNzYWdlLnMgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCAncycpKVxuICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDQsIHdpcmVUeXBlIDIgPSovIDM0KS5ieXRlcyhtZXNzYWdlLnMpO1xuICAgICAgaWYgKG1lc3NhZ2UudCAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsICd0JykpXG4gICAgICAgICRyb290Lm9ubnguVGVuc29yUHJvdG8uZW5jb2RlKG1lc3NhZ2UudCwgd3JpdGVyLnVpbnQzMigvKiBpZCA1LCB3aXJlVHlwZSAyID0qLyA0MikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgIGlmIChtZXNzYWdlLmcgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCAnZycpKVxuICAgICAgICAkcm9vdC5vbm54LkdyYXBoUHJvdG8uZW5jb2RlKG1lc3NhZ2UuZywgd3JpdGVyLnVpbnQzMigvKiBpZCA2LCB3aXJlVHlwZSAyID0qLyA1MCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgIGlmIChtZXNzYWdlLmZsb2F0cyAhPSBudWxsICYmIG1lc3NhZ2UuZmxvYXRzLmxlbmd0aCkge1xuICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDcsIHdpcmVUeXBlIDIgPSovIDU4KS5mb3JrKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5mbG9hdHMubGVuZ3RoOyArK2kpIHdyaXRlci5mbG9hdChtZXNzYWdlLmZsb2F0c1tpXSk7XG4gICAgICAgIHdyaXRlci5sZGVsaW0oKTtcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLmludHMgIT0gbnVsbCAmJiBtZXNzYWdlLmludHMubGVuZ3RoKSB7XG4gICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgOCwgd2lyZVR5cGUgMiA9Ki8gNjYpLmZvcmsoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmludHMubGVuZ3RoOyArK2kpIHdyaXRlci5pbnQ2NChtZXNzYWdlLmludHNbaV0pO1xuICAgICAgICB3cml0ZXIubGRlbGltKCk7XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5zdHJpbmdzICE9IG51bGwgJiYgbWVzc2FnZS5zdHJpbmdzLmxlbmd0aClcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnN0cmluZ3MubGVuZ3RoOyArK2kpXG4gICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA5LCB3aXJlVHlwZSAyID0qLyA3NCkuYnl0ZXMobWVzc2FnZS5zdHJpbmdzW2ldKTtcbiAgICAgIGlmIChtZXNzYWdlLnRlbnNvcnMgIT0gbnVsbCAmJiBtZXNzYWdlLnRlbnNvcnMubGVuZ3RoKVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UudGVuc29ycy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAkcm9vdC5vbm54LlRlbnNvclByb3RvLmVuY29kZShtZXNzYWdlLnRlbnNvcnNbaV0sIHdyaXRlci51aW50MzIoLyogaWQgMTAsIHdpcmVUeXBlIDIgPSovIDgyKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgaWYgKG1lc3NhZ2UuZ3JhcGhzICE9IG51bGwgJiYgbWVzc2FnZS5ncmFwaHMubGVuZ3RoKVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuZ3JhcGhzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICRyb290Lm9ubnguR3JhcGhQcm90by5lbmNvZGUobWVzc2FnZS5ncmFwaHNbaV0sIHdyaXRlci51aW50MzIoLyogaWQgMTEsIHdpcmVUeXBlIDIgPSovIDkwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgaWYgKG1lc3NhZ2UuZG9jU3RyaW5nICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgJ2RvY1N0cmluZycpKVxuICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDEzLCB3aXJlVHlwZSAyID0qLyAxMDYpLnN0cmluZyhtZXNzYWdlLmRvY1N0cmluZyk7XG4gICAgICBpZiAobWVzc2FnZS50cCAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsICd0cCcpKVxuICAgICAgICAkcm9vdC5vbm54LlR5cGVQcm90by5lbmNvZGUobWVzc2FnZS50cCwgd3JpdGVyLnVpbnQzMigvKiBpZCAxNCwgd2lyZVR5cGUgMiA9Ki8gMTE0KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgaWYgKG1lc3NhZ2UudHlwZVByb3RvcyAhPSBudWxsICYmIG1lc3NhZ2UudHlwZVByb3Rvcy5sZW5ndGgpXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS50eXBlUHJvdG9zLmxlbmd0aDsgKytpKVxuICAgICAgICAgICRyb290Lm9ubnguVHlwZVByb3RvLmVuY29kZShcbiAgICAgICAgICAgIG1lc3NhZ2UudHlwZVByb3Rvc1tpXSxcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMTUsIHdpcmVUeXBlIDIgPSovIDEyMikuZm9yaygpLFxuICAgICAgICAgICkubGRlbGltKCk7XG4gICAgICBpZiAobWVzc2FnZS50eXBlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgJ3R5cGUnKSlcbiAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAyMCwgd2lyZVR5cGUgMCA9Ki8gMTYwKS5pbnQzMihtZXNzYWdlLnR5cGUpO1xuICAgICAgaWYgKG1lc3NhZ2UucmVmQXR0ck5hbWUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCAncmVmQXR0ck5hbWUnKSlcbiAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAyMSwgd2lyZVR5cGUgMiA9Ki8gMTcwKS5zdHJpbmcobWVzc2FnZS5yZWZBdHRyTmFtZSk7XG4gICAgICBpZiAobWVzc2FnZS5zcGFyc2VUZW5zb3IgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCAnc3BhcnNlVGVuc29yJykpXG4gICAgICAgICRyb290Lm9ubnguU3BhcnNlVGVuc29yUHJvdG8uZW5jb2RlKFxuICAgICAgICAgIG1lc3NhZ2Uuc3BhcnNlVGVuc29yLFxuICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMjIsIHdpcmVUeXBlIDIgPSovIDE3OCkuZm9yaygpLFxuICAgICAgICApLmxkZWxpbSgpO1xuICAgICAgaWYgKG1lc3NhZ2Uuc3BhcnNlVGVuc29ycyAhPSBudWxsICYmIG1lc3NhZ2Uuc3BhcnNlVGVuc29ycy5sZW5ndGgpXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5zcGFyc2VUZW5zb3JzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICRyb290Lm9ubnguU3BhcnNlVGVuc29yUHJvdG8uZW5jb2RlKFxuICAgICAgICAgICAgbWVzc2FnZS5zcGFyc2VUZW5zb3JzW2ldLFxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAyMywgd2lyZVR5cGUgMiA9Ki8gMTg2KS5mb3JrKCksXG4gICAgICAgICAgKS5sZGVsaW0oKTtcbiAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBBdHRyaWJ1dGVQcm90byBtZXNzYWdlLCBsZW5ndGggZGVsaW1pdGVkLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LkF0dHJpYnV0ZVByb3RvLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAqIEBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWRcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5BdHRyaWJ1dGVQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge29ubnguSUF0dHJpYnV0ZVByb3RvfSBtZXNzYWdlIEF0dHJpYnV0ZVByb3RvIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgKi9cbiAgICBBdHRyaWJ1dGVQcm90by5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhbiBBdHRyaWJ1dGVQcm90byBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5BdHRyaWJ1dGVQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAqIEByZXR1cm5zIHtvbm54LkF0dHJpYnV0ZVByb3RvfSBBdHRyaWJ1dGVQcm90b1xuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICovXG4gICAgQXR0cmlidXRlUHJvdG8uZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSkgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLFxuICAgICAgICBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguQXR0cmlidXRlUHJvdG8oKTtcbiAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICBtZXNzYWdlLm5hbWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAyMToge1xuICAgICAgICAgICAgbWVzc2FnZS5yZWZBdHRyTmFtZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDEzOiB7XG4gICAgICAgICAgICBtZXNzYWdlLmRvY1N0cmluZyA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDIwOiB7XG4gICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgIG1lc3NhZ2UuZiA9IHJlYWRlci5mbG9hdCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMzoge1xuICAgICAgICAgICAgbWVzc2FnZS5pID0gcmVhZGVyLmludDY0KCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSA0OiB7XG4gICAgICAgICAgICBtZXNzYWdlLnMgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDU6IHtcbiAgICAgICAgICAgIG1lc3NhZ2UudCA9ICRyb290Lm9ubnguVGVuc29yUHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDY6IHtcbiAgICAgICAgICAgIG1lc3NhZ2UuZyA9ICRyb290Lm9ubnguR3JhcGhQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMjI6IHtcbiAgICAgICAgICAgIG1lc3NhZ2Uuc3BhcnNlVGVuc29yID0gJHJvb3Qub25ueC5TcGFyc2VUZW5zb3JQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMTQ6IHtcbiAgICAgICAgICAgIG1lc3NhZ2UudHAgPSAkcm9vdC5vbm54LlR5cGVQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgNzoge1xuICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5mbG9hdHMgJiYgbWVzc2FnZS5mbG9hdHMubGVuZ3RoKSkgbWVzc2FnZS5mbG9hdHMgPSBbXTtcbiAgICAgICAgICAgIGlmICgodGFnICYgNykgPT09IDIpIHtcbiAgICAgICAgICAgICAgdmFyIGVuZDIgPSByZWFkZXIudWludDMyKCkgKyByZWFkZXIucG9zO1xuICAgICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZDIpIG1lc3NhZ2UuZmxvYXRzLnB1c2gocmVhZGVyLmZsb2F0KCkpO1xuICAgICAgICAgICAgfSBlbHNlIG1lc3NhZ2UuZmxvYXRzLnB1c2gocmVhZGVyLmZsb2F0KCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgODoge1xuICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5pbnRzICYmIG1lc3NhZ2UuaW50cy5sZW5ndGgpKSBtZXNzYWdlLmludHMgPSBbXTtcbiAgICAgICAgICAgIGlmICgodGFnICYgNykgPT09IDIpIHtcbiAgICAgICAgICAgICAgdmFyIGVuZDIgPSByZWFkZXIudWludDMyKCkgKyByZWFkZXIucG9zO1xuICAgICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZDIpIG1lc3NhZ2UuaW50cy5wdXNoKHJlYWRlci5pbnQ2NCgpKTtcbiAgICAgICAgICAgIH0gZWxzZSBtZXNzYWdlLmludHMucHVzaChyZWFkZXIuaW50NjQoKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSA5OiB7XG4gICAgICAgICAgICBpZiAoIShtZXNzYWdlLnN0cmluZ3MgJiYgbWVzc2FnZS5zdHJpbmdzLmxlbmd0aCkpIG1lc3NhZ2Uuc3RyaW5ncyA9IFtdO1xuICAgICAgICAgICAgbWVzc2FnZS5zdHJpbmdzLnB1c2gocmVhZGVyLmJ5dGVzKCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMTA6IHtcbiAgICAgICAgICAgIGlmICghKG1lc3NhZ2UudGVuc29ycyAmJiBtZXNzYWdlLnRlbnNvcnMubGVuZ3RoKSkgbWVzc2FnZS50ZW5zb3JzID0gW107XG4gICAgICAgICAgICBtZXNzYWdlLnRlbnNvcnMucHVzaCgkcm9vdC5vbm54LlRlbnNvclByb3RvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMTE6IHtcbiAgICAgICAgICAgIGlmICghKG1lc3NhZ2UuZ3JhcGhzICYmIG1lc3NhZ2UuZ3JhcGhzLmxlbmd0aCkpIG1lc3NhZ2UuZ3JhcGhzID0gW107XG4gICAgICAgICAgICBtZXNzYWdlLmdyYXBocy5wdXNoKCRyb290Lm9ubnguR3JhcGhQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDIzOiB7XG4gICAgICAgICAgICBpZiAoIShtZXNzYWdlLnNwYXJzZVRlbnNvcnMgJiYgbWVzc2FnZS5zcGFyc2VUZW5zb3JzLmxlbmd0aCkpIG1lc3NhZ2Uuc3BhcnNlVGVuc29ycyA9IFtdO1xuICAgICAgICAgICAgbWVzc2FnZS5zcGFyc2VUZW5zb3JzLnB1c2goJHJvb3Qub25ueC5TcGFyc2VUZW5zb3JQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDE1OiB7XG4gICAgICAgICAgICBpZiAoIShtZXNzYWdlLnR5cGVQcm90b3MgJiYgbWVzc2FnZS50eXBlUHJvdG9zLmxlbmd0aCkpIG1lc3NhZ2UudHlwZVByb3RvcyA9IFtdO1xuICAgICAgICAgICAgbWVzc2FnZS50eXBlUHJvdG9zLnB1c2goJHJvb3Qub25ueC5UeXBlUHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhbiBBdHRyaWJ1dGVQcm90byBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLCBsZW5ndGggZGVsaW1pdGVkLlxuICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5BdHRyaWJ1dGVQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgKiBAcmV0dXJucyB7b25ueC5BdHRyaWJ1dGVQcm90b30gQXR0cmlidXRlUHJvdG9cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAqL1xuICAgIEF0dHJpYnV0ZVByb3RvLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKSByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgYW4gQXR0cmlidXRlUHJvdG8gbWVzc2FnZS5cbiAgICAgKiBAZnVuY3Rpb24gdmVyaWZ5XG4gICAgICogQG1lbWJlcm9mIG9ubnguQXR0cmlidXRlUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XG4gICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAgICAgKi9cbiAgICBBdHRyaWJ1dGVQcm90by52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSAnb2JqZWN0JyB8fCBtZXNzYWdlID09PSBudWxsKSByZXR1cm4gJ29iamVjdCBleHBlY3RlZCc7XG4gICAgICBpZiAobWVzc2FnZS5uYW1lICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnbmFtZScpKVxuICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UubmFtZSkpIHJldHVybiAnbmFtZTogc3RyaW5nIGV4cGVjdGVkJztcbiAgICAgIGlmIChtZXNzYWdlLnJlZkF0dHJOYW1lICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgncmVmQXR0ck5hbWUnKSlcbiAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLnJlZkF0dHJOYW1lKSkgcmV0dXJuICdyZWZBdHRyTmFtZTogc3RyaW5nIGV4cGVjdGVkJztcbiAgICAgIGlmIChtZXNzYWdlLmRvY1N0cmluZyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ2RvY1N0cmluZycpKVxuICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UuZG9jU3RyaW5nKSkgcmV0dXJuICdkb2NTdHJpbmc6IHN0cmluZyBleHBlY3RlZCc7XG4gICAgICBpZiAobWVzc2FnZS50eXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgndHlwZScpKVxuICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gJ3R5cGU6IGVudW0gdmFsdWUgZXhwZWN0ZWQnO1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UuZiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ2YnKSlcbiAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmYgIT09ICdudW1iZXInKSByZXR1cm4gJ2Y6IG51bWJlciBleHBlY3RlZCc7XG4gICAgICBpZiAobWVzc2FnZS5pICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnaScpKVxuICAgICAgICBpZiAoXG4gICAgICAgICAgISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmkpICYmXG4gICAgICAgICAgIShtZXNzYWdlLmkgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuaS5sb3cpICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmkuaGlnaCkpXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm4gJ2k6IGludGVnZXJ8TG9uZyBleHBlY3RlZCc7XG4gICAgICBpZiAobWVzc2FnZS5zICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgncycpKVxuICAgICAgICBpZiAoISgobWVzc2FnZS5zICYmIHR5cGVvZiBtZXNzYWdlLnMubGVuZ3RoID09PSAnbnVtYmVyJykgfHwgJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5zKSkpXG4gICAgICAgICAgcmV0dXJuICdzOiBidWZmZXIgZXhwZWN0ZWQnO1xuICAgICAgaWYgKG1lc3NhZ2UudCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ3QnKSkge1xuICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LlRlbnNvclByb3RvLnZlcmlmeShtZXNzYWdlLnQpO1xuICAgICAgICBpZiAoZXJyb3IpIHJldHVybiAndC4nICsgZXJyb3I7XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5nICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnZycpKSB7XG4gICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguR3JhcGhQcm90by52ZXJpZnkobWVzc2FnZS5nKTtcbiAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gJ2cuJyArIGVycm9yO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2Uuc3BhcnNlVGVuc29yICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnc3BhcnNlVGVuc29yJykpIHtcbiAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5TcGFyc2VUZW5zb3JQcm90by52ZXJpZnkobWVzc2FnZS5zcGFyc2VUZW5zb3IpO1xuICAgICAgICBpZiAoZXJyb3IpIHJldHVybiAnc3BhcnNlVGVuc29yLicgKyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLnRwICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgndHAnKSkge1xuICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LlR5cGVQcm90by52ZXJpZnkobWVzc2FnZS50cCk7XG4gICAgICAgIGlmIChlcnJvcikgcmV0dXJuICd0cC4nICsgZXJyb3I7XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5mbG9hdHMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdmbG9hdHMnKSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5mbG9hdHMpKSByZXR1cm4gJ2Zsb2F0czogYXJyYXkgZXhwZWN0ZWQnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuZmxvYXRzLmxlbmd0aDsgKytpKVxuICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5mbG9hdHNbaV0gIT09ICdudW1iZXInKSByZXR1cm4gJ2Zsb2F0czogbnVtYmVyW10gZXhwZWN0ZWQnO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UuaW50cyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ2ludHMnKSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5pbnRzKSkgcmV0dXJuICdpbnRzOiBhcnJheSBleHBlY3RlZCc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5pbnRzLmxlbmd0aDsgKytpKVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5pbnRzW2ldKSAmJlxuICAgICAgICAgICAgIShtZXNzYWdlLmludHNbaV0gJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuaW50c1tpXS5sb3cpICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmludHNbaV0uaGlnaCkpXG4gICAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuICdpbnRzOiBpbnRlZ2VyfExvbmdbXSBleHBlY3RlZCc7XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5zdHJpbmdzICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnc3RyaW5ncycpKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLnN0cmluZ3MpKSByZXR1cm4gJ3N0cmluZ3M6IGFycmF5IGV4cGVjdGVkJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnN0cmluZ3MubGVuZ3RoOyArK2kpXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIShcbiAgICAgICAgICAgICAgKG1lc3NhZ2Uuc3RyaW5nc1tpXSAmJiB0eXBlb2YgbWVzc2FnZS5zdHJpbmdzW2ldLmxlbmd0aCA9PT0gJ251bWJlcicpIHx8XG4gICAgICAgICAgICAgICR1dGlsLmlzU3RyaW5nKG1lc3NhZ2Uuc3RyaW5nc1tpXSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm4gJ3N0cmluZ3M6IGJ1ZmZlcltdIGV4cGVjdGVkJztcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLnRlbnNvcnMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCd0ZW5zb3JzJykpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UudGVuc29ycykpIHJldHVybiAndGVuc29yczogYXJyYXkgZXhwZWN0ZWQnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UudGVuc29ycy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguVGVuc29yUHJvdG8udmVyaWZ5KG1lc3NhZ2UudGVuc29yc1tpXSk7XG4gICAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gJ3RlbnNvcnMuJyArIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5ncmFwaHMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdncmFwaHMnKSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5ncmFwaHMpKSByZXR1cm4gJ2dyYXBoczogYXJyYXkgZXhwZWN0ZWQnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuZ3JhcGhzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5HcmFwaFByb3RvLnZlcmlmeShtZXNzYWdlLmdyYXBoc1tpXSk7XG4gICAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gJ2dyYXBocy4nICsgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLnNwYXJzZVRlbnNvcnMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdzcGFyc2VUZW5zb3JzJykpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2Uuc3BhcnNlVGVuc29ycykpIHJldHVybiAnc3BhcnNlVGVuc29yczogYXJyYXkgZXhwZWN0ZWQnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2Uuc3BhcnNlVGVuc29ycy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguU3BhcnNlVGVuc29yUHJvdG8udmVyaWZ5KG1lc3NhZ2Uuc3BhcnNlVGVuc29yc1tpXSk7XG4gICAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gJ3NwYXJzZVRlbnNvcnMuJyArIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS50eXBlUHJvdG9zICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgndHlwZVByb3RvcycpKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLnR5cGVQcm90b3MpKSByZXR1cm4gJ3R5cGVQcm90b3M6IGFycmF5IGV4cGVjdGVkJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnR5cGVQcm90b3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LlR5cGVQcm90by52ZXJpZnkobWVzc2FnZS50eXBlUHJvdG9zW2ldKTtcbiAgICAgICAgICBpZiAoZXJyb3IpIHJldHVybiAndHlwZVByb3Rvcy4nICsgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIEF0dHJpYnV0ZVByb3RvIG1lc3NhZ2UgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cbiAgICAgKiBAZnVuY3Rpb24gZnJvbU9iamVjdFxuICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7b25ueC5BdHRyaWJ1dGVQcm90b30gQXR0cmlidXRlUHJvdG9cbiAgICAgKi9cbiAgICBBdHRyaWJ1dGVQcm90by5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5vbm54LkF0dHJpYnV0ZVByb3RvKSByZXR1cm4gb2JqZWN0O1xuICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5BdHRyaWJ1dGVQcm90bygpO1xuICAgICAgaWYgKG9iamVjdC5uYW1lICE9IG51bGwpIG1lc3NhZ2UubmFtZSA9IFN0cmluZyhvYmplY3QubmFtZSk7XG4gICAgICBpZiAob2JqZWN0LnJlZkF0dHJOYW1lICE9IG51bGwpIG1lc3NhZ2UucmVmQXR0ck5hbWUgPSBTdHJpbmcob2JqZWN0LnJlZkF0dHJOYW1lKTtcbiAgICAgIGlmIChvYmplY3QuZG9jU3RyaW5nICE9IG51bGwpIG1lc3NhZ2UuZG9jU3RyaW5nID0gU3RyaW5nKG9iamVjdC5kb2NTdHJpbmcpO1xuICAgICAgc3dpdGNoIChvYmplY3QudHlwZSkge1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSBvYmplY3QudHlwZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnVU5ERUZJTkVEJzpcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0ZMT0FUJzpcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0lOVCc6XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBtZXNzYWdlLnR5cGUgPSAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdTVFJJTkcnOlxuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgbWVzc2FnZS50eXBlID0gMztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnVEVOU09SJzpcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0dSQVBIJzpcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1NQQVJTRV9URU5TT1InOlxuICAgICAgICBjYXNlIDExOlxuICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDExO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdUWVBFX1BST1RPJzpcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICBtZXNzYWdlLnR5cGUgPSAxMztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnRkxPQVRTJzpcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDY7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0lOVFMnOlxuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgbWVzc2FnZS50eXBlID0gNztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnU1RSSU5HUyc6XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICBtZXNzYWdlLnR5cGUgPSA4O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdURU5TT1JTJzpcbiAgICAgICAgY2FzZSA5OlxuICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0dSQVBIUyc6XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgbWVzc2FnZS50eXBlID0gMTA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1NQQVJTRV9URU5TT1JTJzpcbiAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICBtZXNzYWdlLnR5cGUgPSAxMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnVFlQRV9QUk9UT1MnOlxuICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDE0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKG9iamVjdC5mICE9IG51bGwpIG1lc3NhZ2UuZiA9IE51bWJlcihvYmplY3QuZik7XG4gICAgICBpZiAob2JqZWN0LmkgIT0gbnVsbClcbiAgICAgICAgaWYgKCR1dGlsLkxvbmcpIChtZXNzYWdlLmkgPSAkdXRpbC5Mb25nLmZyb21WYWx1ZShvYmplY3QuaSkpLnVuc2lnbmVkID0gZmFsc2U7XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuaSA9PT0gJ3N0cmluZycpIG1lc3NhZ2UuaSA9IHBhcnNlSW50KG9iamVjdC5pLCAxMCk7XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuaSA9PT0gJ251bWJlcicpIG1lc3NhZ2UuaSA9IG9iamVjdC5pO1xuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmkgPT09ICdvYmplY3QnKVxuICAgICAgICAgIG1lc3NhZ2UuaSA9IG5ldyAkdXRpbC5Mb25nQml0cyhvYmplY3QuaS5sb3cgPj4+IDAsIG9iamVjdC5pLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCk7XG4gICAgICBpZiAob2JqZWN0LnMgIT0gbnVsbClcbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QucyA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgJHV0aWwuYmFzZTY0LmRlY29kZShvYmplY3QucywgKG1lc3NhZ2UucyA9ICR1dGlsLm5ld0J1ZmZlcigkdXRpbC5iYXNlNjQubGVuZ3RoKG9iamVjdC5zKSkpLCAwKTtcbiAgICAgICAgZWxzZSBpZiAob2JqZWN0LnMubGVuZ3RoID49IDApIG1lc3NhZ2UucyA9IG9iamVjdC5zO1xuICAgICAgaWYgKG9iamVjdC50ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QudCAhPT0gJ29iamVjdCcpIHRocm93IFR5cGVFcnJvcignLm9ubnguQXR0cmlidXRlUHJvdG8udDogb2JqZWN0IGV4cGVjdGVkJyk7XG4gICAgICAgIG1lc3NhZ2UudCA9ICRyb290Lm9ubnguVGVuc29yUHJvdG8uZnJvbU9iamVjdChvYmplY3QudCk7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0LmcgIT0gbnVsbCkge1xuICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5nICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCcub25ueC5BdHRyaWJ1dGVQcm90by5nOiBvYmplY3QgZXhwZWN0ZWQnKTtcbiAgICAgICAgbWVzc2FnZS5nID0gJHJvb3Qub25ueC5HcmFwaFByb3RvLmZyb21PYmplY3Qob2JqZWN0LmcpO1xuICAgICAgfVxuICAgICAgaWYgKG9iamVjdC5zcGFyc2VUZW5zb3IgIT0gbnVsbCkge1xuICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5zcGFyc2VUZW5zb3IgIT09ICdvYmplY3QnKVxuICAgICAgICAgIHRocm93IFR5cGVFcnJvcignLm9ubnguQXR0cmlidXRlUHJvdG8uc3BhcnNlVGVuc29yOiBvYmplY3QgZXhwZWN0ZWQnKTtcbiAgICAgICAgbWVzc2FnZS5zcGFyc2VUZW5zb3IgPSAkcm9vdC5vbm54LlNwYXJzZVRlbnNvclByb3RvLmZyb21PYmplY3Qob2JqZWN0LnNwYXJzZVRlbnNvcik7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0LnRwICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QudHAgIT09ICdvYmplY3QnKSB0aHJvdyBUeXBlRXJyb3IoJy5vbm54LkF0dHJpYnV0ZVByb3RvLnRwOiBvYmplY3QgZXhwZWN0ZWQnKTtcbiAgICAgICAgbWVzc2FnZS50cCA9ICRyb290Lm9ubnguVHlwZVByb3RvLmZyb21PYmplY3Qob2JqZWN0LnRwKTtcbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3QuZmxvYXRzKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QuZmxvYXRzKSkgdGhyb3cgVHlwZUVycm9yKCcub25ueC5BdHRyaWJ1dGVQcm90by5mbG9hdHM6IGFycmF5IGV4cGVjdGVkJyk7XG4gICAgICAgIG1lc3NhZ2UuZmxvYXRzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LmZsb2F0cy5sZW5ndGg7ICsraSkgbWVzc2FnZS5mbG9hdHNbaV0gPSBOdW1iZXIob2JqZWN0LmZsb2F0c1tpXSk7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0LmludHMpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5pbnRzKSkgdGhyb3cgVHlwZUVycm9yKCcub25ueC5BdHRyaWJ1dGVQcm90by5pbnRzOiBhcnJheSBleHBlY3RlZCcpO1xuICAgICAgICBtZXNzYWdlLmludHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QuaW50cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICBpZiAoJHV0aWwuTG9uZykgKG1lc3NhZ2UuaW50c1tpXSA9ICR1dGlsLkxvbmcuZnJvbVZhbHVlKG9iamVjdC5pbnRzW2ldKSkudW5zaWduZWQgPSBmYWxzZTtcbiAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmludHNbaV0gPT09ICdzdHJpbmcnKSBtZXNzYWdlLmludHNbaV0gPSBwYXJzZUludChvYmplY3QuaW50c1tpXSwgMTApO1xuICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuaW50c1tpXSA9PT0gJ251bWJlcicpIG1lc3NhZ2UuaW50c1tpXSA9IG9iamVjdC5pbnRzW2ldO1xuICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuaW50c1tpXSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICBtZXNzYWdlLmludHNbaV0gPSBuZXcgJHV0aWwuTG9uZ0JpdHMob2JqZWN0LmludHNbaV0ubG93ID4+PiAwLCBvYmplY3QuaW50c1tpXS5oaWdoID4+PiAwKS50b051bWJlcigpO1xuICAgICAgfVxuICAgICAgaWYgKG9iamVjdC5zdHJpbmdzKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3Quc3RyaW5ncykpIHRocm93IFR5cGVFcnJvcignLm9ubnguQXR0cmlidXRlUHJvdG8uc3RyaW5nczogYXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgbWVzc2FnZS5zdHJpbmdzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LnN0cmluZ3MubGVuZ3RoOyArK2kpXG4gICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3Quc3RyaW5nc1tpXSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAkdXRpbC5iYXNlNjQuZGVjb2RlKFxuICAgICAgICAgICAgICBvYmplY3Quc3RyaW5nc1tpXSxcbiAgICAgICAgICAgICAgKG1lc3NhZ2Uuc3RyaW5nc1tpXSA9ICR1dGlsLm5ld0J1ZmZlcigkdXRpbC5iYXNlNjQubGVuZ3RoKG9iamVjdC5zdHJpbmdzW2ldKSkpLFxuICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBlbHNlIGlmIChvYmplY3Quc3RyaW5nc1tpXS5sZW5ndGggPj0gMCkgbWVzc2FnZS5zdHJpbmdzW2ldID0gb2JqZWN0LnN0cmluZ3NbaV07XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0LnRlbnNvcnMpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC50ZW5zb3JzKSkgdGhyb3cgVHlwZUVycm9yKCcub25ueC5BdHRyaWJ1dGVQcm90by50ZW5zb3JzOiBhcnJheSBleHBlY3RlZCcpO1xuICAgICAgICBtZXNzYWdlLnRlbnNvcnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QudGVuc29ycy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnRlbnNvcnNbaV0gIT09ICdvYmplY3QnKSB0aHJvdyBUeXBlRXJyb3IoJy5vbm54LkF0dHJpYnV0ZVByb3RvLnRlbnNvcnM6IG9iamVjdCBleHBlY3RlZCcpO1xuICAgICAgICAgIG1lc3NhZ2UudGVuc29yc1tpXSA9ICRyb290Lm9ubnguVGVuc29yUHJvdG8uZnJvbU9iamVjdChvYmplY3QudGVuc29yc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3QuZ3JhcGhzKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QuZ3JhcGhzKSkgdGhyb3cgVHlwZUVycm9yKCcub25ueC5BdHRyaWJ1dGVQcm90by5ncmFwaHM6IGFycmF5IGV4cGVjdGVkJyk7XG4gICAgICAgIG1lc3NhZ2UuZ3JhcGhzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LmdyYXBocy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmdyYXBoc1tpXSAhPT0gJ29iamVjdCcpIHRocm93IFR5cGVFcnJvcignLm9ubnguQXR0cmlidXRlUHJvdG8uZ3JhcGhzOiBvYmplY3QgZXhwZWN0ZWQnKTtcbiAgICAgICAgICBtZXNzYWdlLmdyYXBoc1tpXSA9ICRyb290Lm9ubnguR3JhcGhQcm90by5mcm9tT2JqZWN0KG9iamVjdC5ncmFwaHNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0LnNwYXJzZVRlbnNvcnMpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5zcGFyc2VUZW5zb3JzKSkgdGhyb3cgVHlwZUVycm9yKCcub25ueC5BdHRyaWJ1dGVQcm90by5zcGFyc2VUZW5zb3JzOiBhcnJheSBleHBlY3RlZCcpO1xuICAgICAgICBtZXNzYWdlLnNwYXJzZVRlbnNvcnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3Quc3BhcnNlVGVuc29ycy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnNwYXJzZVRlbnNvcnNbaV0gIT09ICdvYmplY3QnKVxuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCcub25ueC5BdHRyaWJ1dGVQcm90by5zcGFyc2VUZW5zb3JzOiBvYmplY3QgZXhwZWN0ZWQnKTtcbiAgICAgICAgICBtZXNzYWdlLnNwYXJzZVRlbnNvcnNbaV0gPSAkcm9vdC5vbm54LlNwYXJzZVRlbnNvclByb3RvLmZyb21PYmplY3Qob2JqZWN0LnNwYXJzZVRlbnNvcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0LnR5cGVQcm90b3MpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC50eXBlUHJvdG9zKSkgdGhyb3cgVHlwZUVycm9yKCcub25ueC5BdHRyaWJ1dGVQcm90by50eXBlUHJvdG9zOiBhcnJheSBleHBlY3RlZCcpO1xuICAgICAgICBtZXNzYWdlLnR5cGVQcm90b3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QudHlwZVByb3Rvcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnR5cGVQcm90b3NbaV0gIT09ICdvYmplY3QnKVxuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCcub25ueC5BdHRyaWJ1dGVQcm90by50eXBlUHJvdG9zOiBvYmplY3QgZXhwZWN0ZWQnKTtcbiAgICAgICAgICBtZXNzYWdlLnR5cGVQcm90b3NbaV0gPSAkcm9vdC5vbm54LlR5cGVQcm90by5mcm9tT2JqZWN0KG9iamVjdC50eXBlUHJvdG9zW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhbiBBdHRyaWJ1dGVQcm90byBtZXNzYWdlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXG4gICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XG4gICAgICogQG1lbWJlcm9mIG9ubnguQXR0cmlidXRlUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtvbm54LkF0dHJpYnV0ZVByb3RvfSBtZXNzYWdlIEF0dHJpYnV0ZVByb3RvXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuSUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcbiAgICAgKi9cbiAgICBBdHRyaWJ1dGVQcm90by50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgaWYgKG9wdGlvbnMuYXJyYXlzIHx8IG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgb2JqZWN0LmZsb2F0cyA9IFtdO1xuICAgICAgICBvYmplY3QuaW50cyA9IFtdO1xuICAgICAgICBvYmplY3Quc3RyaW5ncyA9IFtdO1xuICAgICAgICBvYmplY3QudGVuc29ycyA9IFtdO1xuICAgICAgICBvYmplY3QuZ3JhcGhzID0gW107XG4gICAgICAgIG9iamVjdC50eXBlUHJvdG9zID0gW107XG4gICAgICAgIG9iamVjdC5zcGFyc2VUZW5zb3JzID0gW107XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICBvYmplY3QubmFtZSA9ICcnO1xuICAgICAgICBvYmplY3QuZiA9IDA7XG4gICAgICAgIGlmICgkdXRpbC5Mb25nKSB7XG4gICAgICAgICAgdmFyIGxvbmcgPSBuZXcgJHV0aWwuTG9uZygwLCAwLCBmYWxzZSk7XG4gICAgICAgICAgb2JqZWN0LmkgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBsb25nLnRvU3RyaW5nKCkgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBsb25nLnRvTnVtYmVyKCkgOiBsb25nO1xuICAgICAgICB9IGVsc2Ugb2JqZWN0LmkgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyAnMCcgOiAwO1xuICAgICAgICBpZiAob3B0aW9ucy5ieXRlcyA9PT0gU3RyaW5nKSBvYmplY3QucyA9ICcnO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBvYmplY3QucyA9IFtdO1xuICAgICAgICAgIGlmIChvcHRpb25zLmJ5dGVzICE9PSBBcnJheSkgb2JqZWN0LnMgPSAkdXRpbC5uZXdCdWZmZXIob2JqZWN0LnMpO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdC50ID0gbnVsbDtcbiAgICAgICAgb2JqZWN0LmcgPSBudWxsO1xuICAgICAgICBvYmplY3QuZG9jU3RyaW5nID0gJyc7XG4gICAgICAgIG9iamVjdC50cCA9IG51bGw7XG4gICAgICAgIG9iamVjdC50eXBlID0gb3B0aW9ucy5lbnVtcyA9PT0gU3RyaW5nID8gJ1VOREVGSU5FRCcgOiAwO1xuICAgICAgICBvYmplY3QucmVmQXR0ck5hbWUgPSAnJztcbiAgICAgICAgb2JqZWN0LnNwYXJzZVRlbnNvciA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5uYW1lICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnbmFtZScpKSBvYmplY3QubmFtZSA9IG1lc3NhZ2UubmFtZTtcbiAgICAgIGlmIChtZXNzYWdlLmYgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdmJykpXG4gICAgICAgIG9iamVjdC5mID0gb3B0aW9ucy5qc29uICYmICFpc0Zpbml0ZShtZXNzYWdlLmYpID8gU3RyaW5nKG1lc3NhZ2UuZikgOiBtZXNzYWdlLmY7XG4gICAgICBpZiAobWVzc2FnZS5pICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnaScpKVxuICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuaSA9PT0gJ251bWJlcicpIG9iamVjdC5pID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gU3RyaW5nKG1lc3NhZ2UuaSkgOiBtZXNzYWdlLmk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBvYmplY3QuaSA9XG4gICAgICAgICAgICBvcHRpb25zLmxvbmdzID09PSBTdHJpbmdcbiAgICAgICAgICAgICAgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1lc3NhZ2UuaSlcbiAgICAgICAgICAgICAgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXJcbiAgICAgICAgICAgICAgICA/IG5ldyAkdXRpbC5Mb25nQml0cyhtZXNzYWdlLmkubG93ID4+PiAwLCBtZXNzYWdlLmkuaGlnaCA+Pj4gMCkudG9OdW1iZXIoKVxuICAgICAgICAgICAgICAgIDogbWVzc2FnZS5pO1xuICAgICAgaWYgKG1lc3NhZ2UucyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ3MnKSlcbiAgICAgICAgb2JqZWN0LnMgPVxuICAgICAgICAgIG9wdGlvbnMuYnl0ZXMgPT09IFN0cmluZ1xuICAgICAgICAgICAgPyAkdXRpbC5iYXNlNjQuZW5jb2RlKG1lc3NhZ2UucywgMCwgbWVzc2FnZS5zLmxlbmd0aClcbiAgICAgICAgICAgIDogb3B0aW9ucy5ieXRlcyA9PT0gQXJyYXlcbiAgICAgICAgICAgICAgPyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChtZXNzYWdlLnMpXG4gICAgICAgICAgICAgIDogbWVzc2FnZS5zO1xuICAgICAgaWYgKG1lc3NhZ2UudCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ3QnKSlcbiAgICAgICAgb2JqZWN0LnQgPSAkcm9vdC5vbm54LlRlbnNvclByb3RvLnRvT2JqZWN0KG1lc3NhZ2UudCwgb3B0aW9ucyk7XG4gICAgICBpZiAobWVzc2FnZS5nICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnZycpKVxuICAgICAgICBvYmplY3QuZyA9ICRyb290Lm9ubnguR3JhcGhQcm90by50b09iamVjdChtZXNzYWdlLmcsIG9wdGlvbnMpO1xuICAgICAgaWYgKG1lc3NhZ2UuZmxvYXRzICYmIG1lc3NhZ2UuZmxvYXRzLmxlbmd0aCkge1xuICAgICAgICBvYmplY3QuZmxvYXRzID0gW107XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5mbG9hdHMubGVuZ3RoOyArK2opXG4gICAgICAgICAgb2JqZWN0LmZsb2F0c1tqXSA9XG4gICAgICAgICAgICBvcHRpb25zLmpzb24gJiYgIWlzRmluaXRlKG1lc3NhZ2UuZmxvYXRzW2pdKSA/IFN0cmluZyhtZXNzYWdlLmZsb2F0c1tqXSkgOiBtZXNzYWdlLmZsb2F0c1tqXTtcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLmludHMgJiYgbWVzc2FnZS5pbnRzLmxlbmd0aCkge1xuICAgICAgICBvYmplY3QuaW50cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UuaW50cy5sZW5ndGg7ICsrailcbiAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuaW50c1tqXSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICBvYmplY3QuaW50c1tqXSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtZXNzYWdlLmludHNbal0pIDogbWVzc2FnZS5pbnRzW2pdO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIG9iamVjdC5pbnRzW2pdID1cbiAgICAgICAgICAgICAgb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nXG4gICAgICAgICAgICAgICAgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1lc3NhZ2UuaW50c1tqXSlcbiAgICAgICAgICAgICAgICA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlclxuICAgICAgICAgICAgICAgICAgPyBuZXcgJHV0aWwuTG9uZ0JpdHMobWVzc2FnZS5pbnRzW2pdLmxvdyA+Pj4gMCwgbWVzc2FnZS5pbnRzW2pdLmhpZ2ggPj4+IDApLnRvTnVtYmVyKClcbiAgICAgICAgICAgICAgICAgIDogbWVzc2FnZS5pbnRzW2pdO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2Uuc3RyaW5ncyAmJiBtZXNzYWdlLnN0cmluZ3MubGVuZ3RoKSB7XG4gICAgICAgIG9iamVjdC5zdHJpbmdzID0gW107XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5zdHJpbmdzLmxlbmd0aDsgKytqKVxuICAgICAgICAgIG9iamVjdC5zdHJpbmdzW2pdID1cbiAgICAgICAgICAgIG9wdGlvbnMuYnl0ZXMgPT09IFN0cmluZ1xuICAgICAgICAgICAgICA/ICR1dGlsLmJhc2U2NC5lbmNvZGUobWVzc2FnZS5zdHJpbmdzW2pdLCAwLCBtZXNzYWdlLnN0cmluZ3Nbal0ubGVuZ3RoKVxuICAgICAgICAgICAgICA6IG9wdGlvbnMuYnl0ZXMgPT09IEFycmF5XG4gICAgICAgICAgICAgICAgPyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChtZXNzYWdlLnN0cmluZ3Nbal0pXG4gICAgICAgICAgICAgICAgOiBtZXNzYWdlLnN0cmluZ3Nbal07XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS50ZW5zb3JzICYmIG1lc3NhZ2UudGVuc29ycy5sZW5ndGgpIHtcbiAgICAgICAgb2JqZWN0LnRlbnNvcnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLnRlbnNvcnMubGVuZ3RoOyArK2opXG4gICAgICAgICAgb2JqZWN0LnRlbnNvcnNbal0gPSAkcm9vdC5vbm54LlRlbnNvclByb3RvLnRvT2JqZWN0KG1lc3NhZ2UudGVuc29yc1tqXSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5ncmFwaHMgJiYgbWVzc2FnZS5ncmFwaHMubGVuZ3RoKSB7XG4gICAgICAgIG9iamVjdC5ncmFwaHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLmdyYXBocy5sZW5ndGg7ICsrailcbiAgICAgICAgICBvYmplY3QuZ3JhcGhzW2pdID0gJHJvb3Qub25ueC5HcmFwaFByb3RvLnRvT2JqZWN0KG1lc3NhZ2UuZ3JhcGhzW2pdLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLmRvY1N0cmluZyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ2RvY1N0cmluZycpKSBvYmplY3QuZG9jU3RyaW5nID0gbWVzc2FnZS5kb2NTdHJpbmc7XG4gICAgICBpZiAobWVzc2FnZS50cCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ3RwJykpXG4gICAgICAgIG9iamVjdC50cCA9ICRyb290Lm9ubnguVHlwZVByb3RvLnRvT2JqZWN0KG1lc3NhZ2UudHAsIG9wdGlvbnMpO1xuICAgICAgaWYgKG1lc3NhZ2UudHlwZVByb3RvcyAmJiBtZXNzYWdlLnR5cGVQcm90b3MubGVuZ3RoKSB7XG4gICAgICAgIG9iamVjdC50eXBlUHJvdG9zID0gW107XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS50eXBlUHJvdG9zLmxlbmd0aDsgKytqKVxuICAgICAgICAgIG9iamVjdC50eXBlUHJvdG9zW2pdID0gJHJvb3Qub25ueC5UeXBlUHJvdG8udG9PYmplY3QobWVzc2FnZS50eXBlUHJvdG9zW2pdLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCd0eXBlJykpXG4gICAgICAgIG9iamVjdC50eXBlID1cbiAgICAgICAgICBvcHRpb25zLmVudW1zID09PSBTdHJpbmdcbiAgICAgICAgICAgID8gJHJvb3Qub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlW21lc3NhZ2UudHlwZV0gPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICA/IG1lc3NhZ2UudHlwZVxuICAgICAgICAgICAgICA6ICRyb290Lm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZVttZXNzYWdlLnR5cGVdXG4gICAgICAgICAgICA6IG1lc3NhZ2UudHlwZTtcbiAgICAgIGlmIChtZXNzYWdlLnJlZkF0dHJOYW1lICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgncmVmQXR0ck5hbWUnKSlcbiAgICAgICAgb2JqZWN0LnJlZkF0dHJOYW1lID0gbWVzc2FnZS5yZWZBdHRyTmFtZTtcbiAgICAgIGlmIChtZXNzYWdlLnNwYXJzZVRlbnNvciAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ3NwYXJzZVRlbnNvcicpKVxuICAgICAgICBvYmplY3Quc3BhcnNlVGVuc29yID0gJHJvb3Qub25ueC5TcGFyc2VUZW5zb3JQcm90by50b09iamVjdChtZXNzYWdlLnNwYXJzZVRlbnNvciwgb3B0aW9ucyk7XG4gICAgICBpZiAobWVzc2FnZS5zcGFyc2VUZW5zb3JzICYmIG1lc3NhZ2Uuc3BhcnNlVGVuc29ycy5sZW5ndGgpIHtcbiAgICAgICAgb2JqZWN0LnNwYXJzZVRlbnNvcnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLnNwYXJzZVRlbnNvcnMubGVuZ3RoOyArK2opXG4gICAgICAgICAgb2JqZWN0LnNwYXJzZVRlbnNvcnNbal0gPSAkcm9vdC5vbm54LlNwYXJzZVRlbnNvclByb3RvLnRvT2JqZWN0KG1lc3NhZ2Uuc3BhcnNlVGVuc29yc1tqXSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGlzIEF0dHJpYnV0ZVByb3RvIHRvIEpTT04uXG4gICAgICogQGZ1bmN0aW9uIHRvSlNPTlxuICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICAgICAqL1xuICAgIEF0dHJpYnV0ZVByb3RvLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZGVmYXVsdCB0eXBlIHVybCBmb3IgQXR0cmlidXRlUHJvdG9cbiAgICAgKiBAZnVuY3Rpb24gZ2V0VHlwZVVybFxuICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZVVybFByZWZpeF0geW91ciBjdXN0b20gdHlwZVVybFByZWZpeChkZWZhdWx0IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiKVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBkZWZhdWx0IHR5cGUgdXJsXG4gICAgICovXG4gICAgQXR0cmlidXRlUHJvdG8uZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0eXBlVXJsUHJlZml4ID0gJ3R5cGUuZ29vZ2xlYXBpcy5jb20nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyAnL29ubnguQXR0cmlidXRlUHJvdG8nO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBdHRyaWJ1dGVUeXBlIGVudW0uXG4gICAgICogQG5hbWUgb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlXG4gICAgICogQGVudW0ge251bWJlcn1cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gVU5ERUZJTkVEPTAgVU5ERUZJTkVEIHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEZMT0FUPTEgRkxPQVQgdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gSU5UPTIgSU5UIHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFNUUklORz0zIFNUUklORyB2YWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBURU5TT1I9NCBURU5TT1IgdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gR1JBUEg9NSBHUkFQSCB2YWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBTUEFSU0VfVEVOU09SPTExIFNQQVJTRV9URU5TT1IgdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gVFlQRV9QUk9UTz0xMyBUWVBFX1BST1RPIHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEZMT0FUUz02IEZMT0FUUyB2YWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBJTlRTPTcgSU5UUyB2YWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBTVFJJTkdTPTggU1RSSU5HUyB2YWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBURU5TT1JTPTkgVEVOU09SUyB2YWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBHUkFQSFM9MTAgR1JBUEhTIHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFNQQVJTRV9URU5TT1JTPTEyIFNQQVJTRV9URU5TT1JTIHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFRZUEVfUFJPVE9TPTE0IFRZUEVfUFJPVE9TIHZhbHVlXG4gICAgICovXG4gICAgQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdmFsdWVzQnlJZCA9IHt9LFxuICAgICAgICB2YWx1ZXMgPSBPYmplY3QuY3JlYXRlKHZhbHVlc0J5SWQpO1xuICAgICAgdmFsdWVzWyh2YWx1ZXNCeUlkWzBdID0gJ1VOREVGSU5FRCcpXSA9IDA7XG4gICAgICB2YWx1ZXNbKHZhbHVlc0J5SWRbMV0gPSAnRkxPQVQnKV0gPSAxO1xuICAgICAgdmFsdWVzWyh2YWx1ZXNCeUlkWzJdID0gJ0lOVCcpXSA9IDI7XG4gICAgICB2YWx1ZXNbKHZhbHVlc0J5SWRbM10gPSAnU1RSSU5HJyldID0gMztcbiAgICAgIHZhbHVlc1sodmFsdWVzQnlJZFs0XSA9ICdURU5TT1InKV0gPSA0O1xuICAgICAgdmFsdWVzWyh2YWx1ZXNCeUlkWzVdID0gJ0dSQVBIJyldID0gNTtcbiAgICAgIHZhbHVlc1sodmFsdWVzQnlJZFsxMV0gPSAnU1BBUlNFX1RFTlNPUicpXSA9IDExO1xuICAgICAgdmFsdWVzWyh2YWx1ZXNCeUlkWzEzXSA9ICdUWVBFX1BST1RPJyldID0gMTM7XG4gICAgICB2YWx1ZXNbKHZhbHVlc0J5SWRbNl0gPSAnRkxPQVRTJyldID0gNjtcbiAgICAgIHZhbHVlc1sodmFsdWVzQnlJZFs3XSA9ICdJTlRTJyldID0gNztcbiAgICAgIHZhbHVlc1sodmFsdWVzQnlJZFs4XSA9ICdTVFJJTkdTJyldID0gODtcbiAgICAgIHZhbHVlc1sodmFsdWVzQnlJZFs5XSA9ICdURU5TT1JTJyldID0gOTtcbiAgICAgIHZhbHVlc1sodmFsdWVzQnlJZFsxMF0gPSAnR1JBUEhTJyldID0gMTA7XG4gICAgICB2YWx1ZXNbKHZhbHVlc0J5SWRbMTJdID0gJ1NQQVJTRV9URU5TT1JTJyldID0gMTI7XG4gICAgICB2YWx1ZXNbKHZhbHVlc0J5SWRbMTRdID0gJ1RZUEVfUFJPVE9TJyldID0gMTQ7XG4gICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH0pKCk7XG5cbiAgICByZXR1cm4gQXR0cmlidXRlUHJvdG87XG4gIH0pKCk7XG5cbiAgb25ueC5WYWx1ZUluZm9Qcm90byA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyBvZiBhIFZhbHVlSW5mb1Byb3RvLlxuICAgICAqIEBtZW1iZXJvZiBvbm54XG4gICAgICogQGludGVyZmFjZSBJVmFsdWVJbmZvUHJvdG9cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbbmFtZV0gVmFsdWVJbmZvUHJvdG8gbmFtZVxuICAgICAqIEBwcm9wZXJ0eSB7b25ueC5JVHlwZVByb3RvfG51bGx9IFt0eXBlXSBWYWx1ZUluZm9Qcm90byB0eXBlXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW2RvY1N0cmluZ10gVmFsdWVJbmZvUHJvdG8gZG9jU3RyaW5nXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFZhbHVlSW5mb1Byb3RvLlxuICAgICAqIEBtZW1iZXJvZiBvbm54XG4gICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgVmFsdWVJbmZvUHJvdG8uXG4gICAgICogQGltcGxlbWVudHMgSVZhbHVlSW5mb1Byb3RvXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtvbm54LklWYWx1ZUluZm9Qcm90bz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFZhbHVlSW5mb1Byb3RvKHByb3BlcnRpZXMpIHtcbiAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKSB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBWYWx1ZUluZm9Qcm90byBuYW1lLlxuICAgICAqIEBtZW1iZXIge3N0cmluZ30gbmFtZVxuICAgICAqIEBtZW1iZXJvZiBvbm54LlZhbHVlSW5mb1Byb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgVmFsdWVJbmZvUHJvdG8ucHJvdG90eXBlLm5hbWUgPSAnJztcblxuICAgIC8qKlxuICAgICAqIFZhbHVlSW5mb1Byb3RvIHR5cGUuXG4gICAgICogQG1lbWJlciB7b25ueC5JVHlwZVByb3RvfG51bGx8dW5kZWZpbmVkfSB0eXBlXG4gICAgICogQG1lbWJlcm9mIG9ubnguVmFsdWVJbmZvUHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBWYWx1ZUluZm9Qcm90by5wcm90b3R5cGUudHlwZSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBWYWx1ZUluZm9Qcm90byBkb2NTdHJpbmcuXG4gICAgICogQG1lbWJlciB7c3RyaW5nfSBkb2NTdHJpbmdcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5WYWx1ZUluZm9Qcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIFZhbHVlSW5mb1Byb3RvLnByb3RvdHlwZS5kb2NTdHJpbmcgPSAnJztcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgVmFsdWVJbmZvUHJvdG8gaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAqIEBmdW5jdGlvbiBjcmVhdGVcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5WYWx1ZUluZm9Qcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge29ubnguSVZhbHVlSW5mb1Byb3RvPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICogQHJldHVybnMge29ubnguVmFsdWVJbmZvUHJvdG99IFZhbHVlSW5mb1Byb3RvIGluc3RhbmNlXG4gICAgICovXG4gICAgVmFsdWVJbmZvUHJvdG8uY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgIHJldHVybiBuZXcgVmFsdWVJbmZvUHJvdG8ocHJvcGVydGllcyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBWYWx1ZUluZm9Qcm90byBtZXNzYWdlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LlZhbHVlSW5mb1Byb3RvLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAqIEBmdW5jdGlvbiBlbmNvZGVcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5WYWx1ZUluZm9Qcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge29ubnguSVZhbHVlSW5mb1Byb3RvfSBtZXNzYWdlIFZhbHVlSW5mb1Byb3RvIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgKi9cbiAgICBWYWx1ZUluZm9Qcm90by5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICBpZiAoIXdyaXRlcikgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCAnbmFtZScpKVxuICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovIDEwKS5zdHJpbmcobWVzc2FnZS5uYW1lKTtcbiAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCAndHlwZScpKVxuICAgICAgICAkcm9vdC5vbm54LlR5cGVQcm90by5lbmNvZGUobWVzc2FnZS50eXBlLCB3cml0ZXIudWludDMyKC8qIGlkIDIsIHdpcmVUeXBlIDIgPSovIDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgaWYgKG1lc3NhZ2UuZG9jU3RyaW5nICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgJ2RvY1N0cmluZycpKVxuICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDMsIHdpcmVUeXBlIDIgPSovIDI2KS5zdHJpbmcobWVzc2FnZS5kb2NTdHJpbmcpO1xuICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIFZhbHVlSW5mb1Byb3RvIG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguVmFsdWVJbmZvUHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAqIEBtZW1iZXJvZiBvbm54LlZhbHVlSW5mb1Byb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7b25ueC5JVmFsdWVJbmZvUHJvdG99IG1lc3NhZ2UgVmFsdWVJbmZvUHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAqL1xuICAgIFZhbHVlSW5mb1Byb3RvLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZWNvZGVzIGEgVmFsdWVJbmZvUHJvdG8gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICogQG1lbWJlcm9mIG9ubnguVmFsdWVJbmZvUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgKiBAcmV0dXJucyB7b25ueC5WYWx1ZUluZm9Qcm90b30gVmFsdWVJbmZvUHJvdG9cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAqL1xuICAgIFZhbHVlSW5mb1Byb3RvLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCxcbiAgICAgICAgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LlZhbHVlSW5mb1Byb3RvKCk7XG4gICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgbWVzc2FnZS5uYW1lID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gJHJvb3Qub25ueC5UeXBlUHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDM6IHtcbiAgICAgICAgICAgIG1lc3NhZ2UuZG9jU3RyaW5nID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlY29kZXMgYSBWYWx1ZUluZm9Qcm90byBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLCBsZW5ndGggZGVsaW1pdGVkLlxuICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5WYWx1ZUluZm9Qcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgKiBAcmV0dXJucyB7b25ueC5WYWx1ZUluZm9Qcm90b30gVmFsdWVJbmZvUHJvdG9cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAqL1xuICAgIFZhbHVlSW5mb1Byb3RvLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKSByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgYSBWYWx1ZUluZm9Qcm90byBtZXNzYWdlLlxuICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5WYWx1ZUluZm9Qcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICAgICAqL1xuICAgIFZhbHVlSW5mb1Byb3RvLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09ICdvYmplY3QnIHx8IG1lc3NhZ2UgPT09IG51bGwpIHJldHVybiAnb2JqZWN0IGV4cGVjdGVkJztcbiAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCduYW1lJykpXG4gICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5uYW1lKSkgcmV0dXJuICduYW1lOiBzdHJpbmcgZXhwZWN0ZWQnO1xuICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ3R5cGUnKSkge1xuICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LlR5cGVQcm90by52ZXJpZnkobWVzc2FnZS50eXBlKTtcbiAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gJ3R5cGUuJyArIGVycm9yO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UuZG9jU3RyaW5nICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnZG9jU3RyaW5nJykpXG4gICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5kb2NTdHJpbmcpKSByZXR1cm4gJ2RvY1N0cmluZzogc3RyaW5nIGV4cGVjdGVkJztcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgVmFsdWVJbmZvUHJvdG8gbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICogQG1lbWJlcm9mIG9ubnguVmFsdWVJbmZvUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICAgICAqIEByZXR1cm5zIHtvbm54LlZhbHVlSW5mb1Byb3RvfSBWYWx1ZUluZm9Qcm90b1xuICAgICAqL1xuICAgIFZhbHVlSW5mb1Byb3RvLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290Lm9ubnguVmFsdWVJbmZvUHJvdG8pIHJldHVybiBvYmplY3Q7XG4gICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LlZhbHVlSW5mb1Byb3RvKCk7XG4gICAgICBpZiAob2JqZWN0Lm5hbWUgIT0gbnVsbCkgbWVzc2FnZS5uYW1lID0gU3RyaW5nKG9iamVjdC5uYW1lKTtcbiAgICAgIGlmIChvYmplY3QudHlwZSAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnR5cGUgIT09ICdvYmplY3QnKSB0aHJvdyBUeXBlRXJyb3IoJy5vbm54LlZhbHVlSW5mb1Byb3RvLnR5cGU6IG9iamVjdCBleHBlY3RlZCcpO1xuICAgICAgICBtZXNzYWdlLnR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by5mcm9tT2JqZWN0KG9iamVjdC50eXBlKTtcbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3QuZG9jU3RyaW5nICE9IG51bGwpIG1lc3NhZ2UuZG9jU3RyaW5nID0gU3RyaW5nKG9iamVjdC5kb2NTdHJpbmcpO1xuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhIFZhbHVlSW5mb1Byb3RvIG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5WYWx1ZUluZm9Qcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge29ubnguVmFsdWVJbmZvUHJvdG99IG1lc3NhZ2UgVmFsdWVJbmZvUHJvdG9cbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICAgICAqL1xuICAgIFZhbHVlSW5mb1Byb3RvLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICBvYmplY3QubmFtZSA9ICcnO1xuICAgICAgICBvYmplY3QudHlwZSA9IG51bGw7XG4gICAgICAgIG9iamVjdC5kb2NTdHJpbmcgPSAnJztcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCduYW1lJykpIG9iamVjdC5uYW1lID0gbWVzc2FnZS5uYW1lO1xuICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ3R5cGUnKSlcbiAgICAgICAgb2JqZWN0LnR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by50b09iamVjdChtZXNzYWdlLnR5cGUsIG9wdGlvbnMpO1xuICAgICAgaWYgKG1lc3NhZ2UuZG9jU3RyaW5nICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnZG9jU3RyaW5nJykpIG9iamVjdC5kb2NTdHJpbmcgPSBtZXNzYWdlLmRvY1N0cmluZztcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoaXMgVmFsdWVJbmZvUHJvdG8gdG8gSlNPTi5cbiAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICogQG1lbWJlcm9mIG9ubnguVmFsdWVJbmZvUHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IEpTT04gb2JqZWN0XG4gICAgICovXG4gICAgVmFsdWVJbmZvUHJvdG8ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBkZWZhdWx0IHR5cGUgdXJsIGZvciBWYWx1ZUluZm9Qcm90b1xuICAgICAqIEBmdW5jdGlvbiBnZXRUeXBlVXJsXG4gICAgICogQG1lbWJlcm9mIG9ubnguVmFsdWVJbmZvUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlVXJsUHJlZml4XSB5b3VyIGN1c3RvbSB0eXBlVXJsUHJlZml4KGRlZmF1bHQgXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCIpXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGRlZmF1bHQgdHlwZSB1cmxcbiAgICAgKi9cbiAgICBWYWx1ZUluZm9Qcm90by5nZXRUeXBlVXJsID0gZnVuY3Rpb24gZ2V0VHlwZVVybCh0eXBlVXJsUHJlZml4KSB7XG4gICAgICBpZiAodHlwZVVybFByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHR5cGVVcmxQcmVmaXggPSAndHlwZS5nb29nbGVhcGlzLmNvbSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZVVybFByZWZpeCArICcvb25ueC5WYWx1ZUluZm9Qcm90byc7XG4gICAgfTtcblxuICAgIHJldHVybiBWYWx1ZUluZm9Qcm90bztcbiAgfSkoKTtcblxuICBvbm54Lk5vZGVQcm90byA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyBvZiBhIE5vZGVQcm90by5cbiAgICAgKiBAbWVtYmVyb2Ygb25ueFxuICAgICAqIEBpbnRlcmZhY2UgSU5vZGVQcm90b1xuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPHN0cmluZz58bnVsbH0gW2lucHV0XSBOb2RlUHJvdG8gaW5wdXRcbiAgICAgKiBAcHJvcGVydHkge0FycmF5LjxzdHJpbmc+fG51bGx9IFtvdXRwdXRdIE5vZGVQcm90byBvdXRwdXRcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbbmFtZV0gTm9kZVByb3RvIG5hbWVcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbb3BUeXBlXSBOb2RlUHJvdG8gb3BUeXBlXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW2RvbWFpbl0gTm9kZVByb3RvIGRvbWFpblxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG9ubnguSUF0dHJpYnV0ZVByb3RvPnxudWxsfSBbYXR0cmlidXRlXSBOb2RlUHJvdG8gYXR0cmlidXRlXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW2RvY1N0cmluZ10gTm9kZVByb3RvIGRvY1N0cmluZ1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBOb2RlUHJvdG8uXG4gICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBOb2RlUHJvdG8uXG4gICAgICogQGltcGxlbWVudHMgSU5vZGVQcm90b1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7b25ueC5JTm9kZVByb3RvPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICovXG4gICAgZnVuY3Rpb24gTm9kZVByb3RvKHByb3BlcnRpZXMpIHtcbiAgICAgIHRoaXMuaW5wdXQgPSBbXTtcbiAgICAgIHRoaXMub3V0cHV0ID0gW107XG4gICAgICB0aGlzLmF0dHJpYnV0ZSA9IFtdO1xuICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5vZGVQcm90byBpbnB1dC5cbiAgICAgKiBAbWVtYmVyIHtBcnJheS48c3RyaW5nPn0gaW5wdXRcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5Ob2RlUHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBOb2RlUHJvdG8ucHJvdG90eXBlLmlucHV0ID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgIC8qKlxuICAgICAqIE5vZGVQcm90byBvdXRwdXQuXG4gICAgICogQG1lbWJlciB7QXJyYXkuPHN0cmluZz59IG91dHB1dFxuICAgICAqIEBtZW1iZXJvZiBvbm54Lk5vZGVQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIE5vZGVQcm90by5wcm90b3R5cGUub3V0cHV0ID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgIC8qKlxuICAgICAqIE5vZGVQcm90byBuYW1lLlxuICAgICAqIEBtZW1iZXIge3N0cmluZ30gbmFtZVxuICAgICAqIEBtZW1iZXJvZiBvbm54Lk5vZGVQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIE5vZGVQcm90by5wcm90b3R5cGUubmFtZSA9ICcnO1xuXG4gICAgLyoqXG4gICAgICogTm9kZVByb3RvIG9wVHlwZS5cbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IG9wVHlwZVxuICAgICAqIEBtZW1iZXJvZiBvbm54Lk5vZGVQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIE5vZGVQcm90by5wcm90b3R5cGUub3BUeXBlID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBOb2RlUHJvdG8gZG9tYWluLlxuICAgICAqIEBtZW1iZXIge3N0cmluZ30gZG9tYWluXG4gICAgICogQG1lbWJlcm9mIG9ubnguTm9kZVByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgTm9kZVByb3RvLnByb3RvdHlwZS5kb21haW4gPSAnJztcblxuICAgIC8qKlxuICAgICAqIE5vZGVQcm90byBhdHRyaWJ1dGUuXG4gICAgICogQG1lbWJlciB7QXJyYXkuPG9ubnguSUF0dHJpYnV0ZVByb3RvPn0gYXR0cmlidXRlXG4gICAgICogQG1lbWJlcm9mIG9ubnguTm9kZVByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgTm9kZVByb3RvLnByb3RvdHlwZS5hdHRyaWJ1dGUgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgLyoqXG4gICAgICogTm9kZVByb3RvIGRvY1N0cmluZy5cbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IGRvY1N0cmluZ1xuICAgICAqIEBtZW1iZXJvZiBvbm54Lk5vZGVQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIE5vZGVQcm90by5wcm90b3R5cGUuZG9jU3RyaW5nID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IE5vZGVQcm90byBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxuICAgICAqIEBtZW1iZXJvZiBvbm54Lk5vZGVQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge29ubnguSU5vZGVQcm90bz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAqIEByZXR1cm5zIHtvbm54Lk5vZGVQcm90b30gTm9kZVByb3RvIGluc3RhbmNlXG4gICAgICovXG4gICAgTm9kZVByb3RvLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICByZXR1cm4gbmV3IE5vZGVQcm90byhwcm9wZXJ0aWVzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIE5vZGVQcm90byBtZXNzYWdlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54Lk5vZGVQcm90by52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXG4gICAgICogQG1lbWJlcm9mIG9ubnguTm9kZVByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7b25ueC5JTm9kZVByb3RvfSBtZXNzYWdlIE5vZGVQcm90byBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICovXG4gICAgTm9kZVByb3RvLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgIGlmICghd3JpdGVyKSB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgaWYgKG1lc3NhZ2UuaW5wdXQgIT0gbnVsbCAmJiBtZXNzYWdlLmlucHV0Lmxlbmd0aClcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmlucHV0Lmxlbmd0aDsgKytpKVxuICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki8gMTApLnN0cmluZyhtZXNzYWdlLmlucHV0W2ldKTtcbiAgICAgIGlmIChtZXNzYWdlLm91dHB1dCAhPSBudWxsICYmIG1lc3NhZ2Uub3V0cHV0Lmxlbmd0aClcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLm91dHB1dC5sZW5ndGg7ICsraSlcbiAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDIsIHdpcmVUeXBlIDIgPSovIDE4KS5zdHJpbmcobWVzc2FnZS5vdXRwdXRbaV0pO1xuICAgICAgaWYgKG1lc3NhZ2UubmFtZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsICduYW1lJykpXG4gICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMywgd2lyZVR5cGUgMiA9Ki8gMjYpLnN0cmluZyhtZXNzYWdlLm5hbWUpO1xuICAgICAgaWYgKG1lc3NhZ2Uub3BUeXBlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgJ29wVHlwZScpKVxuICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDQsIHdpcmVUeXBlIDIgPSovIDM0KS5zdHJpbmcobWVzc2FnZS5vcFR5cGUpO1xuICAgICAgaWYgKG1lc3NhZ2UuYXR0cmlidXRlICE9IG51bGwgJiYgbWVzc2FnZS5hdHRyaWJ1dGUubGVuZ3RoKVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuYXR0cmlidXRlLmxlbmd0aDsgKytpKVxuICAgICAgICAgICRyb290Lm9ubnguQXR0cmlidXRlUHJvdG8uZW5jb2RlKFxuICAgICAgICAgICAgbWVzc2FnZS5hdHRyaWJ1dGVbaV0sXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDUsIHdpcmVUeXBlIDIgPSovIDQyKS5mb3JrKCksXG4gICAgICAgICAgKS5sZGVsaW0oKTtcbiAgICAgIGlmIChtZXNzYWdlLmRvY1N0cmluZyAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsICdkb2NTdHJpbmcnKSlcbiAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA2LCB3aXJlVHlwZSAyID0qLyA1MCkuc3RyaW5nKG1lc3NhZ2UuZG9jU3RyaW5nKTtcbiAgICAgIGlmIChtZXNzYWdlLmRvbWFpbiAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsICdkb21haW4nKSlcbiAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA3LCB3aXJlVHlwZSAyID0qLyA1OCkuc3RyaW5nKG1lc3NhZ2UuZG9tYWluKTtcbiAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBOb2RlUHJvdG8gbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5Ob2RlUHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAqIEBtZW1iZXJvZiBvbm54Lk5vZGVQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge29ubnguSU5vZGVQcm90b30gbWVzc2FnZSBOb2RlUHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAqL1xuICAgIE5vZGVQcm90by5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhIE5vZGVQcm90byBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5Ob2RlUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgKiBAcmV0dXJucyB7b25ueC5Ob2RlUHJvdG99IE5vZGVQcm90b1xuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICovXG4gICAgTm9kZVByb3RvLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCxcbiAgICAgICAgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54Lk5vZGVQcm90bygpO1xuICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgIGlmICghKG1lc3NhZ2UuaW5wdXQgJiYgbWVzc2FnZS5pbnB1dC5sZW5ndGgpKSBtZXNzYWdlLmlucHV0ID0gW107XG4gICAgICAgICAgICBtZXNzYWdlLmlucHV0LnB1c2gocmVhZGVyLnN0cmluZygpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgIGlmICghKG1lc3NhZ2Uub3V0cHV0ICYmIG1lc3NhZ2Uub3V0cHV0Lmxlbmd0aCkpIG1lc3NhZ2Uub3V0cHV0ID0gW107XG4gICAgICAgICAgICBtZXNzYWdlLm91dHB1dC5wdXNoKHJlYWRlci5zdHJpbmcoKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAzOiB7XG4gICAgICAgICAgICBtZXNzYWdlLm5hbWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSA0OiB7XG4gICAgICAgICAgICBtZXNzYWdlLm9wVHlwZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDc6IHtcbiAgICAgICAgICAgIG1lc3NhZ2UuZG9tYWluID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgNToge1xuICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5hdHRyaWJ1dGUgJiYgbWVzc2FnZS5hdHRyaWJ1dGUubGVuZ3RoKSkgbWVzc2FnZS5hdHRyaWJ1dGUgPSBbXTtcbiAgICAgICAgICAgIG1lc3NhZ2UuYXR0cmlidXRlLnB1c2goJHJvb3Qub25ueC5BdHRyaWJ1dGVQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDY6IHtcbiAgICAgICAgICAgIG1lc3NhZ2UuZG9jU3RyaW5nID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlY29kZXMgYSBOb2RlUHJvdG8gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlciwgbGVuZ3RoIGRlbGltaXRlZC5cbiAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXG4gICAgICogQG1lbWJlcm9mIG9ubnguTm9kZVByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAqIEByZXR1cm5zIHtvbm54Lk5vZGVQcm90b30gTm9kZVByb3RvXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgKi9cbiAgICBOb2RlUHJvdG8uZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyBhIE5vZGVQcm90byBtZXNzYWdlLlxuICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5Ob2RlUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XG4gICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAgICAgKi9cbiAgICBOb2RlUHJvdG8udmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gJ29iamVjdCcgfHwgbWVzc2FnZSA9PT0gbnVsbCkgcmV0dXJuICdvYmplY3QgZXhwZWN0ZWQnO1xuICAgICAgaWYgKG1lc3NhZ2UuaW5wdXQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdpbnB1dCcpKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLmlucHV0KSkgcmV0dXJuICdpbnB1dDogYXJyYXkgZXhwZWN0ZWQnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuaW5wdXQubGVuZ3RoOyArK2kpXG4gICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLmlucHV0W2ldKSkgcmV0dXJuICdpbnB1dDogc3RyaW5nW10gZXhwZWN0ZWQnO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2Uub3V0cHV0ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnb3V0cHV0JykpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2Uub3V0cHV0KSkgcmV0dXJuICdvdXRwdXQ6IGFycmF5IGV4cGVjdGVkJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLm91dHB1dC5sZW5ndGg7ICsraSlcbiAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2Uub3V0cHV0W2ldKSkgcmV0dXJuICdvdXRwdXQ6IHN0cmluZ1tdIGV4cGVjdGVkJztcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCduYW1lJykpXG4gICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5uYW1lKSkgcmV0dXJuICduYW1lOiBzdHJpbmcgZXhwZWN0ZWQnO1xuICAgICAgaWYgKG1lc3NhZ2Uub3BUeXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnb3BUeXBlJykpXG4gICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5vcFR5cGUpKSByZXR1cm4gJ29wVHlwZTogc3RyaW5nIGV4cGVjdGVkJztcbiAgICAgIGlmIChtZXNzYWdlLmRvbWFpbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ2RvbWFpbicpKVxuICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UuZG9tYWluKSkgcmV0dXJuICdkb21haW46IHN0cmluZyBleHBlY3RlZCc7XG4gICAgICBpZiAobWVzc2FnZS5hdHRyaWJ1dGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdhdHRyaWJ1dGUnKSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5hdHRyaWJ1dGUpKSByZXR1cm4gJ2F0dHJpYnV0ZTogYXJyYXkgZXhwZWN0ZWQnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuYXR0cmlidXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5BdHRyaWJ1dGVQcm90by52ZXJpZnkobWVzc2FnZS5hdHRyaWJ1dGVbaV0pO1xuICAgICAgICAgIGlmIChlcnJvcikgcmV0dXJuICdhdHRyaWJ1dGUuJyArIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5kb2NTdHJpbmcgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdkb2NTdHJpbmcnKSlcbiAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLmRvY1N0cmluZykpIHJldHVybiAnZG9jU3RyaW5nOiBzdHJpbmcgZXhwZWN0ZWQnO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBOb2RlUHJvdG8gbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICogQG1lbWJlcm9mIG9ubnguTm9kZVByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7b25ueC5Ob2RlUHJvdG99IE5vZGVQcm90b1xuICAgICAqL1xuICAgIE5vZGVQcm90by5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5vbm54Lk5vZGVQcm90bykgcmV0dXJuIG9iamVjdDtcbiAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguTm9kZVByb3RvKCk7XG4gICAgICBpZiAob2JqZWN0LmlucHV0KSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QuaW5wdXQpKSB0aHJvdyBUeXBlRXJyb3IoJy5vbm54Lk5vZGVQcm90by5pbnB1dDogYXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgbWVzc2FnZS5pbnB1dCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5pbnB1dC5sZW5ndGg7ICsraSkgbWVzc2FnZS5pbnB1dFtpXSA9IFN0cmluZyhvYmplY3QuaW5wdXRbaV0pO1xuICAgICAgfVxuICAgICAgaWYgKG9iamVjdC5vdXRwdXQpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5vdXRwdXQpKSB0aHJvdyBUeXBlRXJyb3IoJy5vbm54Lk5vZGVQcm90by5vdXRwdXQ6IGFycmF5IGV4cGVjdGVkJyk7XG4gICAgICAgIG1lc3NhZ2Uub3V0cHV0ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0Lm91dHB1dC5sZW5ndGg7ICsraSkgbWVzc2FnZS5vdXRwdXRbaV0gPSBTdHJpbmcob2JqZWN0Lm91dHB1dFtpXSk7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0Lm5hbWUgIT0gbnVsbCkgbWVzc2FnZS5uYW1lID0gU3RyaW5nKG9iamVjdC5uYW1lKTtcbiAgICAgIGlmIChvYmplY3Qub3BUeXBlICE9IG51bGwpIG1lc3NhZ2Uub3BUeXBlID0gU3RyaW5nKG9iamVjdC5vcFR5cGUpO1xuICAgICAgaWYgKG9iamVjdC5kb21haW4gIT0gbnVsbCkgbWVzc2FnZS5kb21haW4gPSBTdHJpbmcob2JqZWN0LmRvbWFpbik7XG4gICAgICBpZiAob2JqZWN0LmF0dHJpYnV0ZSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LmF0dHJpYnV0ZSkpIHRocm93IFR5cGVFcnJvcignLm9ubnguTm9kZVByb3RvLmF0dHJpYnV0ZTogYXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgbWVzc2FnZS5hdHRyaWJ1dGUgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QuYXR0cmlidXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QuYXR0cmlidXRlW2ldICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCcub25ueC5Ob2RlUHJvdG8uYXR0cmlidXRlOiBvYmplY3QgZXhwZWN0ZWQnKTtcbiAgICAgICAgICBtZXNzYWdlLmF0dHJpYnV0ZVtpXSA9ICRyb290Lm9ubnguQXR0cmlidXRlUHJvdG8uZnJvbU9iamVjdChvYmplY3QuYXR0cmlidXRlW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9iamVjdC5kb2NTdHJpbmcgIT0gbnVsbCkgbWVzc2FnZS5kb2NTdHJpbmcgPSBTdHJpbmcob2JqZWN0LmRvY1N0cmluZyk7XG4gICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgTm9kZVByb3RvIG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5Ob2RlUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtvbm54Lk5vZGVQcm90b30gbWVzc2FnZSBOb2RlUHJvdG9cbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICAgICAqL1xuICAgIE5vZGVQcm90by50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgaWYgKG9wdGlvbnMuYXJyYXlzIHx8IG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgb2JqZWN0LmlucHV0ID0gW107XG4gICAgICAgIG9iamVjdC5vdXRwdXQgPSBbXTtcbiAgICAgICAgb2JqZWN0LmF0dHJpYnV0ZSA9IFtdO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgb2JqZWN0Lm5hbWUgPSAnJztcbiAgICAgICAgb2JqZWN0Lm9wVHlwZSA9ICcnO1xuICAgICAgICBvYmplY3QuZG9jU3RyaW5nID0gJyc7XG4gICAgICAgIG9iamVjdC5kb21haW4gPSAnJztcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLmlucHV0ICYmIG1lc3NhZ2UuaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgIG9iamVjdC5pbnB1dCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UuaW5wdXQubGVuZ3RoOyArK2opIG9iamVjdC5pbnB1dFtqXSA9IG1lc3NhZ2UuaW5wdXRbal07XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5vdXRwdXQgJiYgbWVzc2FnZS5vdXRwdXQubGVuZ3RoKSB7XG4gICAgICAgIG9iamVjdC5vdXRwdXQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLm91dHB1dC5sZW5ndGg7ICsraikgb2JqZWN0Lm91dHB1dFtqXSA9IG1lc3NhZ2Uub3V0cHV0W2pdO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UubmFtZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ25hbWUnKSkgb2JqZWN0Lm5hbWUgPSBtZXNzYWdlLm5hbWU7XG4gICAgICBpZiAobWVzc2FnZS5vcFR5cGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdvcFR5cGUnKSkgb2JqZWN0Lm9wVHlwZSA9IG1lc3NhZ2Uub3BUeXBlO1xuICAgICAgaWYgKG1lc3NhZ2UuYXR0cmlidXRlICYmIG1lc3NhZ2UuYXR0cmlidXRlLmxlbmd0aCkge1xuICAgICAgICBvYmplY3QuYXR0cmlidXRlID0gW107XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5hdHRyaWJ1dGUubGVuZ3RoOyArK2opXG4gICAgICAgICAgb2JqZWN0LmF0dHJpYnV0ZVtqXSA9ICRyb290Lm9ubnguQXR0cmlidXRlUHJvdG8udG9PYmplY3QobWVzc2FnZS5hdHRyaWJ1dGVbal0sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UuZG9jU3RyaW5nICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnZG9jU3RyaW5nJykpIG9iamVjdC5kb2NTdHJpbmcgPSBtZXNzYWdlLmRvY1N0cmluZztcbiAgICAgIGlmIChtZXNzYWdlLmRvbWFpbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ2RvbWFpbicpKSBvYmplY3QuZG9tYWluID0gbWVzc2FnZS5kb21haW47XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGlzIE5vZGVQcm90byB0byBKU09OLlxuICAgICAqIEBmdW5jdGlvbiB0b0pTT05cbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5Ob2RlUHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IEpTT04gb2JqZWN0XG4gICAgICovXG4gICAgTm9kZVByb3RvLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZGVmYXVsdCB0eXBlIHVybCBmb3IgTm9kZVByb3RvXG4gICAgICogQGZ1bmN0aW9uIGdldFR5cGVVcmxcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5Ob2RlUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlVXJsUHJlZml4XSB5b3VyIGN1c3RvbSB0eXBlVXJsUHJlZml4KGRlZmF1bHQgXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCIpXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGRlZmF1bHQgdHlwZSB1cmxcbiAgICAgKi9cbiAgICBOb2RlUHJvdG8uZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0eXBlVXJsUHJlZml4ID0gJ3R5cGUuZ29vZ2xlYXBpcy5jb20nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyAnL29ubnguTm9kZVByb3RvJztcbiAgICB9O1xuXG4gICAgcmV0dXJuIE5vZGVQcm90bztcbiAgfSkoKTtcblxuICBvbm54LlRyYWluaW5nSW5mb1Byb3RvID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgVHJhaW5pbmdJbmZvUHJvdG8uXG4gICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgKiBAaW50ZXJmYWNlIElUcmFpbmluZ0luZm9Qcm90b1xuICAgICAqIEBwcm9wZXJ0eSB7b25ueC5JR3JhcGhQcm90b3xudWxsfSBbaW5pdGlhbGl6YXRpb25dIFRyYWluaW5nSW5mb1Byb3RvIGluaXRpYWxpemF0aW9uXG4gICAgICogQHByb3BlcnR5IHtvbm54LklHcmFwaFByb3RvfG51bGx9IFthbGdvcml0aG1dIFRyYWluaW5nSW5mb1Byb3RvIGFsZ29yaXRobVxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG9ubnguSVN0cmluZ1N0cmluZ0VudHJ5UHJvdG8+fG51bGx9IFtpbml0aWFsaXphdGlvbkJpbmRpbmddIFRyYWluaW5nSW5mb1Byb3RvIGluaXRpYWxpemF0aW9uQmluZGluZ1xuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG9ubnguSVN0cmluZ1N0cmluZ0VudHJ5UHJvdG8+fG51bGx9IFt1cGRhdGVCaW5kaW5nXSBUcmFpbmluZ0luZm9Qcm90byB1cGRhdGVCaW5kaW5nXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFRyYWluaW5nSW5mb1Byb3RvLlxuICAgICAqIEBtZW1iZXJvZiBvbm54XG4gICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgVHJhaW5pbmdJbmZvUHJvdG8uXG4gICAgICogQGltcGxlbWVudHMgSVRyYWluaW5nSW5mb1Byb3RvXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtvbm54LklUcmFpbmluZ0luZm9Qcm90bz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRyYWluaW5nSW5mb1Byb3RvKHByb3BlcnRpZXMpIHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6YXRpb25CaW5kaW5nID0gW107XG4gICAgICB0aGlzLnVwZGF0ZUJpbmRpbmcgPSBbXTtcbiAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKSB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmFpbmluZ0luZm9Qcm90byBpbml0aWFsaXphdGlvbi5cbiAgICAgKiBAbWVtYmVyIHtvbm54LklHcmFwaFByb3RvfG51bGx8dW5kZWZpbmVkfSBpbml0aWFsaXphdGlvblxuICAgICAqIEBtZW1iZXJvZiBvbm54LlRyYWluaW5nSW5mb1Byb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgVHJhaW5pbmdJbmZvUHJvdG8ucHJvdG90eXBlLmluaXRpYWxpemF0aW9uID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRyYWluaW5nSW5mb1Byb3RvIGFsZ29yaXRobS5cbiAgICAgKiBAbWVtYmVyIHtvbm54LklHcmFwaFByb3RvfG51bGx8dW5kZWZpbmVkfSBhbGdvcml0aG1cbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5UcmFpbmluZ0luZm9Qcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIFRyYWluaW5nSW5mb1Byb3RvLnByb3RvdHlwZS5hbGdvcml0aG0gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVHJhaW5pbmdJbmZvUHJvdG8gaW5pdGlhbGl6YXRpb25CaW5kaW5nLlxuICAgICAqIEBtZW1iZXIge0FycmF5Ljxvbm54LklTdHJpbmdTdHJpbmdFbnRyeVByb3RvPn0gaW5pdGlhbGl6YXRpb25CaW5kaW5nXG4gICAgICogQG1lbWJlcm9mIG9ubnguVHJhaW5pbmdJbmZvUHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBUcmFpbmluZ0luZm9Qcm90by5wcm90b3R5cGUuaW5pdGlhbGl6YXRpb25CaW5kaW5nID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgIC8qKlxuICAgICAqIFRyYWluaW5nSW5mb1Byb3RvIHVwZGF0ZUJpbmRpbmcuXG4gICAgICogQG1lbWJlciB7QXJyYXkuPG9ubnguSVN0cmluZ1N0cmluZ0VudHJ5UHJvdG8+fSB1cGRhdGVCaW5kaW5nXG4gICAgICogQG1lbWJlcm9mIG9ubnguVHJhaW5pbmdJbmZvUHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBUcmFpbmluZ0luZm9Qcm90by5wcm90b3R5cGUudXBkYXRlQmluZGluZyA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFRyYWluaW5nSW5mb1Byb3RvIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXG4gICAgICogQG1lbWJlcm9mIG9ubnguVHJhaW5pbmdJbmZvUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtvbm54LklUcmFpbmluZ0luZm9Qcm90bz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAqIEByZXR1cm5zIHtvbm54LlRyYWluaW5nSW5mb1Byb3RvfSBUcmFpbmluZ0luZm9Qcm90byBpbnN0YW5jZVxuICAgICAqL1xuICAgIFRyYWluaW5nSW5mb1Byb3RvLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICByZXR1cm4gbmV3IFRyYWluaW5nSW5mb1Byb3RvKHByb3BlcnRpZXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgVHJhaW5pbmdJbmZvUHJvdG8gbWVzc2FnZS4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5UcmFpbmluZ0luZm9Qcm90by52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXG4gICAgICogQG1lbWJlcm9mIG9ubnguVHJhaW5pbmdJbmZvUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtvbm54LklUcmFpbmluZ0luZm9Qcm90b30gbWVzc2FnZSBUcmFpbmluZ0luZm9Qcm90byBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICovXG4gICAgVHJhaW5pbmdJbmZvUHJvdG8uZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgaWYgKCF3cml0ZXIpIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICBpZiAobWVzc2FnZS5pbml0aWFsaXphdGlvbiAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsICdpbml0aWFsaXphdGlvbicpKVxuICAgICAgICAkcm9vdC5vbm54LkdyYXBoUHJvdG8uZW5jb2RlKG1lc3NhZ2UuaW5pdGlhbGl6YXRpb24sIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki8gMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICBpZiAobWVzc2FnZS5hbGdvcml0aG0gIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCAnYWxnb3JpdGhtJykpXG4gICAgICAgICRyb290Lm9ubnguR3JhcGhQcm90by5lbmNvZGUobWVzc2FnZS5hbGdvcml0aG0sIHdyaXRlci51aW50MzIoLyogaWQgMiwgd2lyZVR5cGUgMiA9Ki8gMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICBpZiAobWVzc2FnZS5pbml0aWFsaXphdGlvbkJpbmRpbmcgIT0gbnVsbCAmJiBtZXNzYWdlLmluaXRpYWxpemF0aW9uQmluZGluZy5sZW5ndGgpXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5pbml0aWFsaXphdGlvbkJpbmRpbmcubGVuZ3RoOyArK2kpXG4gICAgICAgICAgJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLmVuY29kZShcbiAgICAgICAgICAgIG1lc3NhZ2UuaW5pdGlhbGl6YXRpb25CaW5kaW5nW2ldLFxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAzLCB3aXJlVHlwZSAyID0qLyAyNikuZm9yaygpLFxuICAgICAgICAgICkubGRlbGltKCk7XG4gICAgICBpZiAobWVzc2FnZS51cGRhdGVCaW5kaW5nICE9IG51bGwgJiYgbWVzc2FnZS51cGRhdGVCaW5kaW5nLmxlbmd0aClcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnVwZGF0ZUJpbmRpbmcubGVuZ3RoOyArK2kpXG4gICAgICAgICAgJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLmVuY29kZShcbiAgICAgICAgICAgIG1lc3NhZ2UudXBkYXRlQmluZGluZ1tpXSxcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgNCwgd2lyZVR5cGUgMiA9Ki8gMzQpLmZvcmsoKSxcbiAgICAgICAgICApLmxkZWxpbSgpO1xuICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIFRyYWluaW5nSW5mb1Byb3RvIG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguVHJhaW5pbmdJbmZvUHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAqIEBtZW1iZXJvZiBvbm54LlRyYWluaW5nSW5mb1Byb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7b25ueC5JVHJhaW5pbmdJbmZvUHJvdG99IG1lc3NhZ2UgVHJhaW5pbmdJbmZvUHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAqL1xuICAgIFRyYWluaW5nSW5mb1Byb3RvLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZWNvZGVzIGEgVHJhaW5pbmdJbmZvUHJvdG8gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICogQG1lbWJlcm9mIG9ubnguVHJhaW5pbmdJbmZvUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgKiBAcmV0dXJucyB7b25ueC5UcmFpbmluZ0luZm9Qcm90b30gVHJhaW5pbmdJbmZvUHJvdG9cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAqL1xuICAgIFRyYWluaW5nSW5mb1Byb3RvLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCxcbiAgICAgICAgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LlRyYWluaW5nSW5mb1Byb3RvKCk7XG4gICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgbWVzc2FnZS5pbml0aWFsaXphdGlvbiA9ICRyb290Lm9ubnguR3JhcGhQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgICAgbWVzc2FnZS5hbGdvcml0aG0gPSAkcm9vdC5vbm54LkdyYXBoUHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDM6IHtcbiAgICAgICAgICAgIGlmICghKG1lc3NhZ2UuaW5pdGlhbGl6YXRpb25CaW5kaW5nICYmIG1lc3NhZ2UuaW5pdGlhbGl6YXRpb25CaW5kaW5nLmxlbmd0aCkpXG4gICAgICAgICAgICAgIG1lc3NhZ2UuaW5pdGlhbGl6YXRpb25CaW5kaW5nID0gW107XG4gICAgICAgICAgICBtZXNzYWdlLmluaXRpYWxpemF0aW9uQmluZGluZy5wdXNoKCRyb290Lm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDQ6IHtcbiAgICAgICAgICAgIGlmICghKG1lc3NhZ2UudXBkYXRlQmluZGluZyAmJiBtZXNzYWdlLnVwZGF0ZUJpbmRpbmcubGVuZ3RoKSkgbWVzc2FnZS51cGRhdGVCaW5kaW5nID0gW107XG4gICAgICAgICAgICBtZXNzYWdlLnVwZGF0ZUJpbmRpbmcucHVzaCgkcm9vdC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhIFRyYWluaW5nSW5mb1Byb3RvIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICogQGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZFxuICAgICAqIEBtZW1iZXJvZiBvbm54LlRyYWluaW5nSW5mb1Byb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAqIEByZXR1cm5zIHtvbm54LlRyYWluaW5nSW5mb1Byb3RvfSBUcmFpbmluZ0luZm9Qcm90b1xuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICovXG4gICAgVHJhaW5pbmdJbmZvUHJvdG8uZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyBhIFRyYWluaW5nSW5mb1Byb3RvIG1lc3NhZ2UuXG4gICAgICogQGZ1bmN0aW9uIHZlcmlmeVxuICAgICAqIEBtZW1iZXJvZiBvbm54LlRyYWluaW5nSW5mb1Byb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XG4gICAgICovXG4gICAgVHJhaW5pbmdJbmZvUHJvdG8udmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gJ29iamVjdCcgfHwgbWVzc2FnZSA9PT0gbnVsbCkgcmV0dXJuICdvYmplY3QgZXhwZWN0ZWQnO1xuICAgICAgaWYgKG1lc3NhZ2UuaW5pdGlhbGl6YXRpb24gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdpbml0aWFsaXphdGlvbicpKSB7XG4gICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguR3JhcGhQcm90by52ZXJpZnkobWVzc2FnZS5pbml0aWFsaXphdGlvbik7XG4gICAgICAgIGlmIChlcnJvcikgcmV0dXJuICdpbml0aWFsaXphdGlvbi4nICsgZXJyb3I7XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5hbGdvcml0aG0gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdhbGdvcml0aG0nKSkge1xuICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LkdyYXBoUHJvdG8udmVyaWZ5KG1lc3NhZ2UuYWxnb3JpdGhtKTtcbiAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gJ2FsZ29yaXRobS4nICsgZXJyb3I7XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5pbml0aWFsaXphdGlvbkJpbmRpbmcgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdpbml0aWFsaXphdGlvbkJpbmRpbmcnKSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5pbml0aWFsaXphdGlvbkJpbmRpbmcpKSByZXR1cm4gJ2luaXRpYWxpemF0aW9uQmluZGluZzogYXJyYXkgZXhwZWN0ZWQnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuaW5pdGlhbGl6YXRpb25CaW5kaW5nLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLnZlcmlmeShtZXNzYWdlLmluaXRpYWxpemF0aW9uQmluZGluZ1tpXSk7XG4gICAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gJ2luaXRpYWxpemF0aW9uQmluZGluZy4nICsgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLnVwZGF0ZUJpbmRpbmcgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCd1cGRhdGVCaW5kaW5nJykpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UudXBkYXRlQmluZGluZykpIHJldHVybiAndXBkYXRlQmluZGluZzogYXJyYXkgZXhwZWN0ZWQnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UudXBkYXRlQmluZGluZy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by52ZXJpZnkobWVzc2FnZS51cGRhdGVCaW5kaW5nW2ldKTtcbiAgICAgICAgICBpZiAoZXJyb3IpIHJldHVybiAndXBkYXRlQmluZGluZy4nICsgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgVHJhaW5pbmdJbmZvUHJvdG8gbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICogQG1lbWJlcm9mIG9ubnguVHJhaW5pbmdJbmZvUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICAgICAqIEByZXR1cm5zIHtvbm54LlRyYWluaW5nSW5mb1Byb3RvfSBUcmFpbmluZ0luZm9Qcm90b1xuICAgICAqL1xuICAgIFRyYWluaW5nSW5mb1Byb3RvLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290Lm9ubnguVHJhaW5pbmdJbmZvUHJvdG8pIHJldHVybiBvYmplY3Q7XG4gICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LlRyYWluaW5nSW5mb1Byb3RvKCk7XG4gICAgICBpZiAob2JqZWN0LmluaXRpYWxpemF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QuaW5pdGlhbGl6YXRpb24gIT09ICdvYmplY3QnKVxuICAgICAgICAgIHRocm93IFR5cGVFcnJvcignLm9ubnguVHJhaW5pbmdJbmZvUHJvdG8uaW5pdGlhbGl6YXRpb246IG9iamVjdCBleHBlY3RlZCcpO1xuICAgICAgICBtZXNzYWdlLmluaXRpYWxpemF0aW9uID0gJHJvb3Qub25ueC5HcmFwaFByb3RvLmZyb21PYmplY3Qob2JqZWN0LmluaXRpYWxpemF0aW9uKTtcbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3QuYWxnb3JpdGhtICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QuYWxnb3JpdGhtICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCcub25ueC5UcmFpbmluZ0luZm9Qcm90by5hbGdvcml0aG06IG9iamVjdCBleHBlY3RlZCcpO1xuICAgICAgICBtZXNzYWdlLmFsZ29yaXRobSA9ICRyb290Lm9ubnguR3JhcGhQcm90by5mcm9tT2JqZWN0KG9iamVjdC5hbGdvcml0aG0pO1xuICAgICAgfVxuICAgICAgaWYgKG9iamVjdC5pbml0aWFsaXphdGlvbkJpbmRpbmcpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5pbml0aWFsaXphdGlvbkJpbmRpbmcpKVxuICAgICAgICAgIHRocm93IFR5cGVFcnJvcignLm9ubnguVHJhaW5pbmdJbmZvUHJvdG8uaW5pdGlhbGl6YXRpb25CaW5kaW5nOiBhcnJheSBleHBlY3RlZCcpO1xuICAgICAgICBtZXNzYWdlLmluaXRpYWxpemF0aW9uQmluZGluZyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5pbml0aWFsaXphdGlvbkJpbmRpbmcubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5pbml0aWFsaXphdGlvbkJpbmRpbmdbaV0gIT09ICdvYmplY3QnKVxuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCcub25ueC5UcmFpbmluZ0luZm9Qcm90by5pbml0aWFsaXphdGlvbkJpbmRpbmc6IG9iamVjdCBleHBlY3RlZCcpO1xuICAgICAgICAgIG1lc3NhZ2UuaW5pdGlhbGl6YXRpb25CaW5kaW5nW2ldID0gJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLmZyb21PYmplY3QoXG4gICAgICAgICAgICBvYmplY3QuaW5pdGlhbGl6YXRpb25CaW5kaW5nW2ldLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3QudXBkYXRlQmluZGluZykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LnVwZGF0ZUJpbmRpbmcpKVxuICAgICAgICAgIHRocm93IFR5cGVFcnJvcignLm9ubnguVHJhaW5pbmdJbmZvUHJvdG8udXBkYXRlQmluZGluZzogYXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgbWVzc2FnZS51cGRhdGVCaW5kaW5nID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LnVwZGF0ZUJpbmRpbmcubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC51cGRhdGVCaW5kaW5nW2ldICE9PSAnb2JqZWN0JylcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcignLm9ubnguVHJhaW5pbmdJbmZvUHJvdG8udXBkYXRlQmluZGluZzogb2JqZWN0IGV4cGVjdGVkJyk7XG4gICAgICAgICAgbWVzc2FnZS51cGRhdGVCaW5kaW5nW2ldID0gJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLmZyb21PYmplY3Qob2JqZWN0LnVwZGF0ZUJpbmRpbmdbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgVHJhaW5pbmdJbmZvUHJvdG8gbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxuICAgICAqIEBtZW1iZXJvZiBvbm54LlRyYWluaW5nSW5mb1Byb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7b25ueC5UcmFpbmluZ0luZm9Qcm90b30gbWVzc2FnZSBUcmFpbmluZ0luZm9Qcm90b1xuICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICovXG4gICAgVHJhaW5pbmdJbmZvUHJvdG8udG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgIGlmIChvcHRpb25zLmFycmF5cyB8fCBvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgIG9iamVjdC5pbml0aWFsaXphdGlvbkJpbmRpbmcgPSBbXTtcbiAgICAgICAgb2JqZWN0LnVwZGF0ZUJpbmRpbmcgPSBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgIG9iamVjdC5pbml0aWFsaXphdGlvbiA9IG51bGw7XG4gICAgICAgIG9iamVjdC5hbGdvcml0aG0gPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UuaW5pdGlhbGl6YXRpb24gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdpbml0aWFsaXphdGlvbicpKVxuICAgICAgICBvYmplY3QuaW5pdGlhbGl6YXRpb24gPSAkcm9vdC5vbm54LkdyYXBoUHJvdG8udG9PYmplY3QobWVzc2FnZS5pbml0aWFsaXphdGlvbiwgb3B0aW9ucyk7XG4gICAgICBpZiAobWVzc2FnZS5hbGdvcml0aG0gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdhbGdvcml0aG0nKSlcbiAgICAgICAgb2JqZWN0LmFsZ29yaXRobSA9ICRyb290Lm9ubnguR3JhcGhQcm90by50b09iamVjdChtZXNzYWdlLmFsZ29yaXRobSwgb3B0aW9ucyk7XG4gICAgICBpZiAobWVzc2FnZS5pbml0aWFsaXphdGlvbkJpbmRpbmcgJiYgbWVzc2FnZS5pbml0aWFsaXphdGlvbkJpbmRpbmcubGVuZ3RoKSB7XG4gICAgICAgIG9iamVjdC5pbml0aWFsaXphdGlvbkJpbmRpbmcgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLmluaXRpYWxpemF0aW9uQmluZGluZy5sZW5ndGg7ICsrailcbiAgICAgICAgICBvYmplY3QuaW5pdGlhbGl6YXRpb25CaW5kaW5nW2pdID0gJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLnRvT2JqZWN0KFxuICAgICAgICAgICAgbWVzc2FnZS5pbml0aWFsaXphdGlvbkJpbmRpbmdbal0sXG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS51cGRhdGVCaW5kaW5nICYmIG1lc3NhZ2UudXBkYXRlQmluZGluZy5sZW5ndGgpIHtcbiAgICAgICAgb2JqZWN0LnVwZGF0ZUJpbmRpbmcgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLnVwZGF0ZUJpbmRpbmcubGVuZ3RoOyArK2opXG4gICAgICAgICAgb2JqZWN0LnVwZGF0ZUJpbmRpbmdbal0gPSAkcm9vdC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8udG9PYmplY3QobWVzc2FnZS51cGRhdGVCaW5kaW5nW2pdLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoaXMgVHJhaW5pbmdJbmZvUHJvdG8gdG8gSlNPTi5cbiAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICogQG1lbWJlcm9mIG9ubnguVHJhaW5pbmdJbmZvUHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IEpTT04gb2JqZWN0XG4gICAgICovXG4gICAgVHJhaW5pbmdJbmZvUHJvdG8ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBkZWZhdWx0IHR5cGUgdXJsIGZvciBUcmFpbmluZ0luZm9Qcm90b1xuICAgICAqIEBmdW5jdGlvbiBnZXRUeXBlVXJsXG4gICAgICogQG1lbWJlcm9mIG9ubnguVHJhaW5pbmdJbmZvUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlVXJsUHJlZml4XSB5b3VyIGN1c3RvbSB0eXBlVXJsUHJlZml4KGRlZmF1bHQgXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCIpXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGRlZmF1bHQgdHlwZSB1cmxcbiAgICAgKi9cbiAgICBUcmFpbmluZ0luZm9Qcm90by5nZXRUeXBlVXJsID0gZnVuY3Rpb24gZ2V0VHlwZVVybCh0eXBlVXJsUHJlZml4KSB7XG4gICAgICBpZiAodHlwZVVybFByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHR5cGVVcmxQcmVmaXggPSAndHlwZS5nb29nbGVhcGlzLmNvbSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZVVybFByZWZpeCArICcvb25ueC5UcmFpbmluZ0luZm9Qcm90byc7XG4gICAgfTtcblxuICAgIHJldHVybiBUcmFpbmluZ0luZm9Qcm90bztcbiAgfSkoKTtcblxuICBvbm54Lk1vZGVsUHJvdG8gPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgb2YgYSBNb2RlbFByb3RvLlxuICAgICAqIEBtZW1iZXJvZiBvbm54XG4gICAgICogQGludGVyZmFjZSBJTW9kZWxQcm90b1xuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfExvbmd8bnVsbH0gW2lyVmVyc2lvbl0gTW9kZWxQcm90byBpclZlcnNpb25cbiAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LklPcGVyYXRvclNldElkUHJvdG8+fG51bGx9IFtvcHNldEltcG9ydF0gTW9kZWxQcm90byBvcHNldEltcG9ydFxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtwcm9kdWNlck5hbWVdIE1vZGVsUHJvdG8gcHJvZHVjZXJOYW1lXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW3Byb2R1Y2VyVmVyc2lvbl0gTW9kZWxQcm90byBwcm9kdWNlclZlcnNpb25cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbZG9tYWluXSBNb2RlbFByb3RvIGRvbWFpblxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfExvbmd8bnVsbH0gW21vZGVsVmVyc2lvbl0gTW9kZWxQcm90byBtb2RlbFZlcnNpb25cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbZG9jU3RyaW5nXSBNb2RlbFByb3RvIGRvY1N0cmluZ1xuICAgICAqIEBwcm9wZXJ0eSB7b25ueC5JR3JhcGhQcm90b3xudWxsfSBbZ3JhcGhdIE1vZGVsUHJvdG8gZ3JhcGhcbiAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LklTdHJpbmdTdHJpbmdFbnRyeVByb3RvPnxudWxsfSBbbWV0YWRhdGFQcm9wc10gTW9kZWxQcm90byBtZXRhZGF0YVByb3BzXG4gICAgICogQHByb3BlcnR5IHtBcnJheS48b25ueC5JVHJhaW5pbmdJbmZvUHJvdG8+fG51bGx9IFt0cmFpbmluZ0luZm9dIE1vZGVsUHJvdG8gdHJhaW5pbmdJbmZvXG4gICAgICogQHByb3BlcnR5IHtBcnJheS48b25ueC5JRnVuY3Rpb25Qcm90bz58bnVsbH0gW2Z1bmN0aW9uc10gTW9kZWxQcm90byBmdW5jdGlvbnNcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgTW9kZWxQcm90by5cbiAgICAgKiBAbWVtYmVyb2Ygb25ueFxuICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIE1vZGVsUHJvdG8uXG4gICAgICogQGltcGxlbWVudHMgSU1vZGVsUHJvdG9cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge29ubnguSU1vZGVsUHJvdG89fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNb2RlbFByb3RvKHByb3BlcnRpZXMpIHtcbiAgICAgIHRoaXMub3BzZXRJbXBvcnQgPSBbXTtcbiAgICAgIHRoaXMubWV0YWRhdGFQcm9wcyA9IFtdO1xuICAgICAgdGhpcy50cmFpbmluZ0luZm8gPSBbXTtcbiAgICAgIHRoaXMuZnVuY3Rpb25zID0gW107XG4gICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbCkgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW9kZWxQcm90byBpclZlcnNpb24uXG4gICAgICogQG1lbWJlciB7bnVtYmVyfExvbmd9IGlyVmVyc2lvblxuICAgICAqIEBtZW1iZXJvZiBvbm54Lk1vZGVsUHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBNb2RlbFByb3RvLnByb3RvdHlwZS5pclZlcnNpb24gPSAkdXRpbC5Mb25nID8gJHV0aWwuTG9uZy5mcm9tQml0cygwLCAwLCBmYWxzZSkgOiAwO1xuXG4gICAgLyoqXG4gICAgICogTW9kZWxQcm90byBvcHNldEltcG9ydC5cbiAgICAgKiBAbWVtYmVyIHtBcnJheS48b25ueC5JT3BlcmF0b3JTZXRJZFByb3RvPn0gb3BzZXRJbXBvcnRcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5Nb2RlbFByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgTW9kZWxQcm90by5wcm90b3R5cGUub3BzZXRJbXBvcnQgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgLyoqXG4gICAgICogTW9kZWxQcm90byBwcm9kdWNlck5hbWUuXG4gICAgICogQG1lbWJlciB7c3RyaW5nfSBwcm9kdWNlck5hbWVcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5Nb2RlbFByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgTW9kZWxQcm90by5wcm90b3R5cGUucHJvZHVjZXJOYW1lID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBNb2RlbFByb3RvIHByb2R1Y2VyVmVyc2lvbi5cbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IHByb2R1Y2VyVmVyc2lvblxuICAgICAqIEBtZW1iZXJvZiBvbm54Lk1vZGVsUHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBNb2RlbFByb3RvLnByb3RvdHlwZS5wcm9kdWNlclZlcnNpb24gPSAnJztcblxuICAgIC8qKlxuICAgICAqIE1vZGVsUHJvdG8gZG9tYWluLlxuICAgICAqIEBtZW1iZXIge3N0cmluZ30gZG9tYWluXG4gICAgICogQG1lbWJlcm9mIG9ubnguTW9kZWxQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIE1vZGVsUHJvdG8ucHJvdG90eXBlLmRvbWFpbiA9ICcnO1xuXG4gICAgLyoqXG4gICAgICogTW9kZWxQcm90byBtb2RlbFZlcnNpb24uXG4gICAgICogQG1lbWJlciB7bnVtYmVyfExvbmd9IG1vZGVsVmVyc2lvblxuICAgICAqIEBtZW1iZXJvZiBvbm54Lk1vZGVsUHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBNb2RlbFByb3RvLnByb3RvdHlwZS5tb2RlbFZlcnNpb24gPSAkdXRpbC5Mb25nID8gJHV0aWwuTG9uZy5mcm9tQml0cygwLCAwLCBmYWxzZSkgOiAwO1xuXG4gICAgLyoqXG4gICAgICogTW9kZWxQcm90byBkb2NTdHJpbmcuXG4gICAgICogQG1lbWJlciB7c3RyaW5nfSBkb2NTdHJpbmdcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5Nb2RlbFByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgTW9kZWxQcm90by5wcm90b3R5cGUuZG9jU3RyaW5nID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBNb2RlbFByb3RvIGdyYXBoLlxuICAgICAqIEBtZW1iZXIge29ubnguSUdyYXBoUHJvdG98bnVsbHx1bmRlZmluZWR9IGdyYXBoXG4gICAgICogQG1lbWJlcm9mIG9ubnguTW9kZWxQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIE1vZGVsUHJvdG8ucHJvdG90eXBlLmdyYXBoID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIE1vZGVsUHJvdG8gbWV0YWRhdGFQcm9wcy5cbiAgICAgKiBAbWVtYmVyIHtBcnJheS48b25ueC5JU3RyaW5nU3RyaW5nRW50cnlQcm90bz59IG1ldGFkYXRhUHJvcHNcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5Nb2RlbFByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgTW9kZWxQcm90by5wcm90b3R5cGUubWV0YWRhdGFQcm9wcyA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAvKipcbiAgICAgKiBNb2RlbFByb3RvIHRyYWluaW5nSW5mby5cbiAgICAgKiBAbWVtYmVyIHtBcnJheS48b25ueC5JVHJhaW5pbmdJbmZvUHJvdG8+fSB0cmFpbmluZ0luZm9cbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5Nb2RlbFByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgTW9kZWxQcm90by5wcm90b3R5cGUudHJhaW5pbmdJbmZvID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgIC8qKlxuICAgICAqIE1vZGVsUHJvdG8gZnVuY3Rpb25zLlxuICAgICAqIEBtZW1iZXIge0FycmF5Ljxvbm54LklGdW5jdGlvblByb3RvPn0gZnVuY3Rpb25zXG4gICAgICogQG1lbWJlcm9mIG9ubnguTW9kZWxQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIE1vZGVsUHJvdG8ucHJvdG90eXBlLmZ1bmN0aW9ucyA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IE1vZGVsUHJvdG8gaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAqIEBmdW5jdGlvbiBjcmVhdGVcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5Nb2RlbFByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7b25ueC5JTW9kZWxQcm90bz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAqIEByZXR1cm5zIHtvbm54Lk1vZGVsUHJvdG99IE1vZGVsUHJvdG8gaW5zdGFuY2VcbiAgICAgKi9cbiAgICBNb2RlbFByb3RvLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICByZXR1cm4gbmV3IE1vZGVsUHJvdG8ocHJvcGVydGllcyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBNb2RlbFByb3RvIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguTW9kZWxQcm90by52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXG4gICAgICogQG1lbWJlcm9mIG9ubnguTW9kZWxQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge29ubnguSU1vZGVsUHJvdG99IG1lc3NhZ2UgTW9kZWxQcm90byBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICovXG4gICAgTW9kZWxQcm90by5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICBpZiAoIXdyaXRlcikgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgIGlmIChtZXNzYWdlLmlyVmVyc2lvbiAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsICdpclZlcnNpb24nKSlcbiAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAxLCB3aXJlVHlwZSAwID0qLyA4KS5pbnQ2NChtZXNzYWdlLmlyVmVyc2lvbik7XG4gICAgICBpZiAobWVzc2FnZS5wcm9kdWNlck5hbWUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCAncHJvZHVjZXJOYW1lJykpXG4gICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMiwgd2lyZVR5cGUgMiA9Ki8gMTgpLnN0cmluZyhtZXNzYWdlLnByb2R1Y2VyTmFtZSk7XG4gICAgICBpZiAobWVzc2FnZS5wcm9kdWNlclZlcnNpb24gIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCAncHJvZHVjZXJWZXJzaW9uJykpXG4gICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMywgd2lyZVR5cGUgMiA9Ki8gMjYpLnN0cmluZyhtZXNzYWdlLnByb2R1Y2VyVmVyc2lvbik7XG4gICAgICBpZiAobWVzc2FnZS5kb21haW4gIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCAnZG9tYWluJykpXG4gICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgNCwgd2lyZVR5cGUgMiA9Ki8gMzQpLnN0cmluZyhtZXNzYWdlLmRvbWFpbik7XG4gICAgICBpZiAobWVzc2FnZS5tb2RlbFZlcnNpb24gIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCAnbW9kZWxWZXJzaW9uJykpXG4gICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgNSwgd2lyZVR5cGUgMCA9Ki8gNDApLmludDY0KG1lc3NhZ2UubW9kZWxWZXJzaW9uKTtcbiAgICAgIGlmIChtZXNzYWdlLmRvY1N0cmluZyAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsICdkb2NTdHJpbmcnKSlcbiAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA2LCB3aXJlVHlwZSAyID0qLyA1MCkuc3RyaW5nKG1lc3NhZ2UuZG9jU3RyaW5nKTtcbiAgICAgIGlmIChtZXNzYWdlLmdyYXBoICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgJ2dyYXBoJykpXG4gICAgICAgICRyb290Lm9ubnguR3JhcGhQcm90by5lbmNvZGUobWVzc2FnZS5ncmFwaCwgd3JpdGVyLnVpbnQzMigvKiBpZCA3LCB3aXJlVHlwZSAyID0qLyA1OCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgIGlmIChtZXNzYWdlLm9wc2V0SW1wb3J0ICE9IG51bGwgJiYgbWVzc2FnZS5vcHNldEltcG9ydC5sZW5ndGgpXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5vcHNldEltcG9ydC5sZW5ndGg7ICsraSlcbiAgICAgICAgICAkcm9vdC5vbm54Lk9wZXJhdG9yU2V0SWRQcm90by5lbmNvZGUoXG4gICAgICAgICAgICBtZXNzYWdlLm9wc2V0SW1wb3J0W2ldLFxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA4LCB3aXJlVHlwZSAyID0qLyA2NikuZm9yaygpLFxuICAgICAgICAgICkubGRlbGltKCk7XG4gICAgICBpZiAobWVzc2FnZS5tZXRhZGF0YVByb3BzICE9IG51bGwgJiYgbWVzc2FnZS5tZXRhZGF0YVByb3BzLmxlbmd0aClcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLm1ldGFkYXRhUHJvcHMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLmVuY29kZShcbiAgICAgICAgICAgIG1lc3NhZ2UubWV0YWRhdGFQcm9wc1tpXSxcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMTQsIHdpcmVUeXBlIDIgPSovIDExNCkuZm9yaygpLFxuICAgICAgICAgICkubGRlbGltKCk7XG4gICAgICBpZiAobWVzc2FnZS50cmFpbmluZ0luZm8gIT0gbnVsbCAmJiBtZXNzYWdlLnRyYWluaW5nSW5mby5sZW5ndGgpXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS50cmFpbmluZ0luZm8ubGVuZ3RoOyArK2kpXG4gICAgICAgICAgJHJvb3Qub25ueC5UcmFpbmluZ0luZm9Qcm90by5lbmNvZGUoXG4gICAgICAgICAgICBtZXNzYWdlLnRyYWluaW5nSW5mb1tpXSxcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMjAsIHdpcmVUeXBlIDIgPSovIDE2MikuZm9yaygpLFxuICAgICAgICAgICkubGRlbGltKCk7XG4gICAgICBpZiAobWVzc2FnZS5mdW5jdGlvbnMgIT0gbnVsbCAmJiBtZXNzYWdlLmZ1bmN0aW9ucy5sZW5ndGgpXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5mdW5jdGlvbnMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgJHJvb3Qub25ueC5GdW5jdGlvblByb3RvLmVuY29kZShcbiAgICAgICAgICAgIG1lc3NhZ2UuZnVuY3Rpb25zW2ldLFxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAyNSwgd2lyZVR5cGUgMiA9Ki8gMjAyKS5mb3JrKCksXG4gICAgICAgICAgKS5sZGVsaW0oKTtcbiAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBNb2RlbFByb3RvIG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguTW9kZWxQcm90by52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgKiBAZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkXG4gICAgICogQG1lbWJlcm9mIG9ubnguTW9kZWxQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge29ubnguSU1vZGVsUHJvdG99IG1lc3NhZ2UgTW9kZWxQcm90byBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICovXG4gICAgTW9kZWxQcm90by5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhIE1vZGVsUHJvdG8gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICogQG1lbWJlcm9mIG9ubnguTW9kZWxQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAqIEByZXR1cm5zIHtvbm54Lk1vZGVsUHJvdG99IE1vZGVsUHJvdG9cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAqL1xuICAgIE1vZGVsUHJvdG8uZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSkgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLFxuICAgICAgICBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguTW9kZWxQcm90bygpO1xuICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgIG1lc3NhZ2UuaXJWZXJzaW9uID0gcmVhZGVyLmludDY0KCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSA4OiB7XG4gICAgICAgICAgICBpZiAoIShtZXNzYWdlLm9wc2V0SW1wb3J0ICYmIG1lc3NhZ2Uub3BzZXRJbXBvcnQubGVuZ3RoKSkgbWVzc2FnZS5vcHNldEltcG9ydCA9IFtdO1xuICAgICAgICAgICAgbWVzc2FnZS5vcHNldEltcG9ydC5wdXNoKCRyb290Lm9ubnguT3BlcmF0b3JTZXRJZFByb3RvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgICAgbWVzc2FnZS5wcm9kdWNlck5hbWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAzOiB7XG4gICAgICAgICAgICBtZXNzYWdlLnByb2R1Y2VyVmVyc2lvbiA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDQ6IHtcbiAgICAgICAgICAgIG1lc3NhZ2UuZG9tYWluID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgNToge1xuICAgICAgICAgICAgbWVzc2FnZS5tb2RlbFZlcnNpb24gPSByZWFkZXIuaW50NjQoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDY6IHtcbiAgICAgICAgICAgIG1lc3NhZ2UuZG9jU3RyaW5nID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgNzoge1xuICAgICAgICAgICAgbWVzc2FnZS5ncmFwaCA9ICRyb290Lm9ubnguR3JhcGhQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMTQ6IHtcbiAgICAgICAgICAgIGlmICghKG1lc3NhZ2UubWV0YWRhdGFQcm9wcyAmJiBtZXNzYWdlLm1ldGFkYXRhUHJvcHMubGVuZ3RoKSkgbWVzc2FnZS5tZXRhZGF0YVByb3BzID0gW107XG4gICAgICAgICAgICBtZXNzYWdlLm1ldGFkYXRhUHJvcHMucHVzaCgkcm9vdC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAyMDoge1xuICAgICAgICAgICAgaWYgKCEobWVzc2FnZS50cmFpbmluZ0luZm8gJiYgbWVzc2FnZS50cmFpbmluZ0luZm8ubGVuZ3RoKSkgbWVzc2FnZS50cmFpbmluZ0luZm8gPSBbXTtcbiAgICAgICAgICAgIG1lc3NhZ2UudHJhaW5pbmdJbmZvLnB1c2goJHJvb3Qub25ueC5UcmFpbmluZ0luZm9Qcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDI1OiB7XG4gICAgICAgICAgICBpZiAoIShtZXNzYWdlLmZ1bmN0aW9ucyAmJiBtZXNzYWdlLmZ1bmN0aW9ucy5sZW5ndGgpKSBtZXNzYWdlLmZ1bmN0aW9ucyA9IFtdO1xuICAgICAgICAgICAgbWVzc2FnZS5mdW5jdGlvbnMucHVzaCgkcm9vdC5vbm54LkZ1bmN0aW9uUHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhIE1vZGVsUHJvdG8gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlciwgbGVuZ3RoIGRlbGltaXRlZC5cbiAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXG4gICAgICogQG1lbWJlcm9mIG9ubnguTW9kZWxQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgKiBAcmV0dXJucyB7b25ueC5Nb2RlbFByb3RvfSBNb2RlbFByb3RvXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgKi9cbiAgICBNb2RlbFByb3RvLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKSByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgYSBNb2RlbFByb3RvIG1lc3NhZ2UuXG4gICAgICogQGZ1bmN0aW9uIHZlcmlmeVxuICAgICAqIEBtZW1iZXJvZiBvbm54Lk1vZGVsUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XG4gICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAgICAgKi9cbiAgICBNb2RlbFByb3RvLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09ICdvYmplY3QnIHx8IG1lc3NhZ2UgPT09IG51bGwpIHJldHVybiAnb2JqZWN0IGV4cGVjdGVkJztcbiAgICAgIGlmIChtZXNzYWdlLmlyVmVyc2lvbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ2lyVmVyc2lvbicpKVxuICAgICAgICBpZiAoXG4gICAgICAgICAgISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmlyVmVyc2lvbikgJiZcbiAgICAgICAgICAhKG1lc3NhZ2UuaXJWZXJzaW9uICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmlyVmVyc2lvbi5sb3cpICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmlyVmVyc2lvbi5oaWdoKSlcbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybiAnaXJWZXJzaW9uOiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWQnO1xuICAgICAgaWYgKG1lc3NhZ2Uub3BzZXRJbXBvcnQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdvcHNldEltcG9ydCcpKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLm9wc2V0SW1wb3J0KSkgcmV0dXJuICdvcHNldEltcG9ydDogYXJyYXkgZXhwZWN0ZWQnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2Uub3BzZXRJbXBvcnQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54Lk9wZXJhdG9yU2V0SWRQcm90by52ZXJpZnkobWVzc2FnZS5vcHNldEltcG9ydFtpXSk7XG4gICAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gJ29wc2V0SW1wb3J0LicgKyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UucHJvZHVjZXJOYW1lICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgncHJvZHVjZXJOYW1lJykpXG4gICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5wcm9kdWNlck5hbWUpKSByZXR1cm4gJ3Byb2R1Y2VyTmFtZTogc3RyaW5nIGV4cGVjdGVkJztcbiAgICAgIGlmIChtZXNzYWdlLnByb2R1Y2VyVmVyc2lvbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ3Byb2R1Y2VyVmVyc2lvbicpKVxuICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UucHJvZHVjZXJWZXJzaW9uKSkgcmV0dXJuICdwcm9kdWNlclZlcnNpb246IHN0cmluZyBleHBlY3RlZCc7XG4gICAgICBpZiAobWVzc2FnZS5kb21haW4gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdkb21haW4nKSlcbiAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLmRvbWFpbikpIHJldHVybiAnZG9tYWluOiBzdHJpbmcgZXhwZWN0ZWQnO1xuICAgICAgaWYgKG1lc3NhZ2UubW9kZWxWZXJzaW9uICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnbW9kZWxWZXJzaW9uJykpXG4gICAgICAgIGlmIChcbiAgICAgICAgICAhJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UubW9kZWxWZXJzaW9uKSAmJlxuICAgICAgICAgICEoXG4gICAgICAgICAgICBtZXNzYWdlLm1vZGVsVmVyc2lvbiAmJlxuICAgICAgICAgICAgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UubW9kZWxWZXJzaW9uLmxvdykgJiZcbiAgICAgICAgICAgICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLm1vZGVsVmVyc2lvbi5oaWdoKVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybiAnbW9kZWxWZXJzaW9uOiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWQnO1xuICAgICAgaWYgKG1lc3NhZ2UuZG9jU3RyaW5nICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnZG9jU3RyaW5nJykpXG4gICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5kb2NTdHJpbmcpKSByZXR1cm4gJ2RvY1N0cmluZzogc3RyaW5nIGV4cGVjdGVkJztcbiAgICAgIGlmIChtZXNzYWdlLmdyYXBoICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnZ3JhcGgnKSkge1xuICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LkdyYXBoUHJvdG8udmVyaWZ5KG1lc3NhZ2UuZ3JhcGgpO1xuICAgICAgICBpZiAoZXJyb3IpIHJldHVybiAnZ3JhcGguJyArIGVycm9yO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UubWV0YWRhdGFQcm9wcyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ21ldGFkYXRhUHJvcHMnKSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5tZXRhZGF0YVByb3BzKSkgcmV0dXJuICdtZXRhZGF0YVByb3BzOiBhcnJheSBleHBlY3RlZCc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5tZXRhZGF0YVByb3BzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLnZlcmlmeShtZXNzYWdlLm1ldGFkYXRhUHJvcHNbaV0pO1xuICAgICAgICAgIGlmIChlcnJvcikgcmV0dXJuICdtZXRhZGF0YVByb3BzLicgKyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UudHJhaW5pbmdJbmZvICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgndHJhaW5pbmdJbmZvJykpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UudHJhaW5pbmdJbmZvKSkgcmV0dXJuICd0cmFpbmluZ0luZm86IGFycmF5IGV4cGVjdGVkJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnRyYWluaW5nSW5mby5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguVHJhaW5pbmdJbmZvUHJvdG8udmVyaWZ5KG1lc3NhZ2UudHJhaW5pbmdJbmZvW2ldKTtcbiAgICAgICAgICBpZiAoZXJyb3IpIHJldHVybiAndHJhaW5pbmdJbmZvLicgKyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UuZnVuY3Rpb25zICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnZnVuY3Rpb25zJykpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UuZnVuY3Rpb25zKSkgcmV0dXJuICdmdW5jdGlvbnM6IGFycmF5IGV4cGVjdGVkJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmZ1bmN0aW9ucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguRnVuY3Rpb25Qcm90by52ZXJpZnkobWVzc2FnZS5mdW5jdGlvbnNbaV0pO1xuICAgICAgICAgIGlmIChlcnJvcikgcmV0dXJuICdmdW5jdGlvbnMuJyArIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIE1vZGVsUHJvdG8gbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICogQG1lbWJlcm9mIG9ubnguTW9kZWxQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gICAgICogQHJldHVybnMge29ubnguTW9kZWxQcm90b30gTW9kZWxQcm90b1xuICAgICAqL1xuICAgIE1vZGVsUHJvdG8uZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3Qub25ueC5Nb2RlbFByb3RvKSByZXR1cm4gb2JqZWN0O1xuICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5Nb2RlbFByb3RvKCk7XG4gICAgICBpZiAob2JqZWN0LmlyVmVyc2lvbiAhPSBudWxsKVxuICAgICAgICBpZiAoJHV0aWwuTG9uZykgKG1lc3NhZ2UuaXJWZXJzaW9uID0gJHV0aWwuTG9uZy5mcm9tVmFsdWUob2JqZWN0LmlyVmVyc2lvbikpLnVuc2lnbmVkID0gZmFsc2U7XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuaXJWZXJzaW9uID09PSAnc3RyaW5nJykgbWVzc2FnZS5pclZlcnNpb24gPSBwYXJzZUludChvYmplY3QuaXJWZXJzaW9uLCAxMCk7XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuaXJWZXJzaW9uID09PSAnbnVtYmVyJykgbWVzc2FnZS5pclZlcnNpb24gPSBvYmplY3QuaXJWZXJzaW9uO1xuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmlyVmVyc2lvbiA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgbWVzc2FnZS5pclZlcnNpb24gPSBuZXcgJHV0aWwuTG9uZ0JpdHMob2JqZWN0LmlyVmVyc2lvbi5sb3cgPj4+IDAsIG9iamVjdC5pclZlcnNpb24uaGlnaCA+Pj4gMCkudG9OdW1iZXIoKTtcbiAgICAgIGlmIChvYmplY3Qub3BzZXRJbXBvcnQpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5vcHNldEltcG9ydCkpIHRocm93IFR5cGVFcnJvcignLm9ubnguTW9kZWxQcm90by5vcHNldEltcG9ydDogYXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgbWVzc2FnZS5vcHNldEltcG9ydCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5vcHNldEltcG9ydC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0Lm9wc2V0SW1wb3J0W2ldICE9PSAnb2JqZWN0JylcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcignLm9ubnguTW9kZWxQcm90by5vcHNldEltcG9ydDogb2JqZWN0IGV4cGVjdGVkJyk7XG4gICAgICAgICAgbWVzc2FnZS5vcHNldEltcG9ydFtpXSA9ICRyb290Lm9ubnguT3BlcmF0b3JTZXRJZFByb3RvLmZyb21PYmplY3Qob2JqZWN0Lm9wc2V0SW1wb3J0W2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9iamVjdC5wcm9kdWNlck5hbWUgIT0gbnVsbCkgbWVzc2FnZS5wcm9kdWNlck5hbWUgPSBTdHJpbmcob2JqZWN0LnByb2R1Y2VyTmFtZSk7XG4gICAgICBpZiAob2JqZWN0LnByb2R1Y2VyVmVyc2lvbiAhPSBudWxsKSBtZXNzYWdlLnByb2R1Y2VyVmVyc2lvbiA9IFN0cmluZyhvYmplY3QucHJvZHVjZXJWZXJzaW9uKTtcbiAgICAgIGlmIChvYmplY3QuZG9tYWluICE9IG51bGwpIG1lc3NhZ2UuZG9tYWluID0gU3RyaW5nKG9iamVjdC5kb21haW4pO1xuICAgICAgaWYgKG9iamVjdC5tb2RlbFZlcnNpb24gIT0gbnVsbClcbiAgICAgICAgaWYgKCR1dGlsLkxvbmcpIChtZXNzYWdlLm1vZGVsVmVyc2lvbiA9ICR1dGlsLkxvbmcuZnJvbVZhbHVlKG9iamVjdC5tb2RlbFZlcnNpb24pKS51bnNpZ25lZCA9IGZhbHNlO1xuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0Lm1vZGVsVmVyc2lvbiA9PT0gJ3N0cmluZycpIG1lc3NhZ2UubW9kZWxWZXJzaW9uID0gcGFyc2VJbnQob2JqZWN0Lm1vZGVsVmVyc2lvbiwgMTApO1xuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0Lm1vZGVsVmVyc2lvbiA9PT0gJ251bWJlcicpIG1lc3NhZ2UubW9kZWxWZXJzaW9uID0gb2JqZWN0Lm1vZGVsVmVyc2lvbjtcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5tb2RlbFZlcnNpb24gPT09ICdvYmplY3QnKVxuICAgICAgICAgIG1lc3NhZ2UubW9kZWxWZXJzaW9uID0gbmV3ICR1dGlsLkxvbmdCaXRzKFxuICAgICAgICAgICAgb2JqZWN0Lm1vZGVsVmVyc2lvbi5sb3cgPj4+IDAsXG4gICAgICAgICAgICBvYmplY3QubW9kZWxWZXJzaW9uLmhpZ2ggPj4+IDAsXG4gICAgICAgICAgKS50b051bWJlcigpO1xuICAgICAgaWYgKG9iamVjdC5kb2NTdHJpbmcgIT0gbnVsbCkgbWVzc2FnZS5kb2NTdHJpbmcgPSBTdHJpbmcob2JqZWN0LmRvY1N0cmluZyk7XG4gICAgICBpZiAob2JqZWN0LmdyYXBoICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QuZ3JhcGggIT09ICdvYmplY3QnKSB0aHJvdyBUeXBlRXJyb3IoJy5vbm54Lk1vZGVsUHJvdG8uZ3JhcGg6IG9iamVjdCBleHBlY3RlZCcpO1xuICAgICAgICBtZXNzYWdlLmdyYXBoID0gJHJvb3Qub25ueC5HcmFwaFByb3RvLmZyb21PYmplY3Qob2JqZWN0LmdyYXBoKTtcbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3QubWV0YWRhdGFQcm9wcykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0Lm1ldGFkYXRhUHJvcHMpKSB0aHJvdyBUeXBlRXJyb3IoJy5vbm54Lk1vZGVsUHJvdG8ubWV0YWRhdGFQcm9wczogYXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgbWVzc2FnZS5tZXRhZGF0YVByb3BzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0Lm1ldGFkYXRhUHJvcHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5tZXRhZGF0YVByb3BzW2ldICE9PSAnb2JqZWN0JylcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcignLm9ubnguTW9kZWxQcm90by5tZXRhZGF0YVByb3BzOiBvYmplY3QgZXhwZWN0ZWQnKTtcbiAgICAgICAgICBtZXNzYWdlLm1ldGFkYXRhUHJvcHNbaV0gPSAkcm9vdC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZnJvbU9iamVjdChvYmplY3QubWV0YWRhdGFQcm9wc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3QudHJhaW5pbmdJbmZvKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QudHJhaW5pbmdJbmZvKSkgdGhyb3cgVHlwZUVycm9yKCcub25ueC5Nb2RlbFByb3RvLnRyYWluaW5nSW5mbzogYXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgbWVzc2FnZS50cmFpbmluZ0luZm8gPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QudHJhaW5pbmdJbmZvLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QudHJhaW5pbmdJbmZvW2ldICE9PSAnb2JqZWN0JylcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcignLm9ubnguTW9kZWxQcm90by50cmFpbmluZ0luZm86IG9iamVjdCBleHBlY3RlZCcpO1xuICAgICAgICAgIG1lc3NhZ2UudHJhaW5pbmdJbmZvW2ldID0gJHJvb3Qub25ueC5UcmFpbmluZ0luZm9Qcm90by5mcm9tT2JqZWN0KG9iamVjdC50cmFpbmluZ0luZm9baV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0LmZ1bmN0aW9ucykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LmZ1bmN0aW9ucykpIHRocm93IFR5cGVFcnJvcignLm9ubnguTW9kZWxQcm90by5mdW5jdGlvbnM6IGFycmF5IGV4cGVjdGVkJyk7XG4gICAgICAgIG1lc3NhZ2UuZnVuY3Rpb25zID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LmZ1bmN0aW9ucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmZ1bmN0aW9uc1tpXSAhPT0gJ29iamVjdCcpIHRocm93IFR5cGVFcnJvcignLm9ubnguTW9kZWxQcm90by5mdW5jdGlvbnM6IG9iamVjdCBleHBlY3RlZCcpO1xuICAgICAgICAgIG1lc3NhZ2UuZnVuY3Rpb25zW2ldID0gJHJvb3Qub25ueC5GdW5jdGlvblByb3RvLmZyb21PYmplY3Qob2JqZWN0LmZ1bmN0aW9uc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYSBNb2RlbFByb3RvIG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5Nb2RlbFByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7b25ueC5Nb2RlbFByb3RvfSBtZXNzYWdlIE1vZGVsUHJvdG9cbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICAgICAqL1xuICAgIE1vZGVsUHJvdG8udG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgIGlmIChvcHRpb25zLmFycmF5cyB8fCBvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgIG9iamVjdC5vcHNldEltcG9ydCA9IFtdO1xuICAgICAgICBvYmplY3QubWV0YWRhdGFQcm9wcyA9IFtdO1xuICAgICAgICBvYmplY3QudHJhaW5pbmdJbmZvID0gW107XG4gICAgICAgIG9iamVjdC5mdW5jdGlvbnMgPSBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgIGlmICgkdXRpbC5Mb25nKSB7XG4gICAgICAgICAgdmFyIGxvbmcgPSBuZXcgJHV0aWwuTG9uZygwLCAwLCBmYWxzZSk7XG4gICAgICAgICAgb2JqZWN0LmlyVmVyc2lvbiA9XG4gICAgICAgICAgICBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBsb25nLnRvU3RyaW5nKCkgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBsb25nLnRvTnVtYmVyKCkgOiBsb25nO1xuICAgICAgICB9IGVsc2Ugb2JqZWN0LmlyVmVyc2lvbiA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/ICcwJyA6IDA7XG4gICAgICAgIG9iamVjdC5wcm9kdWNlck5hbWUgPSAnJztcbiAgICAgICAgb2JqZWN0LnByb2R1Y2VyVmVyc2lvbiA9ICcnO1xuICAgICAgICBvYmplY3QuZG9tYWluID0gJyc7XG4gICAgICAgIGlmICgkdXRpbC5Mb25nKSB7XG4gICAgICAgICAgdmFyIGxvbmcgPSBuZXcgJHV0aWwuTG9uZygwLCAwLCBmYWxzZSk7XG4gICAgICAgICAgb2JqZWN0Lm1vZGVsVmVyc2lvbiA9XG4gICAgICAgICAgICBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBsb25nLnRvU3RyaW5nKCkgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBsb25nLnRvTnVtYmVyKCkgOiBsb25nO1xuICAgICAgICB9IGVsc2Ugb2JqZWN0Lm1vZGVsVmVyc2lvbiA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/ICcwJyA6IDA7XG4gICAgICAgIG9iamVjdC5kb2NTdHJpbmcgPSAnJztcbiAgICAgICAgb2JqZWN0LmdyYXBoID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLmlyVmVyc2lvbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ2lyVmVyc2lvbicpKVxuICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuaXJWZXJzaW9uID09PSAnbnVtYmVyJylcbiAgICAgICAgICBvYmplY3QuaXJWZXJzaW9uID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gU3RyaW5nKG1lc3NhZ2UuaXJWZXJzaW9uKSA6IG1lc3NhZ2UuaXJWZXJzaW9uO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgb2JqZWN0LmlyVmVyc2lvbiA9XG4gICAgICAgICAgICBvcHRpb25zLmxvbmdzID09PSBTdHJpbmdcbiAgICAgICAgICAgICAgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1lc3NhZ2UuaXJWZXJzaW9uKVxuICAgICAgICAgICAgICA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlclxuICAgICAgICAgICAgICAgID8gbmV3ICR1dGlsLkxvbmdCaXRzKG1lc3NhZ2UuaXJWZXJzaW9uLmxvdyA+Pj4gMCwgbWVzc2FnZS5pclZlcnNpb24uaGlnaCA+Pj4gMCkudG9OdW1iZXIoKVxuICAgICAgICAgICAgICAgIDogbWVzc2FnZS5pclZlcnNpb247XG4gICAgICBpZiAobWVzc2FnZS5wcm9kdWNlck5hbWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdwcm9kdWNlck5hbWUnKSlcbiAgICAgICAgb2JqZWN0LnByb2R1Y2VyTmFtZSA9IG1lc3NhZ2UucHJvZHVjZXJOYW1lO1xuICAgICAgaWYgKG1lc3NhZ2UucHJvZHVjZXJWZXJzaW9uICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgncHJvZHVjZXJWZXJzaW9uJykpXG4gICAgICAgIG9iamVjdC5wcm9kdWNlclZlcnNpb24gPSBtZXNzYWdlLnByb2R1Y2VyVmVyc2lvbjtcbiAgICAgIGlmIChtZXNzYWdlLmRvbWFpbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ2RvbWFpbicpKSBvYmplY3QuZG9tYWluID0gbWVzc2FnZS5kb21haW47XG4gICAgICBpZiAobWVzc2FnZS5tb2RlbFZlcnNpb24gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdtb2RlbFZlcnNpb24nKSlcbiAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLm1vZGVsVmVyc2lvbiA9PT0gJ251bWJlcicpXG4gICAgICAgICAgb2JqZWN0Lm1vZGVsVmVyc2lvbiA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtZXNzYWdlLm1vZGVsVmVyc2lvbikgOiBtZXNzYWdlLm1vZGVsVmVyc2lvbjtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIG9iamVjdC5tb2RlbFZlcnNpb24gPVxuICAgICAgICAgICAgb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nXG4gICAgICAgICAgICAgID8gJHV0aWwuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtZXNzYWdlLm1vZGVsVmVyc2lvbilcbiAgICAgICAgICAgICAgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXJcbiAgICAgICAgICAgICAgICA/IG5ldyAkdXRpbC5Mb25nQml0cyhtZXNzYWdlLm1vZGVsVmVyc2lvbi5sb3cgPj4+IDAsIG1lc3NhZ2UubW9kZWxWZXJzaW9uLmhpZ2ggPj4+IDApLnRvTnVtYmVyKClcbiAgICAgICAgICAgICAgICA6IG1lc3NhZ2UubW9kZWxWZXJzaW9uO1xuICAgICAgaWYgKG1lc3NhZ2UuZG9jU3RyaW5nICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnZG9jU3RyaW5nJykpIG9iamVjdC5kb2NTdHJpbmcgPSBtZXNzYWdlLmRvY1N0cmluZztcbiAgICAgIGlmIChtZXNzYWdlLmdyYXBoICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnZ3JhcGgnKSlcbiAgICAgICAgb2JqZWN0LmdyYXBoID0gJHJvb3Qub25ueC5HcmFwaFByb3RvLnRvT2JqZWN0KG1lc3NhZ2UuZ3JhcGgsIG9wdGlvbnMpO1xuICAgICAgaWYgKG1lc3NhZ2Uub3BzZXRJbXBvcnQgJiYgbWVzc2FnZS5vcHNldEltcG9ydC5sZW5ndGgpIHtcbiAgICAgICAgb2JqZWN0Lm9wc2V0SW1wb3J0ID0gW107XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5vcHNldEltcG9ydC5sZW5ndGg7ICsrailcbiAgICAgICAgICBvYmplY3Qub3BzZXRJbXBvcnRbal0gPSAkcm9vdC5vbm54Lk9wZXJhdG9yU2V0SWRQcm90by50b09iamVjdChtZXNzYWdlLm9wc2V0SW1wb3J0W2pdLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLm1ldGFkYXRhUHJvcHMgJiYgbWVzc2FnZS5tZXRhZGF0YVByb3BzLmxlbmd0aCkge1xuICAgICAgICBvYmplY3QubWV0YWRhdGFQcm9wcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UubWV0YWRhdGFQcm9wcy5sZW5ndGg7ICsrailcbiAgICAgICAgICBvYmplY3QubWV0YWRhdGFQcm9wc1tqXSA9ICRyb290Lm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by50b09iamVjdChtZXNzYWdlLm1ldGFkYXRhUHJvcHNbal0sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UudHJhaW5pbmdJbmZvICYmIG1lc3NhZ2UudHJhaW5pbmdJbmZvLmxlbmd0aCkge1xuICAgICAgICBvYmplY3QudHJhaW5pbmdJbmZvID0gW107XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS50cmFpbmluZ0luZm8ubGVuZ3RoOyArK2opXG4gICAgICAgICAgb2JqZWN0LnRyYWluaW5nSW5mb1tqXSA9ICRyb290Lm9ubnguVHJhaW5pbmdJbmZvUHJvdG8udG9PYmplY3QobWVzc2FnZS50cmFpbmluZ0luZm9bal0sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UuZnVuY3Rpb25zICYmIG1lc3NhZ2UuZnVuY3Rpb25zLmxlbmd0aCkge1xuICAgICAgICBvYmplY3QuZnVuY3Rpb25zID0gW107XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5mdW5jdGlvbnMubGVuZ3RoOyArK2opXG4gICAgICAgICAgb2JqZWN0LmZ1bmN0aW9uc1tqXSA9ICRyb290Lm9ubnguRnVuY3Rpb25Qcm90by50b09iamVjdChtZXNzYWdlLmZ1bmN0aW9uc1tqXSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGlzIE1vZGVsUHJvdG8gdG8gSlNPTi5cbiAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICogQG1lbWJlcm9mIG9ubnguTW9kZWxQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcbiAgICAgKi9cbiAgICBNb2RlbFByb3RvLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZGVmYXVsdCB0eXBlIHVybCBmb3IgTW9kZWxQcm90b1xuICAgICAqIEBmdW5jdGlvbiBnZXRUeXBlVXJsXG4gICAgICogQG1lbWJlcm9mIG9ubnguTW9kZWxQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVVcmxQcmVmaXhdIHlvdXIgY3VzdG9tIHR5cGVVcmxQcmVmaXgoZGVmYXVsdCBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIilcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZGVmYXVsdCB0eXBlIHVybFxuICAgICAqL1xuICAgIE1vZGVsUHJvdG8uZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0eXBlVXJsUHJlZml4ID0gJ3R5cGUuZ29vZ2xlYXBpcy5jb20nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyAnL29ubnguTW9kZWxQcm90byc7XG4gICAgfTtcblxuICAgIHJldHVybiBNb2RlbFByb3RvO1xuICB9KSgpO1xuXG4gIG9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90byA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyBvZiBhIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uXG4gICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgKiBAaW50ZXJmYWNlIElTdHJpbmdTdHJpbmdFbnRyeVByb3RvXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW2tleV0gU3RyaW5nU3RyaW5nRW50cnlQcm90byBrZXlcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbdmFsdWVdIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8gdmFsdWVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgU3RyaW5nU3RyaW5nRW50cnlQcm90by5cbiAgICAgKiBAbWVtYmVyb2Ygb25ueFxuICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uXG4gICAgICogQGltcGxlbWVudHMgSVN0cmluZ1N0cmluZ0VudHJ5UHJvdG9cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge29ubnguSVN0cmluZ1N0cmluZ0VudHJ5UHJvdG89fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTdHJpbmdTdHJpbmdFbnRyeVByb3RvKHByb3BlcnRpZXMpIHtcbiAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKSB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdHJpbmdTdHJpbmdFbnRyeVByb3RvIGtleS5cbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IGtleVxuICAgICAqIEBtZW1iZXJvZiBvbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBTdHJpbmdTdHJpbmdFbnRyeVByb3RvLnByb3RvdHlwZS5rZXkgPSAnJztcblxuICAgIC8qKlxuICAgICAqIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8gdmFsdWUuXG4gICAgICogQG1lbWJlciB7c3RyaW5nfSB2YWx1ZVxuICAgICAqIEBtZW1iZXJvZiBvbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBTdHJpbmdTdHJpbmdFbnRyeVByb3RvLnByb3RvdHlwZS52YWx1ZSA9ICcnO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBTdHJpbmdTdHJpbmdFbnRyeVByb3RvIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXG4gICAgICogQG1lbWJlcm9mIG9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge29ubnguSVN0cmluZ1N0cmluZ0VudHJ5UHJvdG89fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgKiBAcmV0dXJucyB7b25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvfSBTdHJpbmdTdHJpbmdFbnRyeVByb3RvIGluc3RhbmNlXG4gICAgICovXG4gICAgU3RyaW5nU3RyaW5nRW50cnlQcm90by5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgcmV0dXJuIG5ldyBTdHJpbmdTdHJpbmdFbnRyeVByb3RvKHByb3BlcnRpZXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgU3RyaW5nU3RyaW5nRW50cnlQcm90byBtZXNzYWdlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICogQGZ1bmN0aW9uIGVuY29kZVxuICAgICAqIEBtZW1iZXJvZiBvbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtvbm54LklTdHJpbmdTdHJpbmdFbnRyeVByb3RvfSBtZXNzYWdlIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAqL1xuICAgIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgaWYgKCF3cml0ZXIpIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICBpZiAobWVzc2FnZS5rZXkgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCAna2V5JykpXG4gICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki8gMTApLnN0cmluZyhtZXNzYWdlLmtleSk7XG4gICAgICBpZiAobWVzc2FnZS52YWx1ZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsICd2YWx1ZScpKVxuICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDIsIHdpcmVUeXBlIDIgPSovIDE4KS5zdHJpbmcobWVzc2FnZS52YWx1ZSk7XG4gICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgU3RyaW5nU3RyaW5nRW50cnlQcm90byBtZXNzYWdlLCBsZW5ndGggZGVsaW1pdGVkLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAqIEBtZW1iZXJvZiBvbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtvbm54LklTdHJpbmdTdHJpbmdFbnRyeVByb3RvfSBtZXNzYWdlIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAqL1xuICAgIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlY29kZXMgYSBTdHJpbmdTdHJpbmdFbnRyeVByb3RvIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAqIEBtZW1iZXJvZiBvbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgKiBAcmV0dXJucyB7b25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvfSBTdHJpbmdTdHJpbmdFbnRyeVByb3RvXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgKi9cbiAgICBTdHJpbmdTdHJpbmdFbnRyeVByb3RvLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCxcbiAgICAgICAgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8oKTtcbiAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICBtZXNzYWdlLmtleSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgIG1lc3NhZ2UudmFsdWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlciwgbGVuZ3RoIGRlbGltaXRlZC5cbiAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXG4gICAgICogQG1lbWJlcm9mIG9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgKiBAcmV0dXJucyB7b25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvfSBTdHJpbmdTdHJpbmdFbnRyeVByb3RvXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgKi9cbiAgICBTdHJpbmdTdHJpbmdFbnRyeVByb3RvLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKSByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgYSBTdHJpbmdTdHJpbmdFbnRyeVByb3RvIG1lc3NhZ2UuXG4gICAgICogQGZ1bmN0aW9uIHZlcmlmeVxuICAgICAqIEBtZW1iZXJvZiBvbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XG4gICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAgICAgKi9cbiAgICBTdHJpbmdTdHJpbmdFbnRyeVByb3RvLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09ICdvYmplY3QnIHx8IG1lc3NhZ2UgPT09IG51bGwpIHJldHVybiAnb2JqZWN0IGV4cGVjdGVkJztcbiAgICAgIGlmIChtZXNzYWdlLmtleSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ2tleScpKVxuICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2Uua2V5KSkgcmV0dXJuICdrZXk6IHN0cmluZyBleHBlY3RlZCc7XG4gICAgICBpZiAobWVzc2FnZS52YWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ3ZhbHVlJykpXG4gICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS52YWx1ZSkpIHJldHVybiAndmFsdWU6IHN0cmluZyBleHBlY3RlZCc7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8gbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICogQG1lbWJlcm9mIG9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gICAgICogQHJldHVybnMge29ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90b30gU3RyaW5nU3RyaW5nRW50cnlQcm90b1xuICAgICAqL1xuICAgIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvKSByZXR1cm4gb2JqZWN0O1xuICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvKCk7XG4gICAgICBpZiAob2JqZWN0LmtleSAhPSBudWxsKSBtZXNzYWdlLmtleSA9IFN0cmluZyhvYmplY3Qua2V5KTtcbiAgICAgIGlmIChvYmplY3QudmFsdWUgIT0gbnVsbCkgbWVzc2FnZS52YWx1ZSA9IFN0cmluZyhvYmplY3QudmFsdWUpO1xuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8gbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxuICAgICAqIEBtZW1iZXJvZiBvbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtvbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG99IG1lc3NhZ2UgU3RyaW5nU3RyaW5nRW50cnlQcm90b1xuICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICovXG4gICAgU3RyaW5nU3RyaW5nRW50cnlQcm90by50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgb2JqZWN0LmtleSA9ICcnO1xuICAgICAgICBvYmplY3QudmFsdWUgPSAnJztcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLmtleSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ2tleScpKSBvYmplY3Qua2V5ID0gbWVzc2FnZS5rZXk7XG4gICAgICBpZiAobWVzc2FnZS52YWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ3ZhbHVlJykpIG9iamVjdC52YWx1ZSA9IG1lc3NhZ2UudmFsdWU7XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGlzIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8gdG8gSlNPTi5cbiAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICogQG1lbWJlcm9mIG9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcbiAgICAgKi9cbiAgICBTdHJpbmdTdHJpbmdFbnRyeVByb3RvLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZGVmYXVsdCB0eXBlIHVybCBmb3IgU3RyaW5nU3RyaW5nRW50cnlQcm90b1xuICAgICAqIEBmdW5jdGlvbiBnZXRUeXBlVXJsXG4gICAgICogQG1lbWJlcm9mIG9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVVcmxQcmVmaXhdIHlvdXIgY3VzdG9tIHR5cGVVcmxQcmVmaXgoZGVmYXVsdCBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIilcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZGVmYXVsdCB0eXBlIHVybFxuICAgICAqL1xuICAgIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0eXBlVXJsUHJlZml4ID0gJ3R5cGUuZ29vZ2xlYXBpcy5jb20nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyAnL29ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90byc7XG4gICAgfTtcblxuICAgIHJldHVybiBTdHJpbmdTdHJpbmdFbnRyeVByb3RvO1xuICB9KSgpO1xuXG4gIG9ubnguVGVuc29yQW5ub3RhdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyBvZiBhIFRlbnNvckFubm90YXRpb24uXG4gICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgKiBAaW50ZXJmYWNlIElUZW5zb3JBbm5vdGF0aW9uXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW3RlbnNvck5hbWVdIFRlbnNvckFubm90YXRpb24gdGVuc29yTmFtZVxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG9ubnguSVN0cmluZ1N0cmluZ0VudHJ5UHJvdG8+fG51bGx9IFtxdWFudFBhcmFtZXRlclRlbnNvck5hbWVzXSBUZW5zb3JBbm5vdGF0aW9uIHF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXNcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgVGVuc29yQW5ub3RhdGlvbi5cbiAgICAgKiBAbWVtYmVyb2Ygb25ueFxuICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIFRlbnNvckFubm90YXRpb24uXG4gICAgICogQGltcGxlbWVudHMgSVRlbnNvckFubm90YXRpb25cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge29ubnguSVRlbnNvckFubm90YXRpb249fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUZW5zb3JBbm5vdGF0aW9uKHByb3BlcnRpZXMpIHtcbiAgICAgIHRoaXMucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcyA9IFtdO1xuICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlbnNvckFubm90YXRpb24gdGVuc29yTmFtZS5cbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IHRlbnNvck5hbWVcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JBbm5vdGF0aW9uXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgVGVuc29yQW5ub3RhdGlvbi5wcm90b3R5cGUudGVuc29yTmFtZSA9ICcnO1xuXG4gICAgLyoqXG4gICAgICogVGVuc29yQW5ub3RhdGlvbiBxdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLlxuICAgICAqIEBtZW1iZXIge0FycmF5Ljxvbm54LklTdHJpbmdTdHJpbmdFbnRyeVByb3RvPn0gcXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lc1xuICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvckFubm90YXRpb25cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBUZW5zb3JBbm5vdGF0aW9uLnByb3RvdHlwZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgVGVuc29yQW5ub3RhdGlvbiBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxuICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvckFubm90YXRpb25cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtvbm54LklUZW5zb3JBbm5vdGF0aW9uPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICogQHJldHVybnMge29ubnguVGVuc29yQW5ub3RhdGlvbn0gVGVuc29yQW5ub3RhdGlvbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIFRlbnNvckFubm90YXRpb24uY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgIHJldHVybiBuZXcgVGVuc29yQW5ub3RhdGlvbihwcm9wZXJ0aWVzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIFRlbnNvckFubm90YXRpb24gbWVzc2FnZS4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5UZW5zb3JBbm5vdGF0aW9uLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAqIEBmdW5jdGlvbiBlbmNvZGVcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JBbm5vdGF0aW9uXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7b25ueC5JVGVuc29yQW5ub3RhdGlvbn0gbWVzc2FnZSBUZW5zb3JBbm5vdGF0aW9uIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgKi9cbiAgICBUZW5zb3JBbm5vdGF0aW9uLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgIGlmICghd3JpdGVyKSB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgaWYgKG1lc3NhZ2UudGVuc29yTmFtZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsICd0ZW5zb3JOYW1lJykpXG4gICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki8gMTApLnN0cmluZyhtZXNzYWdlLnRlbnNvck5hbWUpO1xuICAgICAgaWYgKG1lc3NhZ2UucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcyAhPSBudWxsICYmIG1lc3NhZ2UucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcy5sZW5ndGgpXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICRyb290Lm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5lbmNvZGUoXG4gICAgICAgICAgICBtZXNzYWdlLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXNbaV0sXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDIsIHdpcmVUeXBlIDIgPSovIDE4KS5mb3JrKCksXG4gICAgICAgICAgKS5sZGVsaW0oKTtcbiAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBUZW5zb3JBbm5vdGF0aW9uIG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguVGVuc29yQW5ub3RhdGlvbi52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgKiBAZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkXG4gICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yQW5ub3RhdGlvblxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge29ubnguSVRlbnNvckFubm90YXRpb259IG1lc3NhZ2UgVGVuc29yQW5ub3RhdGlvbiBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICovXG4gICAgVGVuc29yQW5ub3RhdGlvbi5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhIFRlbnNvckFubm90YXRpb24gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yQW5ub3RhdGlvblxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAqIEByZXR1cm5zIHtvbm54LlRlbnNvckFubm90YXRpb259IFRlbnNvckFubm90YXRpb25cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAqL1xuICAgIFRlbnNvckFubm90YXRpb24uZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSkgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLFxuICAgICAgICBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguVGVuc29yQW5ub3RhdGlvbigpO1xuICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgIG1lc3NhZ2UudGVuc29yTmFtZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgIGlmICghKG1lc3NhZ2UucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcyAmJiBtZXNzYWdlLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMubGVuZ3RoKSlcbiAgICAgICAgICAgICAgbWVzc2FnZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzID0gW107XG4gICAgICAgICAgICBtZXNzYWdlLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMucHVzaCgkcm9vdC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhIFRlbnNvckFubm90YXRpb24gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlciwgbGVuZ3RoIGRlbGltaXRlZC5cbiAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXG4gICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yQW5ub3RhdGlvblxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgKiBAcmV0dXJucyB7b25ueC5UZW5zb3JBbm5vdGF0aW9ufSBUZW5zb3JBbm5vdGF0aW9uXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgKi9cbiAgICBUZW5zb3JBbm5vdGF0aW9uLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKSByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgYSBUZW5zb3JBbm5vdGF0aW9uIG1lc3NhZ2UuXG4gICAgICogQGZ1bmN0aW9uIHZlcmlmeVxuICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvckFubm90YXRpb25cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XG4gICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAgICAgKi9cbiAgICBUZW5zb3JBbm5vdGF0aW9uLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09ICdvYmplY3QnIHx8IG1lc3NhZ2UgPT09IG51bGwpIHJldHVybiAnb2JqZWN0IGV4cGVjdGVkJztcbiAgICAgIGlmIChtZXNzYWdlLnRlbnNvck5hbWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCd0ZW5zb3JOYW1lJykpXG4gICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS50ZW5zb3JOYW1lKSkgcmV0dXJuICd0ZW5zb3JOYW1lOiBzdHJpbmcgZXhwZWN0ZWQnO1xuICAgICAgaWYgKG1lc3NhZ2UucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ3F1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMnKSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzKSkgcmV0dXJuICdxdWFudFBhcmFtZXRlclRlbnNvck5hbWVzOiBhcnJheSBleHBlY3RlZCc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLnZlcmlmeShtZXNzYWdlLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXNbaV0pO1xuICAgICAgICAgIGlmIChlcnJvcikgcmV0dXJuICdxdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLicgKyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBUZW5zb3JBbm5vdGF0aW9uIG1lc3NhZ2UgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cbiAgICAgKiBAZnVuY3Rpb24gZnJvbU9iamVjdFxuICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvckFubm90YXRpb25cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICAgICAqIEByZXR1cm5zIHtvbm54LlRlbnNvckFubm90YXRpb259IFRlbnNvckFubm90YXRpb25cbiAgICAgKi9cbiAgICBUZW5zb3JBbm5vdGF0aW9uLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290Lm9ubnguVGVuc29yQW5ub3RhdGlvbikgcmV0dXJuIG9iamVjdDtcbiAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguVGVuc29yQW5ub3RhdGlvbigpO1xuICAgICAgaWYgKG9iamVjdC50ZW5zb3JOYW1lICE9IG51bGwpIG1lc3NhZ2UudGVuc29yTmFtZSA9IFN0cmluZyhvYmplY3QudGVuc29yTmFtZSk7XG4gICAgICBpZiAob2JqZWN0LnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzKSlcbiAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJy5vbm54LlRlbnNvckFubm90YXRpb24ucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lczogYXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgbWVzc2FnZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzW2ldICE9PSAnb2JqZWN0JylcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcignLm9ubnguVGVuc29yQW5ub3RhdGlvbi5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzOiBvYmplY3QgZXhwZWN0ZWQnKTtcbiAgICAgICAgICBtZXNzYWdlLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXNbaV0gPSAkcm9vdC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZnJvbU9iamVjdChcbiAgICAgICAgICAgIG9iamVjdC5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzW2ldLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYSBUZW5zb3JBbm5vdGF0aW9uIG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JBbm5vdGF0aW9uXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7b25ueC5UZW5zb3JBbm5vdGF0aW9ufSBtZXNzYWdlIFRlbnNvckFubm90YXRpb25cbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICAgICAqL1xuICAgIFRlbnNvckFubm90YXRpb24udG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgIGlmIChvcHRpb25zLmFycmF5cyB8fCBvcHRpb25zLmRlZmF1bHRzKSBvYmplY3QucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcyA9IFtdO1xuICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIG9iamVjdC50ZW5zb3JOYW1lID0gJyc7XG4gICAgICBpZiAobWVzc2FnZS50ZW5zb3JOYW1lICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgndGVuc29yTmFtZScpKSBvYmplY3QudGVuc29yTmFtZSA9IG1lc3NhZ2UudGVuc29yTmFtZTtcbiAgICAgIGlmIChtZXNzYWdlLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMgJiYgbWVzc2FnZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLmxlbmd0aCkge1xuICAgICAgICBvYmplY3QucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcy5sZW5ndGg7ICsrailcbiAgICAgICAgICBvYmplY3QucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lc1tqXSA9ICRyb290Lm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by50b09iamVjdChcbiAgICAgICAgICAgIG1lc3NhZ2UucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lc1tqXSxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoaXMgVGVuc29yQW5ub3RhdGlvbiB0byBKU09OLlxuICAgICAqIEBmdW5jdGlvbiB0b0pTT05cbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JBbm5vdGF0aW9uXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICAgICAqL1xuICAgIFRlbnNvckFubm90YXRpb24ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBkZWZhdWx0IHR5cGUgdXJsIGZvciBUZW5zb3JBbm5vdGF0aW9uXG4gICAgICogQGZ1bmN0aW9uIGdldFR5cGVVcmxcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JBbm5vdGF0aW9uXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZVVybFByZWZpeF0geW91ciBjdXN0b20gdHlwZVVybFByZWZpeChkZWZhdWx0IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiKVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBkZWZhdWx0IHR5cGUgdXJsXG4gICAgICovXG4gICAgVGVuc29yQW5ub3RhdGlvbi5nZXRUeXBlVXJsID0gZnVuY3Rpb24gZ2V0VHlwZVVybCh0eXBlVXJsUHJlZml4KSB7XG4gICAgICBpZiAodHlwZVVybFByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHR5cGVVcmxQcmVmaXggPSAndHlwZS5nb29nbGVhcGlzLmNvbSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZVVybFByZWZpeCArICcvb25ueC5UZW5zb3JBbm5vdGF0aW9uJztcbiAgICB9O1xuXG4gICAgcmV0dXJuIFRlbnNvckFubm90YXRpb247XG4gIH0pKCk7XG5cbiAgb25ueC5HcmFwaFByb3RvID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgR3JhcGhQcm90by5cbiAgICAgKiBAbWVtYmVyb2Ygb25ueFxuICAgICAqIEBpbnRlcmZhY2UgSUdyYXBoUHJvdG9cbiAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LklOb2RlUHJvdG8+fG51bGx9IFtub2RlXSBHcmFwaFByb3RvIG5vZGVcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbbmFtZV0gR3JhcGhQcm90byBuYW1lXG4gICAgICogQHByb3BlcnR5IHtBcnJheS48b25ueC5JVGVuc29yUHJvdG8+fG51bGx9IFtpbml0aWFsaXplcl0gR3JhcGhQcm90byBpbml0aWFsaXplclxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG9ubnguSVNwYXJzZVRlbnNvclByb3RvPnxudWxsfSBbc3BhcnNlSW5pdGlhbGl6ZXJdIEdyYXBoUHJvdG8gc3BhcnNlSW5pdGlhbGl6ZXJcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbZG9jU3RyaW5nXSBHcmFwaFByb3RvIGRvY1N0cmluZ1xuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG9ubnguSVZhbHVlSW5mb1Byb3RvPnxudWxsfSBbaW5wdXRdIEdyYXBoUHJvdG8gaW5wdXRcbiAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LklWYWx1ZUluZm9Qcm90bz58bnVsbH0gW291dHB1dF0gR3JhcGhQcm90byBvdXRwdXRcbiAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LklWYWx1ZUluZm9Qcm90bz58bnVsbH0gW3ZhbHVlSW5mb10gR3JhcGhQcm90byB2YWx1ZUluZm9cbiAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LklUZW5zb3JBbm5vdGF0aW9uPnxudWxsfSBbcXVhbnRpemF0aW9uQW5ub3RhdGlvbl0gR3JhcGhQcm90byBxdWFudGl6YXRpb25Bbm5vdGF0aW9uXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IEdyYXBoUHJvdG8uXG4gICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBHcmFwaFByb3RvLlxuICAgICAqIEBpbXBsZW1lbnRzIElHcmFwaFByb3RvXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtvbm54LklHcmFwaFByb3RvPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICovXG4gICAgZnVuY3Rpb24gR3JhcGhQcm90byhwcm9wZXJ0aWVzKSB7XG4gICAgICB0aGlzLm5vZGUgPSBbXTtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZXIgPSBbXTtcbiAgICAgIHRoaXMuc3BhcnNlSW5pdGlhbGl6ZXIgPSBbXTtcbiAgICAgIHRoaXMuaW5wdXQgPSBbXTtcbiAgICAgIHRoaXMub3V0cHV0ID0gW107XG4gICAgICB0aGlzLnZhbHVlSW5mbyA9IFtdO1xuICAgICAgdGhpcy5xdWFudGl6YXRpb25Bbm5vdGF0aW9uID0gW107XG4gICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbCkgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR3JhcGhQcm90byBub2RlLlxuICAgICAqIEBtZW1iZXIge0FycmF5Ljxvbm54LklOb2RlUHJvdG8+fSBub2RlXG4gICAgICogQG1lbWJlcm9mIG9ubnguR3JhcGhQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIEdyYXBoUHJvdG8ucHJvdG90eXBlLm5vZGUgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgLyoqXG4gICAgICogR3JhcGhQcm90byBuYW1lLlxuICAgICAqIEBtZW1iZXIge3N0cmluZ30gbmFtZVxuICAgICAqIEBtZW1iZXJvZiBvbm54LkdyYXBoUHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBHcmFwaFByb3RvLnByb3RvdHlwZS5uYW1lID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBHcmFwaFByb3RvIGluaXRpYWxpemVyLlxuICAgICAqIEBtZW1iZXIge0FycmF5Ljxvbm54LklUZW5zb3JQcm90bz59IGluaXRpYWxpemVyXG4gICAgICogQG1lbWJlcm9mIG9ubnguR3JhcGhQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIEdyYXBoUHJvdG8ucHJvdG90eXBlLmluaXRpYWxpemVyID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgIC8qKlxuICAgICAqIEdyYXBoUHJvdG8gc3BhcnNlSW5pdGlhbGl6ZXIuXG4gICAgICogQG1lbWJlciB7QXJyYXkuPG9ubnguSVNwYXJzZVRlbnNvclByb3RvPn0gc3BhcnNlSW5pdGlhbGl6ZXJcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5HcmFwaFByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgR3JhcGhQcm90by5wcm90b3R5cGUuc3BhcnNlSW5pdGlhbGl6ZXIgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgLyoqXG4gICAgICogR3JhcGhQcm90byBkb2NTdHJpbmcuXG4gICAgICogQG1lbWJlciB7c3RyaW5nfSBkb2NTdHJpbmdcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5HcmFwaFByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgR3JhcGhQcm90by5wcm90b3R5cGUuZG9jU3RyaW5nID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBHcmFwaFByb3RvIGlucHV0LlxuICAgICAqIEBtZW1iZXIge0FycmF5Ljxvbm54LklWYWx1ZUluZm9Qcm90bz59IGlucHV0XG4gICAgICogQG1lbWJlcm9mIG9ubnguR3JhcGhQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIEdyYXBoUHJvdG8ucHJvdG90eXBlLmlucHV0ID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgIC8qKlxuICAgICAqIEdyYXBoUHJvdG8gb3V0cHV0LlxuICAgICAqIEBtZW1iZXIge0FycmF5Ljxvbm54LklWYWx1ZUluZm9Qcm90bz59IG91dHB1dFxuICAgICAqIEBtZW1iZXJvZiBvbm54LkdyYXBoUHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBHcmFwaFByb3RvLnByb3RvdHlwZS5vdXRwdXQgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgLyoqXG4gICAgICogR3JhcGhQcm90byB2YWx1ZUluZm8uXG4gICAgICogQG1lbWJlciB7QXJyYXkuPG9ubnguSVZhbHVlSW5mb1Byb3RvPn0gdmFsdWVJbmZvXG4gICAgICogQG1lbWJlcm9mIG9ubnguR3JhcGhQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIEdyYXBoUHJvdG8ucHJvdG90eXBlLnZhbHVlSW5mbyA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAvKipcbiAgICAgKiBHcmFwaFByb3RvIHF1YW50aXphdGlvbkFubm90YXRpb24uXG4gICAgICogQG1lbWJlciB7QXJyYXkuPG9ubnguSVRlbnNvckFubm90YXRpb24+fSBxdWFudGl6YXRpb25Bbm5vdGF0aW9uXG4gICAgICogQG1lbWJlcm9mIG9ubnguR3JhcGhQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIEdyYXBoUHJvdG8ucHJvdG90eXBlLnF1YW50aXphdGlvbkFubm90YXRpb24gPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBHcmFwaFByb3RvIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXG4gICAgICogQG1lbWJlcm9mIG9ubnguR3JhcGhQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge29ubnguSUdyYXBoUHJvdG89fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgKiBAcmV0dXJucyB7b25ueC5HcmFwaFByb3RvfSBHcmFwaFByb3RvIGluc3RhbmNlXG4gICAgICovXG4gICAgR3JhcGhQcm90by5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgcmV0dXJuIG5ldyBHcmFwaFByb3RvKHByb3BlcnRpZXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgR3JhcGhQcm90byBtZXNzYWdlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LkdyYXBoUHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICogQGZ1bmN0aW9uIGVuY29kZVxuICAgICAqIEBtZW1iZXJvZiBvbm54LkdyYXBoUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtvbm54LklHcmFwaFByb3RvfSBtZXNzYWdlIEdyYXBoUHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAqL1xuICAgIEdyYXBoUHJvdG8uZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgaWYgKCF3cml0ZXIpIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICBpZiAobWVzc2FnZS5ub2RlICE9IG51bGwgJiYgbWVzc2FnZS5ub2RlLmxlbmd0aClcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLm5vZGUubGVuZ3RoOyArK2kpXG4gICAgICAgICAgJHJvb3Qub25ueC5Ob2RlUHJvdG8uZW5jb2RlKG1lc3NhZ2Uubm9kZVtpXSwgd3JpdGVyLnVpbnQzMigvKiBpZCAxLCB3aXJlVHlwZSAyID0qLyAxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCAnbmFtZScpKVxuICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDIsIHdpcmVUeXBlIDIgPSovIDE4KS5zdHJpbmcobWVzc2FnZS5uYW1lKTtcbiAgICAgIGlmIChtZXNzYWdlLmluaXRpYWxpemVyICE9IG51bGwgJiYgbWVzc2FnZS5pbml0aWFsaXplci5sZW5ndGgpXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5pbml0aWFsaXplci5sZW5ndGg7ICsraSlcbiAgICAgICAgICAkcm9vdC5vbm54LlRlbnNvclByb3RvLmVuY29kZShcbiAgICAgICAgICAgIG1lc3NhZ2UuaW5pdGlhbGl6ZXJbaV0sXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDUsIHdpcmVUeXBlIDIgPSovIDQyKS5mb3JrKCksXG4gICAgICAgICAgKS5sZGVsaW0oKTtcbiAgICAgIGlmIChtZXNzYWdlLmRvY1N0cmluZyAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsICdkb2NTdHJpbmcnKSlcbiAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAxMCwgd2lyZVR5cGUgMiA9Ki8gODIpLnN0cmluZyhtZXNzYWdlLmRvY1N0cmluZyk7XG4gICAgICBpZiAobWVzc2FnZS5pbnB1dCAhPSBudWxsICYmIG1lc3NhZ2UuaW5wdXQubGVuZ3RoKVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuaW5wdXQubGVuZ3RoOyArK2kpXG4gICAgICAgICAgJHJvb3Qub25ueC5WYWx1ZUluZm9Qcm90by5lbmNvZGUoXG4gICAgICAgICAgICBtZXNzYWdlLmlucHV0W2ldLFxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAxMSwgd2lyZVR5cGUgMiA9Ki8gOTApLmZvcmsoKSxcbiAgICAgICAgICApLmxkZWxpbSgpO1xuICAgICAgaWYgKG1lc3NhZ2Uub3V0cHV0ICE9IG51bGwgJiYgbWVzc2FnZS5vdXRwdXQubGVuZ3RoKVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2Uub3V0cHV0Lmxlbmd0aDsgKytpKVxuICAgICAgICAgICRyb290Lm9ubnguVmFsdWVJbmZvUHJvdG8uZW5jb2RlKFxuICAgICAgICAgICAgbWVzc2FnZS5vdXRwdXRbaV0sXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDEyLCB3aXJlVHlwZSAyID0qLyA5OCkuZm9yaygpLFxuICAgICAgICAgICkubGRlbGltKCk7XG4gICAgICBpZiAobWVzc2FnZS52YWx1ZUluZm8gIT0gbnVsbCAmJiBtZXNzYWdlLnZhbHVlSW5mby5sZW5ndGgpXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS52YWx1ZUluZm8ubGVuZ3RoOyArK2kpXG4gICAgICAgICAgJHJvb3Qub25ueC5WYWx1ZUluZm9Qcm90by5lbmNvZGUoXG4gICAgICAgICAgICBtZXNzYWdlLnZhbHVlSW5mb1tpXSxcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMTMsIHdpcmVUeXBlIDIgPSovIDEwNikuZm9yaygpLFxuICAgICAgICAgICkubGRlbGltKCk7XG4gICAgICBpZiAobWVzc2FnZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uICE9IG51bGwgJiYgbWVzc2FnZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uLmxlbmd0aClcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnF1YW50aXphdGlvbkFubm90YXRpb24ubGVuZ3RoOyArK2kpXG4gICAgICAgICAgJHJvb3Qub25ueC5UZW5zb3JBbm5vdGF0aW9uLmVuY29kZShcbiAgICAgICAgICAgIG1lc3NhZ2UucXVhbnRpemF0aW9uQW5ub3RhdGlvbltpXSxcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMTQsIHdpcmVUeXBlIDIgPSovIDExNCkuZm9yaygpLFxuICAgICAgICAgICkubGRlbGltKCk7XG4gICAgICBpZiAobWVzc2FnZS5zcGFyc2VJbml0aWFsaXplciAhPSBudWxsICYmIG1lc3NhZ2Uuc3BhcnNlSW5pdGlhbGl6ZXIubGVuZ3RoKVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2Uuc3BhcnNlSW5pdGlhbGl6ZXIubGVuZ3RoOyArK2kpXG4gICAgICAgICAgJHJvb3Qub25ueC5TcGFyc2VUZW5zb3JQcm90by5lbmNvZGUoXG4gICAgICAgICAgICBtZXNzYWdlLnNwYXJzZUluaXRpYWxpemVyW2ldLFxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAxNSwgd2lyZVR5cGUgMiA9Ki8gMTIyKS5mb3JrKCksXG4gICAgICAgICAgKS5sZGVsaW0oKTtcbiAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBHcmFwaFByb3RvIG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguR3JhcGhQcm90by52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgKiBAZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkXG4gICAgICogQG1lbWJlcm9mIG9ubnguR3JhcGhQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge29ubnguSUdyYXBoUHJvdG99IG1lc3NhZ2UgR3JhcGhQcm90byBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICovXG4gICAgR3JhcGhQcm90by5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhIEdyYXBoUHJvdG8gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICogQG1lbWJlcm9mIG9ubnguR3JhcGhQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAqIEByZXR1cm5zIHtvbm54LkdyYXBoUHJvdG99IEdyYXBoUHJvdG9cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAqL1xuICAgIEdyYXBoUHJvdG8uZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSkgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLFxuICAgICAgICBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguR3JhcGhQcm90bygpO1xuICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgIGlmICghKG1lc3NhZ2Uubm9kZSAmJiBtZXNzYWdlLm5vZGUubGVuZ3RoKSkgbWVzc2FnZS5ub2RlID0gW107XG4gICAgICAgICAgICBtZXNzYWdlLm5vZGUucHVzaCgkcm9vdC5vbm54Lk5vZGVQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgIG1lc3NhZ2UubmFtZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDU6IHtcbiAgICAgICAgICAgIGlmICghKG1lc3NhZ2UuaW5pdGlhbGl6ZXIgJiYgbWVzc2FnZS5pbml0aWFsaXplci5sZW5ndGgpKSBtZXNzYWdlLmluaXRpYWxpemVyID0gW107XG4gICAgICAgICAgICBtZXNzYWdlLmluaXRpYWxpemVyLnB1c2goJHJvb3Qub25ueC5UZW5zb3JQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDE1OiB7XG4gICAgICAgICAgICBpZiAoIShtZXNzYWdlLnNwYXJzZUluaXRpYWxpemVyICYmIG1lc3NhZ2Uuc3BhcnNlSW5pdGlhbGl6ZXIubGVuZ3RoKSkgbWVzc2FnZS5zcGFyc2VJbml0aWFsaXplciA9IFtdO1xuICAgICAgICAgICAgbWVzc2FnZS5zcGFyc2VJbml0aWFsaXplci5wdXNoKCRyb290Lm9ubnguU3BhcnNlVGVuc29yUHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAxMDoge1xuICAgICAgICAgICAgbWVzc2FnZS5kb2NTdHJpbmcgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAxMToge1xuICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5pbnB1dCAmJiBtZXNzYWdlLmlucHV0Lmxlbmd0aCkpIG1lc3NhZ2UuaW5wdXQgPSBbXTtcbiAgICAgICAgICAgIG1lc3NhZ2UuaW5wdXQucHVzaCgkcm9vdC5vbm54LlZhbHVlSW5mb1Byb3RvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMTI6IHtcbiAgICAgICAgICAgIGlmICghKG1lc3NhZ2Uub3V0cHV0ICYmIG1lc3NhZ2Uub3V0cHV0Lmxlbmd0aCkpIG1lc3NhZ2Uub3V0cHV0ID0gW107XG4gICAgICAgICAgICBtZXNzYWdlLm91dHB1dC5wdXNoKCRyb290Lm9ubnguVmFsdWVJbmZvUHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAxMzoge1xuICAgICAgICAgICAgaWYgKCEobWVzc2FnZS52YWx1ZUluZm8gJiYgbWVzc2FnZS52YWx1ZUluZm8ubGVuZ3RoKSkgbWVzc2FnZS52YWx1ZUluZm8gPSBbXTtcbiAgICAgICAgICAgIG1lc3NhZ2UudmFsdWVJbmZvLnB1c2goJHJvb3Qub25ueC5WYWx1ZUluZm9Qcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDE0OiB7XG4gICAgICAgICAgICBpZiAoIShtZXNzYWdlLnF1YW50aXphdGlvbkFubm90YXRpb24gJiYgbWVzc2FnZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uLmxlbmd0aCkpXG4gICAgICAgICAgICAgIG1lc3NhZ2UucXVhbnRpemF0aW9uQW5ub3RhdGlvbiA9IFtdO1xuICAgICAgICAgICAgbWVzc2FnZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uLnB1c2goJHJvb3Qub25ueC5UZW5zb3JBbm5vdGF0aW9uLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlY29kZXMgYSBHcmFwaFByb3RvIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICogQGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZFxuICAgICAqIEBtZW1iZXJvZiBvbm54LkdyYXBoUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICogQHJldHVybnMge29ubnguR3JhcGhQcm90b30gR3JhcGhQcm90b1xuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICovXG4gICAgR3JhcGhQcm90by5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSkgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFZlcmlmaWVzIGEgR3JhcGhQcm90byBtZXNzYWdlLlxuICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5HcmFwaFByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XG4gICAgICovXG4gICAgR3JhcGhQcm90by52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSAnb2JqZWN0JyB8fCBtZXNzYWdlID09PSBudWxsKSByZXR1cm4gJ29iamVjdCBleHBlY3RlZCc7XG4gICAgICBpZiAobWVzc2FnZS5ub2RlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnbm9kZScpKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLm5vZGUpKSByZXR1cm4gJ25vZGU6IGFycmF5IGV4cGVjdGVkJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLm5vZGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54Lk5vZGVQcm90by52ZXJpZnkobWVzc2FnZS5ub2RlW2ldKTtcbiAgICAgICAgICBpZiAoZXJyb3IpIHJldHVybiAnbm9kZS4nICsgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCduYW1lJykpXG4gICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5uYW1lKSkgcmV0dXJuICduYW1lOiBzdHJpbmcgZXhwZWN0ZWQnO1xuICAgICAgaWYgKG1lc3NhZ2UuaW5pdGlhbGl6ZXIgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdpbml0aWFsaXplcicpKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLmluaXRpYWxpemVyKSkgcmV0dXJuICdpbml0aWFsaXplcjogYXJyYXkgZXhwZWN0ZWQnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuaW5pdGlhbGl6ZXIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LlRlbnNvclByb3RvLnZlcmlmeShtZXNzYWdlLmluaXRpYWxpemVyW2ldKTtcbiAgICAgICAgICBpZiAoZXJyb3IpIHJldHVybiAnaW5pdGlhbGl6ZXIuJyArIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5zcGFyc2VJbml0aWFsaXplciAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ3NwYXJzZUluaXRpYWxpemVyJykpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2Uuc3BhcnNlSW5pdGlhbGl6ZXIpKSByZXR1cm4gJ3NwYXJzZUluaXRpYWxpemVyOiBhcnJheSBleHBlY3RlZCc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5zcGFyc2VJbml0aWFsaXplci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguU3BhcnNlVGVuc29yUHJvdG8udmVyaWZ5KG1lc3NhZ2Uuc3BhcnNlSW5pdGlhbGl6ZXJbaV0pO1xuICAgICAgICAgIGlmIChlcnJvcikgcmV0dXJuICdzcGFyc2VJbml0aWFsaXplci4nICsgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLmRvY1N0cmluZyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ2RvY1N0cmluZycpKVxuICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UuZG9jU3RyaW5nKSkgcmV0dXJuICdkb2NTdHJpbmc6IHN0cmluZyBleHBlY3RlZCc7XG4gICAgICBpZiAobWVzc2FnZS5pbnB1dCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ2lucHV0JykpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UuaW5wdXQpKSByZXR1cm4gJ2lucHV0OiBhcnJheSBleHBlY3RlZCc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5pbnB1dC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguVmFsdWVJbmZvUHJvdG8udmVyaWZ5KG1lc3NhZ2UuaW5wdXRbaV0pO1xuICAgICAgICAgIGlmIChlcnJvcikgcmV0dXJuICdpbnB1dC4nICsgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLm91dHB1dCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ291dHB1dCcpKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLm91dHB1dCkpIHJldHVybiAnb3V0cHV0OiBhcnJheSBleHBlY3RlZCc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5vdXRwdXQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LlZhbHVlSW5mb1Byb3RvLnZlcmlmeShtZXNzYWdlLm91dHB1dFtpXSk7XG4gICAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gJ291dHB1dC4nICsgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLnZhbHVlSW5mbyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ3ZhbHVlSW5mbycpKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLnZhbHVlSW5mbykpIHJldHVybiAndmFsdWVJbmZvOiBhcnJheSBleHBlY3RlZCc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS52YWx1ZUluZm8ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LlZhbHVlSW5mb1Byb3RvLnZlcmlmeShtZXNzYWdlLnZhbHVlSW5mb1tpXSk7XG4gICAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gJ3ZhbHVlSW5mby4nICsgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLnF1YW50aXphdGlvbkFubm90YXRpb24gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdxdWFudGl6YXRpb25Bbm5vdGF0aW9uJykpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UucXVhbnRpemF0aW9uQW5ub3RhdGlvbikpIHJldHVybiAncXVhbnRpemF0aW9uQW5ub3RhdGlvbjogYXJyYXkgZXhwZWN0ZWQnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UucXVhbnRpemF0aW9uQW5ub3RhdGlvbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguVGVuc29yQW5ub3RhdGlvbi52ZXJpZnkobWVzc2FnZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uW2ldKTtcbiAgICAgICAgICBpZiAoZXJyb3IpIHJldHVybiAncXVhbnRpemF0aW9uQW5ub3RhdGlvbi4nICsgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgR3JhcGhQcm90byBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gICAgICogQGZ1bmN0aW9uIGZyb21PYmplY3RcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5HcmFwaFByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7b25ueC5HcmFwaFByb3RvfSBHcmFwaFByb3RvXG4gICAgICovXG4gICAgR3JhcGhQcm90by5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5vbm54LkdyYXBoUHJvdG8pIHJldHVybiBvYmplY3Q7XG4gICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LkdyYXBoUHJvdG8oKTtcbiAgICAgIGlmIChvYmplY3Qubm9kZSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0Lm5vZGUpKSB0aHJvdyBUeXBlRXJyb3IoJy5vbm54LkdyYXBoUHJvdG8ubm9kZTogYXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgbWVzc2FnZS5ub2RlID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0Lm5vZGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5ub2RlW2ldICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCcub25ueC5HcmFwaFByb3RvLm5vZGU6IG9iamVjdCBleHBlY3RlZCcpO1xuICAgICAgICAgIG1lc3NhZ2Uubm9kZVtpXSA9ICRyb290Lm9ubnguTm9kZVByb3RvLmZyb21PYmplY3Qob2JqZWN0Lm5vZGVbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0Lm5hbWUgIT0gbnVsbCkgbWVzc2FnZS5uYW1lID0gU3RyaW5nKG9iamVjdC5uYW1lKTtcbiAgICAgIGlmIChvYmplY3QuaW5pdGlhbGl6ZXIpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5pbml0aWFsaXplcikpIHRocm93IFR5cGVFcnJvcignLm9ubnguR3JhcGhQcm90by5pbml0aWFsaXplcjogYXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgbWVzc2FnZS5pbml0aWFsaXplciA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5pbml0aWFsaXplci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmluaXRpYWxpemVyW2ldICE9PSAnb2JqZWN0JylcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcignLm9ubnguR3JhcGhQcm90by5pbml0aWFsaXplcjogb2JqZWN0IGV4cGVjdGVkJyk7XG4gICAgICAgICAgbWVzc2FnZS5pbml0aWFsaXplcltpXSA9ICRyb290Lm9ubnguVGVuc29yUHJvdG8uZnJvbU9iamVjdChvYmplY3QuaW5pdGlhbGl6ZXJbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0LnNwYXJzZUluaXRpYWxpemVyKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3Quc3BhcnNlSW5pdGlhbGl6ZXIpKVxuICAgICAgICAgIHRocm93IFR5cGVFcnJvcignLm9ubnguR3JhcGhQcm90by5zcGFyc2VJbml0aWFsaXplcjogYXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgbWVzc2FnZS5zcGFyc2VJbml0aWFsaXplciA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5zcGFyc2VJbml0aWFsaXplci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnNwYXJzZUluaXRpYWxpemVyW2ldICE9PSAnb2JqZWN0JylcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcignLm9ubnguR3JhcGhQcm90by5zcGFyc2VJbml0aWFsaXplcjogb2JqZWN0IGV4cGVjdGVkJyk7XG4gICAgICAgICAgbWVzc2FnZS5zcGFyc2VJbml0aWFsaXplcltpXSA9ICRyb290Lm9ubnguU3BhcnNlVGVuc29yUHJvdG8uZnJvbU9iamVjdChvYmplY3Quc3BhcnNlSW5pdGlhbGl6ZXJbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0LmRvY1N0cmluZyAhPSBudWxsKSBtZXNzYWdlLmRvY1N0cmluZyA9IFN0cmluZyhvYmplY3QuZG9jU3RyaW5nKTtcbiAgICAgIGlmIChvYmplY3QuaW5wdXQpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5pbnB1dCkpIHRocm93IFR5cGVFcnJvcignLm9ubnguR3JhcGhQcm90by5pbnB1dDogYXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgbWVzc2FnZS5pbnB1dCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5pbnB1dC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmlucHV0W2ldICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCcub25ueC5HcmFwaFByb3RvLmlucHV0OiBvYmplY3QgZXhwZWN0ZWQnKTtcbiAgICAgICAgICBtZXNzYWdlLmlucHV0W2ldID0gJHJvb3Qub25ueC5WYWx1ZUluZm9Qcm90by5mcm9tT2JqZWN0KG9iamVjdC5pbnB1dFtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3Qub3V0cHV0KSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3Qub3V0cHV0KSkgdGhyb3cgVHlwZUVycm9yKCcub25ueC5HcmFwaFByb3RvLm91dHB1dDogYXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgbWVzc2FnZS5vdXRwdXQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3Qub3V0cHV0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3Qub3V0cHV0W2ldICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCcub25ueC5HcmFwaFByb3RvLm91dHB1dDogb2JqZWN0IGV4cGVjdGVkJyk7XG4gICAgICAgICAgbWVzc2FnZS5vdXRwdXRbaV0gPSAkcm9vdC5vbm54LlZhbHVlSW5mb1Byb3RvLmZyb21PYmplY3Qob2JqZWN0Lm91dHB1dFtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3QudmFsdWVJbmZvKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QudmFsdWVJbmZvKSkgdGhyb3cgVHlwZUVycm9yKCcub25ueC5HcmFwaFByb3RvLnZhbHVlSW5mbzogYXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgbWVzc2FnZS52YWx1ZUluZm8gPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QudmFsdWVJbmZvLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QudmFsdWVJbmZvW2ldICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCcub25ueC5HcmFwaFByb3RvLnZhbHVlSW5mbzogb2JqZWN0IGV4cGVjdGVkJyk7XG4gICAgICAgICAgbWVzc2FnZS52YWx1ZUluZm9baV0gPSAkcm9vdC5vbm54LlZhbHVlSW5mb1Byb3RvLmZyb21PYmplY3Qob2JqZWN0LnZhbHVlSW5mb1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3QucXVhbnRpemF0aW9uQW5ub3RhdGlvbikge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LnF1YW50aXphdGlvbkFubm90YXRpb24pKVxuICAgICAgICAgIHRocm93IFR5cGVFcnJvcignLm9ubnguR3JhcGhQcm90by5xdWFudGl6YXRpb25Bbm5vdGF0aW9uOiBhcnJheSBleHBlY3RlZCcpO1xuICAgICAgICBtZXNzYWdlLnF1YW50aXphdGlvbkFubm90YXRpb24gPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QucXVhbnRpemF0aW9uQW5ub3RhdGlvbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnF1YW50aXphdGlvbkFubm90YXRpb25baV0gIT09ICdvYmplY3QnKVxuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCcub25ueC5HcmFwaFByb3RvLnF1YW50aXphdGlvbkFubm90YXRpb246IG9iamVjdCBleHBlY3RlZCcpO1xuICAgICAgICAgIG1lc3NhZ2UucXVhbnRpemF0aW9uQW5ub3RhdGlvbltpXSA9ICRyb290Lm9ubnguVGVuc29yQW5ub3RhdGlvbi5mcm9tT2JqZWN0KG9iamVjdC5xdWFudGl6YXRpb25Bbm5vdGF0aW9uW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhIEdyYXBoUHJvdG8gbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxuICAgICAqIEBtZW1iZXJvZiBvbm54LkdyYXBoUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtvbm54LkdyYXBoUHJvdG99IG1lc3NhZ2UgR3JhcGhQcm90b1xuICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICovXG4gICAgR3JhcGhQcm90by50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgaWYgKG9wdGlvbnMuYXJyYXlzIHx8IG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgb2JqZWN0Lm5vZGUgPSBbXTtcbiAgICAgICAgb2JqZWN0LmluaXRpYWxpemVyID0gW107XG4gICAgICAgIG9iamVjdC5pbnB1dCA9IFtdO1xuICAgICAgICBvYmplY3Qub3V0cHV0ID0gW107XG4gICAgICAgIG9iamVjdC52YWx1ZUluZm8gPSBbXTtcbiAgICAgICAgb2JqZWN0LnF1YW50aXphdGlvbkFubm90YXRpb24gPSBbXTtcbiAgICAgICAgb2JqZWN0LnNwYXJzZUluaXRpYWxpemVyID0gW107XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICBvYmplY3QubmFtZSA9ICcnO1xuICAgICAgICBvYmplY3QuZG9jU3RyaW5nID0gJyc7XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5ub2RlICYmIG1lc3NhZ2Uubm9kZS5sZW5ndGgpIHtcbiAgICAgICAgb2JqZWN0Lm5vZGUgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLm5vZGUubGVuZ3RoOyArK2opXG4gICAgICAgICAgb2JqZWN0Lm5vZGVbal0gPSAkcm9vdC5vbm54Lk5vZGVQcm90by50b09iamVjdChtZXNzYWdlLm5vZGVbal0sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UubmFtZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ25hbWUnKSkgb2JqZWN0Lm5hbWUgPSBtZXNzYWdlLm5hbWU7XG4gICAgICBpZiAobWVzc2FnZS5pbml0aWFsaXplciAmJiBtZXNzYWdlLmluaXRpYWxpemVyLmxlbmd0aCkge1xuICAgICAgICBvYmplY3QuaW5pdGlhbGl6ZXIgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLmluaXRpYWxpemVyLmxlbmd0aDsgKytqKVxuICAgICAgICAgIG9iamVjdC5pbml0aWFsaXplcltqXSA9ICRyb290Lm9ubnguVGVuc29yUHJvdG8udG9PYmplY3QobWVzc2FnZS5pbml0aWFsaXplcltqXSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5kb2NTdHJpbmcgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdkb2NTdHJpbmcnKSkgb2JqZWN0LmRvY1N0cmluZyA9IG1lc3NhZ2UuZG9jU3RyaW5nO1xuICAgICAgaWYgKG1lc3NhZ2UuaW5wdXQgJiYgbWVzc2FnZS5pbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgb2JqZWN0LmlucHV0ID0gW107XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5pbnB1dC5sZW5ndGg7ICsrailcbiAgICAgICAgICBvYmplY3QuaW5wdXRbal0gPSAkcm9vdC5vbm54LlZhbHVlSW5mb1Byb3RvLnRvT2JqZWN0KG1lc3NhZ2UuaW5wdXRbal0sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2Uub3V0cHV0ICYmIG1lc3NhZ2Uub3V0cHV0Lmxlbmd0aCkge1xuICAgICAgICBvYmplY3Qub3V0cHV0ID0gW107XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5vdXRwdXQubGVuZ3RoOyArK2opXG4gICAgICAgICAgb2JqZWN0Lm91dHB1dFtqXSA9ICRyb290Lm9ubnguVmFsdWVJbmZvUHJvdG8udG9PYmplY3QobWVzc2FnZS5vdXRwdXRbal0sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UudmFsdWVJbmZvICYmIG1lc3NhZ2UudmFsdWVJbmZvLmxlbmd0aCkge1xuICAgICAgICBvYmplY3QudmFsdWVJbmZvID0gW107XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS52YWx1ZUluZm8ubGVuZ3RoOyArK2opXG4gICAgICAgICAgb2JqZWN0LnZhbHVlSW5mb1tqXSA9ICRyb290Lm9ubnguVmFsdWVJbmZvUHJvdG8udG9PYmplY3QobWVzc2FnZS52YWx1ZUluZm9bal0sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UucXVhbnRpemF0aW9uQW5ub3RhdGlvbiAmJiBtZXNzYWdlLnF1YW50aXphdGlvbkFubm90YXRpb24ubGVuZ3RoKSB7XG4gICAgICAgIG9iamVjdC5xdWFudGl6YXRpb25Bbm5vdGF0aW9uID0gW107XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uLmxlbmd0aDsgKytqKVxuICAgICAgICAgIG9iamVjdC5xdWFudGl6YXRpb25Bbm5vdGF0aW9uW2pdID0gJHJvb3Qub25ueC5UZW5zb3JBbm5vdGF0aW9uLnRvT2JqZWN0KFxuICAgICAgICAgICAgbWVzc2FnZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uW2pdLFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2Uuc3BhcnNlSW5pdGlhbGl6ZXIgJiYgbWVzc2FnZS5zcGFyc2VJbml0aWFsaXplci5sZW5ndGgpIHtcbiAgICAgICAgb2JqZWN0LnNwYXJzZUluaXRpYWxpemVyID0gW107XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5zcGFyc2VJbml0aWFsaXplci5sZW5ndGg7ICsrailcbiAgICAgICAgICBvYmplY3Quc3BhcnNlSW5pdGlhbGl6ZXJbal0gPSAkcm9vdC5vbm54LlNwYXJzZVRlbnNvclByb3RvLnRvT2JqZWN0KG1lc3NhZ2Uuc3BhcnNlSW5pdGlhbGl6ZXJbal0sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhpcyBHcmFwaFByb3RvIHRvIEpTT04uXG4gICAgICogQGZ1bmN0aW9uIHRvSlNPTlxuICAgICAqIEBtZW1iZXJvZiBvbm54LkdyYXBoUHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IEpTT04gb2JqZWN0XG4gICAgICovXG4gICAgR3JhcGhQcm90by5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGRlZmF1bHQgdHlwZSB1cmwgZm9yIEdyYXBoUHJvdG9cbiAgICAgKiBAZnVuY3Rpb24gZ2V0VHlwZVVybFxuICAgICAqIEBtZW1iZXJvZiBvbm54LkdyYXBoUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlVXJsUHJlZml4XSB5b3VyIGN1c3RvbSB0eXBlVXJsUHJlZml4KGRlZmF1bHQgXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCIpXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGRlZmF1bHQgdHlwZSB1cmxcbiAgICAgKi9cbiAgICBHcmFwaFByb3RvLmdldFR5cGVVcmwgPSBmdW5jdGlvbiBnZXRUeXBlVXJsKHR5cGVVcmxQcmVmaXgpIHtcbiAgICAgIGlmICh0eXBlVXJsUHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdHlwZVVybFByZWZpeCA9ICd0eXBlLmdvb2dsZWFwaXMuY29tJztcbiAgICAgIH1cbiAgICAgIHJldHVybiB0eXBlVXJsUHJlZml4ICsgJy9vbm54LkdyYXBoUHJvdG8nO1xuICAgIH07XG5cbiAgICByZXR1cm4gR3JhcGhQcm90bztcbiAgfSkoKTtcblxuICBvbm54LlRlbnNvclByb3RvID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgVGVuc29yUHJvdG8uXG4gICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgKiBAaW50ZXJmYWNlIElUZW5zb3JQcm90b1xuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG51bWJlcnxMb25nPnxudWxsfSBbZGltc10gVGVuc29yUHJvdG8gZGltc1xuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfG51bGx9IFtkYXRhVHlwZV0gVGVuc29yUHJvdG8gZGF0YVR5cGVcbiAgICAgKiBAcHJvcGVydHkge29ubnguVGVuc29yUHJvdG8uSVNlZ21lbnR8bnVsbH0gW3NlZ21lbnRdIFRlbnNvclByb3RvIHNlZ21lbnRcbiAgICAgKiBAcHJvcGVydHkge0FycmF5LjxudW1iZXI+fG51bGx9IFtmbG9hdERhdGFdIFRlbnNvclByb3RvIGZsb2F0RGF0YVxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG51bWJlcj58bnVsbH0gW2ludDMyRGF0YV0gVGVuc29yUHJvdG8gaW50MzJEYXRhXG4gICAgICogQHByb3BlcnR5IHtBcnJheS48VWludDhBcnJheT58bnVsbH0gW3N0cmluZ0RhdGFdIFRlbnNvclByb3RvIHN0cmluZ0RhdGFcbiAgICAgKiBAcHJvcGVydHkge0FycmF5LjxudW1iZXJ8TG9uZz58bnVsbH0gW2ludDY0RGF0YV0gVGVuc29yUHJvdG8gaW50NjREYXRhXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW25hbWVdIFRlbnNvclByb3RvIG5hbWVcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbZG9jU3RyaW5nXSBUZW5zb3JQcm90byBkb2NTdHJpbmdcbiAgICAgKiBAcHJvcGVydHkge1VpbnQ4QXJyYXl8bnVsbH0gW3Jhd0RhdGFdIFRlbnNvclByb3RvIHJhd0RhdGFcbiAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LklTdHJpbmdTdHJpbmdFbnRyeVByb3RvPnxudWxsfSBbZXh0ZXJuYWxEYXRhXSBUZW5zb3JQcm90byBleHRlcm5hbERhdGFcbiAgICAgKiBAcHJvcGVydHkge29ubnguVGVuc29yUHJvdG8uRGF0YUxvY2F0aW9ufG51bGx9IFtkYXRhTG9jYXRpb25dIFRlbnNvclByb3RvIGRhdGFMb2NhdGlvblxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG51bWJlcj58bnVsbH0gW2RvdWJsZURhdGFdIFRlbnNvclByb3RvIGRvdWJsZURhdGFcbiAgICAgKiBAcHJvcGVydHkge0FycmF5LjxudW1iZXJ8TG9uZz58bnVsbH0gW3VpbnQ2NERhdGFdIFRlbnNvclByb3RvIHVpbnQ2NERhdGFcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgVGVuc29yUHJvdG8uXG4gICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBUZW5zb3JQcm90by5cbiAgICAgKiBAaW1wbGVtZW50cyBJVGVuc29yUHJvdG9cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge29ubnguSVRlbnNvclByb3RvPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICovXG4gICAgZnVuY3Rpb24gVGVuc29yUHJvdG8ocHJvcGVydGllcykge1xuICAgICAgdGhpcy5kaW1zID0gW107XG4gICAgICB0aGlzLmZsb2F0RGF0YSA9IFtdO1xuICAgICAgdGhpcy5pbnQzMkRhdGEgPSBbXTtcbiAgICAgIHRoaXMuc3RyaW5nRGF0YSA9IFtdO1xuICAgICAgdGhpcy5pbnQ2NERhdGEgPSBbXTtcbiAgICAgIHRoaXMuZXh0ZXJuYWxEYXRhID0gW107XG4gICAgICB0aGlzLmRvdWJsZURhdGEgPSBbXTtcbiAgICAgIHRoaXMudWludDY0RGF0YSA9IFtdO1xuICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlbnNvclByb3RvIGRpbXMuXG4gICAgICogQG1lbWJlciB7QXJyYXkuPG51bWJlcnxMb25nPn0gZGltc1xuICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgVGVuc29yUHJvdG8ucHJvdG90eXBlLmRpbXMgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgLyoqXG4gICAgICogVGVuc29yUHJvdG8gZGF0YVR5cGUuXG4gICAgICogQG1lbWJlciB7bnVtYmVyfSBkYXRhVHlwZVxuICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgVGVuc29yUHJvdG8ucHJvdG90eXBlLmRhdGFUeXBlID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRlbnNvclByb3RvIHNlZ21lbnQuXG4gICAgICogQG1lbWJlciB7b25ueC5UZW5zb3JQcm90by5JU2VnbWVudHxudWxsfHVuZGVmaW5lZH0gc2VnbWVudFxuICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgVGVuc29yUHJvdG8ucHJvdG90eXBlLnNlZ21lbnQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGVuc29yUHJvdG8gZmxvYXREYXRhLlxuICAgICAqIEBtZW1iZXIge0FycmF5LjxudW1iZXI+fSBmbG9hdERhdGFcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIFRlbnNvclByb3RvLnByb3RvdHlwZS5mbG9hdERhdGEgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgLyoqXG4gICAgICogVGVuc29yUHJvdG8gaW50MzJEYXRhLlxuICAgICAqIEBtZW1iZXIge0FycmF5LjxudW1iZXI+fSBpbnQzMkRhdGFcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIFRlbnNvclByb3RvLnByb3RvdHlwZS5pbnQzMkRhdGEgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgLyoqXG4gICAgICogVGVuc29yUHJvdG8gc3RyaW5nRGF0YS5cbiAgICAgKiBAbWVtYmVyIHtBcnJheS48VWludDhBcnJheT59IHN0cmluZ0RhdGFcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIFRlbnNvclByb3RvLnByb3RvdHlwZS5zdHJpbmdEYXRhID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgIC8qKlxuICAgICAqIFRlbnNvclByb3RvIGludDY0RGF0YS5cbiAgICAgKiBAbWVtYmVyIHtBcnJheS48bnVtYmVyfExvbmc+fSBpbnQ2NERhdGFcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIFRlbnNvclByb3RvLnByb3RvdHlwZS5pbnQ2NERhdGEgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgLyoqXG4gICAgICogVGVuc29yUHJvdG8gbmFtZS5cbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIFRlbnNvclByb3RvLnByb3RvdHlwZS5uYW1lID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBUZW5zb3JQcm90byBkb2NTdHJpbmcuXG4gICAgICogQG1lbWJlciB7c3RyaW5nfSBkb2NTdHJpbmdcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIFRlbnNvclByb3RvLnByb3RvdHlwZS5kb2NTdHJpbmcgPSAnJztcblxuICAgIC8qKlxuICAgICAqIFRlbnNvclByb3RvIHJhd0RhdGEuXG4gICAgICogQG1lbWJlciB7VWludDhBcnJheX0gcmF3RGF0YVxuICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgVGVuc29yUHJvdG8ucHJvdG90eXBlLnJhd0RhdGEgPSAkdXRpbC5uZXdCdWZmZXIoW10pO1xuXG4gICAgLyoqXG4gICAgICogVGVuc29yUHJvdG8gZXh0ZXJuYWxEYXRhLlxuICAgICAqIEBtZW1iZXIge0FycmF5Ljxvbm54LklTdHJpbmdTdHJpbmdFbnRyeVByb3RvPn0gZXh0ZXJuYWxEYXRhXG4gICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBUZW5zb3JQcm90by5wcm90b3R5cGUuZXh0ZXJuYWxEYXRhID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgIC8qKlxuICAgICAqIFRlbnNvclByb3RvIGRhdGFMb2NhdGlvbi5cbiAgICAgKiBAbWVtYmVyIHtvbm54LlRlbnNvclByb3RvLkRhdGFMb2NhdGlvbn0gZGF0YUxvY2F0aW9uXG4gICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBUZW5zb3JQcm90by5wcm90b3R5cGUuZGF0YUxvY2F0aW9uID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRlbnNvclByb3RvIGRvdWJsZURhdGEuXG4gICAgICogQG1lbWJlciB7QXJyYXkuPG51bWJlcj59IGRvdWJsZURhdGFcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIFRlbnNvclByb3RvLnByb3RvdHlwZS5kb3VibGVEYXRhID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgIC8qKlxuICAgICAqIFRlbnNvclByb3RvIHVpbnQ2NERhdGEuXG4gICAgICogQG1lbWJlciB7QXJyYXkuPG51bWJlcnxMb25nPn0gdWludDY0RGF0YVxuICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgVGVuc29yUHJvdG8ucHJvdG90eXBlLnVpbnQ2NERhdGEgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBUZW5zb3JQcm90byBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxuICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7b25ueC5JVGVuc29yUHJvdG89fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgKiBAcmV0dXJucyB7b25ueC5UZW5zb3JQcm90b30gVGVuc29yUHJvdG8gaW5zdGFuY2VcbiAgICAgKi9cbiAgICBUZW5zb3JQcm90by5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgcmV0dXJuIG5ldyBUZW5zb3JQcm90byhwcm9wZXJ0aWVzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIFRlbnNvclByb3RvIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguVGVuc29yUHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICogQGZ1bmN0aW9uIGVuY29kZVxuICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7b25ueC5JVGVuc29yUHJvdG99IG1lc3NhZ2UgVGVuc29yUHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAqL1xuICAgIFRlbnNvclByb3RvLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgIGlmICghd3JpdGVyKSB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgaWYgKG1lc3NhZ2UuZGltcyAhPSBudWxsICYmIG1lc3NhZ2UuZGltcy5sZW5ndGgpIHtcbiAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAxLCB3aXJlVHlwZSAyID0qLyAxMCkuZm9yaygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuZGltcy5sZW5ndGg7ICsraSkgd3JpdGVyLmludDY0KG1lc3NhZ2UuZGltc1tpXSk7XG4gICAgICAgIHdyaXRlci5sZGVsaW0oKTtcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLmRhdGFUeXBlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgJ2RhdGFUeXBlJykpXG4gICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMiwgd2lyZVR5cGUgMCA9Ki8gMTYpLmludDMyKG1lc3NhZ2UuZGF0YVR5cGUpO1xuICAgICAgaWYgKG1lc3NhZ2Uuc2VnbWVudCAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsICdzZWdtZW50JykpXG4gICAgICAgICRyb290Lm9ubnguVGVuc29yUHJvdG8uU2VnbWVudC5lbmNvZGUoXG4gICAgICAgICAgbWVzc2FnZS5zZWdtZW50LFxuICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMywgd2lyZVR5cGUgMiA9Ki8gMjYpLmZvcmsoKSxcbiAgICAgICAgKS5sZGVsaW0oKTtcbiAgICAgIGlmIChtZXNzYWdlLmZsb2F0RGF0YSAhPSBudWxsICYmIG1lc3NhZ2UuZmxvYXREYXRhLmxlbmd0aCkge1xuICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDQsIHdpcmVUeXBlIDIgPSovIDM0KS5mb3JrKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5mbG9hdERhdGEubGVuZ3RoOyArK2kpIHdyaXRlci5mbG9hdChtZXNzYWdlLmZsb2F0RGF0YVtpXSk7XG4gICAgICAgIHdyaXRlci5sZGVsaW0oKTtcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLmludDMyRGF0YSAhPSBudWxsICYmIG1lc3NhZ2UuaW50MzJEYXRhLmxlbmd0aCkge1xuICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDUsIHdpcmVUeXBlIDIgPSovIDQyKS5mb3JrKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5pbnQzMkRhdGEubGVuZ3RoOyArK2kpIHdyaXRlci5pbnQzMihtZXNzYWdlLmludDMyRGF0YVtpXSk7XG4gICAgICAgIHdyaXRlci5sZGVsaW0oKTtcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLnN0cmluZ0RhdGEgIT0gbnVsbCAmJiBtZXNzYWdlLnN0cmluZ0RhdGEubGVuZ3RoKVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2Uuc3RyaW5nRGF0YS5sZW5ndGg7ICsraSlcbiAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDYsIHdpcmVUeXBlIDIgPSovIDUwKS5ieXRlcyhtZXNzYWdlLnN0cmluZ0RhdGFbaV0pO1xuICAgICAgaWYgKG1lc3NhZ2UuaW50NjREYXRhICE9IG51bGwgJiYgbWVzc2FnZS5pbnQ2NERhdGEubGVuZ3RoKSB7XG4gICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgNywgd2lyZVR5cGUgMiA9Ki8gNTgpLmZvcmsoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmludDY0RGF0YS5sZW5ndGg7ICsraSkgd3JpdGVyLmludDY0KG1lc3NhZ2UuaW50NjREYXRhW2ldKTtcbiAgICAgICAgd3JpdGVyLmxkZWxpbSgpO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UubmFtZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsICduYW1lJykpXG4gICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgOCwgd2lyZVR5cGUgMiA9Ki8gNjYpLnN0cmluZyhtZXNzYWdlLm5hbWUpO1xuICAgICAgaWYgKG1lc3NhZ2UucmF3RGF0YSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsICdyYXdEYXRhJykpXG4gICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgOSwgd2lyZVR5cGUgMiA9Ki8gNzQpLmJ5dGVzKG1lc3NhZ2UucmF3RGF0YSk7XG4gICAgICBpZiAobWVzc2FnZS5kb3VibGVEYXRhICE9IG51bGwgJiYgbWVzc2FnZS5kb3VibGVEYXRhLmxlbmd0aCkge1xuICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDEwLCB3aXJlVHlwZSAyID0qLyA4MikuZm9yaygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuZG91YmxlRGF0YS5sZW5ndGg7ICsraSkgd3JpdGVyLmRvdWJsZShtZXNzYWdlLmRvdWJsZURhdGFbaV0pO1xuICAgICAgICB3cml0ZXIubGRlbGltKCk7XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS51aW50NjREYXRhICE9IG51bGwgJiYgbWVzc2FnZS51aW50NjREYXRhLmxlbmd0aCkge1xuICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDExLCB3aXJlVHlwZSAyID0qLyA5MCkuZm9yaygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UudWludDY0RGF0YS5sZW5ndGg7ICsraSkgd3JpdGVyLnVpbnQ2NChtZXNzYWdlLnVpbnQ2NERhdGFbaV0pO1xuICAgICAgICB3cml0ZXIubGRlbGltKCk7XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5kb2NTdHJpbmcgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCAnZG9jU3RyaW5nJykpXG4gICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMTIsIHdpcmVUeXBlIDIgPSovIDk4KS5zdHJpbmcobWVzc2FnZS5kb2NTdHJpbmcpO1xuICAgICAgaWYgKG1lc3NhZ2UuZXh0ZXJuYWxEYXRhICE9IG51bGwgJiYgbWVzc2FnZS5leHRlcm5hbERhdGEubGVuZ3RoKVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuZXh0ZXJuYWxEYXRhLmxlbmd0aDsgKytpKVxuICAgICAgICAgICRyb290Lm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5lbmNvZGUoXG4gICAgICAgICAgICBtZXNzYWdlLmV4dGVybmFsRGF0YVtpXSxcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMTMsIHdpcmVUeXBlIDIgPSovIDEwNikuZm9yaygpLFxuICAgICAgICAgICkubGRlbGltKCk7XG4gICAgICBpZiAobWVzc2FnZS5kYXRhTG9jYXRpb24gIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCAnZGF0YUxvY2F0aW9uJykpXG4gICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMTQsIHdpcmVUeXBlIDAgPSovIDExMikuaW50MzIobWVzc2FnZS5kYXRhTG9jYXRpb24pO1xuICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIFRlbnNvclByb3RvIG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguVGVuc29yUHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7b25ueC5JVGVuc29yUHJvdG99IG1lc3NhZ2UgVGVuc29yUHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAqL1xuICAgIFRlbnNvclByb3RvLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZWNvZGVzIGEgVGVuc29yUHJvdG8gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgKiBAcmV0dXJucyB7b25ueC5UZW5zb3JQcm90b30gVGVuc29yUHJvdG9cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAqL1xuICAgIFRlbnNvclByb3RvLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCxcbiAgICAgICAgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LlRlbnNvclByb3RvKCk7XG4gICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5kaW1zICYmIG1lc3NhZ2UuZGltcy5sZW5ndGgpKSBtZXNzYWdlLmRpbXMgPSBbXTtcbiAgICAgICAgICAgIGlmICgodGFnICYgNykgPT09IDIpIHtcbiAgICAgICAgICAgICAgdmFyIGVuZDIgPSByZWFkZXIudWludDMyKCkgKyByZWFkZXIucG9zO1xuICAgICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZDIpIG1lc3NhZ2UuZGltcy5wdXNoKHJlYWRlci5pbnQ2NCgpKTtcbiAgICAgICAgICAgIH0gZWxzZSBtZXNzYWdlLmRpbXMucHVzaChyZWFkZXIuaW50NjQoKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgICBtZXNzYWdlLmRhdGFUeXBlID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAzOiB7XG4gICAgICAgICAgICBtZXNzYWdlLnNlZ21lbnQgPSAkcm9vdC5vbm54LlRlbnNvclByb3RvLlNlZ21lbnQuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDQ6IHtcbiAgICAgICAgICAgIGlmICghKG1lc3NhZ2UuZmxvYXREYXRhICYmIG1lc3NhZ2UuZmxvYXREYXRhLmxlbmd0aCkpIG1lc3NhZ2UuZmxvYXREYXRhID0gW107XG4gICAgICAgICAgICBpZiAoKHRhZyAmIDcpID09PSAyKSB7XG4gICAgICAgICAgICAgIHZhciBlbmQyID0gcmVhZGVyLnVpbnQzMigpICsgcmVhZGVyLnBvcztcbiAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQyKSBtZXNzYWdlLmZsb2F0RGF0YS5wdXNoKHJlYWRlci5mbG9hdCgpKTtcbiAgICAgICAgICAgIH0gZWxzZSBtZXNzYWdlLmZsb2F0RGF0YS5wdXNoKHJlYWRlci5mbG9hdCgpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDU6IHtcbiAgICAgICAgICAgIGlmICghKG1lc3NhZ2UuaW50MzJEYXRhICYmIG1lc3NhZ2UuaW50MzJEYXRhLmxlbmd0aCkpIG1lc3NhZ2UuaW50MzJEYXRhID0gW107XG4gICAgICAgICAgICBpZiAoKHRhZyAmIDcpID09PSAyKSB7XG4gICAgICAgICAgICAgIHZhciBlbmQyID0gcmVhZGVyLnVpbnQzMigpICsgcmVhZGVyLnBvcztcbiAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQyKSBtZXNzYWdlLmludDMyRGF0YS5wdXNoKHJlYWRlci5pbnQzMigpKTtcbiAgICAgICAgICAgIH0gZWxzZSBtZXNzYWdlLmludDMyRGF0YS5wdXNoKHJlYWRlci5pbnQzMigpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDY6IHtcbiAgICAgICAgICAgIGlmICghKG1lc3NhZ2Uuc3RyaW5nRGF0YSAmJiBtZXNzYWdlLnN0cmluZ0RhdGEubGVuZ3RoKSkgbWVzc2FnZS5zdHJpbmdEYXRhID0gW107XG4gICAgICAgICAgICBtZXNzYWdlLnN0cmluZ0RhdGEucHVzaChyZWFkZXIuYnl0ZXMoKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSA3OiB7XG4gICAgICAgICAgICBpZiAoIShtZXNzYWdlLmludDY0RGF0YSAmJiBtZXNzYWdlLmludDY0RGF0YS5sZW5ndGgpKSBtZXNzYWdlLmludDY0RGF0YSA9IFtdO1xuICAgICAgICAgICAgaWYgKCh0YWcgJiA3KSA9PT0gMikge1xuICAgICAgICAgICAgICB2YXIgZW5kMiA9IHJlYWRlci51aW50MzIoKSArIHJlYWRlci5wb3M7XG4gICAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kMikgbWVzc2FnZS5pbnQ2NERhdGEucHVzaChyZWFkZXIuaW50NjQoKSk7XG4gICAgICAgICAgICB9IGVsc2UgbWVzc2FnZS5pbnQ2NERhdGEucHVzaChyZWFkZXIuaW50NjQoKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSA4OiB7XG4gICAgICAgICAgICBtZXNzYWdlLm5hbWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAxMjoge1xuICAgICAgICAgICAgbWVzc2FnZS5kb2NTdHJpbmcgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSA5OiB7XG4gICAgICAgICAgICBtZXNzYWdlLnJhd0RhdGEgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDEzOiB7XG4gICAgICAgICAgICBpZiAoIShtZXNzYWdlLmV4dGVybmFsRGF0YSAmJiBtZXNzYWdlLmV4dGVybmFsRGF0YS5sZW5ndGgpKSBtZXNzYWdlLmV4dGVybmFsRGF0YSA9IFtdO1xuICAgICAgICAgICAgbWVzc2FnZS5leHRlcm5hbERhdGEucHVzaCgkcm9vdC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAxNDoge1xuICAgICAgICAgICAgbWVzc2FnZS5kYXRhTG9jYXRpb24gPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDEwOiB7XG4gICAgICAgICAgICBpZiAoIShtZXNzYWdlLmRvdWJsZURhdGEgJiYgbWVzc2FnZS5kb3VibGVEYXRhLmxlbmd0aCkpIG1lc3NhZ2UuZG91YmxlRGF0YSA9IFtdO1xuICAgICAgICAgICAgaWYgKCh0YWcgJiA3KSA9PT0gMikge1xuICAgICAgICAgICAgICB2YXIgZW5kMiA9IHJlYWRlci51aW50MzIoKSArIHJlYWRlci5wb3M7XG4gICAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kMikgbWVzc2FnZS5kb3VibGVEYXRhLnB1c2gocmVhZGVyLmRvdWJsZSgpKTtcbiAgICAgICAgICAgIH0gZWxzZSBtZXNzYWdlLmRvdWJsZURhdGEucHVzaChyZWFkZXIuZG91YmxlKCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMTE6IHtcbiAgICAgICAgICAgIGlmICghKG1lc3NhZ2UudWludDY0RGF0YSAmJiBtZXNzYWdlLnVpbnQ2NERhdGEubGVuZ3RoKSkgbWVzc2FnZS51aW50NjREYXRhID0gW107XG4gICAgICAgICAgICBpZiAoKHRhZyAmIDcpID09PSAyKSB7XG4gICAgICAgICAgICAgIHZhciBlbmQyID0gcmVhZGVyLnVpbnQzMigpICsgcmVhZGVyLnBvcztcbiAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQyKSBtZXNzYWdlLnVpbnQ2NERhdGEucHVzaChyZWFkZXIudWludDY0KCkpO1xuICAgICAgICAgICAgfSBlbHNlIG1lc3NhZ2UudWludDY0RGF0YS5wdXNoKHJlYWRlci51aW50NjQoKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhIFRlbnNvclByb3RvIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICogQGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZFxuICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAqIEByZXR1cm5zIHtvbm54LlRlbnNvclByb3RvfSBUZW5zb3JQcm90b1xuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICovXG4gICAgVGVuc29yUHJvdG8uZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyBhIFRlbnNvclByb3RvIG1lc3NhZ2UuXG4gICAgICogQGZ1bmN0aW9uIHZlcmlmeVxuICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XG4gICAgICovXG4gICAgVGVuc29yUHJvdG8udmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gJ29iamVjdCcgfHwgbWVzc2FnZSA9PT0gbnVsbCkgcmV0dXJuICdvYmplY3QgZXhwZWN0ZWQnO1xuICAgICAgaWYgKG1lc3NhZ2UuZGltcyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ2RpbXMnKSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5kaW1zKSkgcmV0dXJuICdkaW1zOiBhcnJheSBleHBlY3RlZCc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5kaW1zLmxlbmd0aDsgKytpKVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5kaW1zW2ldKSAmJlxuICAgICAgICAgICAgIShtZXNzYWdlLmRpbXNbaV0gJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuZGltc1tpXS5sb3cpICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmRpbXNbaV0uaGlnaCkpXG4gICAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuICdkaW1zOiBpbnRlZ2VyfExvbmdbXSBleHBlY3RlZCc7XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5kYXRhVHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ2RhdGFUeXBlJykpXG4gICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuZGF0YVR5cGUpKSByZXR1cm4gJ2RhdGFUeXBlOiBpbnRlZ2VyIGV4cGVjdGVkJztcbiAgICAgIGlmIChtZXNzYWdlLnNlZ21lbnQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdzZWdtZW50JykpIHtcbiAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5UZW5zb3JQcm90by5TZWdtZW50LnZlcmlmeShtZXNzYWdlLnNlZ21lbnQpO1xuICAgICAgICBpZiAoZXJyb3IpIHJldHVybiAnc2VnbWVudC4nICsgZXJyb3I7XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5mbG9hdERhdGEgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdmbG9hdERhdGEnKSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5mbG9hdERhdGEpKSByZXR1cm4gJ2Zsb2F0RGF0YTogYXJyYXkgZXhwZWN0ZWQnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuZmxvYXREYXRhLmxlbmd0aDsgKytpKVxuICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5mbG9hdERhdGFbaV0gIT09ICdudW1iZXInKSByZXR1cm4gJ2Zsb2F0RGF0YTogbnVtYmVyW10gZXhwZWN0ZWQnO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UuaW50MzJEYXRhICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnaW50MzJEYXRhJykpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UuaW50MzJEYXRhKSkgcmV0dXJuICdpbnQzMkRhdGE6IGFycmF5IGV4cGVjdGVkJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmludDMyRGF0YS5sZW5ndGg7ICsraSlcbiAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmludDMyRGF0YVtpXSkpIHJldHVybiAnaW50MzJEYXRhOiBpbnRlZ2VyW10gZXhwZWN0ZWQnO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2Uuc3RyaW5nRGF0YSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ3N0cmluZ0RhdGEnKSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5zdHJpbmdEYXRhKSkgcmV0dXJuICdzdHJpbmdEYXRhOiBhcnJheSBleHBlY3RlZCc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5zdHJpbmdEYXRhLmxlbmd0aDsgKytpKVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICEoXG4gICAgICAgICAgICAgIChtZXNzYWdlLnN0cmluZ0RhdGFbaV0gJiYgdHlwZW9mIG1lc3NhZ2Uuc3RyaW5nRGF0YVtpXS5sZW5ndGggPT09ICdudW1iZXInKSB8fFxuICAgICAgICAgICAgICAkdXRpbC5pc1N0cmluZyhtZXNzYWdlLnN0cmluZ0RhdGFbaV0pXG4gICAgICAgICAgICApXG4gICAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuICdzdHJpbmdEYXRhOiBidWZmZXJbXSBleHBlY3RlZCc7XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5pbnQ2NERhdGEgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdpbnQ2NERhdGEnKSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5pbnQ2NERhdGEpKSByZXR1cm4gJ2ludDY0RGF0YTogYXJyYXkgZXhwZWN0ZWQnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuaW50NjREYXRhLmxlbmd0aDsgKytpKVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5pbnQ2NERhdGFbaV0pICYmXG4gICAgICAgICAgICAhKFxuICAgICAgICAgICAgICBtZXNzYWdlLmludDY0RGF0YVtpXSAmJlxuICAgICAgICAgICAgICAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5pbnQ2NERhdGFbaV0ubG93KSAmJlxuICAgICAgICAgICAgICAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5pbnQ2NERhdGFbaV0uaGlnaClcbiAgICAgICAgICAgIClcbiAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm4gJ2ludDY0RGF0YTogaW50ZWdlcnxMb25nW10gZXhwZWN0ZWQnO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UubmFtZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ25hbWUnKSlcbiAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLm5hbWUpKSByZXR1cm4gJ25hbWU6IHN0cmluZyBleHBlY3RlZCc7XG4gICAgICBpZiAobWVzc2FnZS5kb2NTdHJpbmcgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdkb2NTdHJpbmcnKSlcbiAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLmRvY1N0cmluZykpIHJldHVybiAnZG9jU3RyaW5nOiBzdHJpbmcgZXhwZWN0ZWQnO1xuICAgICAgaWYgKG1lc3NhZ2UucmF3RGF0YSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ3Jhd0RhdGEnKSlcbiAgICAgICAgaWYgKCEoKG1lc3NhZ2UucmF3RGF0YSAmJiB0eXBlb2YgbWVzc2FnZS5yYXdEYXRhLmxlbmd0aCA9PT0gJ251bWJlcicpIHx8ICR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UucmF3RGF0YSkpKVxuICAgICAgICAgIHJldHVybiAncmF3RGF0YTogYnVmZmVyIGV4cGVjdGVkJztcbiAgICAgIGlmIChtZXNzYWdlLmV4dGVybmFsRGF0YSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ2V4dGVybmFsRGF0YScpKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLmV4dGVybmFsRGF0YSkpIHJldHVybiAnZXh0ZXJuYWxEYXRhOiBhcnJheSBleHBlY3RlZCc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5leHRlcm5hbERhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8udmVyaWZ5KG1lc3NhZ2UuZXh0ZXJuYWxEYXRhW2ldKTtcbiAgICAgICAgICBpZiAoZXJyb3IpIHJldHVybiAnZXh0ZXJuYWxEYXRhLicgKyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UuZGF0YUxvY2F0aW9uICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnZGF0YUxvY2F0aW9uJykpXG4gICAgICAgIHN3aXRjaCAobWVzc2FnZS5kYXRhTG9jYXRpb24pIHtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuICdkYXRhTG9jYXRpb246IGVudW0gdmFsdWUgZXhwZWN0ZWQnO1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UuZG91YmxlRGF0YSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ2RvdWJsZURhdGEnKSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5kb3VibGVEYXRhKSkgcmV0dXJuICdkb3VibGVEYXRhOiBhcnJheSBleHBlY3RlZCc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5kb3VibGVEYXRhLmxlbmd0aDsgKytpKVxuICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5kb3VibGVEYXRhW2ldICE9PSAnbnVtYmVyJykgcmV0dXJuICdkb3VibGVEYXRhOiBudW1iZXJbXSBleHBlY3RlZCc7XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS51aW50NjREYXRhICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgndWludDY0RGF0YScpKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLnVpbnQ2NERhdGEpKSByZXR1cm4gJ3VpbnQ2NERhdGE6IGFycmF5IGV4cGVjdGVkJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnVpbnQ2NERhdGEubGVuZ3RoOyArK2kpXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLnVpbnQ2NERhdGFbaV0pICYmXG4gICAgICAgICAgICAhKFxuICAgICAgICAgICAgICBtZXNzYWdlLnVpbnQ2NERhdGFbaV0gJiZcbiAgICAgICAgICAgICAgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UudWludDY0RGF0YVtpXS5sb3cpICYmXG4gICAgICAgICAgICAgICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLnVpbnQ2NERhdGFbaV0uaGlnaClcbiAgICAgICAgICAgIClcbiAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm4gJ3VpbnQ2NERhdGE6IGludGVnZXJ8TG9uZ1tdIGV4cGVjdGVkJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgVGVuc29yUHJvdG8gbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICAgICAqIEByZXR1cm5zIHtvbm54LlRlbnNvclByb3RvfSBUZW5zb3JQcm90b1xuICAgICAqL1xuICAgIFRlbnNvclByb3RvLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290Lm9ubnguVGVuc29yUHJvdG8pIHJldHVybiBvYmplY3Q7XG4gICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LlRlbnNvclByb3RvKCk7XG4gICAgICBpZiAob2JqZWN0LmRpbXMpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5kaW1zKSkgdGhyb3cgVHlwZUVycm9yKCcub25ueC5UZW5zb3JQcm90by5kaW1zOiBhcnJheSBleHBlY3RlZCcpO1xuICAgICAgICBtZXNzYWdlLmRpbXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QuZGltcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICBpZiAoJHV0aWwuTG9uZykgKG1lc3NhZ2UuZGltc1tpXSA9ICR1dGlsLkxvbmcuZnJvbVZhbHVlKG9iamVjdC5kaW1zW2ldKSkudW5zaWduZWQgPSBmYWxzZTtcbiAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmRpbXNbaV0gPT09ICdzdHJpbmcnKSBtZXNzYWdlLmRpbXNbaV0gPSBwYXJzZUludChvYmplY3QuZGltc1tpXSwgMTApO1xuICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuZGltc1tpXSA9PT0gJ251bWJlcicpIG1lc3NhZ2UuZGltc1tpXSA9IG9iamVjdC5kaW1zW2ldO1xuICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuZGltc1tpXSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICBtZXNzYWdlLmRpbXNbaV0gPSBuZXcgJHV0aWwuTG9uZ0JpdHMob2JqZWN0LmRpbXNbaV0ubG93ID4+PiAwLCBvYmplY3QuZGltc1tpXS5oaWdoID4+PiAwKS50b051bWJlcigpO1xuICAgICAgfVxuICAgICAgaWYgKG9iamVjdC5kYXRhVHlwZSAhPSBudWxsKSBtZXNzYWdlLmRhdGFUeXBlID0gb2JqZWN0LmRhdGFUeXBlIHwgMDtcbiAgICAgIGlmIChvYmplY3Quc2VnbWVudCAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnNlZ21lbnQgIT09ICdvYmplY3QnKSB0aHJvdyBUeXBlRXJyb3IoJy5vbm54LlRlbnNvclByb3RvLnNlZ21lbnQ6IG9iamVjdCBleHBlY3RlZCcpO1xuICAgICAgICBtZXNzYWdlLnNlZ21lbnQgPSAkcm9vdC5vbm54LlRlbnNvclByb3RvLlNlZ21lbnQuZnJvbU9iamVjdChvYmplY3Quc2VnbWVudCk7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0LmZsb2F0RGF0YSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LmZsb2F0RGF0YSkpIHRocm93IFR5cGVFcnJvcignLm9ubnguVGVuc29yUHJvdG8uZmxvYXREYXRhOiBhcnJheSBleHBlY3RlZCcpO1xuICAgICAgICBtZXNzYWdlLmZsb2F0RGF0YSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5mbG9hdERhdGEubGVuZ3RoOyArK2kpIG1lc3NhZ2UuZmxvYXREYXRhW2ldID0gTnVtYmVyKG9iamVjdC5mbG9hdERhdGFbaV0pO1xuICAgICAgfVxuICAgICAgaWYgKG9iamVjdC5pbnQzMkRhdGEpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5pbnQzMkRhdGEpKSB0aHJvdyBUeXBlRXJyb3IoJy5vbm54LlRlbnNvclByb3RvLmludDMyRGF0YTogYXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgbWVzc2FnZS5pbnQzMkRhdGEgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QuaW50MzJEYXRhLmxlbmd0aDsgKytpKSBtZXNzYWdlLmludDMyRGF0YVtpXSA9IG9iamVjdC5pbnQzMkRhdGFbaV0gfCAwO1xuICAgICAgfVxuICAgICAgaWYgKG9iamVjdC5zdHJpbmdEYXRhKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3Quc3RyaW5nRGF0YSkpIHRocm93IFR5cGVFcnJvcignLm9ubnguVGVuc29yUHJvdG8uc3RyaW5nRGF0YTogYXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgbWVzc2FnZS5zdHJpbmdEYXRhID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LnN0cmluZ0RhdGEubGVuZ3RoOyArK2kpXG4gICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3Quc3RyaW5nRGF0YVtpXSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAkdXRpbC5iYXNlNjQuZGVjb2RlKFxuICAgICAgICAgICAgICBvYmplY3Quc3RyaW5nRGF0YVtpXSxcbiAgICAgICAgICAgICAgKG1lc3NhZ2Uuc3RyaW5nRGF0YVtpXSA9ICR1dGlsLm5ld0J1ZmZlcigkdXRpbC5iYXNlNjQubGVuZ3RoKG9iamVjdC5zdHJpbmdEYXRhW2ldKSkpLFxuICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBlbHNlIGlmIChvYmplY3Quc3RyaW5nRGF0YVtpXS5sZW5ndGggPj0gMCkgbWVzc2FnZS5zdHJpbmdEYXRhW2ldID0gb2JqZWN0LnN0cmluZ0RhdGFbaV07XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0LmludDY0RGF0YSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LmludDY0RGF0YSkpIHRocm93IFR5cGVFcnJvcignLm9ubnguVGVuc29yUHJvdG8uaW50NjREYXRhOiBhcnJheSBleHBlY3RlZCcpO1xuICAgICAgICBtZXNzYWdlLmludDY0RGF0YSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5pbnQ2NERhdGEubGVuZ3RoOyArK2kpXG4gICAgICAgICAgaWYgKCR1dGlsLkxvbmcpIChtZXNzYWdlLmludDY0RGF0YVtpXSA9ICR1dGlsLkxvbmcuZnJvbVZhbHVlKG9iamVjdC5pbnQ2NERhdGFbaV0pKS51bnNpZ25lZCA9IGZhbHNlO1xuICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuaW50NjREYXRhW2ldID09PSAnc3RyaW5nJykgbWVzc2FnZS5pbnQ2NERhdGFbaV0gPSBwYXJzZUludChvYmplY3QuaW50NjREYXRhW2ldLCAxMCk7XG4gICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5pbnQ2NERhdGFbaV0gPT09ICdudW1iZXInKSBtZXNzYWdlLmludDY0RGF0YVtpXSA9IG9iamVjdC5pbnQ2NERhdGFbaV07XG4gICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5pbnQ2NERhdGFbaV0gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgbWVzc2FnZS5pbnQ2NERhdGFbaV0gPSBuZXcgJHV0aWwuTG9uZ0JpdHMoXG4gICAgICAgICAgICAgIG9iamVjdC5pbnQ2NERhdGFbaV0ubG93ID4+PiAwLFxuICAgICAgICAgICAgICBvYmplY3QuaW50NjREYXRhW2ldLmhpZ2ggPj4+IDAsXG4gICAgICAgICAgICApLnRvTnVtYmVyKCk7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0Lm5hbWUgIT0gbnVsbCkgbWVzc2FnZS5uYW1lID0gU3RyaW5nKG9iamVjdC5uYW1lKTtcbiAgICAgIGlmIChvYmplY3QuZG9jU3RyaW5nICE9IG51bGwpIG1lc3NhZ2UuZG9jU3RyaW5nID0gU3RyaW5nKG9iamVjdC5kb2NTdHJpbmcpO1xuICAgICAgaWYgKG9iamVjdC5yYXdEYXRhICE9IG51bGwpXG4gICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnJhd0RhdGEgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICR1dGlsLmJhc2U2NC5kZWNvZGUoXG4gICAgICAgICAgICBvYmplY3QucmF3RGF0YSxcbiAgICAgICAgICAgIChtZXNzYWdlLnJhd0RhdGEgPSAkdXRpbC5uZXdCdWZmZXIoJHV0aWwuYmFzZTY0Lmxlbmd0aChvYmplY3QucmF3RGF0YSkpKSxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgKTtcbiAgICAgICAgZWxzZSBpZiAob2JqZWN0LnJhd0RhdGEubGVuZ3RoID49IDApIG1lc3NhZ2UucmF3RGF0YSA9IG9iamVjdC5yYXdEYXRhO1xuICAgICAgaWYgKG9iamVjdC5leHRlcm5hbERhdGEpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5leHRlcm5hbERhdGEpKSB0aHJvdyBUeXBlRXJyb3IoJy5vbm54LlRlbnNvclByb3RvLmV4dGVybmFsRGF0YTogYXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgbWVzc2FnZS5leHRlcm5hbERhdGEgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QuZXh0ZXJuYWxEYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QuZXh0ZXJuYWxEYXRhW2ldICE9PSAnb2JqZWN0JylcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcignLm9ubnguVGVuc29yUHJvdG8uZXh0ZXJuYWxEYXRhOiBvYmplY3QgZXhwZWN0ZWQnKTtcbiAgICAgICAgICBtZXNzYWdlLmV4dGVybmFsRGF0YVtpXSA9ICRyb290Lm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5mcm9tT2JqZWN0KG9iamVjdC5leHRlcm5hbERhdGFbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKG9iamVjdC5kYXRhTG9jYXRpb24pIHtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5kYXRhTG9jYXRpb24gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBtZXNzYWdlLmRhdGFMb2NhdGlvbiA9IG9iamVjdC5kYXRhTG9jYXRpb247XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0RFRkFVTFQnOlxuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgbWVzc2FnZS5kYXRhTG9jYXRpb24gPSAwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdFWFRFUk5BTCc6XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBtZXNzYWdlLmRhdGFMb2NhdGlvbiA9IDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0LmRvdWJsZURhdGEpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5kb3VibGVEYXRhKSkgdGhyb3cgVHlwZUVycm9yKCcub25ueC5UZW5zb3JQcm90by5kb3VibGVEYXRhOiBhcnJheSBleHBlY3RlZCcpO1xuICAgICAgICBtZXNzYWdlLmRvdWJsZURhdGEgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QuZG91YmxlRGF0YS5sZW5ndGg7ICsraSkgbWVzc2FnZS5kb3VibGVEYXRhW2ldID0gTnVtYmVyKG9iamVjdC5kb3VibGVEYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3QudWludDY0RGF0YSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LnVpbnQ2NERhdGEpKSB0aHJvdyBUeXBlRXJyb3IoJy5vbm54LlRlbnNvclByb3RvLnVpbnQ2NERhdGE6IGFycmF5IGV4cGVjdGVkJyk7XG4gICAgICAgIG1lc3NhZ2UudWludDY0RGF0YSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC51aW50NjREYXRhLmxlbmd0aDsgKytpKVxuICAgICAgICAgIGlmICgkdXRpbC5Mb25nKSAobWVzc2FnZS51aW50NjREYXRhW2ldID0gJHV0aWwuTG9uZy5mcm9tVmFsdWUob2JqZWN0LnVpbnQ2NERhdGFbaV0pKS51bnNpZ25lZCA9IHRydWU7XG4gICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC51aW50NjREYXRhW2ldID09PSAnc3RyaW5nJykgbWVzc2FnZS51aW50NjREYXRhW2ldID0gcGFyc2VJbnQob2JqZWN0LnVpbnQ2NERhdGFbaV0sIDEwKTtcbiAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LnVpbnQ2NERhdGFbaV0gPT09ICdudW1iZXInKSBtZXNzYWdlLnVpbnQ2NERhdGFbaV0gPSBvYmplY3QudWludDY0RGF0YVtpXTtcbiAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LnVpbnQ2NERhdGFbaV0gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgbWVzc2FnZS51aW50NjREYXRhW2ldID0gbmV3ICR1dGlsLkxvbmdCaXRzKFxuICAgICAgICAgICAgICBvYmplY3QudWludDY0RGF0YVtpXS5sb3cgPj4+IDAsXG4gICAgICAgICAgICAgIG9iamVjdC51aW50NjREYXRhW2ldLmhpZ2ggPj4+IDAsXG4gICAgICAgICAgICApLnRvTnVtYmVyKHRydWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhIFRlbnNvclByb3RvIG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge29ubnguVGVuc29yUHJvdG99IG1lc3NhZ2UgVGVuc29yUHJvdG9cbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICAgICAqL1xuICAgIFRlbnNvclByb3RvLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICBpZiAob3B0aW9ucy5hcnJheXMgfHwgb3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICBvYmplY3QuZGltcyA9IFtdO1xuICAgICAgICBvYmplY3QuZmxvYXREYXRhID0gW107XG4gICAgICAgIG9iamVjdC5pbnQzMkRhdGEgPSBbXTtcbiAgICAgICAgb2JqZWN0LnN0cmluZ0RhdGEgPSBbXTtcbiAgICAgICAgb2JqZWN0LmludDY0RGF0YSA9IFtdO1xuICAgICAgICBvYmplY3QuZG91YmxlRGF0YSA9IFtdO1xuICAgICAgICBvYmplY3QudWludDY0RGF0YSA9IFtdO1xuICAgICAgICBvYmplY3QuZXh0ZXJuYWxEYXRhID0gW107XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICBvYmplY3QuZGF0YVR5cGUgPSAwO1xuICAgICAgICBvYmplY3Quc2VnbWVudCA9IG51bGw7XG4gICAgICAgIG9iamVjdC5uYW1lID0gJyc7XG4gICAgICAgIGlmIChvcHRpb25zLmJ5dGVzID09PSBTdHJpbmcpIG9iamVjdC5yYXdEYXRhID0gJyc7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIG9iamVjdC5yYXdEYXRhID0gW107XG4gICAgICAgICAgaWYgKG9wdGlvbnMuYnl0ZXMgIT09IEFycmF5KSBvYmplY3QucmF3RGF0YSA9ICR1dGlsLm5ld0J1ZmZlcihvYmplY3QucmF3RGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0LmRvY1N0cmluZyA9ICcnO1xuICAgICAgICBvYmplY3QuZGF0YUxvY2F0aW9uID0gb3B0aW9ucy5lbnVtcyA9PT0gU3RyaW5nID8gJ0RFRkFVTFQnIDogMDtcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLmRpbXMgJiYgbWVzc2FnZS5kaW1zLmxlbmd0aCkge1xuICAgICAgICBvYmplY3QuZGltcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UuZGltcy5sZW5ndGg7ICsrailcbiAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuZGltc1tqXSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICBvYmplY3QuZGltc1tqXSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtZXNzYWdlLmRpbXNbal0pIDogbWVzc2FnZS5kaW1zW2pdO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIG9iamVjdC5kaW1zW2pdID1cbiAgICAgICAgICAgICAgb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nXG4gICAgICAgICAgICAgICAgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1lc3NhZ2UuZGltc1tqXSlcbiAgICAgICAgICAgICAgICA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlclxuICAgICAgICAgICAgICAgICAgPyBuZXcgJHV0aWwuTG9uZ0JpdHMobWVzc2FnZS5kaW1zW2pdLmxvdyA+Pj4gMCwgbWVzc2FnZS5kaW1zW2pdLmhpZ2ggPj4+IDApLnRvTnVtYmVyKClcbiAgICAgICAgICAgICAgICAgIDogbWVzc2FnZS5kaW1zW2pdO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UuZGF0YVR5cGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdkYXRhVHlwZScpKSBvYmplY3QuZGF0YVR5cGUgPSBtZXNzYWdlLmRhdGFUeXBlO1xuICAgICAgaWYgKG1lc3NhZ2Uuc2VnbWVudCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ3NlZ21lbnQnKSlcbiAgICAgICAgb2JqZWN0LnNlZ21lbnQgPSAkcm9vdC5vbm54LlRlbnNvclByb3RvLlNlZ21lbnQudG9PYmplY3QobWVzc2FnZS5zZWdtZW50LCBvcHRpb25zKTtcbiAgICAgIGlmIChtZXNzYWdlLmZsb2F0RGF0YSAmJiBtZXNzYWdlLmZsb2F0RGF0YS5sZW5ndGgpIHtcbiAgICAgICAgb2JqZWN0LmZsb2F0RGF0YSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UuZmxvYXREYXRhLmxlbmd0aDsgKytqKVxuICAgICAgICAgIG9iamVjdC5mbG9hdERhdGFbal0gPVxuICAgICAgICAgICAgb3B0aW9ucy5qc29uICYmICFpc0Zpbml0ZShtZXNzYWdlLmZsb2F0RGF0YVtqXSkgPyBTdHJpbmcobWVzc2FnZS5mbG9hdERhdGFbal0pIDogbWVzc2FnZS5mbG9hdERhdGFbal07XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5pbnQzMkRhdGEgJiYgbWVzc2FnZS5pbnQzMkRhdGEubGVuZ3RoKSB7XG4gICAgICAgIG9iamVjdC5pbnQzMkRhdGEgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLmludDMyRGF0YS5sZW5ndGg7ICsraikgb2JqZWN0LmludDMyRGF0YVtqXSA9IG1lc3NhZ2UuaW50MzJEYXRhW2pdO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2Uuc3RyaW5nRGF0YSAmJiBtZXNzYWdlLnN0cmluZ0RhdGEubGVuZ3RoKSB7XG4gICAgICAgIG9iamVjdC5zdHJpbmdEYXRhID0gW107XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5zdHJpbmdEYXRhLmxlbmd0aDsgKytqKVxuICAgICAgICAgIG9iamVjdC5zdHJpbmdEYXRhW2pdID1cbiAgICAgICAgICAgIG9wdGlvbnMuYnl0ZXMgPT09IFN0cmluZ1xuICAgICAgICAgICAgICA/ICR1dGlsLmJhc2U2NC5lbmNvZGUobWVzc2FnZS5zdHJpbmdEYXRhW2pdLCAwLCBtZXNzYWdlLnN0cmluZ0RhdGFbal0ubGVuZ3RoKVxuICAgICAgICAgICAgICA6IG9wdGlvbnMuYnl0ZXMgPT09IEFycmF5XG4gICAgICAgICAgICAgICAgPyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChtZXNzYWdlLnN0cmluZ0RhdGFbal0pXG4gICAgICAgICAgICAgICAgOiBtZXNzYWdlLnN0cmluZ0RhdGFbal07XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5pbnQ2NERhdGEgJiYgbWVzc2FnZS5pbnQ2NERhdGEubGVuZ3RoKSB7XG4gICAgICAgIG9iamVjdC5pbnQ2NERhdGEgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLmludDY0RGF0YS5sZW5ndGg7ICsrailcbiAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuaW50NjREYXRhW2pdID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgIG9iamVjdC5pbnQ2NERhdGFbal0gPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBTdHJpbmcobWVzc2FnZS5pbnQ2NERhdGFbal0pIDogbWVzc2FnZS5pbnQ2NERhdGFbal07XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgb2JqZWN0LmludDY0RGF0YVtqXSA9XG4gICAgICAgICAgICAgIG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZ1xuICAgICAgICAgICAgICAgID8gJHV0aWwuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtZXNzYWdlLmludDY0RGF0YVtqXSlcbiAgICAgICAgICAgICAgICA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlclxuICAgICAgICAgICAgICAgICAgPyBuZXcgJHV0aWwuTG9uZ0JpdHMobWVzc2FnZS5pbnQ2NERhdGFbal0ubG93ID4+PiAwLCBtZXNzYWdlLmludDY0RGF0YVtqXS5oaWdoID4+PiAwKS50b051bWJlcigpXG4gICAgICAgICAgICAgICAgICA6IG1lc3NhZ2UuaW50NjREYXRhW2pdO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UubmFtZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ25hbWUnKSkgb2JqZWN0Lm5hbWUgPSBtZXNzYWdlLm5hbWU7XG4gICAgICBpZiAobWVzc2FnZS5yYXdEYXRhICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgncmF3RGF0YScpKVxuICAgICAgICBvYmplY3QucmF3RGF0YSA9XG4gICAgICAgICAgb3B0aW9ucy5ieXRlcyA9PT0gU3RyaW5nXG4gICAgICAgICAgICA/ICR1dGlsLmJhc2U2NC5lbmNvZGUobWVzc2FnZS5yYXdEYXRhLCAwLCBtZXNzYWdlLnJhd0RhdGEubGVuZ3RoKVxuICAgICAgICAgICAgOiBvcHRpb25zLmJ5dGVzID09PSBBcnJheVxuICAgICAgICAgICAgICA/IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG1lc3NhZ2UucmF3RGF0YSlcbiAgICAgICAgICAgICAgOiBtZXNzYWdlLnJhd0RhdGE7XG4gICAgICBpZiAobWVzc2FnZS5kb3VibGVEYXRhICYmIG1lc3NhZ2UuZG91YmxlRGF0YS5sZW5ndGgpIHtcbiAgICAgICAgb2JqZWN0LmRvdWJsZURhdGEgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLmRvdWJsZURhdGEubGVuZ3RoOyArK2opXG4gICAgICAgICAgb2JqZWN0LmRvdWJsZURhdGFbal0gPVxuICAgICAgICAgICAgb3B0aW9ucy5qc29uICYmICFpc0Zpbml0ZShtZXNzYWdlLmRvdWJsZURhdGFbal0pID8gU3RyaW5nKG1lc3NhZ2UuZG91YmxlRGF0YVtqXSkgOiBtZXNzYWdlLmRvdWJsZURhdGFbal07XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS51aW50NjREYXRhICYmIG1lc3NhZ2UudWludDY0RGF0YS5sZW5ndGgpIHtcbiAgICAgICAgb2JqZWN0LnVpbnQ2NERhdGEgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLnVpbnQ2NERhdGEubGVuZ3RoOyArK2opXG4gICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLnVpbnQ2NERhdGFbal0gPT09ICdudW1iZXInKVxuICAgICAgICAgICAgb2JqZWN0LnVpbnQ2NERhdGFbal0gPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBTdHJpbmcobWVzc2FnZS51aW50NjREYXRhW2pdKSA6IG1lc3NhZ2UudWludDY0RGF0YVtqXTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBvYmplY3QudWludDY0RGF0YVtqXSA9XG4gICAgICAgICAgICAgIG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZ1xuICAgICAgICAgICAgICAgID8gJHV0aWwuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtZXNzYWdlLnVpbnQ2NERhdGFbal0pXG4gICAgICAgICAgICAgICAgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXJcbiAgICAgICAgICAgICAgICAgID8gbmV3ICR1dGlsLkxvbmdCaXRzKG1lc3NhZ2UudWludDY0RGF0YVtqXS5sb3cgPj4+IDAsIG1lc3NhZ2UudWludDY0RGF0YVtqXS5oaWdoID4+PiAwKS50b051bWJlcih0cnVlKVxuICAgICAgICAgICAgICAgICAgOiBtZXNzYWdlLnVpbnQ2NERhdGFbal07XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5kb2NTdHJpbmcgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdkb2NTdHJpbmcnKSkgb2JqZWN0LmRvY1N0cmluZyA9IG1lc3NhZ2UuZG9jU3RyaW5nO1xuICAgICAgaWYgKG1lc3NhZ2UuZXh0ZXJuYWxEYXRhICYmIG1lc3NhZ2UuZXh0ZXJuYWxEYXRhLmxlbmd0aCkge1xuICAgICAgICBvYmplY3QuZXh0ZXJuYWxEYXRhID0gW107XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5leHRlcm5hbERhdGEubGVuZ3RoOyArK2opXG4gICAgICAgICAgb2JqZWN0LmV4dGVybmFsRGF0YVtqXSA9ICRyb290Lm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by50b09iamVjdChtZXNzYWdlLmV4dGVybmFsRGF0YVtqXSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5kYXRhTG9jYXRpb24gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdkYXRhTG9jYXRpb24nKSlcbiAgICAgICAgb2JqZWN0LmRhdGFMb2NhdGlvbiA9XG4gICAgICAgICAgb3B0aW9ucy5lbnVtcyA9PT0gU3RyaW5nXG4gICAgICAgICAgICA/ICRyb290Lm9ubnguVGVuc29yUHJvdG8uRGF0YUxvY2F0aW9uW21lc3NhZ2UuZGF0YUxvY2F0aW9uXSA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgID8gbWVzc2FnZS5kYXRhTG9jYXRpb25cbiAgICAgICAgICAgICAgOiAkcm9vdC5vbm54LlRlbnNvclByb3RvLkRhdGFMb2NhdGlvblttZXNzYWdlLmRhdGFMb2NhdGlvbl1cbiAgICAgICAgICAgIDogbWVzc2FnZS5kYXRhTG9jYXRpb247XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGlzIFRlbnNvclByb3RvIHRvIEpTT04uXG4gICAgICogQGZ1bmN0aW9uIHRvSlNPTlxuICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICAgICAqL1xuICAgIFRlbnNvclByb3RvLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZGVmYXVsdCB0eXBlIHVybCBmb3IgVGVuc29yUHJvdG9cbiAgICAgKiBAZnVuY3Rpb24gZ2V0VHlwZVVybFxuICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZVVybFByZWZpeF0geW91ciBjdXN0b20gdHlwZVVybFByZWZpeChkZWZhdWx0IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiKVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBkZWZhdWx0IHR5cGUgdXJsXG4gICAgICovXG4gICAgVGVuc29yUHJvdG8uZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0eXBlVXJsUHJlZml4ID0gJ3R5cGUuZ29vZ2xlYXBpcy5jb20nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyAnL29ubnguVGVuc29yUHJvdG8nO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEYXRhVHlwZSBlbnVtLlxuICAgICAqIEBuYW1lIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGVcbiAgICAgKiBAZW51bSB7bnVtYmVyfVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBVTkRFRklORUQ9MCBVTkRFRklORUQgdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gRkxPQVQ9MSBGTE9BVCB2YWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBVSU5UOD0yIFVJTlQ4IHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IElOVDg9MyBJTlQ4IHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFVJTlQxNj00IFVJTlQxNiB2YWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBJTlQxNj01IElOVDE2IHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IElOVDMyPTYgSU5UMzIgdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gSU5UNjQ9NyBJTlQ2NCB2YWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBTVFJJTkc9OCBTVFJJTkcgdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gQk9PTD05IEJPT0wgdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gRkxPQVQxNj0xMCBGTE9BVDE2IHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IERPVUJMRT0xMSBET1VCTEUgdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gVUlOVDMyPTEyIFVJTlQzMiB2YWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBVSU5UNjQ9MTMgVUlOVDY0IHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IENPTVBMRVg2ND0xNCBDT01QTEVYNjQgdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gQ09NUExFWDEyOD0xNSBDT01QTEVYMTI4IHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEJGTE9BVDE2PTE2IEJGTE9BVDE2IHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEZMT0FUOEU0TTNGTj0xNyBGTE9BVDhFNE0zRk4gdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gRkxPQVQ4RTRNM0ZOVVo9MTggRkxPQVQ4RTRNM0ZOVVogdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gRkxPQVQ4RTVNMj0xOSBGTE9BVDhFNU0yIHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEZMT0FUOEU1TTJGTlVaPTIwIEZMT0FUOEU1TTJGTlVaIHZhbHVlXG4gICAgICovXG4gICAgVGVuc29yUHJvdG8uRGF0YVR5cGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHZhbHVlc0J5SWQgPSB7fSxcbiAgICAgICAgdmFsdWVzID0gT2JqZWN0LmNyZWF0ZSh2YWx1ZXNCeUlkKTtcbiAgICAgIHZhbHVlc1sodmFsdWVzQnlJZFswXSA9ICdVTkRFRklORUQnKV0gPSAwO1xuICAgICAgdmFsdWVzWyh2YWx1ZXNCeUlkWzFdID0gJ0ZMT0FUJyldID0gMTtcbiAgICAgIHZhbHVlc1sodmFsdWVzQnlJZFsyXSA9ICdVSU5UOCcpXSA9IDI7XG4gICAgICB2YWx1ZXNbKHZhbHVlc0J5SWRbM10gPSAnSU5UOCcpXSA9IDM7XG4gICAgICB2YWx1ZXNbKHZhbHVlc0J5SWRbNF0gPSAnVUlOVDE2JyldID0gNDtcbiAgICAgIHZhbHVlc1sodmFsdWVzQnlJZFs1XSA9ICdJTlQxNicpXSA9IDU7XG4gICAgICB2YWx1ZXNbKHZhbHVlc0J5SWRbNl0gPSAnSU5UMzInKV0gPSA2O1xuICAgICAgdmFsdWVzWyh2YWx1ZXNCeUlkWzddID0gJ0lOVDY0JyldID0gNztcbiAgICAgIHZhbHVlc1sodmFsdWVzQnlJZFs4XSA9ICdTVFJJTkcnKV0gPSA4O1xuICAgICAgdmFsdWVzWyh2YWx1ZXNCeUlkWzldID0gJ0JPT0wnKV0gPSA5O1xuICAgICAgdmFsdWVzWyh2YWx1ZXNCeUlkWzEwXSA9ICdGTE9BVDE2JyldID0gMTA7XG4gICAgICB2YWx1ZXNbKHZhbHVlc0J5SWRbMTFdID0gJ0RPVUJMRScpXSA9IDExO1xuICAgICAgdmFsdWVzWyh2YWx1ZXNCeUlkWzEyXSA9ICdVSU5UMzInKV0gPSAxMjtcbiAgICAgIHZhbHVlc1sodmFsdWVzQnlJZFsxM10gPSAnVUlOVDY0JyldID0gMTM7XG4gICAgICB2YWx1ZXNbKHZhbHVlc0J5SWRbMTRdID0gJ0NPTVBMRVg2NCcpXSA9IDE0O1xuICAgICAgdmFsdWVzWyh2YWx1ZXNCeUlkWzE1XSA9ICdDT01QTEVYMTI4JyldID0gMTU7XG4gICAgICB2YWx1ZXNbKHZhbHVlc0J5SWRbMTZdID0gJ0JGTE9BVDE2JyldID0gMTY7XG4gICAgICB2YWx1ZXNbKHZhbHVlc0J5SWRbMTddID0gJ0ZMT0FUOEU0TTNGTicpXSA9IDE3O1xuICAgICAgdmFsdWVzWyh2YWx1ZXNCeUlkWzE4XSA9ICdGTE9BVDhFNE0zRk5VWicpXSA9IDE4O1xuICAgICAgdmFsdWVzWyh2YWx1ZXNCeUlkWzE5XSA9ICdGTE9BVDhFNU0yJyldID0gMTk7XG4gICAgICB2YWx1ZXNbKHZhbHVlc0J5SWRbMjBdID0gJ0ZMT0FUOEU1TTJGTlVaJyldID0gMjA7XG4gICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH0pKCk7XG5cbiAgICBUZW5zb3JQcm90by5TZWdtZW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8qKlxuICAgICAgICogUHJvcGVydGllcyBvZiBhIFNlZ21lbnQuXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90b1xuICAgICAgICogQGludGVyZmFjZSBJU2VnbWVudFxuICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8TG9uZ3xudWxsfSBbYmVnaW5dIFNlZ21lbnQgYmVnaW5cbiAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfExvbmd8bnVsbH0gW2VuZF0gU2VnbWVudCBlbmRcbiAgICAgICAqL1xuXG4gICAgICAvKipcbiAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgU2VnbWVudC5cbiAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBTZWdtZW50LlxuICAgICAgICogQGltcGxlbWVudHMgSVNlZ21lbnRcbiAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICogQHBhcmFtIHtvbm54LlRlbnNvclByb3RvLklTZWdtZW50PX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIFNlZ21lbnQocHJvcGVydGllcykge1xuICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNlZ21lbnQgYmVnaW4uXG4gICAgICAgKiBAbWVtYmVyIHtudW1iZXJ8TG9uZ30gYmVnaW5cbiAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvLlNlZ21lbnRcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICovXG4gICAgICBTZWdtZW50LnByb3RvdHlwZS5iZWdpbiA9ICR1dGlsLkxvbmcgPyAkdXRpbC5Mb25nLmZyb21CaXRzKDAsIDAsIGZhbHNlKSA6IDA7XG5cbiAgICAgIC8qKlxuICAgICAgICogU2VnbWVudCBlbmQuXG4gICAgICAgKiBAbWVtYmVyIHtudW1iZXJ8TG9uZ30gZW5kXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90by5TZWdtZW50XG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqL1xuICAgICAgU2VnbWVudC5wcm90b3R5cGUuZW5kID0gJHV0aWwuTG9uZyA/ICR1dGlsLkxvbmcuZnJvbUJpdHMoMCwgMCwgZmFsc2UpIDogMDtcblxuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGVzIGEgbmV3IFNlZ21lbnQgaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG8uU2VnbWVudFxuICAgICAgICogQHN0YXRpY1xuICAgICAgICogQHBhcmFtIHtvbm54LlRlbnNvclByb3RvLklTZWdtZW50PX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgKiBAcmV0dXJucyB7b25ueC5UZW5zb3JQcm90by5TZWdtZW50fSBTZWdtZW50IGluc3RhbmNlXG4gICAgICAgKi9cbiAgICAgIFNlZ21lbnQuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZWdtZW50KHByb3BlcnRpZXMpO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgU2VnbWVudCBtZXNzYWdlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LlRlbnNvclByb3RvLlNlZ21lbnQudmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90by5TZWdtZW50XG4gICAgICAgKiBAc3RhdGljXG4gICAgICAgKiBAcGFyYW0ge29ubnguVGVuc29yUHJvdG8uSVNlZ21lbnR9IG1lc3NhZ2UgU2VnbWVudCBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICovXG4gICAgICBTZWdtZW50LmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgaWYgKCF3cml0ZXIpIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgIGlmIChtZXNzYWdlLmJlZ2luICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgJ2JlZ2luJykpXG4gICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAxLCB3aXJlVHlwZSAwID0qLyA4KS5pbnQ2NChtZXNzYWdlLmJlZ2luKTtcbiAgICAgICAgaWYgKG1lc3NhZ2UuZW5kICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgJ2VuZCcpKVxuICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMiwgd2lyZVR5cGUgMCA9Ki8gMTYpLmludDY0KG1lc3NhZ2UuZW5kKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIFNlZ21lbnQgbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5UZW5zb3JQcm90by5TZWdtZW50LnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG8uU2VnbWVudFxuICAgICAgICogQHN0YXRpY1xuICAgICAgICogQHBhcmFtIHtvbm54LlRlbnNvclByb3RvLklTZWdtZW50fSBtZXNzYWdlIFNlZ21lbnQgbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAqL1xuICAgICAgU2VnbWVudC5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBEZWNvZGVzIGEgU2VnbWVudCBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG8uU2VnbWVudFxuICAgICAgICogQHN0YXRpY1xuICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAgICogQHJldHVybnMge29ubnguVGVuc29yUHJvdG8uU2VnbWVudH0gU2VnbWVudFxuICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICovXG4gICAgICBTZWdtZW50LmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSkgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsXG4gICAgICAgICAgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LlRlbnNvclByb3RvLlNlZ21lbnQoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgICAgbWVzc2FnZS5iZWdpbiA9IHJlYWRlci5pbnQ2NCgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgICAgICBtZXNzYWdlLmVuZCA9IHJlYWRlci5pbnQ2NCgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBEZWNvZGVzIGEgU2VnbWVudCBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLCBsZW5ndGggZGVsaW1pdGVkLlxuICAgICAgICogQGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZFxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG8uU2VnbWVudFxuICAgICAgICogQHN0YXRpY1xuICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgKiBAcmV0dXJucyB7b25ueC5UZW5zb3JQcm90by5TZWdtZW50fSBTZWdtZW50XG4gICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgKi9cbiAgICAgIFNlZ21lbnQuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSkgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogVmVyaWZpZXMgYSBTZWdtZW50IG1lc3NhZ2UuXG4gICAgICAgKiBAZnVuY3Rpb24gdmVyaWZ5XG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90by5TZWdtZW50XG4gICAgICAgKiBAc3RhdGljXG4gICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcbiAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XG4gICAgICAgKi9cbiAgICAgIFNlZ21lbnQudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSAnb2JqZWN0JyB8fCBtZXNzYWdlID09PSBudWxsKSByZXR1cm4gJ29iamVjdCBleHBlY3RlZCc7XG4gICAgICAgIGlmIChtZXNzYWdlLmJlZ2luICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnYmVnaW4nKSlcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuYmVnaW4pICYmXG4gICAgICAgICAgICAhKG1lc3NhZ2UuYmVnaW4gJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuYmVnaW4ubG93KSAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5iZWdpbi5oaWdoKSlcbiAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm4gJ2JlZ2luOiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWQnO1xuICAgICAgICBpZiAobWVzc2FnZS5lbmQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdlbmQnKSlcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuZW5kKSAmJlxuICAgICAgICAgICAgIShtZXNzYWdlLmVuZCAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5lbmQubG93KSAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5lbmQuaGlnaCkpXG4gICAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuICdlbmQ6IGludGVnZXJ8TG9uZyBleHBlY3RlZCc7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGVzIGEgU2VnbWVudCBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gICAgICAgKiBAZnVuY3Rpb24gZnJvbU9iamVjdFxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG8uU2VnbWVudFxuICAgICAgICogQHN0YXRpY1xuICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICAgICAgICogQHJldHVybnMge29ubnguVGVuc29yUHJvdG8uU2VnbWVudH0gU2VnbWVudFxuICAgICAgICovXG4gICAgICBTZWdtZW50LmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3Qub25ueC5UZW5zb3JQcm90by5TZWdtZW50KSByZXR1cm4gb2JqZWN0O1xuICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LlRlbnNvclByb3RvLlNlZ21lbnQoKTtcbiAgICAgICAgaWYgKG9iamVjdC5iZWdpbiAhPSBudWxsKVxuICAgICAgICAgIGlmICgkdXRpbC5Mb25nKSAobWVzc2FnZS5iZWdpbiA9ICR1dGlsLkxvbmcuZnJvbVZhbHVlKG9iamVjdC5iZWdpbikpLnVuc2lnbmVkID0gZmFsc2U7XG4gICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5iZWdpbiA9PT0gJ3N0cmluZycpIG1lc3NhZ2UuYmVnaW4gPSBwYXJzZUludChvYmplY3QuYmVnaW4sIDEwKTtcbiAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmJlZ2luID09PSAnbnVtYmVyJykgbWVzc2FnZS5iZWdpbiA9IG9iamVjdC5iZWdpbjtcbiAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmJlZ2luID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIG1lc3NhZ2UuYmVnaW4gPSBuZXcgJHV0aWwuTG9uZ0JpdHMob2JqZWN0LmJlZ2luLmxvdyA+Pj4gMCwgb2JqZWN0LmJlZ2luLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCk7XG4gICAgICAgIGlmIChvYmplY3QuZW5kICE9IG51bGwpXG4gICAgICAgICAgaWYgKCR1dGlsLkxvbmcpIChtZXNzYWdlLmVuZCA9ICR1dGlsLkxvbmcuZnJvbVZhbHVlKG9iamVjdC5lbmQpKS51bnNpZ25lZCA9IGZhbHNlO1xuICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuZW5kID09PSAnc3RyaW5nJykgbWVzc2FnZS5lbmQgPSBwYXJzZUludChvYmplY3QuZW5kLCAxMCk7XG4gICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5lbmQgPT09ICdudW1iZXInKSBtZXNzYWdlLmVuZCA9IG9iamVjdC5lbmQ7XG4gICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5lbmQgPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgbWVzc2FnZS5lbmQgPSBuZXcgJHV0aWwuTG9uZ0JpdHMob2JqZWN0LmVuZC5sb3cgPj4+IDAsIG9iamVjdC5lbmQuaGlnaCA+Pj4gMCkudG9OdW1iZXIoKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhIFNlZ21lbnQgbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICAgICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90by5TZWdtZW50XG4gICAgICAgKiBAc3RhdGljXG4gICAgICAgKiBAcGFyYW0ge29ubnguVGVuc29yUHJvdG8uU2VnbWVudH0gbWVzc2FnZSBTZWdtZW50XG4gICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICAgKi9cbiAgICAgIFNlZ21lbnQudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgaWYgKCR1dGlsLkxvbmcpIHtcbiAgICAgICAgICAgIHZhciBsb25nID0gbmV3ICR1dGlsLkxvbmcoMCwgMCwgZmFsc2UpO1xuICAgICAgICAgICAgb2JqZWN0LmJlZ2luID1cbiAgICAgICAgICAgICAgb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gbG9uZy50b1N0cmluZygpIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyID8gbG9uZy50b051bWJlcigpIDogbG9uZztcbiAgICAgICAgICB9IGVsc2Ugb2JqZWN0LmJlZ2luID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gJzAnIDogMDtcbiAgICAgICAgICBpZiAoJHV0aWwuTG9uZykge1xuICAgICAgICAgICAgdmFyIGxvbmcgPSBuZXcgJHV0aWwuTG9uZygwLCAwLCBmYWxzZSk7XG4gICAgICAgICAgICBvYmplY3QuZW5kID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gbG9uZy50b1N0cmluZygpIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyID8gbG9uZy50b051bWJlcigpIDogbG9uZztcbiAgICAgICAgICB9IGVsc2Ugb2JqZWN0LmVuZCA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/ICcwJyA6IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuYmVnaW4gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdiZWdpbicpKVxuICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5iZWdpbiA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICBvYmplY3QuYmVnaW4gPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBTdHJpbmcobWVzc2FnZS5iZWdpbikgOiBtZXNzYWdlLmJlZ2luO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIG9iamVjdC5iZWdpbiA9XG4gICAgICAgICAgICAgIG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZ1xuICAgICAgICAgICAgICAgID8gJHV0aWwuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtZXNzYWdlLmJlZ2luKVxuICAgICAgICAgICAgICAgIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyXG4gICAgICAgICAgICAgICAgICA/IG5ldyAkdXRpbC5Mb25nQml0cyhtZXNzYWdlLmJlZ2luLmxvdyA+Pj4gMCwgbWVzc2FnZS5iZWdpbi5oaWdoID4+PiAwKS50b051bWJlcigpXG4gICAgICAgICAgICAgICAgICA6IG1lc3NhZ2UuYmVnaW47XG4gICAgICAgIGlmIChtZXNzYWdlLmVuZCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ2VuZCcpKVxuICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5lbmQgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgb2JqZWN0LmVuZCA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtZXNzYWdlLmVuZCkgOiBtZXNzYWdlLmVuZDtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBvYmplY3QuZW5kID1cbiAgICAgICAgICAgICAgb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nXG4gICAgICAgICAgICAgICAgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1lc3NhZ2UuZW5kKVxuICAgICAgICAgICAgICAgIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyXG4gICAgICAgICAgICAgICAgICA/IG5ldyAkdXRpbC5Mb25nQml0cyhtZXNzYWdlLmVuZC5sb3cgPj4+IDAsIG1lc3NhZ2UuZW5kLmhpZ2ggPj4+IDApLnRvTnVtYmVyKClcbiAgICAgICAgICAgICAgICAgIDogbWVzc2FnZS5lbmQ7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIENvbnZlcnRzIHRoaXMgU2VnbWVudCB0byBKU09OLlxuICAgICAgICogQGZ1bmN0aW9uIHRvSlNPTlxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG8uU2VnbWVudFxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IEpTT04gb2JqZWN0XG4gICAgICAgKi9cbiAgICAgIFNlZ21lbnQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIEdldHMgdGhlIGRlZmF1bHQgdHlwZSB1cmwgZm9yIFNlZ21lbnRcbiAgICAgICAqIEBmdW5jdGlvbiBnZXRUeXBlVXJsXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90by5TZWdtZW50XG4gICAgICAgKiBAc3RhdGljXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVVcmxQcmVmaXhdIHlvdXIgY3VzdG9tIHR5cGVVcmxQcmVmaXgoZGVmYXVsdCBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIilcbiAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBkZWZhdWx0IHR5cGUgdXJsXG4gICAgICAgKi9cbiAgICAgIFNlZ21lbnQuZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgICBpZiAodHlwZVVybFByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdHlwZVVybFByZWZpeCA9ICd0eXBlLmdvb2dsZWFwaXMuY29tJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZVVybFByZWZpeCArICcvb25ueC5UZW5zb3JQcm90by5TZWdtZW50JztcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBTZWdtZW50O1xuICAgIH0pKCk7XG5cbiAgICAvKipcbiAgICAgKiBEYXRhTG9jYXRpb24gZW51bS5cbiAgICAgKiBAbmFtZSBvbm54LlRlbnNvclByb3RvLkRhdGFMb2NhdGlvblxuICAgICAqIEBlbnVtIHtudW1iZXJ9XG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IERFRkFVTFQ9MCBERUZBVUxUIHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEVYVEVSTkFMPTEgRVhURVJOQUwgdmFsdWVcbiAgICAgKi9cbiAgICBUZW5zb3JQcm90by5EYXRhTG9jYXRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHZhbHVlc0J5SWQgPSB7fSxcbiAgICAgICAgdmFsdWVzID0gT2JqZWN0LmNyZWF0ZSh2YWx1ZXNCeUlkKTtcbiAgICAgIHZhbHVlc1sodmFsdWVzQnlJZFswXSA9ICdERUZBVUxUJyldID0gMDtcbiAgICAgIHZhbHVlc1sodmFsdWVzQnlJZFsxXSA9ICdFWFRFUk5BTCcpXSA9IDE7XG4gICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH0pKCk7XG5cbiAgICByZXR1cm4gVGVuc29yUHJvdG87XG4gIH0pKCk7XG5cbiAgb25ueC5TcGFyc2VUZW5zb3JQcm90byA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyBvZiBhIFNwYXJzZVRlbnNvclByb3RvLlxuICAgICAqIEBtZW1iZXJvZiBvbm54XG4gICAgICogQGludGVyZmFjZSBJU3BhcnNlVGVuc29yUHJvdG9cbiAgICAgKiBAcHJvcGVydHkge29ubnguSVRlbnNvclByb3RvfG51bGx9IFt2YWx1ZXNdIFNwYXJzZVRlbnNvclByb3RvIHZhbHVlc1xuICAgICAqIEBwcm9wZXJ0eSB7b25ueC5JVGVuc29yUHJvdG98bnVsbH0gW2luZGljZXNdIFNwYXJzZVRlbnNvclByb3RvIGluZGljZXNcbiAgICAgKiBAcHJvcGVydHkge0FycmF5LjxudW1iZXJ8TG9uZz58bnVsbH0gW2RpbXNdIFNwYXJzZVRlbnNvclByb3RvIGRpbXNcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgU3BhcnNlVGVuc29yUHJvdG8uXG4gICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBTcGFyc2VUZW5zb3JQcm90by5cbiAgICAgKiBAaW1wbGVtZW50cyBJU3BhcnNlVGVuc29yUHJvdG9cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge29ubnguSVNwYXJzZVRlbnNvclByb3RvPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICovXG4gICAgZnVuY3Rpb24gU3BhcnNlVGVuc29yUHJvdG8ocHJvcGVydGllcykge1xuICAgICAgdGhpcy5kaW1zID0gW107XG4gICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbCkgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3BhcnNlVGVuc29yUHJvdG8gdmFsdWVzLlxuICAgICAqIEBtZW1iZXIge29ubnguSVRlbnNvclByb3RvfG51bGx8dW5kZWZpbmVkfSB2YWx1ZXNcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5TcGFyc2VUZW5zb3JQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIFNwYXJzZVRlbnNvclByb3RvLnByb3RvdHlwZS52YWx1ZXMgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogU3BhcnNlVGVuc29yUHJvdG8gaW5kaWNlcy5cbiAgICAgKiBAbWVtYmVyIHtvbm54LklUZW5zb3JQcm90b3xudWxsfHVuZGVmaW5lZH0gaW5kaWNlc1xuICAgICAqIEBtZW1iZXJvZiBvbm54LlNwYXJzZVRlbnNvclByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgU3BhcnNlVGVuc29yUHJvdG8ucHJvdG90eXBlLmluZGljZXMgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogU3BhcnNlVGVuc29yUHJvdG8gZGltcy5cbiAgICAgKiBAbWVtYmVyIHtBcnJheS48bnVtYmVyfExvbmc+fSBkaW1zXG4gICAgICogQG1lbWJlcm9mIG9ubnguU3BhcnNlVGVuc29yUHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBTcGFyc2VUZW5zb3JQcm90by5wcm90b3R5cGUuZGltcyA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFNwYXJzZVRlbnNvclByb3RvIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXG4gICAgICogQG1lbWJlcm9mIG9ubnguU3BhcnNlVGVuc29yUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtvbm54LklTcGFyc2VUZW5zb3JQcm90bz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAqIEByZXR1cm5zIHtvbm54LlNwYXJzZVRlbnNvclByb3RvfSBTcGFyc2VUZW5zb3JQcm90byBpbnN0YW5jZVxuICAgICAqL1xuICAgIFNwYXJzZVRlbnNvclByb3RvLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICByZXR1cm4gbmV3IFNwYXJzZVRlbnNvclByb3RvKHByb3BlcnRpZXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgU3BhcnNlVGVuc29yUHJvdG8gbWVzc2FnZS4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5TcGFyc2VUZW5zb3JQcm90by52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXG4gICAgICogQG1lbWJlcm9mIG9ubnguU3BhcnNlVGVuc29yUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtvbm54LklTcGFyc2VUZW5zb3JQcm90b30gbWVzc2FnZSBTcGFyc2VUZW5zb3JQcm90byBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICovXG4gICAgU3BhcnNlVGVuc29yUHJvdG8uZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgaWYgKCF3cml0ZXIpIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICBpZiAobWVzc2FnZS52YWx1ZXMgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCAndmFsdWVzJykpXG4gICAgICAgICRyb290Lm9ubnguVGVuc29yUHJvdG8uZW5jb2RlKG1lc3NhZ2UudmFsdWVzLCB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovIDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgaWYgKG1lc3NhZ2UuaW5kaWNlcyAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsICdpbmRpY2VzJykpXG4gICAgICAgICRyb290Lm9ubnguVGVuc29yUHJvdG8uZW5jb2RlKG1lc3NhZ2UuaW5kaWNlcywgd3JpdGVyLnVpbnQzMigvKiBpZCAyLCB3aXJlVHlwZSAyID0qLyAxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgIGlmIChtZXNzYWdlLmRpbXMgIT0gbnVsbCAmJiBtZXNzYWdlLmRpbXMubGVuZ3RoKSB7XG4gICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMywgd2lyZVR5cGUgMiA9Ki8gMjYpLmZvcmsoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmRpbXMubGVuZ3RoOyArK2kpIHdyaXRlci5pbnQ2NChtZXNzYWdlLmRpbXNbaV0pO1xuICAgICAgICB3cml0ZXIubGRlbGltKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgU3BhcnNlVGVuc29yUHJvdG8gbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5TcGFyc2VUZW5zb3JQcm90by52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgKiBAZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkXG4gICAgICogQG1lbWJlcm9mIG9ubnguU3BhcnNlVGVuc29yUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtvbm54LklTcGFyc2VUZW5zb3JQcm90b30gbWVzc2FnZSBTcGFyc2VUZW5zb3JQcm90byBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICovXG4gICAgU3BhcnNlVGVuc29yUHJvdG8uZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlY29kZXMgYSBTcGFyc2VUZW5zb3JQcm90byBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5TcGFyc2VUZW5zb3JQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAqIEByZXR1cm5zIHtvbm54LlNwYXJzZVRlbnNvclByb3RvfSBTcGFyc2VUZW5zb3JQcm90b1xuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICovXG4gICAgU3BhcnNlVGVuc29yUHJvdG8uZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSkgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLFxuICAgICAgICBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguU3BhcnNlVGVuc29yUHJvdG8oKTtcbiAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICBtZXNzYWdlLnZhbHVlcyA9ICRyb290Lm9ubnguVGVuc29yUHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgIG1lc3NhZ2UuaW5kaWNlcyA9ICRyb290Lm9ubnguVGVuc29yUHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDM6IHtcbiAgICAgICAgICAgIGlmICghKG1lc3NhZ2UuZGltcyAmJiBtZXNzYWdlLmRpbXMubGVuZ3RoKSkgbWVzc2FnZS5kaW1zID0gW107XG4gICAgICAgICAgICBpZiAoKHRhZyAmIDcpID09PSAyKSB7XG4gICAgICAgICAgICAgIHZhciBlbmQyID0gcmVhZGVyLnVpbnQzMigpICsgcmVhZGVyLnBvcztcbiAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQyKSBtZXNzYWdlLmRpbXMucHVzaChyZWFkZXIuaW50NjQoKSk7XG4gICAgICAgICAgICB9IGVsc2UgbWVzc2FnZS5kaW1zLnB1c2gocmVhZGVyLmludDY0KCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlY29kZXMgYSBTcGFyc2VUZW5zb3JQcm90byBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLCBsZW5ndGggZGVsaW1pdGVkLlxuICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5TcGFyc2VUZW5zb3JQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgKiBAcmV0dXJucyB7b25ueC5TcGFyc2VUZW5zb3JQcm90b30gU3BhcnNlVGVuc29yUHJvdG9cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAqL1xuICAgIFNwYXJzZVRlbnNvclByb3RvLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKSByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgYSBTcGFyc2VUZW5zb3JQcm90byBtZXNzYWdlLlxuICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5TcGFyc2VUZW5zb3JQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICAgICAqL1xuICAgIFNwYXJzZVRlbnNvclByb3RvLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09ICdvYmplY3QnIHx8IG1lc3NhZ2UgPT09IG51bGwpIHJldHVybiAnb2JqZWN0IGV4cGVjdGVkJztcbiAgICAgIGlmIChtZXNzYWdlLnZhbHVlcyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ3ZhbHVlcycpKSB7XG4gICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguVGVuc29yUHJvdG8udmVyaWZ5KG1lc3NhZ2UudmFsdWVzKTtcbiAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gJ3ZhbHVlcy4nICsgZXJyb3I7XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5pbmRpY2VzICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnaW5kaWNlcycpKSB7XG4gICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguVGVuc29yUHJvdG8udmVyaWZ5KG1lc3NhZ2UuaW5kaWNlcyk7XG4gICAgICAgIGlmIChlcnJvcikgcmV0dXJuICdpbmRpY2VzLicgKyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLmRpbXMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdkaW1zJykpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UuZGltcykpIHJldHVybiAnZGltczogYXJyYXkgZXhwZWN0ZWQnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuZGltcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuZGltc1tpXSkgJiZcbiAgICAgICAgICAgICEobWVzc2FnZS5kaW1zW2ldICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmRpbXNbaV0ubG93KSAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5kaW1zW2ldLmhpZ2gpKVxuICAgICAgICAgIClcbiAgICAgICAgICAgIHJldHVybiAnZGltczogaW50ZWdlcnxMb25nW10gZXhwZWN0ZWQnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBTcGFyc2VUZW5zb3JQcm90byBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gICAgICogQGZ1bmN0aW9uIGZyb21PYmplY3RcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5TcGFyc2VUZW5zb3JQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gICAgICogQHJldHVybnMge29ubnguU3BhcnNlVGVuc29yUHJvdG99IFNwYXJzZVRlbnNvclByb3RvXG4gICAgICovXG4gICAgU3BhcnNlVGVuc29yUHJvdG8uZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3Qub25ueC5TcGFyc2VUZW5zb3JQcm90bykgcmV0dXJuIG9iamVjdDtcbiAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguU3BhcnNlVGVuc29yUHJvdG8oKTtcbiAgICAgIGlmIChvYmplY3QudmFsdWVzICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QudmFsdWVzICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCcub25ueC5TcGFyc2VUZW5zb3JQcm90by52YWx1ZXM6IG9iamVjdCBleHBlY3RlZCcpO1xuICAgICAgICBtZXNzYWdlLnZhbHVlcyA9ICRyb290Lm9ubnguVGVuc29yUHJvdG8uZnJvbU9iamVjdChvYmplY3QudmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3QuaW5kaWNlcyAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmluZGljZXMgIT09ICdvYmplY3QnKSB0aHJvdyBUeXBlRXJyb3IoJy5vbm54LlNwYXJzZVRlbnNvclByb3RvLmluZGljZXM6IG9iamVjdCBleHBlY3RlZCcpO1xuICAgICAgICBtZXNzYWdlLmluZGljZXMgPSAkcm9vdC5vbm54LlRlbnNvclByb3RvLmZyb21PYmplY3Qob2JqZWN0LmluZGljZXMpO1xuICAgICAgfVxuICAgICAgaWYgKG9iamVjdC5kaW1zKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QuZGltcykpIHRocm93IFR5cGVFcnJvcignLm9ubnguU3BhcnNlVGVuc29yUHJvdG8uZGltczogYXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgbWVzc2FnZS5kaW1zID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LmRpbXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgaWYgKCR1dGlsLkxvbmcpIChtZXNzYWdlLmRpbXNbaV0gPSAkdXRpbC5Mb25nLmZyb21WYWx1ZShvYmplY3QuZGltc1tpXSkpLnVuc2lnbmVkID0gZmFsc2U7XG4gICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5kaW1zW2ldID09PSAnc3RyaW5nJykgbWVzc2FnZS5kaW1zW2ldID0gcGFyc2VJbnQob2JqZWN0LmRpbXNbaV0sIDEwKTtcbiAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmRpbXNbaV0gPT09ICdudW1iZXInKSBtZXNzYWdlLmRpbXNbaV0gPSBvYmplY3QuZGltc1tpXTtcbiAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmRpbXNbaV0gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgbWVzc2FnZS5kaW1zW2ldID0gbmV3ICR1dGlsLkxvbmdCaXRzKG9iamVjdC5kaW1zW2ldLmxvdyA+Pj4gMCwgb2JqZWN0LmRpbXNbaV0uaGlnaCA+Pj4gMCkudG9OdW1iZXIoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYSBTcGFyc2VUZW5zb3JQcm90byBtZXNzYWdlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXG4gICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XG4gICAgICogQG1lbWJlcm9mIG9ubnguU3BhcnNlVGVuc29yUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtvbm54LlNwYXJzZVRlbnNvclByb3RvfSBtZXNzYWdlIFNwYXJzZVRlbnNvclByb3RvXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuSUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcbiAgICAgKi9cbiAgICBTcGFyc2VUZW5zb3JQcm90by50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgaWYgKG9wdGlvbnMuYXJyYXlzIHx8IG9wdGlvbnMuZGVmYXVsdHMpIG9iamVjdC5kaW1zID0gW107XG4gICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICBvYmplY3QudmFsdWVzID0gbnVsbDtcbiAgICAgICAgb2JqZWN0LmluZGljZXMgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UudmFsdWVzICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgndmFsdWVzJykpXG4gICAgICAgIG9iamVjdC52YWx1ZXMgPSAkcm9vdC5vbm54LlRlbnNvclByb3RvLnRvT2JqZWN0KG1lc3NhZ2UudmFsdWVzLCBvcHRpb25zKTtcbiAgICAgIGlmIChtZXNzYWdlLmluZGljZXMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdpbmRpY2VzJykpXG4gICAgICAgIG9iamVjdC5pbmRpY2VzID0gJHJvb3Qub25ueC5UZW5zb3JQcm90by50b09iamVjdChtZXNzYWdlLmluZGljZXMsIG9wdGlvbnMpO1xuICAgICAgaWYgKG1lc3NhZ2UuZGltcyAmJiBtZXNzYWdlLmRpbXMubGVuZ3RoKSB7XG4gICAgICAgIG9iamVjdC5kaW1zID0gW107XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5kaW1zLmxlbmd0aDsgKytqKVxuICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5kaW1zW2pdID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgIG9iamVjdC5kaW1zW2pdID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gU3RyaW5nKG1lc3NhZ2UuZGltc1tqXSkgOiBtZXNzYWdlLmRpbXNbal07XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgb2JqZWN0LmRpbXNbal0gPVxuICAgICAgICAgICAgICBvcHRpb25zLmxvbmdzID09PSBTdHJpbmdcbiAgICAgICAgICAgICAgICA/ICR1dGlsLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobWVzc2FnZS5kaW1zW2pdKVxuICAgICAgICAgICAgICAgIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyXG4gICAgICAgICAgICAgICAgICA/IG5ldyAkdXRpbC5Mb25nQml0cyhtZXNzYWdlLmRpbXNbal0ubG93ID4+PiAwLCBtZXNzYWdlLmRpbXNbal0uaGlnaCA+Pj4gMCkudG9OdW1iZXIoKVxuICAgICAgICAgICAgICAgICAgOiBtZXNzYWdlLmRpbXNbal07XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGlzIFNwYXJzZVRlbnNvclByb3RvIHRvIEpTT04uXG4gICAgICogQGZ1bmN0aW9uIHRvSlNPTlxuICAgICAqIEBtZW1iZXJvZiBvbm54LlNwYXJzZVRlbnNvclByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICAgICAqL1xuICAgIFNwYXJzZVRlbnNvclByb3RvLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZGVmYXVsdCB0eXBlIHVybCBmb3IgU3BhcnNlVGVuc29yUHJvdG9cbiAgICAgKiBAZnVuY3Rpb24gZ2V0VHlwZVVybFxuICAgICAqIEBtZW1iZXJvZiBvbm54LlNwYXJzZVRlbnNvclByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZVVybFByZWZpeF0geW91ciBjdXN0b20gdHlwZVVybFByZWZpeChkZWZhdWx0IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiKVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBkZWZhdWx0IHR5cGUgdXJsXG4gICAgICovXG4gICAgU3BhcnNlVGVuc29yUHJvdG8uZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0eXBlVXJsUHJlZml4ID0gJ3R5cGUuZ29vZ2xlYXBpcy5jb20nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyAnL29ubnguU3BhcnNlVGVuc29yUHJvdG8nO1xuICAgIH07XG5cbiAgICByZXR1cm4gU3BhcnNlVGVuc29yUHJvdG87XG4gIH0pKCk7XG5cbiAgb25ueC5UZW5zb3JTaGFwZVByb3RvID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgVGVuc29yU2hhcGVQcm90by5cbiAgICAgKiBAbWVtYmVyb2Ygb25ueFxuICAgICAqIEBpbnRlcmZhY2UgSVRlbnNvclNoYXBlUHJvdG9cbiAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LlRlbnNvclNoYXBlUHJvdG8uSURpbWVuc2lvbj58bnVsbH0gW2RpbV0gVGVuc29yU2hhcGVQcm90byBkaW1cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgVGVuc29yU2hhcGVQcm90by5cbiAgICAgKiBAbWVtYmVyb2Ygb25ueFxuICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIFRlbnNvclNoYXBlUHJvdG8uXG4gICAgICogQGltcGxlbWVudHMgSVRlbnNvclNoYXBlUHJvdG9cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge29ubnguSVRlbnNvclNoYXBlUHJvdG89fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUZW5zb3JTaGFwZVByb3RvKHByb3BlcnRpZXMpIHtcbiAgICAgIHRoaXMuZGltID0gW107XG4gICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbCkgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGVuc29yU2hhcGVQcm90byBkaW0uXG4gICAgICogQG1lbWJlciB7QXJyYXkuPG9ubnguVGVuc29yU2hhcGVQcm90by5JRGltZW5zaW9uPn0gZGltXG4gICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yU2hhcGVQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIFRlbnNvclNoYXBlUHJvdG8ucHJvdG90eXBlLmRpbSA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFRlbnNvclNoYXBlUHJvdG8gaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAqIEBmdW5jdGlvbiBjcmVhdGVcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JTaGFwZVByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7b25ueC5JVGVuc29yU2hhcGVQcm90bz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAqIEByZXR1cm5zIHtvbm54LlRlbnNvclNoYXBlUHJvdG99IFRlbnNvclNoYXBlUHJvdG8gaW5zdGFuY2VcbiAgICAgKi9cbiAgICBUZW5zb3JTaGFwZVByb3RvLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICByZXR1cm4gbmV3IFRlbnNvclNoYXBlUHJvdG8ocHJvcGVydGllcyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBUZW5zb3JTaGFwZVByb3RvIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguVGVuc29yU2hhcGVQcm90by52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXG4gICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yU2hhcGVQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge29ubnguSVRlbnNvclNoYXBlUHJvdG99IG1lc3NhZ2UgVGVuc29yU2hhcGVQcm90byBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICovXG4gICAgVGVuc29yU2hhcGVQcm90by5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICBpZiAoIXdyaXRlcikgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgIGlmIChtZXNzYWdlLmRpbSAhPSBudWxsICYmIG1lc3NhZ2UuZGltLmxlbmd0aClcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmRpbS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAkcm9vdC5vbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uLmVuY29kZShcbiAgICAgICAgICAgIG1lc3NhZ2UuZGltW2ldLFxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAxLCB3aXJlVHlwZSAyID0qLyAxMCkuZm9yaygpLFxuICAgICAgICAgICkubGRlbGltKCk7XG4gICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgVGVuc29yU2hhcGVQcm90byBtZXNzYWdlLCBsZW5ndGggZGVsaW1pdGVkLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LlRlbnNvclNoYXBlUHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclNoYXBlUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtvbm54LklUZW5zb3JTaGFwZVByb3RvfSBtZXNzYWdlIFRlbnNvclNoYXBlUHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAqL1xuICAgIFRlbnNvclNoYXBlUHJvdG8uZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlY29kZXMgYSBUZW5zb3JTaGFwZVByb3RvIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclNoYXBlUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgKiBAcmV0dXJucyB7b25ueC5UZW5zb3JTaGFwZVByb3RvfSBUZW5zb3JTaGFwZVByb3RvXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgKi9cbiAgICBUZW5zb3JTaGFwZVByb3RvLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCxcbiAgICAgICAgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LlRlbnNvclNoYXBlUHJvdG8oKTtcbiAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICBpZiAoIShtZXNzYWdlLmRpbSAmJiBtZXNzYWdlLmRpbS5sZW5ndGgpKSBtZXNzYWdlLmRpbSA9IFtdO1xuICAgICAgICAgICAgbWVzc2FnZS5kaW0ucHVzaCgkcm9vdC5vbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlY29kZXMgYSBUZW5zb3JTaGFwZVByb3RvIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICogQGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZFxuICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclNoYXBlUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICogQHJldHVybnMge29ubnguVGVuc29yU2hhcGVQcm90b30gVGVuc29yU2hhcGVQcm90b1xuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICovXG4gICAgVGVuc29yU2hhcGVQcm90by5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSkgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFZlcmlmaWVzIGEgVGVuc29yU2hhcGVQcm90byBtZXNzYWdlLlxuICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JTaGFwZVByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XG4gICAgICovXG4gICAgVGVuc29yU2hhcGVQcm90by52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSAnb2JqZWN0JyB8fCBtZXNzYWdlID09PSBudWxsKSByZXR1cm4gJ29iamVjdCBleHBlY3RlZCc7XG4gICAgICBpZiAobWVzc2FnZS5kaW0gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdkaW0nKSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5kaW0pKSByZXR1cm4gJ2RpbTogYXJyYXkgZXhwZWN0ZWQnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuZGltLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbi52ZXJpZnkobWVzc2FnZS5kaW1baV0pO1xuICAgICAgICAgIGlmIChlcnJvcikgcmV0dXJuICdkaW0uJyArIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFRlbnNvclNoYXBlUHJvdG8gbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yU2hhcGVQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gICAgICogQHJldHVybnMge29ubnguVGVuc29yU2hhcGVQcm90b30gVGVuc29yU2hhcGVQcm90b1xuICAgICAqL1xuICAgIFRlbnNvclNoYXBlUHJvdG8uZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3Qub25ueC5UZW5zb3JTaGFwZVByb3RvKSByZXR1cm4gb2JqZWN0O1xuICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5UZW5zb3JTaGFwZVByb3RvKCk7XG4gICAgICBpZiAob2JqZWN0LmRpbSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LmRpbSkpIHRocm93IFR5cGVFcnJvcignLm9ubnguVGVuc29yU2hhcGVQcm90by5kaW06IGFycmF5IGV4cGVjdGVkJyk7XG4gICAgICAgIG1lc3NhZ2UuZGltID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LmRpbS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmRpbVtpXSAhPT0gJ29iamVjdCcpIHRocm93IFR5cGVFcnJvcignLm9ubnguVGVuc29yU2hhcGVQcm90by5kaW06IG9iamVjdCBleHBlY3RlZCcpO1xuICAgICAgICAgIG1lc3NhZ2UuZGltW2ldID0gJHJvb3Qub25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbi5mcm9tT2JqZWN0KG9iamVjdC5kaW1baV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgVGVuc29yU2hhcGVQcm90byBtZXNzYWdlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXG4gICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XG4gICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yU2hhcGVQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge29ubnguVGVuc29yU2hhcGVQcm90b30gbWVzc2FnZSBUZW5zb3JTaGFwZVByb3RvXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuSUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcbiAgICAgKi9cbiAgICBUZW5zb3JTaGFwZVByb3RvLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICBpZiAob3B0aW9ucy5hcnJheXMgfHwgb3B0aW9ucy5kZWZhdWx0cykgb2JqZWN0LmRpbSA9IFtdO1xuICAgICAgaWYgKG1lc3NhZ2UuZGltICYmIG1lc3NhZ2UuZGltLmxlbmd0aCkge1xuICAgICAgICBvYmplY3QuZGltID0gW107XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5kaW0ubGVuZ3RoOyArK2opXG4gICAgICAgICAgb2JqZWN0LmRpbVtqXSA9ICRyb290Lm9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb24udG9PYmplY3QobWVzc2FnZS5kaW1bal0sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhpcyBUZW5zb3JTaGFwZVByb3RvIHRvIEpTT04uXG4gICAgICogQGZ1bmN0aW9uIHRvSlNPTlxuICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclNoYXBlUHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IEpTT04gb2JqZWN0XG4gICAgICovXG4gICAgVGVuc29yU2hhcGVQcm90by5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGRlZmF1bHQgdHlwZSB1cmwgZm9yIFRlbnNvclNoYXBlUHJvdG9cbiAgICAgKiBAZnVuY3Rpb24gZ2V0VHlwZVVybFxuICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclNoYXBlUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlVXJsUHJlZml4XSB5b3VyIGN1c3RvbSB0eXBlVXJsUHJlZml4KGRlZmF1bHQgXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCIpXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGRlZmF1bHQgdHlwZSB1cmxcbiAgICAgKi9cbiAgICBUZW5zb3JTaGFwZVByb3RvLmdldFR5cGVVcmwgPSBmdW5jdGlvbiBnZXRUeXBlVXJsKHR5cGVVcmxQcmVmaXgpIHtcbiAgICAgIGlmICh0eXBlVXJsUHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdHlwZVVybFByZWZpeCA9ICd0eXBlLmdvb2dsZWFwaXMuY29tJztcbiAgICAgIH1cbiAgICAgIHJldHVybiB0eXBlVXJsUHJlZml4ICsgJy9vbm54LlRlbnNvclNoYXBlUHJvdG8nO1xuICAgIH07XG5cbiAgICBUZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAvKipcbiAgICAgICAqIFByb3BlcnRpZXMgb2YgYSBEaW1lbnNpb24uXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JTaGFwZVByb3RvXG4gICAgICAgKiBAaW50ZXJmYWNlIElEaW1lbnNpb25cbiAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfExvbmd8bnVsbH0gW2RpbVZhbHVlXSBEaW1lbnNpb24gZGltVmFsdWVcbiAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtkaW1QYXJhbV0gRGltZW5zaW9uIGRpbVBhcmFtXG4gICAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbZGVub3RhdGlvbl0gRGltZW5zaW9uIGRlbm90YXRpb25cbiAgICAgICAqL1xuXG4gICAgICAvKipcbiAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgRGltZW5zaW9uLlxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yU2hhcGVQcm90b1xuICAgICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgRGltZW5zaW9uLlxuICAgICAgICogQGltcGxlbWVudHMgSURpbWVuc2lvblxuICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgKiBAcGFyYW0ge29ubnguVGVuc29yU2hhcGVQcm90by5JRGltZW5zaW9uPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIERpbWVuc2lvbihwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbCkgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRGltZW5zaW9uIGRpbVZhbHVlLlxuICAgICAgICogQG1lbWJlciB7bnVtYmVyfExvbmd8bnVsbHx1bmRlZmluZWR9IGRpbVZhbHVlXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvblxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKi9cbiAgICAgIERpbWVuc2lvbi5wcm90b3R5cGUuZGltVmFsdWUgPSBudWxsO1xuXG4gICAgICAvKipcbiAgICAgICAqIERpbWVuc2lvbiBkaW1QYXJhbS5cbiAgICAgICAqIEBtZW1iZXIge3N0cmluZ3xudWxsfHVuZGVmaW5lZH0gZGltUGFyYW1cbiAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqL1xuICAgICAgRGltZW5zaW9uLnByb3RvdHlwZS5kaW1QYXJhbSA9IG51bGw7XG5cbiAgICAgIC8qKlxuICAgICAgICogRGltZW5zaW9uIGRlbm90YXRpb24uXG4gICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IGRlbm90YXRpb25cbiAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqL1xuICAgICAgRGltZW5zaW9uLnByb3RvdHlwZS5kZW5vdGF0aW9uID0gJyc7XG5cbiAgICAgIC8vIE9uZU9mIGZpZWxkIG5hbWVzIGJvdW5kIHRvIHZpcnR1YWwgZ2V0dGVycyBhbmQgc2V0dGVyc1xuICAgICAgdmFyICRvbmVPZkZpZWxkcztcblxuICAgICAgLyoqXG4gICAgICAgKiBEaW1lbnNpb24gdmFsdWUuXG4gICAgICAgKiBAbWVtYmVyIHtcImRpbVZhbHVlXCJ8XCJkaW1QYXJhbVwifHVuZGVmaW5lZH0gdmFsdWVcbiAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqL1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERpbWVuc2lvbi5wcm90b3R5cGUsICd2YWx1ZScsIHtcbiAgICAgICAgZ2V0OiAkdXRpbC5vbmVPZkdldHRlcigoJG9uZU9mRmllbGRzID0gWydkaW1WYWx1ZScsICdkaW1QYXJhbSddKSksXG4gICAgICAgIHNldDogJHV0aWwub25lT2ZTZXR0ZXIoJG9uZU9mRmllbGRzKSxcbiAgICAgIH0pO1xuXG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgYSBuZXcgRGltZW5zaW9uIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgICAqIEBmdW5jdGlvbiBjcmVhdGVcbiAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uXG4gICAgICAgKiBAc3RhdGljXG4gICAgICAgKiBAcGFyYW0ge29ubnguVGVuc29yU2hhcGVQcm90by5JRGltZW5zaW9uPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgKiBAcmV0dXJucyB7b25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbn0gRGltZW5zaW9uIGluc3RhbmNlXG4gICAgICAgKi9cbiAgICAgIERpbWVuc2lvbi5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICByZXR1cm4gbmV3IERpbWVuc2lvbihwcm9wZXJ0aWVzKTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIERpbWVuc2lvbiBtZXNzYWdlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICogQGZ1bmN0aW9uIGVuY29kZVxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb25cbiAgICAgICAqIEBzdGF0aWNcbiAgICAgICAqIEBwYXJhbSB7b25ueC5UZW5zb3JTaGFwZVByb3RvLklEaW1lbnNpb259IG1lc3NhZ2UgRGltZW5zaW9uIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgKi9cbiAgICAgIERpbWVuc2lvbi5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgIGlmICghd3JpdGVyKSB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICBpZiAobWVzc2FnZS5kaW1WYWx1ZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsICdkaW1WYWx1ZScpKVxuICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMCA9Ki8gOCkuaW50NjQobWVzc2FnZS5kaW1WYWx1ZSk7XG4gICAgICAgIGlmIChtZXNzYWdlLmRpbVBhcmFtICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgJ2RpbVBhcmFtJykpXG4gICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAyLCB3aXJlVHlwZSAyID0qLyAxOCkuc3RyaW5nKG1lc3NhZ2UuZGltUGFyYW0pO1xuICAgICAgICBpZiAobWVzc2FnZS5kZW5vdGF0aW9uICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgJ2Rlbm90YXRpb24nKSlcbiAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDMsIHdpcmVUeXBlIDIgPSovIDI2KS5zdHJpbmcobWVzc2FnZS5kZW5vdGF0aW9uKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIERpbWVuc2lvbiBtZXNzYWdlLCBsZW5ndGggZGVsaW1pdGVkLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb25cbiAgICAgICAqIEBzdGF0aWNcbiAgICAgICAqIEBwYXJhbSB7b25ueC5UZW5zb3JTaGFwZVByb3RvLklEaW1lbnNpb259IG1lc3NhZ2UgRGltZW5zaW9uIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgKi9cbiAgICAgIERpbWVuc2lvbi5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBEZWNvZGVzIGEgRGltZW5zaW9uIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvblxuICAgICAgICogQHN0YXRpY1xuICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAgICogQHJldHVybnMge29ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb259IERpbWVuc2lvblxuICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICovXG4gICAgICBEaW1lbnNpb24uZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKSByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCxcbiAgICAgICAgICBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb24oKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgICAgbWVzc2FnZS5kaW1WYWx1ZSA9IHJlYWRlci5pbnQ2NCgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgICAgICBtZXNzYWdlLmRpbVBhcmFtID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMzoge1xuICAgICAgICAgICAgICBtZXNzYWdlLmRlbm90YXRpb24gPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIERlY29kZXMgYSBEaW1lbnNpb24gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlciwgbGVuZ3RoIGRlbGltaXRlZC5cbiAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uXG4gICAgICAgKiBAc3RhdGljXG4gICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAqIEByZXR1cm5zIHtvbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9ufSBEaW1lbnNpb25cbiAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAqL1xuICAgICAgRGltZW5zaW9uLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIFZlcmlmaWVzIGEgRGltZW5zaW9uIG1lc3NhZ2UuXG4gICAgICAgKiBAZnVuY3Rpb24gdmVyaWZ5XG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvblxuICAgICAgICogQHN0YXRpY1xuICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XG4gICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICAgICAgICovXG4gICAgICBEaW1lbnNpb24udmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSAnb2JqZWN0JyB8fCBtZXNzYWdlID09PSBudWxsKSByZXR1cm4gJ29iamVjdCBleHBlY3RlZCc7XG4gICAgICAgIHZhciBwcm9wZXJ0aWVzID0ge307XG4gICAgICAgIGlmIChtZXNzYWdlLmRpbVZhbHVlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnZGltVmFsdWUnKSkge1xuICAgICAgICAgIHByb3BlcnRpZXMudmFsdWUgPSAxO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5kaW1WYWx1ZSkgJiZcbiAgICAgICAgICAgICEobWVzc2FnZS5kaW1WYWx1ZSAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5kaW1WYWx1ZS5sb3cpICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmRpbVZhbHVlLmhpZ2gpKVxuICAgICAgICAgIClcbiAgICAgICAgICAgIHJldHVybiAnZGltVmFsdWU6IGludGVnZXJ8TG9uZyBleHBlY3RlZCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuZGltUGFyYW0gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdkaW1QYXJhbScpKSB7XG4gICAgICAgICAgaWYgKHByb3BlcnRpZXMudmFsdWUgPT09IDEpIHJldHVybiAndmFsdWU6IG11bHRpcGxlIHZhbHVlcyc7XG4gICAgICAgICAgcHJvcGVydGllcy52YWx1ZSA9IDE7XG4gICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLmRpbVBhcmFtKSkgcmV0dXJuICdkaW1QYXJhbTogc3RyaW5nIGV4cGVjdGVkJztcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5kZW5vdGF0aW9uICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnZGVub3RhdGlvbicpKVxuICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5kZW5vdGF0aW9uKSkgcmV0dXJuICdkZW5vdGF0aW9uOiBzdHJpbmcgZXhwZWN0ZWQnO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlcyBhIERpbWVuc2lvbiBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gICAgICAgKiBAZnVuY3Rpb24gZnJvbU9iamVjdFxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb25cbiAgICAgICAqIEBzdGF0aWNcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcbiAgICAgICAqIEByZXR1cm5zIHtvbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9ufSBEaW1lbnNpb25cbiAgICAgICAqL1xuICAgICAgRGltZW5zaW9uLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3Qub25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbikgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbigpO1xuICAgICAgICBpZiAob2JqZWN0LmRpbVZhbHVlICE9IG51bGwpXG4gICAgICAgICAgaWYgKCR1dGlsLkxvbmcpIChtZXNzYWdlLmRpbVZhbHVlID0gJHV0aWwuTG9uZy5mcm9tVmFsdWUob2JqZWN0LmRpbVZhbHVlKSkudW5zaWduZWQgPSBmYWxzZTtcbiAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmRpbVZhbHVlID09PSAnc3RyaW5nJykgbWVzc2FnZS5kaW1WYWx1ZSA9IHBhcnNlSW50KG9iamVjdC5kaW1WYWx1ZSwgMTApO1xuICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuZGltVmFsdWUgPT09ICdudW1iZXInKSBtZXNzYWdlLmRpbVZhbHVlID0gb2JqZWN0LmRpbVZhbHVlO1xuICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuZGltVmFsdWUgPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgbWVzc2FnZS5kaW1WYWx1ZSA9IG5ldyAkdXRpbC5Mb25nQml0cyhvYmplY3QuZGltVmFsdWUubG93ID4+PiAwLCBvYmplY3QuZGltVmFsdWUuaGlnaCA+Pj4gMCkudG9OdW1iZXIoKTtcbiAgICAgICAgaWYgKG9iamVjdC5kaW1QYXJhbSAhPSBudWxsKSBtZXNzYWdlLmRpbVBhcmFtID0gU3RyaW5nKG9iamVjdC5kaW1QYXJhbSk7XG4gICAgICAgIGlmIChvYmplY3QuZGVub3RhdGlvbiAhPSBudWxsKSBtZXNzYWdlLmRlbm90YXRpb24gPSBTdHJpbmcob2JqZWN0LmRlbm90YXRpb24pO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgRGltZW5zaW9uIG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAgICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb25cbiAgICAgICAqIEBzdGF0aWNcbiAgICAgICAqIEBwYXJhbSB7b25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbn0gbWVzc2FnZSBEaW1lbnNpb25cbiAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcbiAgICAgICAqL1xuICAgICAgRGltZW5zaW9uLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykgb2JqZWN0LmRlbm90YXRpb24gPSAnJztcbiAgICAgICAgaWYgKG1lc3NhZ2UuZGltVmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdkaW1WYWx1ZScpKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmRpbVZhbHVlID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgIG9iamVjdC5kaW1WYWx1ZSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtZXNzYWdlLmRpbVZhbHVlKSA6IG1lc3NhZ2UuZGltVmFsdWU7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgb2JqZWN0LmRpbVZhbHVlID1cbiAgICAgICAgICAgICAgb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nXG4gICAgICAgICAgICAgICAgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1lc3NhZ2UuZGltVmFsdWUpXG4gICAgICAgICAgICAgICAgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXJcbiAgICAgICAgICAgICAgICAgID8gbmV3ICR1dGlsLkxvbmdCaXRzKG1lc3NhZ2UuZGltVmFsdWUubG93ID4+PiAwLCBtZXNzYWdlLmRpbVZhbHVlLmhpZ2ggPj4+IDApLnRvTnVtYmVyKClcbiAgICAgICAgICAgICAgICAgIDogbWVzc2FnZS5kaW1WYWx1ZTtcbiAgICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpIG9iamVjdC52YWx1ZSA9ICdkaW1WYWx1ZSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuZGltUGFyYW0gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdkaW1QYXJhbScpKSB7XG4gICAgICAgICAgb2JqZWN0LmRpbVBhcmFtID0gbWVzc2FnZS5kaW1QYXJhbTtcbiAgICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpIG9iamVjdC52YWx1ZSA9ICdkaW1QYXJhbSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuZGVub3RhdGlvbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ2Rlbm90YXRpb24nKSkgb2JqZWN0LmRlbm90YXRpb24gPSBtZXNzYWdlLmRlbm90YXRpb247XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIENvbnZlcnRzIHRoaXMgRGltZW5zaW9uIHRvIEpTT04uXG4gICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvblxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IEpTT04gb2JqZWN0XG4gICAgICAgKi9cbiAgICAgIERpbWVuc2lvbi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogR2V0cyB0aGUgZGVmYXVsdCB0eXBlIHVybCBmb3IgRGltZW5zaW9uXG4gICAgICAgKiBAZnVuY3Rpb24gZ2V0VHlwZVVybFxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb25cbiAgICAgICAqIEBzdGF0aWNcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZVVybFByZWZpeF0geW91ciBjdXN0b20gdHlwZVVybFByZWZpeChkZWZhdWx0IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiKVxuICAgICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGRlZmF1bHQgdHlwZSB1cmxcbiAgICAgICAqL1xuICAgICAgRGltZW5zaW9uLmdldFR5cGVVcmwgPSBmdW5jdGlvbiBnZXRUeXBlVXJsKHR5cGVVcmxQcmVmaXgpIHtcbiAgICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHR5cGVVcmxQcmVmaXggPSAndHlwZS5nb29nbGVhcGlzLmNvbSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyAnL29ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb24nO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIERpbWVuc2lvbjtcbiAgICB9KSgpO1xuXG4gICAgcmV0dXJuIFRlbnNvclNoYXBlUHJvdG87XG4gIH0pKCk7XG5cbiAgb25ueC5UeXBlUHJvdG8gPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgb2YgYSBUeXBlUHJvdG8uXG4gICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgKiBAaW50ZXJmYWNlIElUeXBlUHJvdG9cbiAgICAgKiBAcHJvcGVydHkge29ubnguVHlwZVByb3RvLklUZW5zb3J8bnVsbH0gW3RlbnNvclR5cGVdIFR5cGVQcm90byB0ZW5zb3JUeXBlXG4gICAgICogQHByb3BlcnR5IHtvbm54LlR5cGVQcm90by5JU2VxdWVuY2V8bnVsbH0gW3NlcXVlbmNlVHlwZV0gVHlwZVByb3RvIHNlcXVlbmNlVHlwZVxuICAgICAqIEBwcm9wZXJ0eSB7b25ueC5UeXBlUHJvdG8uSU1hcHxudWxsfSBbbWFwVHlwZV0gVHlwZVByb3RvIG1hcFR5cGVcbiAgICAgKiBAcHJvcGVydHkge29ubnguVHlwZVByb3RvLklPcHRpb25hbHxudWxsfSBbb3B0aW9uYWxUeXBlXSBUeXBlUHJvdG8gb3B0aW9uYWxUeXBlXG4gICAgICogQHByb3BlcnR5IHtvbm54LlR5cGVQcm90by5JU3BhcnNlVGVuc29yfG51bGx9IFtzcGFyc2VUZW5zb3JUeXBlXSBUeXBlUHJvdG8gc3BhcnNlVGVuc29yVHlwZVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtkZW5vdGF0aW9uXSBUeXBlUHJvdG8gZGVub3RhdGlvblxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBUeXBlUHJvdG8uXG4gICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBUeXBlUHJvdG8uXG4gICAgICogQGltcGxlbWVudHMgSVR5cGVQcm90b1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7b25ueC5JVHlwZVByb3RvPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICovXG4gICAgZnVuY3Rpb24gVHlwZVByb3RvKHByb3BlcnRpZXMpIHtcbiAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKSB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUeXBlUHJvdG8gdGVuc29yVHlwZS5cbiAgICAgKiBAbWVtYmVyIHtvbm54LlR5cGVQcm90by5JVGVuc29yfG51bGx8dW5kZWZpbmVkfSB0ZW5zb3JUeXBlXG4gICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgVHlwZVByb3RvLnByb3RvdHlwZS50ZW5zb3JUeXBlID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFR5cGVQcm90byBzZXF1ZW5jZVR5cGUuXG4gICAgICogQG1lbWJlciB7b25ueC5UeXBlUHJvdG8uSVNlcXVlbmNlfG51bGx8dW5kZWZpbmVkfSBzZXF1ZW5jZVR5cGVcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBUeXBlUHJvdG8ucHJvdG90eXBlLnNlcXVlbmNlVHlwZSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlUHJvdG8gbWFwVHlwZS5cbiAgICAgKiBAbWVtYmVyIHtvbm54LlR5cGVQcm90by5JTWFwfG51bGx8dW5kZWZpbmVkfSBtYXBUeXBlXG4gICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgVHlwZVByb3RvLnByb3RvdHlwZS5tYXBUeXBlID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFR5cGVQcm90byBvcHRpb25hbFR5cGUuXG4gICAgICogQG1lbWJlciB7b25ueC5UeXBlUHJvdG8uSU9wdGlvbmFsfG51bGx8dW5kZWZpbmVkfSBvcHRpb25hbFR5cGVcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBUeXBlUHJvdG8ucHJvdG90eXBlLm9wdGlvbmFsVHlwZSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlUHJvdG8gc3BhcnNlVGVuc29yVHlwZS5cbiAgICAgKiBAbWVtYmVyIHtvbm54LlR5cGVQcm90by5JU3BhcnNlVGVuc29yfG51bGx8dW5kZWZpbmVkfSBzcGFyc2VUZW5zb3JUeXBlXG4gICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgVHlwZVByb3RvLnByb3RvdHlwZS5zcGFyc2VUZW5zb3JUeXBlID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFR5cGVQcm90byBkZW5vdGF0aW9uLlxuICAgICAqIEBtZW1iZXIge3N0cmluZ30gZGVub3RhdGlvblxuICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIFR5cGVQcm90by5wcm90b3R5cGUuZGVub3RhdGlvbiA9ICcnO1xuXG4gICAgLy8gT25lT2YgZmllbGQgbmFtZXMgYm91bmQgdG8gdmlydHVhbCBnZXR0ZXJzIGFuZCBzZXR0ZXJzXG4gICAgdmFyICRvbmVPZkZpZWxkcztcblxuICAgIC8qKlxuICAgICAqIFR5cGVQcm90byB2YWx1ZS5cbiAgICAgKiBAbWVtYmVyIHtcInRlbnNvclR5cGVcInxcInNlcXVlbmNlVHlwZVwifFwibWFwVHlwZVwifFwib3B0aW9uYWxUeXBlXCJ8XCJzcGFyc2VUZW5zb3JUeXBlXCJ8dW5kZWZpbmVkfSB2YWx1ZVxuICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUeXBlUHJvdG8ucHJvdG90eXBlLCAndmFsdWUnLCB7XG4gICAgICBnZXQ6ICR1dGlsLm9uZU9mR2V0dGVyKFxuICAgICAgICAoJG9uZU9mRmllbGRzID0gWyd0ZW5zb3JUeXBlJywgJ3NlcXVlbmNlVHlwZScsICdtYXBUeXBlJywgJ29wdGlvbmFsVHlwZScsICdzcGFyc2VUZW5zb3JUeXBlJ10pLFxuICAgICAgKSxcbiAgICAgIHNldDogJHV0aWwub25lT2ZTZXR0ZXIoJG9uZU9mRmllbGRzKSxcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgVHlwZVByb3RvIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXG4gICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7b25ueC5JVHlwZVByb3RvPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICogQHJldHVybnMge29ubnguVHlwZVByb3RvfSBUeXBlUHJvdG8gaW5zdGFuY2VcbiAgICAgKi9cbiAgICBUeXBlUHJvdG8uY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgIHJldHVybiBuZXcgVHlwZVByb3RvKHByb3BlcnRpZXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgVHlwZVByb3RvIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguVHlwZVByb3RvLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAqIEBmdW5jdGlvbiBlbmNvZGVcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtvbm54LklUeXBlUHJvdG99IG1lc3NhZ2UgVHlwZVByb3RvIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgKi9cbiAgICBUeXBlUHJvdG8uZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgaWYgKCF3cml0ZXIpIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICBpZiAobWVzc2FnZS50ZW5zb3JUeXBlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgJ3RlbnNvclR5cGUnKSlcbiAgICAgICAgJHJvb3Qub25ueC5UeXBlUHJvdG8uVGVuc29yLmVuY29kZShcbiAgICAgICAgICBtZXNzYWdlLnRlbnNvclR5cGUsXG4gICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAxLCB3aXJlVHlwZSAyID0qLyAxMCkuZm9yaygpLFxuICAgICAgICApLmxkZWxpbSgpO1xuICAgICAgaWYgKG1lc3NhZ2Uuc2VxdWVuY2VUeXBlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgJ3NlcXVlbmNlVHlwZScpKVxuICAgICAgICAkcm9vdC5vbm54LlR5cGVQcm90by5TZXF1ZW5jZS5lbmNvZGUoXG4gICAgICAgICAgbWVzc2FnZS5zZXF1ZW5jZVR5cGUsXG4gICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA0LCB3aXJlVHlwZSAyID0qLyAzNCkuZm9yaygpLFxuICAgICAgICApLmxkZWxpbSgpO1xuICAgICAgaWYgKG1lc3NhZ2UubWFwVHlwZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsICdtYXBUeXBlJykpXG4gICAgICAgICRyb290Lm9ubnguVHlwZVByb3RvLk1hcC5lbmNvZGUobWVzc2FnZS5tYXBUeXBlLCB3cml0ZXIudWludDMyKC8qIGlkIDUsIHdpcmVUeXBlIDIgPSovIDQyKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgaWYgKG1lc3NhZ2UuZGVub3RhdGlvbiAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsICdkZW5vdGF0aW9uJykpXG4gICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgNiwgd2lyZVR5cGUgMiA9Ki8gNTApLnN0cmluZyhtZXNzYWdlLmRlbm90YXRpb24pO1xuICAgICAgaWYgKG1lc3NhZ2Uuc3BhcnNlVGVuc29yVHlwZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsICdzcGFyc2VUZW5zb3JUeXBlJykpXG4gICAgICAgICRyb290Lm9ubnguVHlwZVByb3RvLlNwYXJzZVRlbnNvci5lbmNvZGUoXG4gICAgICAgICAgbWVzc2FnZS5zcGFyc2VUZW5zb3JUeXBlLFxuICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgOCwgd2lyZVR5cGUgMiA9Ki8gNjYpLmZvcmsoKSxcbiAgICAgICAgKS5sZGVsaW0oKTtcbiAgICAgIGlmIChtZXNzYWdlLm9wdGlvbmFsVHlwZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsICdvcHRpb25hbFR5cGUnKSlcbiAgICAgICAgJHJvb3Qub25ueC5UeXBlUHJvdG8uT3B0aW9uYWwuZW5jb2RlKFxuICAgICAgICAgIG1lc3NhZ2Uub3B0aW9uYWxUeXBlLFxuICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgOSwgd2lyZVR5cGUgMiA9Ki8gNzQpLmZvcmsoKSxcbiAgICAgICAgKS5sZGVsaW0oKTtcbiAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBUeXBlUHJvdG8gbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5UeXBlUHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge29ubnguSVR5cGVQcm90b30gbWVzc2FnZSBUeXBlUHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAqL1xuICAgIFR5cGVQcm90by5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhIFR5cGVQcm90byBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgKiBAcmV0dXJucyB7b25ueC5UeXBlUHJvdG99IFR5cGVQcm90b1xuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICovXG4gICAgVHlwZVByb3RvLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCxcbiAgICAgICAgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LlR5cGVQcm90bygpO1xuICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgIG1lc3NhZ2UudGVuc29yVHlwZSA9ICRyb290Lm9ubnguVHlwZVByb3RvLlRlbnNvci5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgNDoge1xuICAgICAgICAgICAgbWVzc2FnZS5zZXF1ZW5jZVR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by5TZXF1ZW5jZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgNToge1xuICAgICAgICAgICAgbWVzc2FnZS5tYXBUeXBlID0gJHJvb3Qub25ueC5UeXBlUHJvdG8uTWFwLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSA5OiB7XG4gICAgICAgICAgICBtZXNzYWdlLm9wdGlvbmFsVHlwZSA9ICRyb290Lm9ubnguVHlwZVByb3RvLk9wdGlvbmFsLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSA4OiB7XG4gICAgICAgICAgICBtZXNzYWdlLnNwYXJzZVRlbnNvclR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by5TcGFyc2VUZW5zb3IuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDY6IHtcbiAgICAgICAgICAgIG1lc3NhZ2UuZGVub3RhdGlvbiA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZWNvZGVzIGEgVHlwZVByb3RvIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICogQGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZFxuICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgKiBAcmV0dXJucyB7b25ueC5UeXBlUHJvdG99IFR5cGVQcm90b1xuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICovXG4gICAgVHlwZVByb3RvLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKSByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgYSBUeXBlUHJvdG8gbWVzc2FnZS5cbiAgICAgKiBAZnVuY3Rpb24gdmVyaWZ5XG4gICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XG4gICAgICovXG4gICAgVHlwZVByb3RvLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09ICdvYmplY3QnIHx8IG1lc3NhZ2UgPT09IG51bGwpIHJldHVybiAnb2JqZWN0IGV4cGVjdGVkJztcbiAgICAgIHZhciBwcm9wZXJ0aWVzID0ge307XG4gICAgICBpZiAobWVzc2FnZS50ZW5zb3JUeXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgndGVuc29yVHlwZScpKSB7XG4gICAgICAgIHByb3BlcnRpZXMudmFsdWUgPSAxO1xuICAgICAgICB7XG4gICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5UeXBlUHJvdG8uVGVuc29yLnZlcmlmeShtZXNzYWdlLnRlbnNvclR5cGUpO1xuICAgICAgICAgIGlmIChlcnJvcikgcmV0dXJuICd0ZW5zb3JUeXBlLicgKyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2Uuc2VxdWVuY2VUeXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnc2VxdWVuY2VUeXBlJykpIHtcbiAgICAgICAgaWYgKHByb3BlcnRpZXMudmFsdWUgPT09IDEpIHJldHVybiAndmFsdWU6IG11bHRpcGxlIHZhbHVlcyc7XG4gICAgICAgIHByb3BlcnRpZXMudmFsdWUgPSAxO1xuICAgICAgICB7XG4gICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5UeXBlUHJvdG8uU2VxdWVuY2UudmVyaWZ5KG1lc3NhZ2Uuc2VxdWVuY2VUeXBlKTtcbiAgICAgICAgICBpZiAoZXJyb3IpIHJldHVybiAnc2VxdWVuY2VUeXBlLicgKyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UubWFwVHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ21hcFR5cGUnKSkge1xuICAgICAgICBpZiAocHJvcGVydGllcy52YWx1ZSA9PT0gMSkgcmV0dXJuICd2YWx1ZTogbXVsdGlwbGUgdmFsdWVzJztcbiAgICAgICAgcHJvcGVydGllcy52YWx1ZSA9IDE7XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LlR5cGVQcm90by5NYXAudmVyaWZ5KG1lc3NhZ2UubWFwVHlwZSk7XG4gICAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gJ21hcFR5cGUuJyArIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5vcHRpb25hbFR5cGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdvcHRpb25hbFR5cGUnKSkge1xuICAgICAgICBpZiAocHJvcGVydGllcy52YWx1ZSA9PT0gMSkgcmV0dXJuICd2YWx1ZTogbXVsdGlwbGUgdmFsdWVzJztcbiAgICAgICAgcHJvcGVydGllcy52YWx1ZSA9IDE7XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LlR5cGVQcm90by5PcHRpb25hbC52ZXJpZnkobWVzc2FnZS5vcHRpb25hbFR5cGUpO1xuICAgICAgICAgIGlmIChlcnJvcikgcmV0dXJuICdvcHRpb25hbFR5cGUuJyArIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5zcGFyc2VUZW5zb3JUeXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnc3BhcnNlVGVuc29yVHlwZScpKSB7XG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLnZhbHVlID09PSAxKSByZXR1cm4gJ3ZhbHVlOiBtdWx0aXBsZSB2YWx1ZXMnO1xuICAgICAgICBwcm9wZXJ0aWVzLnZhbHVlID0gMTtcbiAgICAgICAge1xuICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguVHlwZVByb3RvLlNwYXJzZVRlbnNvci52ZXJpZnkobWVzc2FnZS5zcGFyc2VUZW5zb3JUeXBlKTtcbiAgICAgICAgICBpZiAoZXJyb3IpIHJldHVybiAnc3BhcnNlVGVuc29yVHlwZS4nICsgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLmRlbm90YXRpb24gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdkZW5vdGF0aW9uJykpXG4gICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5kZW5vdGF0aW9uKSkgcmV0dXJuICdkZW5vdGF0aW9uOiBzdHJpbmcgZXhwZWN0ZWQnO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBUeXBlUHJvdG8gbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7b25ueC5UeXBlUHJvdG99IFR5cGVQcm90b1xuICAgICAqL1xuICAgIFR5cGVQcm90by5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5vbm54LlR5cGVQcm90bykgcmV0dXJuIG9iamVjdDtcbiAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguVHlwZVByb3RvKCk7XG4gICAgICBpZiAob2JqZWN0LnRlbnNvclR5cGUgIT0gbnVsbCkge1xuICAgICAgICBpZiAodHlwZW9mIG9iamVjdC50ZW5zb3JUeXBlICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCcub25ueC5UeXBlUHJvdG8udGVuc29yVHlwZTogb2JqZWN0IGV4cGVjdGVkJyk7XG4gICAgICAgIG1lc3NhZ2UudGVuc29yVHlwZSA9ICRyb290Lm9ubnguVHlwZVByb3RvLlRlbnNvci5mcm9tT2JqZWN0KG9iamVjdC50ZW5zb3JUeXBlKTtcbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3Quc2VxdWVuY2VUeXBlICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3Quc2VxdWVuY2VUeXBlICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCcub25ueC5UeXBlUHJvdG8uc2VxdWVuY2VUeXBlOiBvYmplY3QgZXhwZWN0ZWQnKTtcbiAgICAgICAgbWVzc2FnZS5zZXF1ZW5jZVR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by5TZXF1ZW5jZS5mcm9tT2JqZWN0KG9iamVjdC5zZXF1ZW5jZVR5cGUpO1xuICAgICAgfVxuICAgICAgaWYgKG9iamVjdC5tYXBUeXBlICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QubWFwVHlwZSAhPT0gJ29iamVjdCcpIHRocm93IFR5cGVFcnJvcignLm9ubnguVHlwZVByb3RvLm1hcFR5cGU6IG9iamVjdCBleHBlY3RlZCcpO1xuICAgICAgICBtZXNzYWdlLm1hcFR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by5NYXAuZnJvbU9iamVjdChvYmplY3QubWFwVHlwZSk7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0Lm9wdGlvbmFsVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0Lm9wdGlvbmFsVHlwZSAhPT0gJ29iamVjdCcpIHRocm93IFR5cGVFcnJvcignLm9ubnguVHlwZVByb3RvLm9wdGlvbmFsVHlwZTogb2JqZWN0IGV4cGVjdGVkJyk7XG4gICAgICAgIG1lc3NhZ2Uub3B0aW9uYWxUeXBlID0gJHJvb3Qub25ueC5UeXBlUHJvdG8uT3B0aW9uYWwuZnJvbU9iamVjdChvYmplY3Qub3B0aW9uYWxUeXBlKTtcbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3Quc3BhcnNlVGVuc29yVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnNwYXJzZVRlbnNvclR5cGUgIT09ICdvYmplY3QnKVxuICAgICAgICAgIHRocm93IFR5cGVFcnJvcignLm9ubnguVHlwZVByb3RvLnNwYXJzZVRlbnNvclR5cGU6IG9iamVjdCBleHBlY3RlZCcpO1xuICAgICAgICBtZXNzYWdlLnNwYXJzZVRlbnNvclR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by5TcGFyc2VUZW5zb3IuZnJvbU9iamVjdChvYmplY3Quc3BhcnNlVGVuc29yVHlwZSk7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0LmRlbm90YXRpb24gIT0gbnVsbCkgbWVzc2FnZS5kZW5vdGF0aW9uID0gU3RyaW5nKG9iamVjdC5kZW5vdGF0aW9uKTtcbiAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYSBUeXBlUHJvdG8gbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxuICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge29ubnguVHlwZVByb3RvfSBtZXNzYWdlIFR5cGVQcm90b1xuICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICovXG4gICAgVHlwZVByb3RvLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykgb2JqZWN0LmRlbm90YXRpb24gPSAnJztcbiAgICAgIGlmIChtZXNzYWdlLnRlbnNvclR5cGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCd0ZW5zb3JUeXBlJykpIHtcbiAgICAgICAgb2JqZWN0LnRlbnNvclR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by5UZW5zb3IudG9PYmplY3QobWVzc2FnZS50ZW5zb3JUeXBlLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKG9wdGlvbnMub25lb2ZzKSBvYmplY3QudmFsdWUgPSAndGVuc29yVHlwZSc7XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5zZXF1ZW5jZVR5cGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdzZXF1ZW5jZVR5cGUnKSkge1xuICAgICAgICBvYmplY3Quc2VxdWVuY2VUeXBlID0gJHJvb3Qub25ueC5UeXBlUHJvdG8uU2VxdWVuY2UudG9PYmplY3QobWVzc2FnZS5zZXF1ZW5jZVR5cGUsIG9wdGlvbnMpO1xuICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpIG9iamVjdC52YWx1ZSA9ICdzZXF1ZW5jZVR5cGUnO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UubWFwVHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ21hcFR5cGUnKSkge1xuICAgICAgICBvYmplY3QubWFwVHlwZSA9ICRyb290Lm9ubnguVHlwZVByb3RvLk1hcC50b09iamVjdChtZXNzYWdlLm1hcFR5cGUsIG9wdGlvbnMpO1xuICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpIG9iamVjdC52YWx1ZSA9ICdtYXBUeXBlJztcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLmRlbm90YXRpb24gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdkZW5vdGF0aW9uJykpIG9iamVjdC5kZW5vdGF0aW9uID0gbWVzc2FnZS5kZW5vdGF0aW9uO1xuICAgICAgaWYgKG1lc3NhZ2Uuc3BhcnNlVGVuc29yVHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ3NwYXJzZVRlbnNvclR5cGUnKSkge1xuICAgICAgICBvYmplY3Quc3BhcnNlVGVuc29yVHlwZSA9ICRyb290Lm9ubnguVHlwZVByb3RvLlNwYXJzZVRlbnNvci50b09iamVjdChtZXNzYWdlLnNwYXJzZVRlbnNvclR5cGUsIG9wdGlvbnMpO1xuICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpIG9iamVjdC52YWx1ZSA9ICdzcGFyc2VUZW5zb3JUeXBlJztcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLm9wdGlvbmFsVHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ29wdGlvbmFsVHlwZScpKSB7XG4gICAgICAgIG9iamVjdC5vcHRpb25hbFR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by5PcHRpb25hbC50b09iamVjdChtZXNzYWdlLm9wdGlvbmFsVHlwZSwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChvcHRpb25zLm9uZW9mcykgb2JqZWN0LnZhbHVlID0gJ29wdGlvbmFsVHlwZSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGlzIFR5cGVQcm90byB0byBKU09OLlxuICAgICAqIEBmdW5jdGlvbiB0b0pTT05cbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IEpTT04gb2JqZWN0XG4gICAgICovXG4gICAgVHlwZVByb3RvLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZGVmYXVsdCB0eXBlIHVybCBmb3IgVHlwZVByb3RvXG4gICAgICogQGZ1bmN0aW9uIGdldFR5cGVVcmxcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlVXJsUHJlZml4XSB5b3VyIGN1c3RvbSB0eXBlVXJsUHJlZml4KGRlZmF1bHQgXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCIpXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGRlZmF1bHQgdHlwZSB1cmxcbiAgICAgKi9cbiAgICBUeXBlUHJvdG8uZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0eXBlVXJsUHJlZml4ID0gJ3R5cGUuZ29vZ2xlYXBpcy5jb20nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyAnL29ubnguVHlwZVByb3RvJztcbiAgICB9O1xuXG4gICAgVHlwZVByb3RvLlRlbnNvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAvKipcbiAgICAgICAqIFByb3BlcnRpZXMgb2YgYSBUZW5zb3IuXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG9cbiAgICAgICAqIEBpbnRlcmZhY2UgSVRlbnNvclxuICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8bnVsbH0gW2VsZW1UeXBlXSBUZW5zb3IgZWxlbVR5cGVcbiAgICAgICAqIEBwcm9wZXJ0eSB7b25ueC5JVGVuc29yU2hhcGVQcm90b3xudWxsfSBbc2hhcGVdIFRlbnNvciBzaGFwZVxuICAgICAgICovXG5cbiAgICAgIC8qKlxuICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBUZW5zb3IuXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG9cbiAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIFRlbnNvci5cbiAgICAgICAqIEBpbXBsZW1lbnRzIElUZW5zb3JcbiAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICogQHBhcmFtIHtvbm54LlR5cGVQcm90by5JVGVuc29yPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIFRlbnNvcihwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbCkgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVGVuc29yIGVsZW1UeXBlLlxuICAgICAgICogQG1lbWJlciB7bnVtYmVyfSBlbGVtVHlwZVxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlRlbnNvclxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKi9cbiAgICAgIFRlbnNvci5wcm90b3R5cGUuZWxlbVR5cGUgPSAwO1xuXG4gICAgICAvKipcbiAgICAgICAqIFRlbnNvciBzaGFwZS5cbiAgICAgICAqIEBtZW1iZXIge29ubnguSVRlbnNvclNoYXBlUHJvdG98bnVsbHx1bmRlZmluZWR9IHNoYXBlXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uVGVuc29yXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqL1xuICAgICAgVGVuc29yLnByb3RvdHlwZS5zaGFwZSA9IG51bGw7XG5cbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlcyBhIG5ldyBUZW5zb3IgaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlRlbnNvclxuICAgICAgICogQHN0YXRpY1xuICAgICAgICogQHBhcmFtIHtvbm54LlR5cGVQcm90by5JVGVuc29yPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgKiBAcmV0dXJucyB7b25ueC5UeXBlUHJvdG8uVGVuc29yfSBUZW5zb3IgaW5zdGFuY2VcbiAgICAgICAqL1xuICAgICAgVGVuc29yLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGVuc29yKHByb3BlcnRpZXMpO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgVGVuc29yIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguVHlwZVByb3RvLlRlbnNvci52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVcbiAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5UZW5zb3JcbiAgICAgICAqIEBzdGF0aWNcbiAgICAgICAqIEBwYXJhbSB7b25ueC5UeXBlUHJvdG8uSVRlbnNvcn0gbWVzc2FnZSBUZW5zb3IgbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAqL1xuICAgICAgVGVuc29yLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgaWYgKCF3cml0ZXIpIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgIGlmIChtZXNzYWdlLmVsZW1UeXBlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgJ2VsZW1UeXBlJykpXG4gICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAxLCB3aXJlVHlwZSAwID0qLyA4KS5pbnQzMihtZXNzYWdlLmVsZW1UeXBlKTtcbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2hhcGUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCAnc2hhcGUnKSlcbiAgICAgICAgICAkcm9vdC5vbm54LlRlbnNvclNoYXBlUHJvdG8uZW5jb2RlKG1lc3NhZ2Uuc2hhcGUsIHdyaXRlci51aW50MzIoLyogaWQgMiwgd2lyZVR5cGUgMiA9Ki8gMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBUZW5zb3IgbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5UeXBlUHJvdG8uVGVuc29yLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlRlbnNvclxuICAgICAgICogQHN0YXRpY1xuICAgICAgICogQHBhcmFtIHtvbm54LlR5cGVQcm90by5JVGVuc29yfSBtZXNzYWdlIFRlbnNvciBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICovXG4gICAgICBUZW5zb3IuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogRGVjb2RlcyBhIFRlbnNvciBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlRlbnNvclxuICAgICAgICogQHN0YXRpY1xuICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAgICogQHJldHVybnMge29ubnguVHlwZVByb3RvLlRlbnNvcn0gVGVuc29yXG4gICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgKi9cbiAgICAgIFRlbnNvci5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLFxuICAgICAgICAgIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5UeXBlUHJvdG8uVGVuc29yKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgIG1lc3NhZ2UuZWxlbVR5cGUgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgICAgbWVzc2FnZS5zaGFwZSA9ICRyb290Lm9ubnguVGVuc29yU2hhcGVQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBEZWNvZGVzIGEgVGVuc29yIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uVGVuc29yXG4gICAgICAgKiBAc3RhdGljXG4gICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAqIEByZXR1cm5zIHtvbm54LlR5cGVQcm90by5UZW5zb3J9IFRlbnNvclxuICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICovXG4gICAgICBUZW5zb3IuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSkgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogVmVyaWZpZXMgYSBUZW5zb3IgbWVzc2FnZS5cbiAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5UZW5zb3JcbiAgICAgICAqIEBzdGF0aWNcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICAgICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAgICAgICAqL1xuICAgICAgVGVuc29yLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gJ29iamVjdCcgfHwgbWVzc2FnZSA9PT0gbnVsbCkgcmV0dXJuICdvYmplY3QgZXhwZWN0ZWQnO1xuICAgICAgICBpZiAobWVzc2FnZS5lbGVtVHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ2VsZW1UeXBlJykpXG4gICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5lbGVtVHlwZSkpIHJldHVybiAnZWxlbVR5cGU6IGludGVnZXIgZXhwZWN0ZWQnO1xuICAgICAgICBpZiAobWVzc2FnZS5zaGFwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ3NoYXBlJykpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LlRlbnNvclNoYXBlUHJvdG8udmVyaWZ5KG1lc3NhZ2Uuc2hhcGUpO1xuICAgICAgICAgIGlmIChlcnJvcikgcmV0dXJuICdzaGFwZS4nICsgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgYSBUZW5zb3IgbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICAgICAgICogQGZ1bmN0aW9uIGZyb21PYmplY3RcbiAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5UZW5zb3JcbiAgICAgICAqIEBzdGF0aWNcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcbiAgICAgICAqIEByZXR1cm5zIHtvbm54LlR5cGVQcm90by5UZW5zb3J9IFRlbnNvclxuICAgICAgICovXG4gICAgICBUZW5zb3IuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5vbm54LlR5cGVQcm90by5UZW5zb3IpIHJldHVybiBvYmplY3Q7XG4gICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguVHlwZVByb3RvLlRlbnNvcigpO1xuICAgICAgICBpZiAob2JqZWN0LmVsZW1UeXBlICE9IG51bGwpIG1lc3NhZ2UuZWxlbVR5cGUgPSBvYmplY3QuZWxlbVR5cGUgfCAwO1xuICAgICAgICBpZiAob2JqZWN0LnNoYXBlICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5zaGFwZSAhPT0gJ29iamVjdCcpIHRocm93IFR5cGVFcnJvcignLm9ubnguVHlwZVByb3RvLlRlbnNvci5zaGFwZTogb2JqZWN0IGV4cGVjdGVkJyk7XG4gICAgICAgICAgbWVzc2FnZS5zaGFwZSA9ICRyb290Lm9ubnguVGVuc29yU2hhcGVQcm90by5mcm9tT2JqZWN0KG9iamVjdC5zaGFwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhIFRlbnNvciBtZXNzYWdlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXG4gICAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcbiAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5UZW5zb3JcbiAgICAgICAqIEBzdGF0aWNcbiAgICAgICAqIEBwYXJhbSB7b25ueC5UeXBlUHJvdG8uVGVuc29yfSBtZXNzYWdlIFRlbnNvclxuICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuSUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICAgICAgICovXG4gICAgICBUZW5zb3IudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgb2JqZWN0LmVsZW1UeXBlID0gMDtcbiAgICAgICAgICBvYmplY3Quc2hhcGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmVsZW1UeXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnZWxlbVR5cGUnKSkgb2JqZWN0LmVsZW1UeXBlID0gbWVzc2FnZS5lbGVtVHlwZTtcbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2hhcGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdzaGFwZScpKVxuICAgICAgICAgIG9iamVjdC5zaGFwZSA9ICRyb290Lm9ubnguVGVuc29yU2hhcGVQcm90by50b09iamVjdChtZXNzYWdlLnNoYXBlLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogQ29udmVydHMgdGhpcyBUZW5zb3IgdG8gSlNPTi5cbiAgICAgICAqIEBmdW5jdGlvbiB0b0pTT05cbiAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5UZW5zb3JcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICAgICAgICovXG4gICAgICBUZW5zb3IucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIEdldHMgdGhlIGRlZmF1bHQgdHlwZSB1cmwgZm9yIFRlbnNvclxuICAgICAgICogQGZ1bmN0aW9uIGdldFR5cGVVcmxcbiAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5UZW5zb3JcbiAgICAgICAqIEBzdGF0aWNcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZVVybFByZWZpeF0geW91ciBjdXN0b20gdHlwZVVybFByZWZpeChkZWZhdWx0IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiKVxuICAgICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGRlZmF1bHQgdHlwZSB1cmxcbiAgICAgICAqL1xuICAgICAgVGVuc29yLmdldFR5cGVVcmwgPSBmdW5jdGlvbiBnZXRUeXBlVXJsKHR5cGVVcmxQcmVmaXgpIHtcbiAgICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHR5cGVVcmxQcmVmaXggPSAndHlwZS5nb29nbGVhcGlzLmNvbSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyAnL29ubnguVHlwZVByb3RvLlRlbnNvcic7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gVGVuc29yO1xuICAgIH0pKCk7XG5cbiAgICBUeXBlUHJvdG8uU2VxdWVuY2UgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgLyoqXG4gICAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgU2VxdWVuY2UuXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG9cbiAgICAgICAqIEBpbnRlcmZhY2UgSVNlcXVlbmNlXG4gICAgICAgKiBAcHJvcGVydHkge29ubnguSVR5cGVQcm90b3xudWxsfSBbZWxlbVR5cGVdIFNlcXVlbmNlIGVsZW1UeXBlXG4gICAgICAgKi9cblxuICAgICAgLyoqXG4gICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFNlcXVlbmNlLlxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvXG4gICAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBTZXF1ZW5jZS5cbiAgICAgICAqIEBpbXBsZW1lbnRzIElTZXF1ZW5jZVxuICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgKiBAcGFyYW0ge29ubnguVHlwZVByb3RvLklTZXF1ZW5jZT19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBTZXF1ZW5jZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbCkgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2VxdWVuY2UgZWxlbVR5cGUuXG4gICAgICAgKiBAbWVtYmVyIHtvbm54LklUeXBlUHJvdG98bnVsbHx1bmRlZmluZWR9IGVsZW1UeXBlXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uU2VxdWVuY2VcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICovXG4gICAgICBTZXF1ZW5jZS5wcm90b3R5cGUuZWxlbVR5cGUgPSBudWxsO1xuXG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgYSBuZXcgU2VxdWVuY2UgaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlNlcXVlbmNlXG4gICAgICAgKiBAc3RhdGljXG4gICAgICAgKiBAcGFyYW0ge29ubnguVHlwZVByb3RvLklTZXF1ZW5jZT19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICogQHJldHVybnMge29ubnguVHlwZVByb3RvLlNlcXVlbmNlfSBTZXF1ZW5jZSBpbnN0YW5jZVxuICAgICAgICovXG4gICAgICBTZXF1ZW5jZS5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICByZXR1cm4gbmV3IFNlcXVlbmNlKHByb3BlcnRpZXMpO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgU2VxdWVuY2UgbWVzc2FnZS4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5UeXBlUHJvdG8uU2VxdWVuY2UudmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uU2VxdWVuY2VcbiAgICAgICAqIEBzdGF0aWNcbiAgICAgICAqIEBwYXJhbSB7b25ueC5UeXBlUHJvdG8uSVNlcXVlbmNlfSBtZXNzYWdlIFNlcXVlbmNlIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgKi9cbiAgICAgIFNlcXVlbmNlLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgaWYgKCF3cml0ZXIpIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgIGlmIChtZXNzYWdlLmVsZW1UeXBlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgJ2VsZW1UeXBlJykpXG4gICAgICAgICAgJHJvb3Qub25ueC5UeXBlUHJvdG8uZW5jb2RlKG1lc3NhZ2UuZWxlbVR5cGUsIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki8gMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBTZXF1ZW5jZSBtZXNzYWdlLCBsZW5ndGggZGVsaW1pdGVkLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LlR5cGVQcm90by5TZXF1ZW5jZS52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWRcbiAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5TZXF1ZW5jZVxuICAgICAgICogQHN0YXRpY1xuICAgICAgICogQHBhcmFtIHtvbm54LlR5cGVQcm90by5JU2VxdWVuY2V9IG1lc3NhZ2UgU2VxdWVuY2UgbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAqL1xuICAgICAgU2VxdWVuY2UuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogRGVjb2RlcyBhIFNlcXVlbmNlIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uU2VxdWVuY2VcbiAgICAgICAqIEBzdGF0aWNcbiAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgICAqIEByZXR1cm5zIHtvbm54LlR5cGVQcm90by5TZXF1ZW5jZX0gU2VxdWVuY2VcbiAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAqL1xuICAgICAgU2VxdWVuY2UuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKSByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCxcbiAgICAgICAgICBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguVHlwZVByb3RvLlNlcXVlbmNlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgIG1lc3NhZ2UuZWxlbVR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBEZWNvZGVzIGEgU2VxdWVuY2UgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlciwgbGVuZ3RoIGRlbGltaXRlZC5cbiAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5TZXF1ZW5jZVxuICAgICAgICogQHN0YXRpY1xuICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgKiBAcmV0dXJucyB7b25ueC5UeXBlUHJvdG8uU2VxdWVuY2V9IFNlcXVlbmNlXG4gICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgKi9cbiAgICAgIFNlcXVlbmNlLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIFZlcmlmaWVzIGEgU2VxdWVuY2UgbWVzc2FnZS5cbiAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5TZXF1ZW5jZVxuICAgICAgICogQHN0YXRpY1xuICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XG4gICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICAgICAgICovXG4gICAgICBTZXF1ZW5jZS52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09ICdvYmplY3QnIHx8IG1lc3NhZ2UgPT09IG51bGwpIHJldHVybiAnb2JqZWN0IGV4cGVjdGVkJztcbiAgICAgICAgaWYgKG1lc3NhZ2UuZWxlbVR5cGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdlbGVtVHlwZScpKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5UeXBlUHJvdG8udmVyaWZ5KG1lc3NhZ2UuZWxlbVR5cGUpO1xuICAgICAgICAgIGlmIChlcnJvcikgcmV0dXJuICdlbGVtVHlwZS4nICsgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgYSBTZXF1ZW5jZSBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gICAgICAgKiBAZnVuY3Rpb24gZnJvbU9iamVjdFxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlNlcXVlbmNlXG4gICAgICAgKiBAc3RhdGljXG4gICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gICAgICAgKiBAcmV0dXJucyB7b25ueC5UeXBlUHJvdG8uU2VxdWVuY2V9IFNlcXVlbmNlXG4gICAgICAgKi9cbiAgICAgIFNlcXVlbmNlLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3Qub25ueC5UeXBlUHJvdG8uU2VxdWVuY2UpIHJldHVybiBvYmplY3Q7XG4gICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguVHlwZVByb3RvLlNlcXVlbmNlKCk7XG4gICAgICAgIGlmIChvYmplY3QuZWxlbVR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmVsZW1UeXBlICE9PSAnb2JqZWN0JylcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcignLm9ubnguVHlwZVByb3RvLlNlcXVlbmNlLmVsZW1UeXBlOiBvYmplY3QgZXhwZWN0ZWQnKTtcbiAgICAgICAgICBtZXNzYWdlLmVsZW1UeXBlID0gJHJvb3Qub25ueC5UeXBlUHJvdG8uZnJvbU9iamVjdChvYmplY3QuZWxlbVR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYSBTZXF1ZW5jZSBtZXNzYWdlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXG4gICAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcbiAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5TZXF1ZW5jZVxuICAgICAgICogQHN0YXRpY1xuICAgICAgICogQHBhcmFtIHtvbm54LlR5cGVQcm90by5TZXF1ZW5jZX0gbWVzc2FnZSBTZXF1ZW5jZVxuICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuSUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICAgICAgICovXG4gICAgICBTZXF1ZW5jZS50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIG9iamVjdC5lbGVtVHlwZSA9IG51bGw7XG4gICAgICAgIGlmIChtZXNzYWdlLmVsZW1UeXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnZWxlbVR5cGUnKSlcbiAgICAgICAgICBvYmplY3QuZWxlbVR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by50b09iamVjdChtZXNzYWdlLmVsZW1UeXBlLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogQ29udmVydHMgdGhpcyBTZXF1ZW5jZSB0byBKU09OLlxuICAgICAgICogQGZ1bmN0aW9uIHRvSlNPTlxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlNlcXVlbmNlXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcbiAgICAgICAqL1xuICAgICAgU2VxdWVuY2UucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIEdldHMgdGhlIGRlZmF1bHQgdHlwZSB1cmwgZm9yIFNlcXVlbmNlXG4gICAgICAgKiBAZnVuY3Rpb24gZ2V0VHlwZVVybFxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlNlcXVlbmNlXG4gICAgICAgKiBAc3RhdGljXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVVcmxQcmVmaXhdIHlvdXIgY3VzdG9tIHR5cGVVcmxQcmVmaXgoZGVmYXVsdCBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIilcbiAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBkZWZhdWx0IHR5cGUgdXJsXG4gICAgICAgKi9cbiAgICAgIFNlcXVlbmNlLmdldFR5cGVVcmwgPSBmdW5jdGlvbiBnZXRUeXBlVXJsKHR5cGVVcmxQcmVmaXgpIHtcbiAgICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHR5cGVVcmxQcmVmaXggPSAndHlwZS5nb29nbGVhcGlzLmNvbSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyAnL29ubnguVHlwZVByb3RvLlNlcXVlbmNlJztcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBTZXF1ZW5jZTtcbiAgICB9KSgpO1xuXG4gICAgVHlwZVByb3RvLk1hcCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAvKipcbiAgICAgICAqIFByb3BlcnRpZXMgb2YgYSBNYXAuXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG9cbiAgICAgICAqIEBpbnRlcmZhY2UgSU1hcFxuICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8bnVsbH0gW2tleVR5cGVdIE1hcCBrZXlUeXBlXG4gICAgICAgKiBAcHJvcGVydHkge29ubnguSVR5cGVQcm90b3xudWxsfSBbdmFsdWVUeXBlXSBNYXAgdmFsdWVUeXBlXG4gICAgICAgKi9cblxuICAgICAgLyoqXG4gICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IE1hcC5cbiAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90b1xuICAgICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgTWFwLlxuICAgICAgICogQGltcGxlbWVudHMgSU1hcFxuICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgKiBAcGFyYW0ge29ubnguVHlwZVByb3RvLklNYXA9fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gTWFwKHByb3BlcnRpZXMpIHtcbiAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKSB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBNYXAga2V5VHlwZS5cbiAgICAgICAqIEBtZW1iZXIge251bWJlcn0ga2V5VHlwZVxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLk1hcFxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKi9cbiAgICAgIE1hcC5wcm90b3R5cGUua2V5VHlwZSA9IDA7XG5cbiAgICAgIC8qKlxuICAgICAgICogTWFwIHZhbHVlVHlwZS5cbiAgICAgICAqIEBtZW1iZXIge29ubnguSVR5cGVQcm90b3xudWxsfHVuZGVmaW5lZH0gdmFsdWVUeXBlXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uTWFwXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqL1xuICAgICAgTWFwLnByb3RvdHlwZS52YWx1ZVR5cGUgPSBudWxsO1xuXG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgYSBuZXcgTWFwIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgICAqIEBmdW5jdGlvbiBjcmVhdGVcbiAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5NYXBcbiAgICAgICAqIEBzdGF0aWNcbiAgICAgICAqIEBwYXJhbSB7b25ueC5UeXBlUHJvdG8uSU1hcD19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICogQHJldHVybnMge29ubnguVHlwZVByb3RvLk1hcH0gTWFwIGluc3RhbmNlXG4gICAgICAgKi9cbiAgICAgIE1hcC5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICByZXR1cm4gbmV3IE1hcChwcm9wZXJ0aWVzKTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIE1hcCBtZXNzYWdlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LlR5cGVQcm90by5NYXAudmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uTWFwXG4gICAgICAgKiBAc3RhdGljXG4gICAgICAgKiBAcGFyYW0ge29ubnguVHlwZVByb3RvLklNYXB9IG1lc3NhZ2UgTWFwIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgKi9cbiAgICAgIE1hcC5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgIGlmICghd3JpdGVyKSB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICBpZiAobWVzc2FnZS5rZXlUeXBlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgJ2tleVR5cGUnKSlcbiAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDAgPSovIDgpLmludDMyKG1lc3NhZ2Uua2V5VHlwZSk7XG4gICAgICAgIGlmIChtZXNzYWdlLnZhbHVlVHlwZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsICd2YWx1ZVR5cGUnKSlcbiAgICAgICAgICAkcm9vdC5vbm54LlR5cGVQcm90by5lbmNvZGUobWVzc2FnZS52YWx1ZVR5cGUsIHdyaXRlci51aW50MzIoLyogaWQgMiwgd2lyZVR5cGUgMiA9Ki8gMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBNYXAgbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5UeXBlUHJvdG8uTWFwLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLk1hcFxuICAgICAgICogQHN0YXRpY1xuICAgICAgICogQHBhcmFtIHtvbm54LlR5cGVQcm90by5JTWFwfSBtZXNzYWdlIE1hcCBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICovXG4gICAgICBNYXAuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogRGVjb2RlcyBhIE1hcCBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLk1hcFxuICAgICAgICogQHN0YXRpY1xuICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAgICogQHJldHVybnMge29ubnguVHlwZVByb3RvLk1hcH0gTWFwXG4gICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgKi9cbiAgICAgIE1hcC5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLFxuICAgICAgICAgIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5UeXBlUHJvdG8uTWFwKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgIG1lc3NhZ2Uua2V5VHlwZSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgICAgICBtZXNzYWdlLnZhbHVlVHlwZSA9ICRyb290Lm9ubnguVHlwZVByb3RvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIERlY29kZXMgYSBNYXAgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlciwgbGVuZ3RoIGRlbGltaXRlZC5cbiAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5NYXBcbiAgICAgICAqIEBzdGF0aWNcbiAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICogQHJldHVybnMge29ubnguVHlwZVByb3RvLk1hcH0gTWFwXG4gICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgKi9cbiAgICAgIE1hcC5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKSByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBWZXJpZmllcyBhIE1hcCBtZXNzYWdlLlxuICAgICAgICogQGZ1bmN0aW9uIHZlcmlmeVxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLk1hcFxuICAgICAgICogQHN0YXRpY1xuICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XG4gICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICAgICAgICovXG4gICAgICBNYXAudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSAnb2JqZWN0JyB8fCBtZXNzYWdlID09PSBudWxsKSByZXR1cm4gJ29iamVjdCBleHBlY3RlZCc7XG4gICAgICAgIGlmIChtZXNzYWdlLmtleVR5cGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdrZXlUeXBlJykpXG4gICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5rZXlUeXBlKSkgcmV0dXJuICdrZXlUeXBlOiBpbnRlZ2VyIGV4cGVjdGVkJztcbiAgICAgICAgaWYgKG1lc3NhZ2UudmFsdWVUeXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgndmFsdWVUeXBlJykpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LlR5cGVQcm90by52ZXJpZnkobWVzc2FnZS52YWx1ZVR5cGUpO1xuICAgICAgICAgIGlmIChlcnJvcikgcmV0dXJuICd2YWx1ZVR5cGUuJyArIGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGVzIGEgTWFwIG1lc3NhZ2UgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cbiAgICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uTWFwXG4gICAgICAgKiBAc3RhdGljXG4gICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gICAgICAgKiBAcmV0dXJucyB7b25ueC5UeXBlUHJvdG8uTWFwfSBNYXBcbiAgICAgICAqL1xuICAgICAgTWFwLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3Qub25ueC5UeXBlUHJvdG8uTWFwKSByZXR1cm4gb2JqZWN0O1xuICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LlR5cGVQcm90by5NYXAoKTtcbiAgICAgICAgaWYgKG9iamVjdC5rZXlUeXBlICE9IG51bGwpIG1lc3NhZ2Uua2V5VHlwZSA9IG9iamVjdC5rZXlUeXBlIHwgMDtcbiAgICAgICAgaWYgKG9iamVjdC52YWx1ZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnZhbHVlVHlwZSAhPT0gJ29iamVjdCcpIHRocm93IFR5cGVFcnJvcignLm9ubnguVHlwZVByb3RvLk1hcC52YWx1ZVR5cGU6IG9iamVjdCBleHBlY3RlZCcpO1xuICAgICAgICAgIG1lc3NhZ2UudmFsdWVUeXBlID0gJHJvb3Qub25ueC5UeXBlUHJvdG8uZnJvbU9iamVjdChvYmplY3QudmFsdWVUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgTWFwIG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAgICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLk1hcFxuICAgICAgICogQHN0YXRpY1xuICAgICAgICogQHBhcmFtIHtvbm54LlR5cGVQcm90by5NYXB9IG1lc3NhZ2UgTWFwXG4gICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICAgKi9cbiAgICAgIE1hcC50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgICBvYmplY3Qua2V5VHlwZSA9IDA7XG4gICAgICAgICAgb2JqZWN0LnZhbHVlVHlwZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uua2V5VHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ2tleVR5cGUnKSkgb2JqZWN0LmtleVR5cGUgPSBtZXNzYWdlLmtleVR5cGU7XG4gICAgICAgIGlmIChtZXNzYWdlLnZhbHVlVHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ3ZhbHVlVHlwZScpKVxuICAgICAgICAgIG9iamVjdC52YWx1ZVR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by50b09iamVjdChtZXNzYWdlLnZhbHVlVHlwZSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIENvbnZlcnRzIHRoaXMgTWFwIHRvIEpTT04uXG4gICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uTWFwXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcbiAgICAgICAqL1xuICAgICAgTWFwLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBHZXRzIHRoZSBkZWZhdWx0IHR5cGUgdXJsIGZvciBNYXBcbiAgICAgICAqIEBmdW5jdGlvbiBnZXRUeXBlVXJsXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uTWFwXG4gICAgICAgKiBAc3RhdGljXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVVcmxQcmVmaXhdIHlvdXIgY3VzdG9tIHR5cGVVcmxQcmVmaXgoZGVmYXVsdCBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIilcbiAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBkZWZhdWx0IHR5cGUgdXJsXG4gICAgICAgKi9cbiAgICAgIE1hcC5nZXRUeXBlVXJsID0gZnVuY3Rpb24gZ2V0VHlwZVVybCh0eXBlVXJsUHJlZml4KSB7XG4gICAgICAgIGlmICh0eXBlVXJsUHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0eXBlVXJsUHJlZml4ID0gJ3R5cGUuZ29vZ2xlYXBpcy5jb20nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlVXJsUHJlZml4ICsgJy9vbm54LlR5cGVQcm90by5NYXAnO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIE1hcDtcbiAgICB9KSgpO1xuXG4gICAgVHlwZVByb3RvLk9wdGlvbmFsID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8qKlxuICAgICAgICogUHJvcGVydGllcyBvZiBhbiBPcHRpb25hbC5cbiAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90b1xuICAgICAgICogQGludGVyZmFjZSBJT3B0aW9uYWxcbiAgICAgICAqIEBwcm9wZXJ0eSB7b25ueC5JVHlwZVByb3RvfG51bGx9IFtlbGVtVHlwZV0gT3B0aW9uYWwgZWxlbVR5cGVcbiAgICAgICAqL1xuXG4gICAgICAvKipcbiAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgT3B0aW9uYWwuXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG9cbiAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhbiBPcHRpb25hbC5cbiAgICAgICAqIEBpbXBsZW1lbnRzIElPcHRpb25hbFxuICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgKiBAcGFyYW0ge29ubnguVHlwZVByb3RvLklPcHRpb25hbD19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBPcHRpb25hbChwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbCkgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogT3B0aW9uYWwgZWxlbVR5cGUuXG4gICAgICAgKiBAbWVtYmVyIHtvbm54LklUeXBlUHJvdG98bnVsbHx1bmRlZmluZWR9IGVsZW1UeXBlXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uT3B0aW9uYWxcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICovXG4gICAgICBPcHRpb25hbC5wcm90b3R5cGUuZWxlbVR5cGUgPSBudWxsO1xuXG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgYSBuZXcgT3B0aW9uYWwgaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLk9wdGlvbmFsXG4gICAgICAgKiBAc3RhdGljXG4gICAgICAgKiBAcGFyYW0ge29ubnguVHlwZVByb3RvLklPcHRpb25hbD19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICogQHJldHVybnMge29ubnguVHlwZVByb3RvLk9wdGlvbmFsfSBPcHRpb25hbCBpbnN0YW5jZVxuICAgICAgICovXG4gICAgICBPcHRpb25hbC5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICByZXR1cm4gbmV3IE9wdGlvbmFsKHByb3BlcnRpZXMpO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgT3B0aW9uYWwgbWVzc2FnZS4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5UeXBlUHJvdG8uT3B0aW9uYWwudmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uT3B0aW9uYWxcbiAgICAgICAqIEBzdGF0aWNcbiAgICAgICAqIEBwYXJhbSB7b25ueC5UeXBlUHJvdG8uSU9wdGlvbmFsfSBtZXNzYWdlIE9wdGlvbmFsIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgKi9cbiAgICAgIE9wdGlvbmFsLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgaWYgKCF3cml0ZXIpIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgIGlmIChtZXNzYWdlLmVsZW1UeXBlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgJ2VsZW1UeXBlJykpXG4gICAgICAgICAgJHJvb3Qub25ueC5UeXBlUHJvdG8uZW5jb2RlKG1lc3NhZ2UuZWxlbVR5cGUsIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki8gMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBPcHRpb25hbCBtZXNzYWdlLCBsZW5ndGggZGVsaW1pdGVkLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LlR5cGVQcm90by5PcHRpb25hbC52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWRcbiAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5PcHRpb25hbFxuICAgICAgICogQHN0YXRpY1xuICAgICAgICogQHBhcmFtIHtvbm54LlR5cGVQcm90by5JT3B0aW9uYWx9IG1lc3NhZ2UgT3B0aW9uYWwgbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAqL1xuICAgICAgT3B0aW9uYWwuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogRGVjb2RlcyBhbiBPcHRpb25hbCBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLk9wdGlvbmFsXG4gICAgICAgKiBAc3RhdGljXG4gICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgKiBAcmV0dXJucyB7b25ueC5UeXBlUHJvdG8uT3B0aW9uYWx9IE9wdGlvbmFsXG4gICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgKi9cbiAgICAgIE9wdGlvbmFsLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSkgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsXG4gICAgICAgICAgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LlR5cGVQcm90by5PcHRpb25hbCgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICBtZXNzYWdlLmVsZW1UeXBlID0gJHJvb3Qub25ueC5UeXBlUHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogRGVjb2RlcyBhbiBPcHRpb25hbCBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLCBsZW5ndGggZGVsaW1pdGVkLlxuICAgICAgICogQGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZFxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLk9wdGlvbmFsXG4gICAgICAgKiBAc3RhdGljXG4gICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAqIEByZXR1cm5zIHtvbm54LlR5cGVQcm90by5PcHRpb25hbH0gT3B0aW9uYWxcbiAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAqL1xuICAgICAgT3B0aW9uYWwuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSkgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogVmVyaWZpZXMgYW4gT3B0aW9uYWwgbWVzc2FnZS5cbiAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5PcHRpb25hbFxuICAgICAgICogQHN0YXRpY1xuICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XG4gICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICAgICAgICovXG4gICAgICBPcHRpb25hbC52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09ICdvYmplY3QnIHx8IG1lc3NhZ2UgPT09IG51bGwpIHJldHVybiAnb2JqZWN0IGV4cGVjdGVkJztcbiAgICAgICAgaWYgKG1lc3NhZ2UuZWxlbVR5cGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdlbGVtVHlwZScpKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5UeXBlUHJvdG8udmVyaWZ5KG1lc3NhZ2UuZWxlbVR5cGUpO1xuICAgICAgICAgIGlmIChlcnJvcikgcmV0dXJuICdlbGVtVHlwZS4nICsgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgYW4gT3B0aW9uYWwgbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICAgICAgICogQGZ1bmN0aW9uIGZyb21PYmplY3RcbiAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5PcHRpb25hbFxuICAgICAgICogQHN0YXRpY1xuICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICAgICAgICogQHJldHVybnMge29ubnguVHlwZVByb3RvLk9wdGlvbmFsfSBPcHRpb25hbFxuICAgICAgICovXG4gICAgICBPcHRpb25hbC5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290Lm9ubnguVHlwZVByb3RvLk9wdGlvbmFsKSByZXR1cm4gb2JqZWN0O1xuICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LlR5cGVQcm90by5PcHRpb25hbCgpO1xuICAgICAgICBpZiAob2JqZWN0LmVsZW1UeXBlICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5lbGVtVHlwZSAhPT0gJ29iamVjdCcpXG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJy5vbm54LlR5cGVQcm90by5PcHRpb25hbC5lbGVtVHlwZTogb2JqZWN0IGV4cGVjdGVkJyk7XG4gICAgICAgICAgbWVzc2FnZS5lbGVtVHlwZSA9ICRyb290Lm9ubnguVHlwZVByb3RvLmZyb21PYmplY3Qob2JqZWN0LmVsZW1UeXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGFuIE9wdGlvbmFsIG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAgICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLk9wdGlvbmFsXG4gICAgICAgKiBAc3RhdGljXG4gICAgICAgKiBAcGFyYW0ge29ubnguVHlwZVByb3RvLk9wdGlvbmFsfSBtZXNzYWdlIE9wdGlvbmFsXG4gICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICAgKi9cbiAgICAgIE9wdGlvbmFsLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykgb2JqZWN0LmVsZW1UeXBlID0gbnVsbDtcbiAgICAgICAgaWYgKG1lc3NhZ2UuZWxlbVR5cGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdlbGVtVHlwZScpKVxuICAgICAgICAgIG9iamVjdC5lbGVtVHlwZSA9ICRyb290Lm9ubnguVHlwZVByb3RvLnRvT2JqZWN0KG1lc3NhZ2UuZWxlbVR5cGUsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBDb252ZXJ0cyB0aGlzIE9wdGlvbmFsIHRvIEpTT04uXG4gICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uT3B0aW9uYWxcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICAgICAgICovXG4gICAgICBPcHRpb25hbC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogR2V0cyB0aGUgZGVmYXVsdCB0eXBlIHVybCBmb3IgT3B0aW9uYWxcbiAgICAgICAqIEBmdW5jdGlvbiBnZXRUeXBlVXJsXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uT3B0aW9uYWxcbiAgICAgICAqIEBzdGF0aWNcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZVVybFByZWZpeF0geW91ciBjdXN0b20gdHlwZVVybFByZWZpeChkZWZhdWx0IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiKVxuICAgICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGRlZmF1bHQgdHlwZSB1cmxcbiAgICAgICAqL1xuICAgICAgT3B0aW9uYWwuZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgICBpZiAodHlwZVVybFByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdHlwZVVybFByZWZpeCA9ICd0eXBlLmdvb2dsZWFwaXMuY29tJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZVVybFByZWZpeCArICcvb25ueC5UeXBlUHJvdG8uT3B0aW9uYWwnO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIE9wdGlvbmFsO1xuICAgIH0pKCk7XG5cbiAgICBUeXBlUHJvdG8uU3BhcnNlVGVuc29yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8qKlxuICAgICAgICogUHJvcGVydGllcyBvZiBhIFNwYXJzZVRlbnNvci5cbiAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90b1xuICAgICAgICogQGludGVyZmFjZSBJU3BhcnNlVGVuc29yXG4gICAgICAgKiBAcHJvcGVydHkge251bWJlcnxudWxsfSBbZWxlbVR5cGVdIFNwYXJzZVRlbnNvciBlbGVtVHlwZVxuICAgICAgICogQHByb3BlcnR5IHtvbm54LklUZW5zb3JTaGFwZVByb3RvfG51bGx9IFtzaGFwZV0gU3BhcnNlVGVuc29yIHNoYXBlXG4gICAgICAgKi9cblxuICAgICAgLyoqXG4gICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFNwYXJzZVRlbnNvci5cbiAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90b1xuICAgICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgU3BhcnNlVGVuc29yLlxuICAgICAgICogQGltcGxlbWVudHMgSVNwYXJzZVRlbnNvclxuICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgKiBAcGFyYW0ge29ubnguVHlwZVByb3RvLklTcGFyc2VUZW5zb3I9fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gU3BhcnNlVGVuc29yKHByb3BlcnRpZXMpIHtcbiAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKSB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTcGFyc2VUZW5zb3IgZWxlbVR5cGUuXG4gICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGVsZW1UeXBlXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uU3BhcnNlVGVuc29yXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqL1xuICAgICAgU3BhcnNlVGVuc29yLnByb3RvdHlwZS5lbGVtVHlwZSA9IDA7XG5cbiAgICAgIC8qKlxuICAgICAgICogU3BhcnNlVGVuc29yIHNoYXBlLlxuICAgICAgICogQG1lbWJlciB7b25ueC5JVGVuc29yU2hhcGVQcm90b3xudWxsfHVuZGVmaW5lZH0gc2hhcGVcbiAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5TcGFyc2VUZW5zb3JcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICovXG4gICAgICBTcGFyc2VUZW5zb3IucHJvdG90eXBlLnNoYXBlID0gbnVsbDtcblxuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGVzIGEgbmV3IFNwYXJzZVRlbnNvciBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uU3BhcnNlVGVuc29yXG4gICAgICAgKiBAc3RhdGljXG4gICAgICAgKiBAcGFyYW0ge29ubnguVHlwZVByb3RvLklTcGFyc2VUZW5zb3I9fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAqIEByZXR1cm5zIHtvbm54LlR5cGVQcm90by5TcGFyc2VUZW5zb3J9IFNwYXJzZVRlbnNvciBpbnN0YW5jZVxuICAgICAgICovXG4gICAgICBTcGFyc2VUZW5zb3IuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTcGFyc2VUZW5zb3IocHJvcGVydGllcyk7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBTcGFyc2VUZW5zb3IgbWVzc2FnZS4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5UeXBlUHJvdG8uU3BhcnNlVGVuc29yLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICogQGZ1bmN0aW9uIGVuY29kZVxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlNwYXJzZVRlbnNvclxuICAgICAgICogQHN0YXRpY1xuICAgICAgICogQHBhcmFtIHtvbm54LlR5cGVQcm90by5JU3BhcnNlVGVuc29yfSBtZXNzYWdlIFNwYXJzZVRlbnNvciBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICovXG4gICAgICBTcGFyc2VUZW5zb3IuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICBpZiAoIXdyaXRlcikgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgaWYgKG1lc3NhZ2UuZWxlbVR5cGUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCAnZWxlbVR5cGUnKSlcbiAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDAgPSovIDgpLmludDMyKG1lc3NhZ2UuZWxlbVR5cGUpO1xuICAgICAgICBpZiAobWVzc2FnZS5zaGFwZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsICdzaGFwZScpKVxuICAgICAgICAgICRyb290Lm9ubnguVGVuc29yU2hhcGVQcm90by5lbmNvZGUobWVzc2FnZS5zaGFwZSwgd3JpdGVyLnVpbnQzMigvKiBpZCAyLCB3aXJlVHlwZSAyID0qLyAxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIFNwYXJzZVRlbnNvciBtZXNzYWdlLCBsZW5ndGggZGVsaW1pdGVkLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LlR5cGVQcm90by5TcGFyc2VUZW5zb3IudmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uU3BhcnNlVGVuc29yXG4gICAgICAgKiBAc3RhdGljXG4gICAgICAgKiBAcGFyYW0ge29ubnguVHlwZVByb3RvLklTcGFyc2VUZW5zb3J9IG1lc3NhZ2UgU3BhcnNlVGVuc29yIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgKi9cbiAgICAgIFNwYXJzZVRlbnNvci5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBEZWNvZGVzIGEgU3BhcnNlVGVuc29yIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uU3BhcnNlVGVuc29yXG4gICAgICAgKiBAc3RhdGljXG4gICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgKiBAcmV0dXJucyB7b25ueC5UeXBlUHJvdG8uU3BhcnNlVGVuc29yfSBTcGFyc2VUZW5zb3JcbiAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAqL1xuICAgICAgU3BhcnNlVGVuc29yLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSkgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsXG4gICAgICAgICAgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LlR5cGVQcm90by5TcGFyc2VUZW5zb3IoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgICAgbWVzc2FnZS5lbGVtVHlwZSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgICAgICBtZXNzYWdlLnNoYXBlID0gJHJvb3Qub25ueC5UZW5zb3JTaGFwZVByb3RvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIERlY29kZXMgYSBTcGFyc2VUZW5zb3IgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlciwgbGVuZ3RoIGRlbGltaXRlZC5cbiAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5TcGFyc2VUZW5zb3JcbiAgICAgICAqIEBzdGF0aWNcbiAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICogQHJldHVybnMge29ubnguVHlwZVByb3RvLlNwYXJzZVRlbnNvcn0gU3BhcnNlVGVuc29yXG4gICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgKi9cbiAgICAgIFNwYXJzZVRlbnNvci5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKSByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBWZXJpZmllcyBhIFNwYXJzZVRlbnNvciBtZXNzYWdlLlxuICAgICAgICogQGZ1bmN0aW9uIHZlcmlmeVxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlNwYXJzZVRlbnNvclxuICAgICAgICogQHN0YXRpY1xuICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XG4gICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICAgICAgICovXG4gICAgICBTcGFyc2VUZW5zb3IudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSAnb2JqZWN0JyB8fCBtZXNzYWdlID09PSBudWxsKSByZXR1cm4gJ29iamVjdCBleHBlY3RlZCc7XG4gICAgICAgIGlmIChtZXNzYWdlLmVsZW1UeXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnZWxlbVR5cGUnKSlcbiAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmVsZW1UeXBlKSkgcmV0dXJuICdlbGVtVHlwZTogaW50ZWdlciBleHBlY3RlZCc7XG4gICAgICAgIGlmIChtZXNzYWdlLnNoYXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnc2hhcGUnKSkge1xuICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguVGVuc29yU2hhcGVQcm90by52ZXJpZnkobWVzc2FnZS5zaGFwZSk7XG4gICAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gJ3NoYXBlLicgKyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlcyBhIFNwYXJzZVRlbnNvciBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gICAgICAgKiBAZnVuY3Rpb24gZnJvbU9iamVjdFxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlNwYXJzZVRlbnNvclxuICAgICAgICogQHN0YXRpY1xuICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICAgICAgICogQHJldHVybnMge29ubnguVHlwZVByb3RvLlNwYXJzZVRlbnNvcn0gU3BhcnNlVGVuc29yXG4gICAgICAgKi9cbiAgICAgIFNwYXJzZVRlbnNvci5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290Lm9ubnguVHlwZVByb3RvLlNwYXJzZVRlbnNvcikgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5UeXBlUHJvdG8uU3BhcnNlVGVuc29yKCk7XG4gICAgICAgIGlmIChvYmplY3QuZWxlbVR5cGUgIT0gbnVsbCkgbWVzc2FnZS5lbGVtVHlwZSA9IG9iamVjdC5lbGVtVHlwZSB8IDA7XG4gICAgICAgIGlmIChvYmplY3Quc2hhcGUgIT0gbnVsbCkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnNoYXBlICE9PSAnb2JqZWN0JykgdGhyb3cgVHlwZUVycm9yKCcub25ueC5UeXBlUHJvdG8uU3BhcnNlVGVuc29yLnNoYXBlOiBvYmplY3QgZXhwZWN0ZWQnKTtcbiAgICAgICAgICBtZXNzYWdlLnNoYXBlID0gJHJvb3Qub25ueC5UZW5zb3JTaGFwZVByb3RvLmZyb21PYmplY3Qob2JqZWN0LnNoYXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgU3BhcnNlVGVuc29yIG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAgICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlNwYXJzZVRlbnNvclxuICAgICAgICogQHN0YXRpY1xuICAgICAgICogQHBhcmFtIHtvbm54LlR5cGVQcm90by5TcGFyc2VUZW5zb3J9IG1lc3NhZ2UgU3BhcnNlVGVuc29yXG4gICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICAgKi9cbiAgICAgIFNwYXJzZVRlbnNvci50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgICBvYmplY3QuZWxlbVR5cGUgPSAwO1xuICAgICAgICAgIG9iamVjdC5zaGFwZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuZWxlbVR5cGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdlbGVtVHlwZScpKSBvYmplY3QuZWxlbVR5cGUgPSBtZXNzYWdlLmVsZW1UeXBlO1xuICAgICAgICBpZiAobWVzc2FnZS5zaGFwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ3NoYXBlJykpXG4gICAgICAgICAgb2JqZWN0LnNoYXBlID0gJHJvb3Qub25ueC5UZW5zb3JTaGFwZVByb3RvLnRvT2JqZWN0KG1lc3NhZ2Uuc2hhcGUsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBDb252ZXJ0cyB0aGlzIFNwYXJzZVRlbnNvciB0byBKU09OLlxuICAgICAgICogQGZ1bmN0aW9uIHRvSlNPTlxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlNwYXJzZVRlbnNvclxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IEpTT04gb2JqZWN0XG4gICAgICAgKi9cbiAgICAgIFNwYXJzZVRlbnNvci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogR2V0cyB0aGUgZGVmYXVsdCB0eXBlIHVybCBmb3IgU3BhcnNlVGVuc29yXG4gICAgICAgKiBAZnVuY3Rpb24gZ2V0VHlwZVVybFxuICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlNwYXJzZVRlbnNvclxuICAgICAgICogQHN0YXRpY1xuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlVXJsUHJlZml4XSB5b3VyIGN1c3RvbSB0eXBlVXJsUHJlZml4KGRlZmF1bHQgXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCIpXG4gICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZGVmYXVsdCB0eXBlIHVybFxuICAgICAgICovXG4gICAgICBTcGFyc2VUZW5zb3IuZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgICBpZiAodHlwZVVybFByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdHlwZVVybFByZWZpeCA9ICd0eXBlLmdvb2dsZWFwaXMuY29tJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZVVybFByZWZpeCArICcvb25ueC5UeXBlUHJvdG8uU3BhcnNlVGVuc29yJztcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBTcGFyc2VUZW5zb3I7XG4gICAgfSkoKTtcblxuICAgIHJldHVybiBUeXBlUHJvdG87XG4gIH0pKCk7XG5cbiAgb25ueC5PcGVyYXRvclNldElkUHJvdG8gPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgb2YgYW4gT3BlcmF0b3JTZXRJZFByb3RvLlxuICAgICAqIEBtZW1iZXJvZiBvbm54XG4gICAgICogQGludGVyZmFjZSBJT3BlcmF0b3JTZXRJZFByb3RvXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW2RvbWFpbl0gT3BlcmF0b3JTZXRJZFByb3RvIGRvbWFpblxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfExvbmd8bnVsbH0gW3ZlcnNpb25dIE9wZXJhdG9yU2V0SWRQcm90byB2ZXJzaW9uXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IE9wZXJhdG9yU2V0SWRQcm90by5cbiAgICAgKiBAbWVtYmVyb2Ygb25ueFxuICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhbiBPcGVyYXRvclNldElkUHJvdG8uXG4gICAgICogQGltcGxlbWVudHMgSU9wZXJhdG9yU2V0SWRQcm90b1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7b25ueC5JT3BlcmF0b3JTZXRJZFByb3RvPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICovXG4gICAgZnVuY3Rpb24gT3BlcmF0b3JTZXRJZFByb3RvKHByb3BlcnRpZXMpIHtcbiAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKSB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPcGVyYXRvclNldElkUHJvdG8gZG9tYWluLlxuICAgICAqIEBtZW1iZXIge3N0cmluZ30gZG9tYWluXG4gICAgICogQG1lbWJlcm9mIG9ubnguT3BlcmF0b3JTZXRJZFByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgT3BlcmF0b3JTZXRJZFByb3RvLnByb3RvdHlwZS5kb21haW4gPSAnJztcblxuICAgIC8qKlxuICAgICAqIE9wZXJhdG9yU2V0SWRQcm90byB2ZXJzaW9uLlxuICAgICAqIEBtZW1iZXIge251bWJlcnxMb25nfSB2ZXJzaW9uXG4gICAgICogQG1lbWJlcm9mIG9ubnguT3BlcmF0b3JTZXRJZFByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgT3BlcmF0b3JTZXRJZFByb3RvLnByb3RvdHlwZS52ZXJzaW9uID0gJHV0aWwuTG9uZyA/ICR1dGlsLkxvbmcuZnJvbUJpdHMoMCwgMCwgZmFsc2UpIDogMDtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgT3BlcmF0b3JTZXRJZFByb3RvIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXG4gICAgICogQG1lbWJlcm9mIG9ubnguT3BlcmF0b3JTZXRJZFByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7b25ueC5JT3BlcmF0b3JTZXRJZFByb3RvPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICogQHJldHVybnMge29ubnguT3BlcmF0b3JTZXRJZFByb3RvfSBPcGVyYXRvclNldElkUHJvdG8gaW5zdGFuY2VcbiAgICAgKi9cbiAgICBPcGVyYXRvclNldElkUHJvdG8uY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgIHJldHVybiBuZXcgT3BlcmF0b3JTZXRJZFByb3RvKHByb3BlcnRpZXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgT3BlcmF0b3JTZXRJZFByb3RvIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguT3BlcmF0b3JTZXRJZFByb3RvLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAqIEBmdW5jdGlvbiBlbmNvZGVcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5PcGVyYXRvclNldElkUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtvbm54LklPcGVyYXRvclNldElkUHJvdG99IG1lc3NhZ2UgT3BlcmF0b3JTZXRJZFByb3RvIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgKi9cbiAgICBPcGVyYXRvclNldElkUHJvdG8uZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgaWYgKCF3cml0ZXIpIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICBpZiAobWVzc2FnZS5kb21haW4gIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCAnZG9tYWluJykpXG4gICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki8gMTApLnN0cmluZyhtZXNzYWdlLmRvbWFpbik7XG4gICAgICBpZiAobWVzc2FnZS52ZXJzaW9uICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgJ3ZlcnNpb24nKSlcbiAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAyLCB3aXJlVHlwZSAwID0qLyAxNikuaW50NjQobWVzc2FnZS52ZXJzaW9uKTtcbiAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBPcGVyYXRvclNldElkUHJvdG8gbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5PcGVyYXRvclNldElkUHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAqIEBtZW1iZXJvZiBvbm54Lk9wZXJhdG9yU2V0SWRQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge29ubnguSU9wZXJhdG9yU2V0SWRQcm90b30gbWVzc2FnZSBPcGVyYXRvclNldElkUHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAqL1xuICAgIE9wZXJhdG9yU2V0SWRQcm90by5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhbiBPcGVyYXRvclNldElkUHJvdG8gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICogQG1lbWJlcm9mIG9ubnguT3BlcmF0b3JTZXRJZFByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICogQHJldHVybnMge29ubnguT3BlcmF0b3JTZXRJZFByb3RvfSBPcGVyYXRvclNldElkUHJvdG9cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAqL1xuICAgIE9wZXJhdG9yU2V0SWRQcm90by5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgpIHtcbiAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKSByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsXG4gICAgICAgIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5PcGVyYXRvclNldElkUHJvdG8oKTtcbiAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICBtZXNzYWdlLmRvbWFpbiA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgIG1lc3NhZ2UudmVyc2lvbiA9IHJlYWRlci5pbnQ2NCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlY29kZXMgYW4gT3BlcmF0b3JTZXRJZFByb3RvIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICogQGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZFxuICAgICAqIEBtZW1iZXJvZiBvbm54Lk9wZXJhdG9yU2V0SWRQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgKiBAcmV0dXJucyB7b25ueC5PcGVyYXRvclNldElkUHJvdG99IE9wZXJhdG9yU2V0SWRQcm90b1xuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICovXG4gICAgT3BlcmF0b3JTZXRJZFByb3RvLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKSByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgYW4gT3BlcmF0b3JTZXRJZFByb3RvIG1lc3NhZ2UuXG4gICAgICogQGZ1bmN0aW9uIHZlcmlmeVxuICAgICAqIEBtZW1iZXJvZiBvbm54Lk9wZXJhdG9yU2V0SWRQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICAgICAqL1xuICAgIE9wZXJhdG9yU2V0SWRQcm90by52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSAnb2JqZWN0JyB8fCBtZXNzYWdlID09PSBudWxsKSByZXR1cm4gJ29iamVjdCBleHBlY3RlZCc7XG4gICAgICBpZiAobWVzc2FnZS5kb21haW4gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdkb21haW4nKSlcbiAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLmRvbWFpbikpIHJldHVybiAnZG9tYWluOiBzdHJpbmcgZXhwZWN0ZWQnO1xuICAgICAgaWYgKG1lc3NhZ2UudmVyc2lvbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ3ZlcnNpb24nKSlcbiAgICAgICAgaWYgKFxuICAgICAgICAgICEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS52ZXJzaW9uKSAmJlxuICAgICAgICAgICEobWVzc2FnZS52ZXJzaW9uICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLnZlcnNpb24ubG93KSAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS52ZXJzaW9uLmhpZ2gpKVxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuICd2ZXJzaW9uOiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWQnO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gT3BlcmF0b3JTZXRJZFByb3RvIG1lc3NhZ2UgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cbiAgICAgKiBAZnVuY3Rpb24gZnJvbU9iamVjdFxuICAgICAqIEBtZW1iZXJvZiBvbm54Lk9wZXJhdG9yU2V0SWRQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gICAgICogQHJldHVybnMge29ubnguT3BlcmF0b3JTZXRJZFByb3RvfSBPcGVyYXRvclNldElkUHJvdG9cbiAgICAgKi9cbiAgICBPcGVyYXRvclNldElkUHJvdG8uZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3Qub25ueC5PcGVyYXRvclNldElkUHJvdG8pIHJldHVybiBvYmplY3Q7XG4gICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54Lk9wZXJhdG9yU2V0SWRQcm90bygpO1xuICAgICAgaWYgKG9iamVjdC5kb21haW4gIT0gbnVsbCkgbWVzc2FnZS5kb21haW4gPSBTdHJpbmcob2JqZWN0LmRvbWFpbik7XG4gICAgICBpZiAob2JqZWN0LnZlcnNpb24gIT0gbnVsbClcbiAgICAgICAgaWYgKCR1dGlsLkxvbmcpIChtZXNzYWdlLnZlcnNpb24gPSAkdXRpbC5Mb25nLmZyb21WYWx1ZShvYmplY3QudmVyc2lvbikpLnVuc2lnbmVkID0gZmFsc2U7XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QudmVyc2lvbiA9PT0gJ3N0cmluZycpIG1lc3NhZ2UudmVyc2lvbiA9IHBhcnNlSW50KG9iamVjdC52ZXJzaW9uLCAxMCk7XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QudmVyc2lvbiA9PT0gJ251bWJlcicpIG1lc3NhZ2UudmVyc2lvbiA9IG9iamVjdC52ZXJzaW9uO1xuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LnZlcnNpb24gPT09ICdvYmplY3QnKVxuICAgICAgICAgIG1lc3NhZ2UudmVyc2lvbiA9IG5ldyAkdXRpbC5Mb25nQml0cyhvYmplY3QudmVyc2lvbi5sb3cgPj4+IDAsIG9iamVjdC52ZXJzaW9uLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCk7XG4gICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGFuIE9wZXJhdG9yU2V0SWRQcm90byBtZXNzYWdlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXG4gICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XG4gICAgICogQG1lbWJlcm9mIG9ubnguT3BlcmF0b3JTZXRJZFByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7b25ueC5PcGVyYXRvclNldElkUHJvdG99IG1lc3NhZ2UgT3BlcmF0b3JTZXRJZFByb3RvXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuSUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcbiAgICAgKi9cbiAgICBPcGVyYXRvclNldElkUHJvdG8udG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgIG9iamVjdC5kb21haW4gPSAnJztcbiAgICAgICAgaWYgKCR1dGlsLkxvbmcpIHtcbiAgICAgICAgICB2YXIgbG9uZyA9IG5ldyAkdXRpbC5Mb25nKDAsIDAsIGZhbHNlKTtcbiAgICAgICAgICBvYmplY3QudmVyc2lvbiA9XG4gICAgICAgICAgICBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBsb25nLnRvU3RyaW5nKCkgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBsb25nLnRvTnVtYmVyKCkgOiBsb25nO1xuICAgICAgICB9IGVsc2Ugb2JqZWN0LnZlcnNpb24gPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyAnMCcgOiAwO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UuZG9tYWluICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnZG9tYWluJykpIG9iamVjdC5kb21haW4gPSBtZXNzYWdlLmRvbWFpbjtcbiAgICAgIGlmIChtZXNzYWdlLnZlcnNpb24gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCd2ZXJzaW9uJykpXG4gICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS52ZXJzaW9uID09PSAnbnVtYmVyJylcbiAgICAgICAgICBvYmplY3QudmVyc2lvbiA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtZXNzYWdlLnZlcnNpb24pIDogbWVzc2FnZS52ZXJzaW9uO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgb2JqZWN0LnZlcnNpb24gPVxuICAgICAgICAgICAgb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nXG4gICAgICAgICAgICAgID8gJHV0aWwuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtZXNzYWdlLnZlcnNpb24pXG4gICAgICAgICAgICAgIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyXG4gICAgICAgICAgICAgICAgPyBuZXcgJHV0aWwuTG9uZ0JpdHMobWVzc2FnZS52ZXJzaW9uLmxvdyA+Pj4gMCwgbWVzc2FnZS52ZXJzaW9uLmhpZ2ggPj4+IDApLnRvTnVtYmVyKClcbiAgICAgICAgICAgICAgICA6IG1lc3NhZ2UudmVyc2lvbjtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoaXMgT3BlcmF0b3JTZXRJZFByb3RvIHRvIEpTT04uXG4gICAgICogQGZ1bmN0aW9uIHRvSlNPTlxuICAgICAqIEBtZW1iZXJvZiBvbm54Lk9wZXJhdG9yU2V0SWRQcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcbiAgICAgKi9cbiAgICBPcGVyYXRvclNldElkUHJvdG8ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBkZWZhdWx0IHR5cGUgdXJsIGZvciBPcGVyYXRvclNldElkUHJvdG9cbiAgICAgKiBAZnVuY3Rpb24gZ2V0VHlwZVVybFxuICAgICAqIEBtZW1iZXJvZiBvbm54Lk9wZXJhdG9yU2V0SWRQcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVVcmxQcmVmaXhdIHlvdXIgY3VzdG9tIHR5cGVVcmxQcmVmaXgoZGVmYXVsdCBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIilcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZGVmYXVsdCB0eXBlIHVybFxuICAgICAqL1xuICAgIE9wZXJhdG9yU2V0SWRQcm90by5nZXRUeXBlVXJsID0gZnVuY3Rpb24gZ2V0VHlwZVVybCh0eXBlVXJsUHJlZml4KSB7XG4gICAgICBpZiAodHlwZVVybFByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHR5cGVVcmxQcmVmaXggPSAndHlwZS5nb29nbGVhcGlzLmNvbSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZVVybFByZWZpeCArICcvb25ueC5PcGVyYXRvclNldElkUHJvdG8nO1xuICAgIH07XG5cbiAgICByZXR1cm4gT3BlcmF0b3JTZXRJZFByb3RvO1xuICB9KSgpO1xuXG4gIC8qKlxuICAgKiBPcGVyYXRvclN0YXR1cyBlbnVtLlxuICAgKiBAbmFtZSBvbm54Lk9wZXJhdG9yU3RhdHVzXG4gICAqIEBlbnVtIHtudW1iZXJ9XG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBFWFBFUklNRU5UQUw9MCBFWFBFUklNRU5UQUwgdmFsdWVcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IFNUQUJMRT0xIFNUQUJMRSB2YWx1ZVxuICAgKi9cbiAgb25ueC5PcGVyYXRvclN0YXR1cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhbHVlc0J5SWQgPSB7fSxcbiAgICAgIHZhbHVlcyA9IE9iamVjdC5jcmVhdGUodmFsdWVzQnlJZCk7XG4gICAgdmFsdWVzWyh2YWx1ZXNCeUlkWzBdID0gJ0VYUEVSSU1FTlRBTCcpXSA9IDA7XG4gICAgdmFsdWVzWyh2YWx1ZXNCeUlkWzFdID0gJ1NUQUJMRScpXSA9IDE7XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfSkoKTtcblxuICBvbm54LkZ1bmN0aW9uUHJvdG8gPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgb2YgYSBGdW5jdGlvblByb3RvLlxuICAgICAqIEBtZW1iZXJvZiBvbm54XG4gICAgICogQGludGVyZmFjZSBJRnVuY3Rpb25Qcm90b1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtuYW1lXSBGdW5jdGlvblByb3RvIG5hbWVcbiAgICAgKiBAcHJvcGVydHkge0FycmF5LjxzdHJpbmc+fG51bGx9IFtpbnB1dF0gRnVuY3Rpb25Qcm90byBpbnB1dFxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPHN0cmluZz58bnVsbH0gW291dHB1dF0gRnVuY3Rpb25Qcm90byBvdXRwdXRcbiAgICAgKiBAcHJvcGVydHkge0FycmF5LjxzdHJpbmc+fG51bGx9IFthdHRyaWJ1dGVdIEZ1bmN0aW9uUHJvdG8gYXR0cmlidXRlXG4gICAgICogQHByb3BlcnR5IHtBcnJheS48b25ueC5JQXR0cmlidXRlUHJvdG8+fG51bGx9IFthdHRyaWJ1dGVQcm90b10gRnVuY3Rpb25Qcm90byBhdHRyaWJ1dGVQcm90b1xuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG9ubnguSU5vZGVQcm90bz58bnVsbH0gW25vZGVdIEZ1bmN0aW9uUHJvdG8gbm9kZVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtkb2NTdHJpbmddIEZ1bmN0aW9uUHJvdG8gZG9jU3RyaW5nXG4gICAgICogQHByb3BlcnR5IHtBcnJheS48b25ueC5JT3BlcmF0b3JTZXRJZFByb3RvPnxudWxsfSBbb3BzZXRJbXBvcnRdIEZ1bmN0aW9uUHJvdG8gb3BzZXRJbXBvcnRcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbZG9tYWluXSBGdW5jdGlvblByb3RvIGRvbWFpblxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBGdW5jdGlvblByb3RvLlxuICAgICAqIEBtZW1iZXJvZiBvbm54XG4gICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgRnVuY3Rpb25Qcm90by5cbiAgICAgKiBAaW1wbGVtZW50cyBJRnVuY3Rpb25Qcm90b1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7b25ueC5JRnVuY3Rpb25Qcm90bz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEZ1bmN0aW9uUHJvdG8ocHJvcGVydGllcykge1xuICAgICAgdGhpcy5pbnB1dCA9IFtdO1xuICAgICAgdGhpcy5vdXRwdXQgPSBbXTtcbiAgICAgIHRoaXMuYXR0cmlidXRlID0gW107XG4gICAgICB0aGlzLmF0dHJpYnV0ZVByb3RvID0gW107XG4gICAgICB0aGlzLm5vZGUgPSBbXTtcbiAgICAgIHRoaXMub3BzZXRJbXBvcnQgPSBbXTtcbiAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKSB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvblByb3RvIG5hbWUuXG4gICAgICogQG1lbWJlciB7c3RyaW5nfSBuYW1lXG4gICAgICogQG1lbWJlcm9mIG9ubnguRnVuY3Rpb25Qcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIEZ1bmN0aW9uUHJvdG8ucHJvdG90eXBlLm5hbWUgPSAnJztcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uUHJvdG8gaW5wdXQuXG4gICAgICogQG1lbWJlciB7QXJyYXkuPHN0cmluZz59IGlucHV0XG4gICAgICogQG1lbWJlcm9mIG9ubnguRnVuY3Rpb25Qcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIEZ1bmN0aW9uUHJvdG8ucHJvdG90eXBlLmlucHV0ID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uUHJvdG8gb3V0cHV0LlxuICAgICAqIEBtZW1iZXIge0FycmF5LjxzdHJpbmc+fSBvdXRwdXRcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5GdW5jdGlvblByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgRnVuY3Rpb25Qcm90by5wcm90b3R5cGUub3V0cHV0ID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uUHJvdG8gYXR0cmlidXRlLlxuICAgICAqIEBtZW1iZXIge0FycmF5LjxzdHJpbmc+fSBhdHRyaWJ1dGVcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5GdW5jdGlvblByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgRnVuY3Rpb25Qcm90by5wcm90b3R5cGUuYXR0cmlidXRlID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uUHJvdG8gYXR0cmlidXRlUHJvdG8uXG4gICAgICogQG1lbWJlciB7QXJyYXkuPG9ubnguSUF0dHJpYnV0ZVByb3RvPn0gYXR0cmlidXRlUHJvdG9cbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5GdW5jdGlvblByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgRnVuY3Rpb25Qcm90by5wcm90b3R5cGUuYXR0cmlidXRlUHJvdG8gPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb25Qcm90byBub2RlLlxuICAgICAqIEBtZW1iZXIge0FycmF5Ljxvbm54LklOb2RlUHJvdG8+fSBub2RlXG4gICAgICogQG1lbWJlcm9mIG9ubnguRnVuY3Rpb25Qcm90b1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIEZ1bmN0aW9uUHJvdG8ucHJvdG90eXBlLm5vZGUgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb25Qcm90byBkb2NTdHJpbmcuXG4gICAgICogQG1lbWJlciB7c3RyaW5nfSBkb2NTdHJpbmdcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5GdW5jdGlvblByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgRnVuY3Rpb25Qcm90by5wcm90b3R5cGUuZG9jU3RyaW5nID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvblByb3RvIG9wc2V0SW1wb3J0LlxuICAgICAqIEBtZW1iZXIge0FycmF5Ljxvbm54LklPcGVyYXRvclNldElkUHJvdG8+fSBvcHNldEltcG9ydFxuICAgICAqIEBtZW1iZXJvZiBvbm54LkZ1bmN0aW9uUHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBGdW5jdGlvblByb3RvLnByb3RvdHlwZS5vcHNldEltcG9ydCA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvblByb3RvIGRvbWFpbi5cbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IGRvbWFpblxuICAgICAqIEBtZW1iZXJvZiBvbm54LkZ1bmN0aW9uUHJvdG9cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBGdW5jdGlvblByb3RvLnByb3RvdHlwZS5kb21haW4gPSAnJztcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgRnVuY3Rpb25Qcm90byBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxuICAgICAqIEBtZW1iZXJvZiBvbm54LkZ1bmN0aW9uUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtvbm54LklGdW5jdGlvblByb3RvPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICogQHJldHVybnMge29ubnguRnVuY3Rpb25Qcm90b30gRnVuY3Rpb25Qcm90byBpbnN0YW5jZVxuICAgICAqL1xuICAgIEZ1bmN0aW9uUHJvdG8uY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgIHJldHVybiBuZXcgRnVuY3Rpb25Qcm90byhwcm9wZXJ0aWVzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIEZ1bmN0aW9uUHJvdG8gbWVzc2FnZS4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5GdW5jdGlvblByb3RvLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAqIEBmdW5jdGlvbiBlbmNvZGVcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5GdW5jdGlvblByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7b25ueC5JRnVuY3Rpb25Qcm90b30gbWVzc2FnZSBGdW5jdGlvblByb3RvIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgKi9cbiAgICBGdW5jdGlvblByb3RvLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgIGlmICghd3JpdGVyKSB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgaWYgKG1lc3NhZ2UubmFtZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsICduYW1lJykpXG4gICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki8gMTApLnN0cmluZyhtZXNzYWdlLm5hbWUpO1xuICAgICAgaWYgKG1lc3NhZ2UuaW5wdXQgIT0gbnVsbCAmJiBtZXNzYWdlLmlucHV0Lmxlbmd0aClcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmlucHV0Lmxlbmd0aDsgKytpKVxuICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgNCwgd2lyZVR5cGUgMiA9Ki8gMzQpLnN0cmluZyhtZXNzYWdlLmlucHV0W2ldKTtcbiAgICAgIGlmIChtZXNzYWdlLm91dHB1dCAhPSBudWxsICYmIG1lc3NhZ2Uub3V0cHV0Lmxlbmd0aClcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLm91dHB1dC5sZW5ndGg7ICsraSlcbiAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDUsIHdpcmVUeXBlIDIgPSovIDQyKS5zdHJpbmcobWVzc2FnZS5vdXRwdXRbaV0pO1xuICAgICAgaWYgKG1lc3NhZ2UuYXR0cmlidXRlICE9IG51bGwgJiYgbWVzc2FnZS5hdHRyaWJ1dGUubGVuZ3RoKVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuYXR0cmlidXRlLmxlbmd0aDsgKytpKVxuICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgNiwgd2lyZVR5cGUgMiA9Ki8gNTApLnN0cmluZyhtZXNzYWdlLmF0dHJpYnV0ZVtpXSk7XG4gICAgICBpZiAobWVzc2FnZS5ub2RlICE9IG51bGwgJiYgbWVzc2FnZS5ub2RlLmxlbmd0aClcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLm5vZGUubGVuZ3RoOyArK2kpXG4gICAgICAgICAgJHJvb3Qub25ueC5Ob2RlUHJvdG8uZW5jb2RlKG1lc3NhZ2Uubm9kZVtpXSwgd3JpdGVyLnVpbnQzMigvKiBpZCA3LCB3aXJlVHlwZSAyID0qLyA1OCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgIGlmIChtZXNzYWdlLmRvY1N0cmluZyAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsICdkb2NTdHJpbmcnKSlcbiAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA4LCB3aXJlVHlwZSAyID0qLyA2Nikuc3RyaW5nKG1lc3NhZ2UuZG9jU3RyaW5nKTtcbiAgICAgIGlmIChtZXNzYWdlLm9wc2V0SW1wb3J0ICE9IG51bGwgJiYgbWVzc2FnZS5vcHNldEltcG9ydC5sZW5ndGgpXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5vcHNldEltcG9ydC5sZW5ndGg7ICsraSlcbiAgICAgICAgICAkcm9vdC5vbm54Lk9wZXJhdG9yU2V0SWRQcm90by5lbmNvZGUoXG4gICAgICAgICAgICBtZXNzYWdlLm9wc2V0SW1wb3J0W2ldLFxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA5LCB3aXJlVHlwZSAyID0qLyA3NCkuZm9yaygpLFxuICAgICAgICAgICkubGRlbGltKCk7XG4gICAgICBpZiAobWVzc2FnZS5kb21haW4gIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCAnZG9tYWluJykpXG4gICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMTAsIHdpcmVUeXBlIDIgPSovIDgyKS5zdHJpbmcobWVzc2FnZS5kb21haW4pO1xuICAgICAgaWYgKG1lc3NhZ2UuYXR0cmlidXRlUHJvdG8gIT0gbnVsbCAmJiBtZXNzYWdlLmF0dHJpYnV0ZVByb3RvLmxlbmd0aClcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmF0dHJpYnV0ZVByb3RvLmxlbmd0aDsgKytpKVxuICAgICAgICAgICRyb290Lm9ubnguQXR0cmlidXRlUHJvdG8uZW5jb2RlKFxuICAgICAgICAgICAgbWVzc2FnZS5hdHRyaWJ1dGVQcm90b1tpXSxcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMTEsIHdpcmVUeXBlIDIgPSovIDkwKS5mb3JrKCksXG4gICAgICAgICAgKS5sZGVsaW0oKTtcbiAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBGdW5jdGlvblByb3RvIG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguRnVuY3Rpb25Qcm90by52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgKiBAZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkXG4gICAgICogQG1lbWJlcm9mIG9ubnguRnVuY3Rpb25Qcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge29ubnguSUZ1bmN0aW9uUHJvdG99IG1lc3NhZ2UgRnVuY3Rpb25Qcm90byBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICovXG4gICAgRnVuY3Rpb25Qcm90by5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhIEZ1bmN0aW9uUHJvdG8gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICogQG1lbWJlcm9mIG9ubnguRnVuY3Rpb25Qcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAqIEByZXR1cm5zIHtvbm54LkZ1bmN0aW9uUHJvdG99IEZ1bmN0aW9uUHJvdG9cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAqL1xuICAgIEZ1bmN0aW9uUHJvdG8uZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSkgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLFxuICAgICAgICBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguRnVuY3Rpb25Qcm90bygpO1xuICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgIG1lc3NhZ2UubmFtZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDQ6IHtcbiAgICAgICAgICAgIGlmICghKG1lc3NhZ2UuaW5wdXQgJiYgbWVzc2FnZS5pbnB1dC5sZW5ndGgpKSBtZXNzYWdlLmlucHV0ID0gW107XG4gICAgICAgICAgICBtZXNzYWdlLmlucHV0LnB1c2gocmVhZGVyLnN0cmluZygpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDU6IHtcbiAgICAgICAgICAgIGlmICghKG1lc3NhZ2Uub3V0cHV0ICYmIG1lc3NhZ2Uub3V0cHV0Lmxlbmd0aCkpIG1lc3NhZ2Uub3V0cHV0ID0gW107XG4gICAgICAgICAgICBtZXNzYWdlLm91dHB1dC5wdXNoKHJlYWRlci5zdHJpbmcoKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSA2OiB7XG4gICAgICAgICAgICBpZiAoIShtZXNzYWdlLmF0dHJpYnV0ZSAmJiBtZXNzYWdlLmF0dHJpYnV0ZS5sZW5ndGgpKSBtZXNzYWdlLmF0dHJpYnV0ZSA9IFtdO1xuICAgICAgICAgICAgbWVzc2FnZS5hdHRyaWJ1dGUucHVzaChyZWFkZXIuc3RyaW5nKCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMTE6IHtcbiAgICAgICAgICAgIGlmICghKG1lc3NhZ2UuYXR0cmlidXRlUHJvdG8gJiYgbWVzc2FnZS5hdHRyaWJ1dGVQcm90by5sZW5ndGgpKSBtZXNzYWdlLmF0dHJpYnV0ZVByb3RvID0gW107XG4gICAgICAgICAgICBtZXNzYWdlLmF0dHJpYnV0ZVByb3RvLnB1c2goJHJvb3Qub25ueC5BdHRyaWJ1dGVQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDc6IHtcbiAgICAgICAgICAgIGlmICghKG1lc3NhZ2Uubm9kZSAmJiBtZXNzYWdlLm5vZGUubGVuZ3RoKSkgbWVzc2FnZS5ub2RlID0gW107XG4gICAgICAgICAgICBtZXNzYWdlLm5vZGUucHVzaCgkcm9vdC5vbm54Lk5vZGVQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDg6IHtcbiAgICAgICAgICAgIG1lc3NhZ2UuZG9jU3RyaW5nID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgOToge1xuICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5vcHNldEltcG9ydCAmJiBtZXNzYWdlLm9wc2V0SW1wb3J0Lmxlbmd0aCkpIG1lc3NhZ2Uub3BzZXRJbXBvcnQgPSBbXTtcbiAgICAgICAgICAgIG1lc3NhZ2Uub3BzZXRJbXBvcnQucHVzaCgkcm9vdC5vbm54Lk9wZXJhdG9yU2V0SWRQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDEwOiB7XG4gICAgICAgICAgICBtZXNzYWdlLmRvbWFpbiA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZWNvZGVzIGEgRnVuY3Rpb25Qcm90byBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLCBsZW5ndGggZGVsaW1pdGVkLlxuICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5GdW5jdGlvblByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAqIEByZXR1cm5zIHtvbm54LkZ1bmN0aW9uUHJvdG99IEZ1bmN0aW9uUHJvdG9cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAqL1xuICAgIEZ1bmN0aW9uUHJvdG8uZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyBhIEZ1bmN0aW9uUHJvdG8gbWVzc2FnZS5cbiAgICAgKiBAZnVuY3Rpb24gdmVyaWZ5XG4gICAgICogQG1lbWJlcm9mIG9ubnguRnVuY3Rpb25Qcm90b1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICAgICAqL1xuICAgIEZ1bmN0aW9uUHJvdG8udmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gJ29iamVjdCcgfHwgbWVzc2FnZSA9PT0gbnVsbCkgcmV0dXJuICdvYmplY3QgZXhwZWN0ZWQnO1xuICAgICAgaWYgKG1lc3NhZ2UubmFtZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ25hbWUnKSlcbiAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLm5hbWUpKSByZXR1cm4gJ25hbWU6IHN0cmluZyBleHBlY3RlZCc7XG4gICAgICBpZiAobWVzc2FnZS5pbnB1dCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ2lucHV0JykpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UuaW5wdXQpKSByZXR1cm4gJ2lucHV0OiBhcnJheSBleHBlY3RlZCc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5pbnB1dC5sZW5ndGg7ICsraSlcbiAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UuaW5wdXRbaV0pKSByZXR1cm4gJ2lucHV0OiBzdHJpbmdbXSBleHBlY3RlZCc7XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5vdXRwdXQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdvdXRwdXQnKSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5vdXRwdXQpKSByZXR1cm4gJ291dHB1dDogYXJyYXkgZXhwZWN0ZWQnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2Uub3V0cHV0Lmxlbmd0aDsgKytpKVxuICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5vdXRwdXRbaV0pKSByZXR1cm4gJ291dHB1dDogc3RyaW5nW10gZXhwZWN0ZWQnO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UuYXR0cmlidXRlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnYXR0cmlidXRlJykpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UuYXR0cmlidXRlKSkgcmV0dXJuICdhdHRyaWJ1dGU6IGFycmF5IGV4cGVjdGVkJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmF0dHJpYnV0ZS5sZW5ndGg7ICsraSlcbiAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UuYXR0cmlidXRlW2ldKSkgcmV0dXJuICdhdHRyaWJ1dGU6IHN0cmluZ1tdIGV4cGVjdGVkJztcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLmF0dHJpYnV0ZVByb3RvICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnYXR0cmlidXRlUHJvdG8nKSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5hdHRyaWJ1dGVQcm90bykpIHJldHVybiAnYXR0cmlidXRlUHJvdG86IGFycmF5IGV4cGVjdGVkJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmF0dHJpYnV0ZVByb3RvLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5BdHRyaWJ1dGVQcm90by52ZXJpZnkobWVzc2FnZS5hdHRyaWJ1dGVQcm90b1tpXSk7XG4gICAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gJ2F0dHJpYnV0ZVByb3RvLicgKyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2Uubm9kZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ25vZGUnKSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5ub2RlKSkgcmV0dXJuICdub2RlOiBhcnJheSBleHBlY3RlZCc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5ub2RlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5Ob2RlUHJvdG8udmVyaWZ5KG1lc3NhZ2Uubm9kZVtpXSk7XG4gICAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gJ25vZGUuJyArIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5kb2NTdHJpbmcgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdkb2NTdHJpbmcnKSlcbiAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLmRvY1N0cmluZykpIHJldHVybiAnZG9jU3RyaW5nOiBzdHJpbmcgZXhwZWN0ZWQnO1xuICAgICAgaWYgKG1lc3NhZ2Uub3BzZXRJbXBvcnQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCdvcHNldEltcG9ydCcpKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLm9wc2V0SW1wb3J0KSkgcmV0dXJuICdvcHNldEltcG9ydDogYXJyYXkgZXhwZWN0ZWQnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2Uub3BzZXRJbXBvcnQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54Lk9wZXJhdG9yU2V0SWRQcm90by52ZXJpZnkobWVzc2FnZS5vcHNldEltcG9ydFtpXSk7XG4gICAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gJ29wc2V0SW1wb3J0LicgKyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UuZG9tYWluICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnZG9tYWluJykpXG4gICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5kb21haW4pKSByZXR1cm4gJ2RvbWFpbjogc3RyaW5nIGV4cGVjdGVkJztcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgRnVuY3Rpb25Qcm90byBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gICAgICogQGZ1bmN0aW9uIGZyb21PYmplY3RcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5GdW5jdGlvblByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7b25ueC5GdW5jdGlvblByb3RvfSBGdW5jdGlvblByb3RvXG4gICAgICovXG4gICAgRnVuY3Rpb25Qcm90by5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5vbm54LkZ1bmN0aW9uUHJvdG8pIHJldHVybiBvYmplY3Q7XG4gICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LkZ1bmN0aW9uUHJvdG8oKTtcbiAgICAgIGlmIChvYmplY3QubmFtZSAhPSBudWxsKSBtZXNzYWdlLm5hbWUgPSBTdHJpbmcob2JqZWN0Lm5hbWUpO1xuICAgICAgaWYgKG9iamVjdC5pbnB1dCkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LmlucHV0KSkgdGhyb3cgVHlwZUVycm9yKCcub25ueC5GdW5jdGlvblByb3RvLmlucHV0OiBhcnJheSBleHBlY3RlZCcpO1xuICAgICAgICBtZXNzYWdlLmlucHV0ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LmlucHV0Lmxlbmd0aDsgKytpKSBtZXNzYWdlLmlucHV0W2ldID0gU3RyaW5nKG9iamVjdC5pbnB1dFtpXSk7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0Lm91dHB1dCkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0Lm91dHB1dCkpIHRocm93IFR5cGVFcnJvcignLm9ubnguRnVuY3Rpb25Qcm90by5vdXRwdXQ6IGFycmF5IGV4cGVjdGVkJyk7XG4gICAgICAgIG1lc3NhZ2Uub3V0cHV0ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0Lm91dHB1dC5sZW5ndGg7ICsraSkgbWVzc2FnZS5vdXRwdXRbaV0gPSBTdHJpbmcob2JqZWN0Lm91dHB1dFtpXSk7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0LmF0dHJpYnV0ZSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LmF0dHJpYnV0ZSkpIHRocm93IFR5cGVFcnJvcignLm9ubnguRnVuY3Rpb25Qcm90by5hdHRyaWJ1dGU6IGFycmF5IGV4cGVjdGVkJyk7XG4gICAgICAgIG1lc3NhZ2UuYXR0cmlidXRlID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LmF0dHJpYnV0ZS5sZW5ndGg7ICsraSkgbWVzc2FnZS5hdHRyaWJ1dGVbaV0gPSBTdHJpbmcob2JqZWN0LmF0dHJpYnV0ZVtpXSk7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0LmF0dHJpYnV0ZVByb3RvKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QuYXR0cmlidXRlUHJvdG8pKVxuICAgICAgICAgIHRocm93IFR5cGVFcnJvcignLm9ubnguRnVuY3Rpb25Qcm90by5hdHRyaWJ1dGVQcm90bzogYXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgbWVzc2FnZS5hdHRyaWJ1dGVQcm90byA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5hdHRyaWJ1dGVQcm90by5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmF0dHJpYnV0ZVByb3RvW2ldICE9PSAnb2JqZWN0JylcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcignLm9ubnguRnVuY3Rpb25Qcm90by5hdHRyaWJ1dGVQcm90bzogb2JqZWN0IGV4cGVjdGVkJyk7XG4gICAgICAgICAgbWVzc2FnZS5hdHRyaWJ1dGVQcm90b1tpXSA9ICRyb290Lm9ubnguQXR0cmlidXRlUHJvdG8uZnJvbU9iamVjdChvYmplY3QuYXR0cmlidXRlUHJvdG9baV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0Lm5vZGUpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5ub2RlKSkgdGhyb3cgVHlwZUVycm9yKCcub25ueC5GdW5jdGlvblByb3RvLm5vZGU6IGFycmF5IGV4cGVjdGVkJyk7XG4gICAgICAgIG1lc3NhZ2Uubm9kZSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5ub2RlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3Qubm9kZVtpXSAhPT0gJ29iamVjdCcpIHRocm93IFR5cGVFcnJvcignLm9ubnguRnVuY3Rpb25Qcm90by5ub2RlOiBvYmplY3QgZXhwZWN0ZWQnKTtcbiAgICAgICAgICBtZXNzYWdlLm5vZGVbaV0gPSAkcm9vdC5vbm54Lk5vZGVQcm90by5mcm9tT2JqZWN0KG9iamVjdC5ub2RlW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9iamVjdC5kb2NTdHJpbmcgIT0gbnVsbCkgbWVzc2FnZS5kb2NTdHJpbmcgPSBTdHJpbmcob2JqZWN0LmRvY1N0cmluZyk7XG4gICAgICBpZiAob2JqZWN0Lm9wc2V0SW1wb3J0KSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3Qub3BzZXRJbXBvcnQpKSB0aHJvdyBUeXBlRXJyb3IoJy5vbm54LkZ1bmN0aW9uUHJvdG8ub3BzZXRJbXBvcnQ6IGFycmF5IGV4cGVjdGVkJyk7XG4gICAgICAgIG1lc3NhZ2Uub3BzZXRJbXBvcnQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3Qub3BzZXRJbXBvcnQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5vcHNldEltcG9ydFtpXSAhPT0gJ29iamVjdCcpXG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJy5vbm54LkZ1bmN0aW9uUHJvdG8ub3BzZXRJbXBvcnQ6IG9iamVjdCBleHBlY3RlZCcpO1xuICAgICAgICAgIG1lc3NhZ2Uub3BzZXRJbXBvcnRbaV0gPSAkcm9vdC5vbm54Lk9wZXJhdG9yU2V0SWRQcm90by5mcm9tT2JqZWN0KG9iamVjdC5vcHNldEltcG9ydFtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3QuZG9tYWluICE9IG51bGwpIG1lc3NhZ2UuZG9tYWluID0gU3RyaW5nKG9iamVjdC5kb21haW4pO1xuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhIEZ1bmN0aW9uUHJvdG8gbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxuICAgICAqIEBtZW1iZXJvZiBvbm54LkZ1bmN0aW9uUHJvdG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtvbm54LkZ1bmN0aW9uUHJvdG99IG1lc3NhZ2UgRnVuY3Rpb25Qcm90b1xuICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICovXG4gICAgRnVuY3Rpb25Qcm90by50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgaWYgKG9wdGlvbnMuYXJyYXlzIHx8IG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgb2JqZWN0LmlucHV0ID0gW107XG4gICAgICAgIG9iamVjdC5vdXRwdXQgPSBbXTtcbiAgICAgICAgb2JqZWN0LmF0dHJpYnV0ZSA9IFtdO1xuICAgICAgICBvYmplY3Qubm9kZSA9IFtdO1xuICAgICAgICBvYmplY3Qub3BzZXRJbXBvcnQgPSBbXTtcbiAgICAgICAgb2JqZWN0LmF0dHJpYnV0ZVByb3RvID0gW107XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICBvYmplY3QubmFtZSA9ICcnO1xuICAgICAgICBvYmplY3QuZG9jU3RyaW5nID0gJyc7XG4gICAgICAgIG9iamVjdC5kb21haW4gPSAnJztcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KCduYW1lJykpIG9iamVjdC5uYW1lID0gbWVzc2FnZS5uYW1lO1xuICAgICAgaWYgKG1lc3NhZ2UuaW5wdXQgJiYgbWVzc2FnZS5pbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgb2JqZWN0LmlucHV0ID0gW107XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5pbnB1dC5sZW5ndGg7ICsraikgb2JqZWN0LmlucHV0W2pdID0gbWVzc2FnZS5pbnB1dFtqXTtcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLm91dHB1dCAmJiBtZXNzYWdlLm91dHB1dC5sZW5ndGgpIHtcbiAgICAgICAgb2JqZWN0Lm91dHB1dCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2Uub3V0cHV0Lmxlbmd0aDsgKytqKSBvYmplY3Qub3V0cHV0W2pdID0gbWVzc2FnZS5vdXRwdXRbal07XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5hdHRyaWJ1dGUgJiYgbWVzc2FnZS5hdHRyaWJ1dGUubGVuZ3RoKSB7XG4gICAgICAgIG9iamVjdC5hdHRyaWJ1dGUgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLmF0dHJpYnV0ZS5sZW5ndGg7ICsraikgb2JqZWN0LmF0dHJpYnV0ZVtqXSA9IG1lc3NhZ2UuYXR0cmlidXRlW2pdO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2Uubm9kZSAmJiBtZXNzYWdlLm5vZGUubGVuZ3RoKSB7XG4gICAgICAgIG9iamVjdC5ub2RlID0gW107XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5ub2RlLmxlbmd0aDsgKytqKVxuICAgICAgICAgIG9iamVjdC5ub2RlW2pdID0gJHJvb3Qub25ueC5Ob2RlUHJvdG8udG9PYmplY3QobWVzc2FnZS5ub2RlW2pdLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLmRvY1N0cmluZyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoJ2RvY1N0cmluZycpKSBvYmplY3QuZG9jU3RyaW5nID0gbWVzc2FnZS5kb2NTdHJpbmc7XG4gICAgICBpZiAobWVzc2FnZS5vcHNldEltcG9ydCAmJiBtZXNzYWdlLm9wc2V0SW1wb3J0Lmxlbmd0aCkge1xuICAgICAgICBvYmplY3Qub3BzZXRJbXBvcnQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLm9wc2V0SW1wb3J0Lmxlbmd0aDsgKytqKVxuICAgICAgICAgIG9iamVjdC5vcHNldEltcG9ydFtqXSA9ICRyb290Lm9ubnguT3BlcmF0b3JTZXRJZFByb3RvLnRvT2JqZWN0KG1lc3NhZ2Uub3BzZXRJbXBvcnRbal0sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UuZG9tYWluICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eSgnZG9tYWluJykpIG9iamVjdC5kb21haW4gPSBtZXNzYWdlLmRvbWFpbjtcbiAgICAgIGlmIChtZXNzYWdlLmF0dHJpYnV0ZVByb3RvICYmIG1lc3NhZ2UuYXR0cmlidXRlUHJvdG8ubGVuZ3RoKSB7XG4gICAgICAgIG9iamVjdC5hdHRyaWJ1dGVQcm90byA9IFtdO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UuYXR0cmlidXRlUHJvdG8ubGVuZ3RoOyArK2opXG4gICAgICAgICAgb2JqZWN0LmF0dHJpYnV0ZVByb3RvW2pdID0gJHJvb3Qub25ueC5BdHRyaWJ1dGVQcm90by50b09iamVjdChtZXNzYWdlLmF0dHJpYnV0ZVByb3RvW2pdLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoaXMgRnVuY3Rpb25Qcm90byB0byBKU09OLlxuICAgICAqIEBmdW5jdGlvbiB0b0pTT05cbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5GdW5jdGlvblByb3RvXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICAgICAqL1xuICAgIEZ1bmN0aW9uUHJvdG8ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBkZWZhdWx0IHR5cGUgdXJsIGZvciBGdW5jdGlvblByb3RvXG4gICAgICogQGZ1bmN0aW9uIGdldFR5cGVVcmxcbiAgICAgKiBAbWVtYmVyb2Ygb25ueC5GdW5jdGlvblByb3RvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZVVybFByZWZpeF0geW91ciBjdXN0b20gdHlwZVVybFByZWZpeChkZWZhdWx0IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiKVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBkZWZhdWx0IHR5cGUgdXJsXG4gICAgICovXG4gICAgRnVuY3Rpb25Qcm90by5nZXRUeXBlVXJsID0gZnVuY3Rpb24gZ2V0VHlwZVVybCh0eXBlVXJsUHJlZml4KSB7XG4gICAgICBpZiAodHlwZVVybFByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHR5cGVVcmxQcmVmaXggPSAndHlwZS5nb29nbGVhcGlzLmNvbSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZVVybFByZWZpeCArICcvb25ueC5GdW5jdGlvblByb3RvJztcbiAgICB9O1xuXG4gICAgcmV0dXJuIEZ1bmN0aW9uUHJvdG87XG4gIH0pKCk7XG5cbiAgcmV0dXJuIG9ubng7XG59KSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICRyb290O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBmbGF0YnVmZmVycyB9IGZyb20gJ2ZsYXRidWZmZXJzJztcbmltcG9ydCBMb25nIGZyb20gJ2xvbmcnO1xuXG5pbXBvcnQgeyBHcmFwaCB9IGZyb20gJy4vZ3JhcGgnO1xuaW1wb3J0IHsgb25ueHJ1bnRpbWUgfSBmcm9tICcuL29ydC1zY2hlbWEvZmxhdGJ1ZmZlcnMvb3J0LWdlbmVyYXRlZCc7XG5pbXBvcnQgeyBvbm54IH0gZnJvbSAnLi9vcnQtc2NoZW1hL3Byb3RvYnVmL29ubngnO1xuaW1wb3J0IHsgVGVuc29yIH0gZnJvbSAnLi90ZW5zb3InO1xuXG4vLyBjaGVjayB0aGUgaW5wdXRzIHNoYXBlIGJlZm9yZSBydW5uaW5nIGFuIE9QLlxuLy8gcmV0dXJuIHRydWUgd2hlbiB0aGUgaW5wdXRzIHBhc3MgdGhlIGNoZWNrXG4vLyByZXR1cm4gZmFsc2Ugd2hlbiB0aGUgaW5wdXRzIGRvIG5vdCBmaXQgdGhlIHJlcXVpcmVtZW50XG4vLyB0aHJvdyBleGNlcHRpb24gd2hlbiBmYXRhbCBlcnJvciBvciBub3QgaW1wbGVtZW50ZWRcbmV4cG9ydCBmdW5jdGlvbiBjaGVja0lucHV0c1NoYXBlKGlucHV0czogVGVuc29yW10sIC4uLmV4cGVjdGVkRGltZW5zaW9uczogbnVtYmVyW10pOiBib29sZWFuIHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gZXhwZWN0ZWREaW1lbnNpb25zLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0cy5sZW5ndGg7IGkrKykge1xuICAgIGlmICghaW5wdXRzW2ldLmRpbXMgfHwgaW5wdXRzW2ldLmRpbXMubGVuZ3RoICE9PSBleHBlY3RlZERpbWVuc2lvbnNbaV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIEV2YWx1YXRlcyB0aGUgZ2l2ZW4gZXhwcmVzc2lvbiBhbmQgYXNzZXJ0cyBlcnJvciBtZXNzYWdlIGlmIGNvbmRpdGlvbiBpcyB1bm1ldC5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnQoZXhwcjogYm9vbGVhbiwgbXNnOiAoKSA9PiBzdHJpbmcpIHtcbiAgaWYgKCFleHByKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHR5cGVvZiBtc2cgPT09ICdzdHJpbmcnID8gbXNnIDogbXNnKCkpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBBcnJheVV0aWwge1xuICAvKipcbiAgICogVmVyaWZpZXMgaWYgMiBpbnB1dCBhcnJheXMgY29udGFpbiB0aGUgc2FtZSBlbGVtZW50cy5cbiAgICogQHBhcmFtIG4xIEFycmF5IDFcbiAgICogQHBhcmFtIG4yIEFycmF5IDJcbiAgICogQHJldHVybnMgV2hldGhlciB0aGVzZSAyIGFyZSBlcXVhbFxuICAgKi9cbiAgc3RhdGljIGFycmF5c0VxdWFsKFxuICAgIG4xOlxuICAgICAgfCByZWFkb25seSBudW1iZXJbXVxuICAgICAgfCBJbnQ4QXJyYXlcbiAgICAgIHwgVWludDhBcnJheVxuICAgICAgfCBJbnQxNkFycmF5XG4gICAgICB8IFVpbnQxNkFycmF5XG4gICAgICB8IEludDMyQXJyYXlcbiAgICAgIHwgVWludDMyQXJyYXlcbiAgICAgIHwgVWludDhDbGFtcGVkQXJyYXlcbiAgICAgIHwgRmxvYXQzMkFycmF5XG4gICAgICB8IEZsb2F0NjRBcnJheSxcbiAgICBuMjpcbiAgICAgIHwgcmVhZG9ubHkgbnVtYmVyW11cbiAgICAgIHwgSW50OEFycmF5XG4gICAgICB8IFVpbnQ4QXJyYXlcbiAgICAgIHwgSW50MTZBcnJheVxuICAgICAgfCBVaW50MTZBcnJheVxuICAgICAgfCBJbnQzMkFycmF5XG4gICAgICB8IFVpbnQzMkFycmF5XG4gICAgICB8IFVpbnQ4Q2xhbXBlZEFycmF5XG4gICAgICB8IEZsb2F0MzJBcnJheVxuICAgICAgfCBGbG9hdDY0QXJyYXksXG4gICkge1xuICAgIGlmIChuMS5sZW5ndGggIT09IG4yLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG4xLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobjFbaV0gIT09IG4yW2ldKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIE1hdE11bFV0aWwge1xuICAvKipcbiAgICogRml4IHRoZSBpbnB1dCBzaGFwZXMgZm9yIE1hdE11bCBvcGVyYXRpb24gaWYgdGhleSBuZWVkIGZpeGluZ1xuICAgKiBAcGFyYW0gZGltc0EgVGhlIHNoYXBlIG9mIHRlbnNvciBBLiBTaG91bGQgYmUgYW4gYXJyYXkgb2YgcG9zaXRpdmUgaW50ZWdlcnNcbiAgICogQHBhcmFtIGRpbXNCIFRoZSBzaGFwZSBvZiB0ZW5zb3IgQi4gU2hvdWxkIGJlIGFuIGFycmF5IG9mIHBvc2l0aXZlIGludGVnZXJzXG4gICAqIEByZXR1cm5zIEEgdHVwbGUgY29udGFpbmluZyB0aGUgcHJlcHJvY2Vzc2VkIGlucHV0IHNoYXBlcyBhcyByZXF1aXJlZCBieSBPTk5YIHNwZWNpZmljYXRpb25zXG4gICAqL1xuICBzdGF0aWMgcHJlcHJvY2Vzc0lucHV0U2hhcGVzKFxuICAgIGRpbXNBOiByZWFkb25seSBudW1iZXJbXSxcbiAgICBkaW1zQjogcmVhZG9ubHkgbnVtYmVyW10sXG4gICk6IFtyZWFkb25seSBudW1iZXJbXSwgcmVhZG9ubHkgbnVtYmVyW11dIHtcbiAgICAvLyBJZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgMS1ELCBpdCBpcyBwcm9tb3RlZCB0byBhIG1hdHJpeCBieSBwcmVwZW5kaW5nXG4gICAgLy8gYSAxIHRvIGl0cyBkaW1lbnNpb25zLiBBZnRlciBtYXRyaXggbXVsdGlwbGljYXRpb24gdGhlIHByZXBlbmRlZCAxIGlzXG4gICAgLy8gcmVtb3ZlZC5cbiAgICBjb25zdCBhID0gZGltc0EubGVuZ3RoID09PSAxID8gWzEsIGRpbXNBWzBdXSA6IGRpbXNBO1xuXG4gICAgLy8gSWYgdGhlIHNlY29uZCBhcmd1bWVudCBpcyAxLUQsIGl0IGlzIHByb21vdGVkIHRvIGEgbWF0cml4IGJ5IGFwcGVuZGluZ1xuICAgIC8vIGEgMSB0byBpdHMgZGltZW5zaW9ucy4gQWZ0ZXIgbWF0cml4IG11bHRpcGxpY2F0aW9uIHRoZSBhcHBlbmRlZCAxIGlzXG4gICAgLy8gcmVtb3ZlZC5cbiAgICBjb25zdCBiID0gZGltc0IubGVuZ3RoID09PSAxID8gW2RpbXNCWzBdLCAxXSA6IGRpbXNCO1xuXG4gICAgcmV0dXJuIFthLCBiXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaXggdGhlIG91dHB1dCBzaGFwZSBjb21wdXRlZCBmb3IgTWF0TXVsIG9wZXJhdGlvbiBpZiBpdCBuZWVkcyBmaXhpbmdcbiAgICogQHBhcmFtIG91dHB1dFNoYXBlIFRoZSBjb21wdXRlZCBvdXRwdXRTaGFwZS4gU2hvdWxkIGJlIGFuIGFycmF5IChhdGxlYXN0IG9mIGxlbmd0aCAyKSBvZiBwb3NpdGl2ZSBpbnRlZ2Vycy5cbiAgICogVGhpcyB3aWxsIGJlIG11dGF0ZWQuXG4gICAqIEBwYXJhbSBhUmFuayBUaGUgcmFuayBvZiB0ZW5zb3IgQS5cbiAgICogQHBhcmFtIGJSYW5rIFRoZSByYW5rIG9mIHRlbnNvciBCLlxuICAgKi9cbiAgc3RhdGljIHBvc3Rwcm9jZXNzT3V0cHV0U2hhcGUob3V0cHV0U2hhcGU6IG51bWJlcltdLCBhUmFuazogbnVtYmVyLCBiUmFuazogbnVtYmVyKSB7XG4gICAgLy8gUmVtb3ZlIHByZXBlbmRlZCBkaW1lbnNpb24gaWYgZmlyc3QgaW5wdXQgaXMgMWRcbiAgICBpZiAoYVJhbmsgPT09IDEpIHtcbiAgICAgIC8vIG91dHB1dFNoYXBlID0gb3V0cHV0U2hhcGUuc2xpY2UoMCwgb3V0cHV0U2hhcGUubGVuZ3RoIC0gMikuY29uY2F0KG91dHB1dFNoYXBlLnNsaWNlKG91dHB1dFNoYXBlLmxlbmd0aCAtIDEpKTtcbiAgICAgIG91dHB1dFNoYXBlLnNwbGljZShvdXRwdXRTaGFwZS5sZW5ndGggLSAyLCAxKTtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIGFwcGVuZGVkIGRpbWVuc2lvbiBpZiBzZWNvbmQgaW5wdXQgaXMgMWRcbiAgICBpZiAoYlJhbmsgPT09IDEpIHtcbiAgICAgIG91dHB1dFNoYXBlLnBvcCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGV4cGVjdGVkIHNoYXBlIHdoZW4gbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAqIEBwYXJhbSBhIFRoZSBzaGFwZSBvZiB0ZW5zb3IgQS4gU2hvdWxkIGJlIGEgdHVwbGUgb2YgMiBwb3NpdGl2ZSBpbnRlZ2Vyc1xuICAgKiBAcGFyYW0gYiBUaGUgc2hhcGUgb2YgdGVuc29yIEIuIFNob3VsZCBiZSBhIHR1cGxlIG9mIDIgcG9zaXRpdmUgaW50ZWdlcnNcbiAgICogQHJldHVybnMgVGhlIGV4cGVjdGVkIHNoYXBlIG9mIHRoZSByZXN1bHQsIG9yIHVuZGVmaW5lZCBpZiBOL0FcbiAgICovXG4gIHN0YXRpYyBjYWxjTWF0TXVsU2hhcGUoYTogW251bWJlciwgbnVtYmVyXSwgYjogW251bWJlciwgbnVtYmVyXSk6IFtudW1iZXIsIG51bWJlcl0gfCB1bmRlZmluZWQge1xuICAgIHJldHVybiBhWzFdICE9PSBiWzBdID8gdW5kZWZpbmVkIDogW2FbMF0sIGJbMV1dO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBCcm9hZGNhc3RVdGlsIHtcbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgZXhwZWN0ZWQgc2hhcGUgd2hlbiBicm9hZGNhc3RpbmcgMiB0ZW5zb3JzXG4gICAqIEBwYXJhbSBhIFRoZSBzaGFwZSBvZiB0ZW5zb3IgQS4gU2hvdWxkIGJlIGFuIGFycmF5IG9mIHBvc2l0aXZlIGludGVnZXJzXG4gICAqIEBwYXJhbSBiIFRoZSBzaGFwZSBvZiB0ZW5zb3IgQi4gU2hvdWxkIGJlIGFuIGFycmF5IG9mIHBvc2l0aXZlIGludGVnZXJzXG4gICAqIEBwYXJhbSBpc01hdE11bCBXaGV0aGVyIHRoZSBvcGVyYXRpb24gaXMgTWF0TXVsXG4gICAqIEByZXR1cm5zIFRoZSBleHBlY3RlZCBzaGFwZSBvZiB0aGUgcmVzdWx0LCBvciB1bmRlZmluZWQgaWYgTi9BXG4gICAqL1xuICBzdGF0aWMgY2FsY1NoYXBlKFxuICAgIGFkaW1zOiByZWFkb25seSBudW1iZXJbXSxcbiAgICBiZGltczogcmVhZG9ubHkgbnVtYmVyW10sXG4gICAgaXNNYXRNdWwgPSBmYWxzZSxcbiAgKTogcmVhZG9ubHkgbnVtYmVyW10gfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IGFyYW5rID0gYWRpbXMubGVuZ3RoO1xuICAgIGNvbnN0IGJyYW5rID0gYmRpbXMubGVuZ3RoO1xuICAgIGlmIChhcmFuayA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJkaW1zO1xuICAgIH1cbiAgICBpZiAoYnJhbmsgPT09IDApIHtcbiAgICAgIHJldHVybiBhZGltcztcbiAgICB9XG4gICAgY29uc3QgY3JhbmsgPSBNYXRoLm1heChhZGltcy5sZW5ndGgsIGJkaW1zLmxlbmd0aCk7XG4gICAgY29uc3QgY2RpbXMgPSBuZXcgQXJyYXk8bnVtYmVyPihjcmFuayk7XG5cbiAgICAvLyBjYWxjdWxhdGUgdGhlIGxhc3QgMiBkaW1lbnNpb24gaWYgaXQgaXMgTWF0TXVsXG4gICAgaWYgKGlzTWF0TXVsKSB7XG4gICAgICBpZiAoYXJhbmsgPCAyIHx8IGJyYW5rIDwgMikge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgY29uc3QgY1NoYXBlTWF0TXVsID0gTWF0TXVsVXRpbC5jYWxjTWF0TXVsU2hhcGUoXG4gICAgICAgIFthZGltc1thcmFuayAtIDJdLCBhZGltc1thcmFuayAtIDFdXSxcbiAgICAgICAgW2JkaW1zW2JyYW5rIC0gMl0sIGJkaW1zW2JyYW5rIC0gMV1dLFxuICAgICAgKTtcbiAgICAgIGlmIChjU2hhcGVNYXRNdWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgW2NkaW1zW2NyYW5rIC0gMl0sIGNkaW1zW2NyYW5rIC0gMV1dID0gY1NoYXBlTWF0TXVsO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSBpc01hdE11bCA/IDMgOiAxOyBpIDw9IGNyYW5rOyBpKyspIHtcbiAgICAgIGNvbnN0IGFMZW4gPSBhcmFuayAtIGkgPCAwID8gMSA6IGFkaW1zW2FyYW5rIC0gaV07XG4gICAgICBjb25zdCBiTGVuID0gYnJhbmsgLSBpIDwgMCA/IDEgOiBiZGltc1ticmFuayAtIGldO1xuXG4gICAgICBpZiAoYUxlbiAhPT0gYkxlbiAmJiBhTGVuID4gMSAmJiBiTGVuID4gMSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgY2RpbXNbY3JhbmsgLSBpXSA9IE1hdGgubWF4KGFMZW4sIGJMZW4pO1xuICAgIH1cblxuICAgIHJldHVybiBjZGltcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHaXZlbiB0aGUgaW5kaWNlcyBvZiBhIGJyb2FkY2FzdGVkIHRlbnNvciwgY2FsY3VsYXRlIHRoZSBvcmlnaW5hbCBpbmRpY2VzXG4gICAqIEBwYXJhbSBicm9hZGNhc3RlZEluZGljZXMgVGhlIGdpdmVuIGluZGljZXMgb2YgdGhlIGJyb2FkY2FzdGVkIHRlbnNvci5cbiAgICogQHBhcmFtIG9yaWdpbmFsU2hhcGUgVGhlIG9yaWdpbmFsIHNoYXBlIG9mIHRoZSB0ZW5zb3IgYmVmb3JlIGJyb2FkY2FzXG4gICAqIEByZXR1cm5zIFRoZSBjYWxjdWxhdGVkIGluZGljZXMgdGhhdCBtYXBzIHRvIHRoZSBvcmlnaW5hbCB0ZW5zb3IuXG4gICAqL1xuICBzdGF0aWMgaW5kZXgoYnJvYWRjYXN0ZWRJbmRpY2VzOiByZWFkb25seSBudW1iZXJbXSwgb3JpZ2luYWxTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10pOiBudW1iZXJbXSB7XG4gICAgLy8gTk9URSAxOiB3ZSBhc3N1bWUgdGhlIHBhcmFtZXRlciBicm9hZGNhc3RlZEluZGljZXMgaXMgdmFsaWQuIGllLiBpdCBzaG91bGQgaGF2ZSB0aGUgc2FtZVxuICAgIC8vIGxlbmd0aCBhcyB0aGUgYnJvYWRjYXN0ZWQgc2hhcGUsIGFuZCBmb3IgZWFjaCBkaW1lbnNpb24gdGhlIGluZGV4IHNob3VsZFxuICAgIC8vIG5vdCBiZSBvdXQgb2YgcmFuZ2UuXG4gICAgY29uc3Qgb3JpZ2luYWxJbmRpY2VzID0gbmV3IEFycmF5KG9yaWdpbmFsU2hhcGUubGVuZ3RoKTtcbiAgICBCcm9hZGNhc3RVdGlsLmZpbGxJbmRleChicm9hZGNhc3RlZEluZGljZXMsIG9yaWdpbmFsU2hhcGUsIG9yaWdpbmFsSW5kaWNlcyk7XG4gICAgcmV0dXJuIG9yaWdpbmFsSW5kaWNlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHaXZlbiB0aGUgaW5kaWNlcyBvZiBhIGJyb2FkY2FzdGVkIHRlbnNvciwgY2FsY3VsYXRlIHRoZSBvcmlnaW5hbCBpbmRpY2VzXG4gICAqIEBwYXJhbSBicm9hZGNhc3RlZEluZGljZXMgVGhlIGdpdmVuIGluZGljZXMgb2YgdGhlIGJyb2FkY2FzdGVkIHRlbnNvci5cbiAgICogQHBhcmFtIG9yaWdpbmFsU2hhcGUgVGhlIG9yaWdpbmFsIHNoYXBlIG9mIHRoZSB0ZW5zb3IgYmVmb3JlIGJyb2FkY2FzdFxuICAgKiBAcGFyYW0gb3JpZ2luYWxJbmRpY2VzIFRoZSBtYXBwaW5nIG9mIGJyb2FkY2FzdGVkSW5kaWNlcyB0byB0aGUgb3JpZ2luYWxJbmRpY2VzIChvdXRwdXQgcGFyYW1ldGVyIC0gd2lsbCBiZVxuICAgKiAgICAgbXV0YXRlZCkuXG4gICAqL1xuICBzdGF0aWMgZmlsbEluZGV4KGJyb2FkY2FzdGVkSW5kaWNlczogcmVhZG9ubHkgbnVtYmVyW10sIG9yaWdpbmFsU2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBvcmlnaW5hbEluZGljZXM6IG51bWJlcltdKSB7XG4gICAgLy8gTk9URSAxOiB3ZSBhc3N1bWUgdGhlIHBhcmFtZXRlciBicm9hZGNhc3RlZEluZGljZXMgaXMgdmFsaWQuIGllLiBpdCBzaG91bGQgaGF2ZSB0aGUgc2FtZSBsZW5ndGggYXMgdGhlXG4gICAgLy8gYnJvYWRjYXN0ZWQgc2hhcGUsIGFuZCBmb3IgZWFjaCBkaW1lbnNpb24gdGhlIGluZGV4IHNob3VsZCBub3QgYmUgb3V0IG9mIHJhbmdlLlxuICAgIC8vIE5PVEUgMjogd2UgYXNzdW1lIHRoZSBwYXJhbWV0ZXIgb3JpZ2luYWxJbmRpY2VzIGhhcyB0aGUgc2FtZSBsZW5ndGggYXMgdGhlIG9yaWdpbmFsU2hhcGVcbiAgICBjb25zdCBkaW1PZmZzZXQgPSBicm9hZGNhc3RlZEluZGljZXMubGVuZ3RoIC0gb3JpZ2luYWxTaGFwZS5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcmlnaW5hbFNoYXBlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvcmlnaW5hbEluZGljZXNbaV0gPSBicm9hZGNhc3RlZEluZGljZXNbZGltT2Zmc2V0ICsgaV0gJSBvcmlnaW5hbFNoYXBlW2ldO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIHRoZSBicm9hZGNhc3Rpbmcgb3BlcmF0aW9uIG9uIHRoZSBzcGVjaWZpYyBvcGVyYXRvclxuICAgKiBAcGFyYW0gYSBUaGUgaW5wdXQgdGVuc29yIEFcbiAgICogQHBhcmFtIGIgVGhlIGlucHV0IHRlbnNvciBCXG4gICAqIEBwYXJhbSBvcCBUaGUgb3BlcmF0b3IgbGFtYmRhIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSBpbnBsYWNlIFdoZXRoZXIgdG8gd3JpdGUgdGhlIHJlc3VsdCBiYWNrIHRvIEEuXG4gICAqIEByZXR1cm5zIFRoZSByZXN1bHQgdGVuc29yLCBvciB1bmRlZmluZWQgaWYgaW5wdXQgbm90IGJyb2FkY2FzdGFibGUuXG4gICAqL1xuICBzdGF0aWMgY2FsYyhcbiAgICBhOiBUZW5zb3IsXG4gICAgYjogVGVuc29yLFxuICAgIG9wOiAoYTogc3RyaW5nIHwgbnVtYmVyLCBiOiBzdHJpbmcgfCBudW1iZXIpID0+IHN0cmluZyB8IG51bWJlcixcbiAgICBpbnBsYWNlOiBib29sZWFuLFxuICAgIHJlc3VsdFR5cGU/OiBUZW5zb3IuRGF0YVR5cGUsXG4gICk6IFRlbnNvciB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBCcm9hZGNhc3RVdGlsLmNhbGNTaGFwZShhLmRpbXMsIGIuZGltcyk7XG5cbiAgICBpZiAob3V0cHV0U2hhcGUpIHtcbiAgICAgIGlmIChpbnBsYWNlICYmICFTaGFwZVV0aWwuYXJlRXF1YWwob3V0cHV0U2hhcGUsIGEuZGltcykpIHtcbiAgICAgICAgLy8gQiBpcyBub3QgYnJvYWRjYXN0YWJsZSB0byBBLCBmYWlsZWQgdG8gY2FsY3VsYXRlIGlucGxhY2UuXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG4gICAgICBjb25zdCBjID0gaW5wbGFjZSA/IGEgOiBuZXcgVGVuc29yKG91dHB1dFNoYXBlLCByZXN1bHRUeXBlIHx8IGEudHlwZSk7XG5cbiAgICAgIC8vIGJvdGggaW5wdXRzIGFyZSBzY2FsYXJzXG4gICAgICBpZiAob3V0cHV0U2hhcGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGMuc2V0KFtdLCBvcChhLmdldChbXSkgYXMgbnVtYmVyLCBiLmdldChbXSkgYXMgbnVtYmVyKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGF0bGVhc3Qgb25lIGlucHV0IGlzIGEgbm9uLXNjYWxhclxuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG91dHB1dEluZGljZXMgPSBuZXcgQXJyYXk8bnVtYmVyPihvdXRwdXRTaGFwZS5sZW5ndGgpO1xuICAgICAgICBjb25zdCBvcmlnaW5hbEluZGljZXNBID0gbmV3IEFycmF5KGEuZGltcy5sZW5ndGgpO1xuICAgICAgICBjb25zdCBvcmlnaW5hbEluZGljZXNCID0gbmV3IEFycmF5KGIuZGltcy5sZW5ndGgpO1xuICAgICAgICBsZXQgdmFsQTogc3RyaW5nIHwgbnVtYmVyID0gMDtcbiAgICAgICAgbGV0IHZhbEI6IHN0cmluZyB8IG51bWJlciA9IDA7XG4gICAgICAgIGxldCBpc0FTY2FsYXIgPSBmYWxzZTtcbiAgICAgICAgbGV0IGlzQlNjYWxhciA9IGZhbHNlO1xuICAgICAgICBpZiAoYS5kaW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHZhbEEgPSBhLmdldChbXSkgYXMgbnVtYmVyO1xuICAgICAgICAgIGlzQVNjYWxhciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGIuZGltcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB2YWxCID0gYi5nZXQoW10pIGFzIG51bWJlcjtcbiAgICAgICAgICBpc0JTY2FsYXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN0OiBudW1iZXI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgLy8gdHJhdmVyc2FsIGluZGljZXNcbiAgICAgICAgICByZXN0ID0gaTtcbiAgICAgICAgICBmb3IgKGxldCBqID0gb3V0cHV0U2hhcGUubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgIG91dHB1dEluZGljZXNbal0gPSByZXN0ICUgb3V0cHV0U2hhcGVbal07XG4gICAgICAgICAgICByZXN0ID0gTWF0aC5mbG9vcihyZXN0IC8gb3V0cHV0U2hhcGVbal0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghaXNBU2NhbGFyKSB7XG4gICAgICAgICAgICAvLyBtYXAgb3V0cHV0SW5kaWNlcyAod2hpY2ggaXMgYWN0dWFsbHkgYnJvYWRjYXN0ZWQpIHRvIHRoZSBvcmlnaW5hbEluZGljZXNcbiAgICAgICAgICAgIEJyb2FkY2FzdFV0aWwuZmlsbEluZGV4KG91dHB1dEluZGljZXMsIGEuZGltcywgb3JpZ2luYWxJbmRpY2VzQSk7XG4gICAgICAgICAgICB2YWxBID0gYS5nZXQob3JpZ2luYWxJbmRpY2VzQSkgYXMgbnVtYmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWlzQlNjYWxhcikge1xuICAgICAgICAgICAgQnJvYWRjYXN0VXRpbC5maWxsSW5kZXgob3V0cHV0SW5kaWNlcywgYi5kaW1zLCBvcmlnaW5hbEluZGljZXNCKTtcbiAgICAgICAgICAgIHZhbEIgPSBiLmdldChvcmlnaW5hbEluZGljZXNCKSBhcyBudW1iZXI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYy5zZXQob3V0cHV0SW5kaWNlcywgb3AodmFsQSwgdmFsQikpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjO1xuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lIGlmIGEgc2hhcGUgaXMgdW5pZGlyZWN0aW9uYWwgYnJvYWRjYXN0YWJsZSB0byBhbm90aGVyIHNoYXBlXG4gICAqIEBwYXJhbSBzaGFwZSBUaGUgaW5wdXQgc2hhcGVcbiAgICogQHBhcmFtIGZpbmFsU2hhcGUgVGhlIGRlc2lyZWQgc2hhcGUgYWZ0ZXIgYnJvYWRjYXN0aW5nXG4gICAqL1xuICBzdGF0aWMgaXNWYWxpZEJyb2FkY2FzdChzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIGZpbmFsU2hhcGU6IHJlYWRvbmx5IG51bWJlcltdKTogYm9vbGVhbiB7XG4gICAgLy8gYWxpZ24gc2hhcGUgdG8gdGhlIHJpZ2h0XG4gICAgY29uc3QgaW5wdXRSYW5rID0gc2hhcGUubGVuZ3RoO1xuICAgIGNvbnN0IGZpbmFsUmFuayA9IGZpbmFsU2hhcGUubGVuZ3RoO1xuICAgIGlmIChpbnB1dFJhbmsgPiBmaW5hbFJhbmspIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gaW5wdXRSYW5rOyBpKyspIHtcbiAgICAgIGlmIChzaGFwZVtpbnB1dFJhbmsgLSBpXSAhPT0gMSAmJiBzaGFwZVtpbnB1dFJhbmsgLSBpXSAhPT0gZmluYWxTaGFwZVtmaW5hbFJhbmsgLSBpXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZSB0aGUgYnJvYWRjYXN0ZWQgZGltcyBpbiBpbnB1dCBzaGFwZSBiYXNlZCBvbiB0aGUgZ2l2ZW4gb3V0cHV0IHNoYXBlLlxuICAgKiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiBvbmx5IHJldHVybnMgdGhlIGJyb2FkY2FzdGVkIGRpbXMuXG4gICAqIEBwYXJhbSBpbnB1dFNoYXBlIFRoZSBpbnB1dCBzaGFwZVxuICAgKiBAcGFyYW0gb3V0cHV0U2hhcGUgVGhlIG91dHB1dCBzaGFwZVxuICAgKiBAcmV0dXJucyBUaGUgYnJvYWRjYXN0ZWQgZGltcyBpbiBpbnB1dCBzaGFwZS5cbiAgICovXG4gIHN0YXRpYyBnZXRCcm9hZGNhc3REaW1zKGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBvdXRwdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10pOiBudW1iZXJbXSB7XG4gICAgY29uc3QgaW5SYW5rID0gaW5wdXRTaGFwZS5sZW5ndGg7XG4gICAgY29uc3QgZGltczogbnVtYmVyW10gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluUmFuazsgaSsrKSB7XG4gICAgICBjb25zdCBkaW0gPSBpblJhbmsgLSAxIC0gaTtcbiAgICAgIGNvbnN0IGEgPSBpbnB1dFNoYXBlW2RpbV0gfHwgMTtcbiAgICAgIGNvbnN0IGIgPSBvdXRwdXRTaGFwZVtvdXRwdXRTaGFwZS5sZW5ndGggLSAxIC0gaV0gfHwgMTtcbiAgICAgIGlmIChiID4gMSAmJiBhID09PSAxKSB7XG4gICAgICAgIGRpbXMudW5zaGlmdChkaW0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGltcztcbiAgfVxufVxuXG4vLyBjb3B5IGFycmF5IGhlbHBlclxuLy8gbWltaWNzIG1lbWNweSBhcyBtdWNoIGFzIHBvc3NpYmxlXG5leHBvcnQgZnVuY3Rpb24gYXJyYXlDb3B5SGVscGVyKFxuICB0YXJnZXQ6IG51bWJlcltdIHwgVGVuc29yLk51bWJlclR5cGUsXG4gIHNvdXJjZTogbnVtYmVyW10gfCBUZW5zb3IuTnVtYmVyVHlwZSxcbiAgdGFyZ2V0SW5kZXg6IG51bWJlcixcbiAgc291cmNlSW5kZXg6IG51bWJlcixcbiAgYmxvY2tTaXplOiBudW1iZXIsXG4pIHtcbiAgaWYgKHNvdXJjZUluZGV4IDwgMCB8fCBzb3VyY2VJbmRleCA+PSBzb3VyY2UubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2VJbmRleCBvdXQgb2YgYm91bmRzJyk7XG4gIH1cbiAgaWYgKHRhcmdldEluZGV4IDwgMCB8fCB0YXJnZXRJbmRleCA+PSB0YXJnZXQubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd0YXJnZXRJbmRleCBvdXQgb2YgYm91bmRzJyk7XG4gIH1cbiAgaWYgKHNvdXJjZUluZGV4ICsgYmxvY2tTaXplID4gc291cmNlLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc291cmNlIGluZGljZXMgdG8gYmUgY29waWVkIGFyZSBvdXRzaWRlIGJvdW5kcycpO1xuICB9XG4gIGlmICh0YXJnZXRJbmRleCArIGJsb2NrU2l6ZSA+IHRhcmdldC5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3RhcmdldCBhcnJheSBpcyB0b28gc21hbGwgdG8gaG9sZCByZXN1bHQnKTtcbiAgfVxuXG4gIGZvciAobGV0IG9mZnNldCA9IDA7IG9mZnNldCA8IGJsb2NrU2l6ZTsgb2Zmc2V0KyspIHtcbiAgICB0YXJnZXRbdGFyZ2V0SW5kZXggKyBvZmZzZXRdID0gc291cmNlW3NvdXJjZUluZGV4ICsgb2Zmc2V0XTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgR2VtbVV0aWwge1xuICAvLyB3aWxsIG1ha2Ugc3VyZSBpbnB1dCBzaGFwZXMgYXJlIGNvbXBhdGlibGUgZm9yIHRoaXMgb3BcbiAgLy8gYW5kIHJldHVybiBiYWNrIHRoZSBzaGFwZSBvZiB0aGUgb3V0cHV0IGluIHRoZSBmb3JtIG9mIGEgdHVwbGVcbiAgLy8gd2lsbCB0aHJvdyBleGNlcHRpb24gaWYgdGhlIGlucHV0IHNoYXBlcyBhcmUgbm90IGNvbXBhdGlibGVcbiAgc3RhdGljIGdldFNoYXBlT2ZHZW1tUmVzdWx0KFxuICAgIGxlZnRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gICAgdHJhbnNMZWZ0OiBib29sZWFuLFxuICAgIHJpZ2h0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIHRyYW5zUmlnaHQ6IGJvb2xlYW4sXG4gICAgYmlhc1NoYXBlPzogcmVhZG9ubHkgbnVtYmVyW10sXG4gICk6IHJlYWRvbmx5IG51bWJlcltdIHtcbiAgICBpZiAobGVmdFNoYXBlLmxlbmd0aCAhPT0gMiB8fCByaWdodFNoYXBlLmxlbmd0aCAhPT0gMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaGFwZSBuZWVkIHRvIGJlIG9mIHNpemUgMicpO1xuICAgIH1cblxuICAgIGxldCBNOiBudW1iZXI7XG4gICAgbGV0IEs6IG51bWJlcjtcbiAgICBsZXQgTjogbnVtYmVyO1xuXG4gICAgaWYgKHRyYW5zTGVmdCkge1xuICAgICAgTSA9IGxlZnRTaGFwZVsxXTtcbiAgICAgIEsgPSBsZWZ0U2hhcGVbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIE0gPSBsZWZ0U2hhcGVbMF07XG4gICAgICBLID0gbGVmdFNoYXBlWzFdO1xuICAgIH1cblxuICAgIGxldCBrRGltID0gLTE7XG5cbiAgICBpZiAodHJhbnNSaWdodCkge1xuICAgICAgTiA9IHJpZ2h0U2hhcGVbMF07XG4gICAgICBrRGltID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgTiA9IHJpZ2h0U2hhcGVbMV07XG4gICAgICBrRGltID0gMDtcbiAgICB9XG5cbiAgICBpZiAocmlnaHRTaGFwZVtrRGltXSAhPT0gSykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaW1lbnNpb24gbWlzbWF0Y2gnKTtcbiAgICB9XG5cbiAgICBpZiAoTSA8PSAwIHx8IE4gPD0gMCB8fCBLIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzaGFwZSBzcGVjaWZpZWQnKTtcbiAgICB9XG5cbiAgICBpZiAoYmlhc1NoYXBlICYmICFCcm9hZGNhc3RVdGlsLmlzVmFsaWRCcm9hZGNhc3QoYmlhc1NoYXBlLCBbTSwgTl0pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dlbW06IGludmFsaWQgYmlhcyBzaGFwZSBmb3IgYnJvYWRjYXN0Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtNLCBOLCBLXTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgUHJvdG9VdGlsIHtcbiAgc3RhdGljIHRlbnNvckRhdGFUeXBlRnJvbVByb3RvKFxuICAgIHR5cGVQcm90bzogb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZSB8IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGUsXG4gICk6IFRlbnNvci5EYXRhVHlwZSB7XG4gICAgc3dpdGNoICh0eXBlUHJvdG8pIHtcbiAgICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQ4OlxuICAgICAgICByZXR1cm4gJ2ludDgnO1xuICAgICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ4OlxuICAgICAgICByZXR1cm4gJ3VpbnQ4JztcbiAgICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5CT09MOlxuICAgICAgICByZXR1cm4gJ2Jvb2wnO1xuICAgICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDE2OlxuICAgICAgICByZXR1cm4gJ2ludDE2JztcbiAgICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMTY6XG4gICAgICAgIHJldHVybiAndWludDE2JztcbiAgICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQzMjpcbiAgICAgICAgcmV0dXJuICdpbnQzMic7XG4gICAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDMyOlxuICAgICAgICByZXR1cm4gJ3VpbnQzMic7XG4gICAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuRkxPQVQ6XG4gICAgICAgIHJldHVybiAnZmxvYXQzMic7XG4gICAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuRE9VQkxFOlxuICAgICAgICByZXR1cm4gJ2Zsb2F0NjQnO1xuICAgICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlNUUklORzpcbiAgICAgICAgcmV0dXJuICdzdHJpbmcnO1xuXG4gICAgICAvLyBGb3IgSU5UNjQvVUlOVDY0LCByZWR1Y2UgdGhlaXIgdmFsdWUgdG8gMzItYml0cy5cbiAgICAgIC8vIFNob3VsZCB0aHJvdyBleGNlcHRpb24gd2hlbiBvdmVyZmxvd1xuICAgICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDY0OlxuICAgICAgICByZXR1cm4gJ2ludDMyJztcbiAgICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UNjQ6XG4gICAgICAgIHJldHVybiAndWludDMyJztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7b25ueC5UZW5zb3JQcm90by5EYXRhVHlwZVt0eXBlUHJvdG9dfWApO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyB0ZW5zb3JEYXRhVHlwZVN0cmluZ1RvRW51bSh0eXBlOiBzdHJpbmcpOiBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2ludDgnOlxuICAgICAgICByZXR1cm4gb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQ4O1xuICAgICAgY2FzZSAndWludDgnOlxuICAgICAgICByZXR1cm4gb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UODtcbiAgICAgIGNhc2UgJ2Jvb2wnOlxuICAgICAgICByZXR1cm4gb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5CT09MO1xuICAgICAgY2FzZSAnaW50MTYnOlxuICAgICAgICByZXR1cm4gb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQxNjtcbiAgICAgIGNhc2UgJ3VpbnQxNic6XG4gICAgICAgIHJldHVybiBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQxNjtcbiAgICAgIGNhc2UgJ2ludDMyJzpcbiAgICAgICAgcmV0dXJuIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UMzI7XG4gICAgICBjYXNlICd1aW50MzInOlxuICAgICAgICByZXR1cm4gb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMzI7XG4gICAgICBjYXNlICdmbG9hdDMyJzpcbiAgICAgICAgcmV0dXJuIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuRkxPQVQ7XG4gICAgICBjYXNlICdmbG9hdDY0JzpcbiAgICAgICAgcmV0dXJuIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuRE9VQkxFO1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgcmV0dXJuIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuU1RSSU5HO1xuICAgICAgY2FzZSAnaW50NjQnOlxuICAgICAgICByZXR1cm4gb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQ2NDtcbiAgICAgIGNhc2UgJ3VpbnQ2NCc6XG4gICAgICAgIHJldHVybiBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ2NDtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7dHlwZX1gKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgdGVuc29yRGltc0Zyb21Qcm90byhkaW1zOiBBcnJheTxudW1iZXIgfCBMb25nPik6IG51bWJlcltdIHtcbiAgICAvLyBnZXQgcmlkIG9mIExvbmcgdHlwZSBmb3IgZGltc1xuICAgIHJldHVybiBkaW1zLm1hcCgoZCkgPT4gKExvbmcuaXNMb25nKGQpID8gZC50b051bWJlcigpIDogZCkpO1xuICB9XG5cbiAgc3RhdGljIHRlbnNvclZhbHVlVHlwZUZyb21Qcm90byh2YWx1ZVR5cGU6IG9ubnguVHlwZVByb3RvLklUZW5zb3IpOiBHcmFwaC5WYWx1ZVR5cGUge1xuICAgIHJldHVybiB7XG4gICAgICB0ZW5zb3JUeXBlOiBQcm90b1V0aWwudGVuc29yRGF0YVR5cGVGcm9tUHJvdG8odmFsdWVUeXBlLmVsZW1UeXBlISksXG4gICAgICBzaGFwZTogeyBkaW1zOiBQcm90b1V0aWwudGVuc29yRGltc0Zyb21Qcm90byh2YWx1ZVR5cGUuc2hhcGUhLmRpbSEubWFwKChkKSA9PiBkLmRpbVZhbHVlISkpIH0sXG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyB0ZW5zb3JEaW1zRnJvbU9SVEZvcm1hdCh0ZW5zb3I6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yKSB7XG4gICAgY29uc3QgZGltcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGVuc29yLmRpbXNMZW5ndGgoKTsgaSsrKSB7XG4gICAgICBkaW1zLnB1c2goTG9uZ1V0aWwubG9uZ1RvTnVtYmVyKHRlbnNvci5kaW1zKGkpISkpO1xuICAgIH1cbiAgICByZXR1cm4gZGltcztcbiAgfVxuXG4gIHN0YXRpYyB0ZW5zb3JBdHRyaWJ1dGVzRnJvbU9SVEZvcm1hdChub2RlOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLk5vZGUpIHtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmF0dHJpYnV0ZXNMZW5ndGgoKTsgaSsrKSB7XG4gICAgICBhdHRyaWJ1dGVzLnB1c2gobm9kZS5hdHRyaWJ1dGVzKGkpISk7XG4gICAgfVxuICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBMb25nVXRpbCB7XG4gIC8vIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHRvIGdldCBhIG51bWJlciBmcm9tIGxvbmcgdHlwZSBvZiBkYXRhIGZvciBhdHRyaWJ1dGUsIGRpbSwgYW5kIGlyIHZlcnNpb24sXG4gIC8vIHdoaWNoIHZhbHVlcyBhcmUgc2lnbmVkIGludGVnZXJzLlxuICAvLyBUbyBtYWtlIGl0IG1vcmUgZ2VuZXJpYywgYWRkIGFuIG9wdGlvbmFsIHBhcmFtZXRlciB0byBjb252ZXJ0IHRvIGEgdW5zaWduZWQgbnVtYmVyLlxuICBzdGF0aWMgbG9uZ1RvTnVtYmVyKG46IExvbmcgfCBmbGF0YnVmZmVycy5Mb25nIHwgbnVtYmVyLCB1bnNpZ25lZD86IGJvb2xlYW4pIHtcbiAgICBpZiAoTG9uZy5pc0xvbmcobikpIHtcbiAgICAgIHJldHVybiBuLnRvTnVtYmVyKCk7XG4gICAgfSBlbHNlIGlmIChuIGluc3RhbmNlb2YgZmxhdGJ1ZmZlcnMuTG9uZykge1xuICAgICAgcmV0dXJuIExvbmcuZnJvbVZhbHVlKHsgbG93OiBuLmxvdywgaGlnaDogbi5oaWdoLCB1bnNpZ25lZDogdW5zaWduZWQgPz8gZmFsc2UgfSkudG9OdW1iZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIG47XG4gIH1cbiAgc3RhdGljIGlzTG9uZyhuOiB1bmtub3duKSB7XG4gICAgcmV0dXJuIExvbmcuaXNMb25nKG4pIHx8IG4gaW5zdGFuY2VvZiBmbGF0YnVmZmVycy5Mb25nO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBTaGFwZVV0aWwge1xuICBzdGF0aWMgc2l6ZShkaW1zOiByZWFkb25seSBudW1iZXJbXSk6IG51bWJlciB7XG4gICAgcmV0dXJuIFNoYXBlVXRpbC5nZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKGRpbXMsIDAsIGRpbXMubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIGBheGlzYCBpbmNsdXNpdmVcbiAgc3RhdGljIHNpemVGcm9tRGltZW5zaW9uKGRpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBheGlzOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGlmIChheGlzIDwgMCB8fCBheGlzID4gZGltcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBkaW1lbnNpb24gb2YgJHtheGlzfSBmb3Igc2l6ZUZyb21EaW1lbnNpb24gYXMgVGVuc29yIGhhcyAke2RpbXMubGVuZ3RofSBkaW1lbnNpb25zLmApO1xuICAgIH1cbiAgICByZXR1cm4gU2hhcGVVdGlsLmdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UoZGltcywgYXhpcywgZGltcy5sZW5ndGgpO1xuICB9XG5cbiAgLy8gYGF4aXNgIGV4Y2x1c2l2ZVxuICBzdGF0aWMgc2l6ZVRvRGltZW5zaW9uKGRpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBheGlzOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGlmIChheGlzIDwgMCB8fCBheGlzID4gZGltcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBkaW1lbnNpb24gb2YgJHtheGlzfSBmb3Igc2l6ZVRvRGltZW5zaW9uIGFzIFRlbnNvciBoYXMgJHtkaW1zLmxlbmd0aH0gZGltZW5zaW9ucy5gKTtcbiAgICB9XG4gICAgcmV0dXJuIFNoYXBlVXRpbC5nZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKGRpbXMsIDAsIGF4aXMpO1xuICB9XG5cbiAgc3RhdGljIGdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UoZGltczogcmVhZG9ubHkgbnVtYmVyW10sIHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBsZXQgc2l6ZSA9IDE7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIC8vIHNhZmV0eSBjaGVjayBhcyB0aGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgbXVsdGlwbGUgb3RoZXIgbWV0aG9kcyByZXF1aXJpbmcgc2l6ZS5cbiAgICAgIC8vIHNpemUgY2Fubm90IGJlIDAgb3IgbmVnYXRpdmUuXG4gICAgICBpZiAoZGltc1tpXSA8PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICAgICAgICAgICdjYW5ub3QgZ2V0IHZhbGlkIHNpemUgZnJvbSBzcGVjaWZpZWQgZGltZW5zaW9uIHJhbmdlLiBNb3N0IGxpa2VseSB0aGUgcmFuZ2UgY29udGFpbnMgMCBvciBuZWdhdGl2ZSB2YWx1ZXMgaW4gdGhlbS4nLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgc2l6ZSAqPSBkaW1zW2ldO1xuICAgIH1cbiAgICByZXR1cm4gc2l6ZTtcbiAgfVxuXG4gIHN0YXRpYyBjb21wdXRlU3RyaWRlcyhkaW1zOiByZWFkb25seSBudW1iZXJbXSk6IHJlYWRvbmx5IG51bWJlcltdIHtcbiAgICBjb25zdCByYW5rID0gZGltcy5sZW5ndGg7XG4gICAgaWYgKHJhbmsgPT09IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9IGVsc2UgaWYgKHJhbmsgPT09IDEpIHtcbiAgICAgIHJldHVybiBbMV07XG4gICAgfVxuICAgIGNvbnN0IHN0cmlkZXMgPSBuZXcgQXJyYXkocmFuayk7XG4gICAgc3RyaWRlc1tyYW5rIC0gMV0gPSAxO1xuICAgIHN0cmlkZXNbcmFuayAtIDJdID0gZGltc1tyYW5rIC0gMV07XG4gICAgZm9yIChsZXQgaSA9IHJhbmsgLSAzOyBpID49IDA7IC0taSkge1xuICAgICAgc3RyaWRlc1tpXSA9IHN0cmlkZXNbaSArIDFdICogZGltc1tpICsgMV07XG4gICAgfVxuICAgIHJldHVybiBzdHJpZGVzO1xuICB9XG5cbiAgc3RhdGljIHRyYW5zcG9zZShkaW1zOiByZWFkb25seSBudW1iZXJbXSk6IHJlYWRvbmx5IG51bWJlcltdIHtcbiAgICBjb25zdCBjb3B5ID0gZGltcy5zbGljZSgpO1xuICAgIHJldHVybiBjb3B5LnJldmVyc2UoKTtcbiAgfVxuXG4gIHN0YXRpYyBpbmRpY2VzVG9PZmZzZXQoaW5kaWNlczogcmVhZG9ubHkgbnVtYmVyW10sIHN0cmlkZXM6IHJlYWRvbmx5IG51bWJlcltdLCBheGlzPzogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBpZiAoYXhpcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBheGlzID0gaW5kaWNlcy5sZW5ndGg7XG4gICAgfVxuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXhpczsgKytpKSB7XG4gICAgICBvZmZzZXQgKz0gc3RyaWRlc1tpXSAqIGluZGljZXNbaV07XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXQ7XG4gIH1cblxuICBzdGF0aWMgb2Zmc2V0VG9JbmRpY2VzKG9mZnNldDogbnVtYmVyLCBzdHJpZGVzOiByZWFkb25seSBudW1iZXJbXSk6IHJlYWRvbmx5IG51bWJlcltdIHtcbiAgICBjb25zdCByYW5rID0gc3RyaWRlcy5sZW5ndGg7XG4gICAgaWYgKHJhbmsgPT09IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9IGVsc2UgaWYgKHJhbmsgPT09IDEpIHtcbiAgICAgIHJldHVybiBbb2Zmc2V0ICogc3RyaWRlc1swXV07XG4gICAgfVxuICAgIGNvbnN0IGluZGljZXM6IG51bWJlcltdID0gbmV3IEFycmF5KHN0cmlkZXMubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGljZXMubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICBpbmRpY2VzW2ldID0gTWF0aC5mbG9vcihvZmZzZXQgLyBzdHJpZGVzW2ldKTtcbiAgICAgIG9mZnNldCAtPSBpbmRpY2VzW2ldICogc3RyaWRlc1tpXTtcbiAgICB9XG4gICAgaW5kaWNlc1tpbmRpY2VzLmxlbmd0aCAtIDFdID0gb2Zmc2V0O1xuICAgIHJldHVybiBpbmRpY2VzO1xuICB9XG5cbiAgLyoqXG4gICAqIG5vcm1haWx6ZSBheGlzIG9mIHJhbmdlIFstciwgcikgaW50byBbMCwgcikuXG4gICAqL1xuICBzdGF0aWMgbm9ybWFsaXplQXhpcyhheGlzOiBudW1iZXIsIHRlbnNvclJhbms6IG51bWJlcik6IG51bWJlciB7XG4gICAgaWYgKGF4aXMgPCAtdGVuc29yUmFuayAmJiBheGlzID49IHRlbnNvclJhbmspIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndW5zdXBwb3J0ZWQgYXhpcyBmb3IgdGhpcyBvcGVyYXRpb24uJyk7XG4gICAgfVxuICAgIHJldHVybiBheGlzIDwgMCA/IGF4aXMgKyB0ZW5zb3JSYW5rIDogYXhpcztcbiAgfVxuXG4gIHN0YXRpYyBub3JtYWxpemVBeGVzKGF4ZXM6IHJlYWRvbmx5IG51bWJlcltdLCB0ZW5zb3JSYW5rOiBudW1iZXIpOiBudW1iZXJbXSB7XG4gICAgcmV0dXJuIGF4ZXMubWFwKCh4KSA9PiB0aGlzLm5vcm1hbGl6ZUF4aXMoeCwgdGVuc29yUmFuaykpO1xuICB9XG5cbiAgLy8gSW5jcmVtZW50IGFuIGluZGV4IGludG8gYSB0ZW5zb3IgKGluIGxleGljb2dyYXBoaWNcbiAgLy8gb3JkZXJpbmcpLCB3cmFwcGluZyBhcm91bmQgdGhlIHNwZWNpZmllZCB1cHBlcl9ib3VuZC5cbiAgLyoqXG4gICAqIEluY3JlbWVudCBhbiBpbmRleCBpbnRvIGEgdGVuc29yIChpbiBsZXhpY29ncmFwaGljIG9yZGVyaW5nKSwgd3JhcHBpbmcgYXJvdW5kIHRoZSBzcGVjaWZpZWQgdXBwZXJfYm91bmQuXG4gICAqIEBwYXJhbSBpbmRleCBHaXZlbiBpbmRleCB0byBpbmNyZW1lbnQgKFdpbGwgYmUgbXV0YXRlZClcbiAgICogQHBhcmFtIGRpbXMgVGhlIGRpbWVuc2lvbnMgb2YgdGhlIHRlbnNvciBmb3Igd2hpY2ggdGhlIGdpdmVuIGluZGV4IGNvcnJlc3BvbmRzIHRvXG4gICAqIEBwYXJhbSBheGlzVG9JbmNyZW1lbnRPbiBUaGUgMS1pbmRleGVkIGF4aXMgdG8gaW5jcmVtZW50IG9uLiBJZiB1bmRlZmluZWQsIGF4aXNUb0luY3JlbWVudE9uID09IHJhbmtcbiAgICovXG4gIHN0YXRpYyBpbmNyZW1lbnRJbmRleChpbmRleDogbnVtYmVyW10sIGRpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBheGlzVG9JbmNyZW1lbnRPbj86IG51bWJlcikge1xuICAgIGlmIChkaW1zLmxlbmd0aCA9PT0gMCB8fCBpbmRleC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5kZXggaW5jcmVtZW50aW5nIHVuc3VwcG9ydGVkIGZvciBzY2FsYXIgVGVuc29yJyk7XG4gICAgfVxuICAgIGlmIChheGlzVG9JbmNyZW1lbnRPbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBheGlzVG9JbmNyZW1lbnRPbiA9IGRpbXMubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYXhpc1RvSW5jcmVtZW50T24gPD0gMCB8fCBheGlzVG9JbmNyZW1lbnRPbiA+IGRpbXMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb3JyZWN0IGF4aXMgdG8gaW5jcmVtZW50IG9uJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChsZXQgayA9IGF4aXNUb0luY3JlbWVudE9uIC0gMTsgayA+PSAwOyAtLWspIHtcbiAgICAgIGluZGV4W2tdKys7XG4gICAgICBpZiAoaW5kZXhba10gPCBkaW1zW2tdKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaW5kZXhba10gPSAwO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9kdWNlcyBhIG5ldyBkaW1lbnNpb25zIGFycmF5IGJhc2VkIG9uIHRoZSB2YWx1ZXMgaW4gdGhlICdvcmlnaW5hbERpbWVuc2lvbnMnIGFuZCAnc2hhcGUnIGFycmF5XG4gICAqIFVzZWQgaW4gUmVzaGFwZVxuICAgKiBAcGFyYW0gb3JpZ2luYWxEaW1zIE9yaWdpbmFsIFNoYXBlIGFycmF5XG4gICAqIEBwYXJhbSBzaGFwZUhpbnRzIGFycmF5IGNvbnRhaW5pbmcgdmFsdWVzIHRvIGNvbXB1dGUgdGhlIG5ldyBkaW1lbnNpb25zXG4gICAqIEZvciBleGFtcGxlOlxuICAgKiBvcmlnaW5hbERpbXMgPSBbMiwyXSBhbmQgc2hhcGVIaW50cyA9IFswLC0xXSB3aWxsIHJldHVybiBbMiwyXVxuICAgKiBvcmlnaW5hbERpbXMgPSBbMiwyXSBhbmQgc2hhcGVIaW50cyA9IFs0XSB3aWxsIHJldHVybiBbNF1cbiAgICogb3JpZ2luYWxEaW1zID0gWzIsMl0gYW5kIHNoYXBlSGludHMgPSBbNV0gd2lsbCB0aHJvdyBhbiBleGNlcHRpb25cbiAgICogaHR0cHM6Ly9naXRodWIuY29tL29ubngvb25ueC9ibG9iL21haW4vZG9jcy9PcGVyYXRvcnMubWQjUmVzaGFwZVxuICAgKi9cblxuICBzdGF0aWMgY2FsY3VsYXRlUmVzaGFwZWREaW1zKG9yaWdpbmFsRGltczogcmVhZG9ubHkgbnVtYmVyW10sIHNoYXBlSGludHM6IEFycmF5TGlrZTxudW1iZXI+KTogbnVtYmVyW10ge1xuICAgIC8vIHJlc2hhcGUgdG8gYSBTY2FsYXIgVGVuc29yXG4gICAgaWYgKHNoYXBlSGludHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAob3JpZ2luYWxEaW1zLmxlbmd0aCA9PT0gMCB8fCBTaGFwZVV0aWwuc2l6ZShvcmlnaW5hbERpbXMpID09PSAxKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHJlc2hhcGUgdG8gYSBzY2FsYXIgVGVuc29yJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgbkRpbXMgPSBzaGFwZUhpbnRzLmxlbmd0aDtcbiAgICBjb25zdCByZXNoYXBlZERpbXMgPSBuZXcgQXJyYXk8bnVtYmVyPihuRGltcyk7XG4gICAgbGV0IHVua25vd25EaW1lbnNpb24gPSAtMTtcbiAgICBsZXQgbmV3VGVuc29yU2l6ZSA9IDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuRGltczsgaSsrKSB7XG4gICAgICBpZiAoc2hhcGVIaW50c1tpXSA8IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYSBkaW1lbnNpb24gaW4gc2hhcGUgaGludHMgY2Fubm90IGJlIGxlc3MgdGhhbiAtMScpO1xuICAgICAgfVxuICAgICAgaWYgKHNoYXBlSGludHNbaV0gPT09IC0xKSB7XG4gICAgICAgIGlmICh1bmtub3duRGltZW5zaW9uICE9PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXQgbW9zdCBvbmUgZGltZW5zaW9uIGluIHNoYXBlIGhpbnRzIGNhbiBiZSAtMScpO1xuICAgICAgICB9XG4gICAgICAgIHVua25vd25EaW1lbnNpb24gPSBpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHNoYXBlSGludHNbaV0gPT09IDApIHtcbiAgICAgICAgICBpZiAoaSA+PSBvcmlnaW5hbERpbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RoZSBkaW1lbnNpb24gd2l0aCB2YWx1ZSB6ZXJvIGV4Y2VlZHMgdGhlIGRpbWVuc2lvbiBzaXplIG9mIHRoZSBpbnB1dCB0ZW5zb3InKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzaGFwZWREaW1zW2ldID0gb3JpZ2luYWxEaW1zW2ldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc2hhcGVkRGltc1tpXSA9IHNoYXBlSGludHNbaV07XG4gICAgICAgIH1cbiAgICAgICAgbmV3VGVuc29yU2l6ZSAqPSByZXNoYXBlZERpbXNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgb2xkVGVuc29yU2l6ZSA9IFNoYXBlVXRpbC5zaXplKG9yaWdpbmFsRGltcyk7XG4gICAgaWYgKHVua25vd25EaW1lbnNpb24gIT09IC0xKSB7XG4gICAgICBpZiAob2xkVGVuc29yU2l6ZSAlIG5ld1RlbnNvclNpemUgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGB0aGUgaW5wdXQgdGVuc29yIGNhbm5vdCBiZSByZXNoYXBlZCB0byB0aGUgcmVxdWVzdGVkIHNoYXBlLiBJbnB1dCBzaGFwZTogWyR7XG4gICAgICAgICAgICBvcmlnaW5hbERpbXNcbiAgICAgICAgICB9XSBPdXRwdXQgc2hhcGU6IFske3NoYXBlSGludHN9XWAsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXNoYXBlZERpbXNbdW5rbm93bkRpbWVuc2lvbl0gPSBvbGRUZW5zb3JTaXplIC8gbmV3VGVuc29yU2l6ZTtcbiAgICB9XG4gICAgLy8gdmFsaWRhdGUgc2l6ZXMgZnJvbSBvcmlnaW5hbERpbXMgYW5kIHJlc2hhcGVkRGltcyBtYXRjaFxuICAgIGVsc2Uge1xuICAgICAgaWYgKG5ld1RlbnNvclNpemUgIT09IG9sZFRlbnNvclNpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmVzaGFwZWREaW1zIGFuZCBvcmlnaW5hbERpbXMgZG9uJ3QgaGF2ZSBtYXRjaGluZyBzaXplc1wiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc2hhcGVkRGltcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTb3J0cyBhIGdpdmVuIGFycmF5IGJhc2VkIG9uIHRoZSBpbmRpY2VzIGluIHRoZSBQZXJtIGFycmF5XG4gICAqIFVzZWQgaW4gVHJhbnNwb3NlXG4gICAqIEBwYXJhbSBhIEFycmF5IHRvIGJlIHNvcnRlZCBzdWNoIGFzIGRpbXMgb3Igc3RyaWRlc1xuICAgKiBAcGFyYW0gcGVybSBQZXJtIGdpdmVuOyBpZiBudWxsIGEgd2lsbCBiZSByZXZlcnNlZFxuICAgKi9cbiAgc3RhdGljIHNvcnRCYXNlZE9uUGVybShhOiByZWFkb25seSBudW1iZXJbXSwgcGVybT86IHJlYWRvbmx5IG51bWJlcltdKTogcmVhZG9ubHkgbnVtYmVyW10ge1xuICAgIGlmIChwZXJtKSB7XG4gICAgICByZXR1cm4gcGVybS5tYXAoKHYpID0+IGFbdl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYS5zbGljZSgpLnJldmVyc2UoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGFkcyBhIGdpdmVuIHNoYXBlIGFjY29yZGluZyB0byB0aGUgcGFkZGluZyB2YWx1ZXNcbiAgICogQHBhcmFtIGRpbXMgc2hhcGUgb2YgdGhlIFRlbnNvciB0byBiZSBwYWRkZWRcbiAgICogQHBhcmFtIHBhZCBwYWQgdmFsdWVzXG4gICAqL1xuICBzdGF0aWMgcGFkU2hhcGUoZGltczogcmVhZG9ubHkgbnVtYmVyW10sIHBhZDogcmVhZG9ubHkgbnVtYmVyW10pOiByZWFkb25seSBudW1iZXJbXSB7XG4gICAgY29uc3QgcmFuayA9IGRpbXMubGVuZ3RoO1xuICAgIHJldHVybiBkaW1zLm1hcCgodiwgaSkgPT4gdiArIHBhZFtpXSArIHBhZFtpICsgcmFua10pO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgaWYgdGhlIHR3byBzaGFwZXMgYXJlIGlkZW50aWNhbFxuICAgKiBAcGFyYW0gc2hhcGUxXG4gICAqIEBwYXJhbSBzaGFwZTJcbiAgICovXG4gIHN0YXRpYyBhcmVFcXVhbChzaGFwZTE6IHJlYWRvbmx5IG51bWJlcltdLCBzaGFwZTI6IHJlYWRvbmx5IG51bWJlcltdKTogYm9vbGVhbiB7XG4gICAgaWYgKHNoYXBlMS5sZW5ndGggIT09IHNoYXBlMi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHNoYXBlMS5ldmVyeSgodiwgaSkgPT4gdiA9PT0gc2hhcGUyW2ldKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgaWYgdGhlIGdpdmVuIGBkaW1zYCBvciBgc2hhcGVgIGlzIHZhbGlkIGluIE9OTlguanMgY29udGV4dCBhbmQgcmV0dXJucyBkYXRhIHNpemVcbiAgICogQHBhcmFtIGRpbXMgLSBpbnB1dCBgZGltc2AgdGhhdCBuZWVkcyB0byBiZSBjaGVja2VkXG4gICAqL1xuICBzdGF0aWMgdmFsaWRhdGVEaW1zQW5kQ2FsY1NpemUoZGltczogcmVhZG9ubHkgbnVtYmVyW10pOiBudW1iZXIge1xuICAgIGlmIChkaW1zLmxlbmd0aCA+IDYpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09ubHkgcmFuayAwIHRvIDYgaXMgc3VwcG9ydGVkIGZvciB0ZW5zb3Igc2hhcGUuJyk7XG4gICAgfVxuICAgIGxldCBzaXplID0gMTtcbiAgICBmb3IgKGNvbnN0IG4gb2YgZGltcykge1xuICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG4pKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgc2hhcGU6ICR7bn0gaXMgbm90IGFuIGludGVnZXJgKTtcbiAgICAgIH1cbiAgICAgIGlmIChuIDwgMCB8fCBuID4gMjE0NzQ4MzY0Nykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIHNoYXBlOiBsZW5ndGggJHtufSBpcyBub3QgYWxsb3dlZGApO1xuICAgICAgfVxuICAgICAgc2l6ZSAqPSBuO1xuICAgIH1cbiAgICByZXR1cm4gc2l6ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHRoZSBzaGFwZSBvZiBvdXRwdXQgdGVuc29yIHkgPSBmbGF0dGVuKHgsIGF4aXMpXG4gICAqIEBwYXJhbSBkaW1zIC0gc2hhcGUgb2YgaW5wdXQgdGVuc29yXG4gICAqIEBwYXJhbSBheGlzIC0gZmxhdHRlbiBheGlzLCBpbiB0aGUgcmFuZ2UgWy1yLCByXVxuICAgKi9cbiAgc3RhdGljIGZsYXR0ZW5TaGFwZShkaW1zOiByZWFkb25seSBudW1iZXJbXSwgYXhpczogbnVtYmVyKTogcmVhZG9ubHkgbnVtYmVyW10ge1xuICAgIGlmIChheGlzIDwgMCkge1xuICAgICAgYXhpcyArPSBkaW1zLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgdG90YWwgPSBkaW1zLnJlZHVjZSgoeCwgeSkgPT4geCAqIHksIDEpO1xuICAgIGNvbnN0IHJpZ2h0ID0gZGltcy5zbGljZShheGlzKS5yZWR1Y2UoKHgsIHkpID0+IHggKiB5LCAxKTtcbiAgICBjb25zdCBvdXRwdXREaW1zID0gW3RvdGFsIC8gcmlnaHQsIHJpZ2h0XTtcblxuICAgIHJldHVybiBvdXRwdXREaW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgdGhlIHNoYXBlIG9mIG91dHB1dCB0ZW5zb3IgeSA9IHNxdWVlemUoeCwgYXhlcylcbiAgICogQHBhcmFtIGRpbXMgLSBzaGFwZSBvZiBpbnB1dCB0ZW5zb3JcbiAgICogQHBhcmFtIGF4ZXMgLSBzcXVlZXplIGF4ZXNcbiAgICovXG4gIHN0YXRpYyBzcXVlZXplU2hhcGUoZGltczogcmVhZG9ubHkgbnVtYmVyW10sIGF4ZXM6IHJlYWRvbmx5IG51bWJlcltdKTogcmVhZG9ubHkgbnVtYmVyW10ge1xuICAgIGNvbnN0IG91dHB1dERpbXMgPSBuZXcgQXJyYXk8bnVtYmVyPigpO1xuXG4gICAgLy8gc2FuaXR5IGNoZWNrXG4gICAgYXhlcyA9IFNoYXBlVXRpbC5ub3JtYWxpemVBeGVzKGF4ZXMsIGRpbXMubGVuZ3RoKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGltcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaW5TcXVlZXplTGlzdCA9IGF4ZXMuaW5kZXhPZihpKSA+PSAwO1xuICAgICAgaWYgKGluU3F1ZWV6ZUxpc3QgJiYgZGltc1tpXSAhPT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NxdWVlemUgYW4gYXhpcyBvZiBzaXplIGRpZmZlcmVudCB0aGFuIDEnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKChheGVzLmxlbmd0aCA9PT0gMCAmJiBkaW1zW2ldID4gMSkgfHwgKGF4ZXMubGVuZ3RoID4gMCAmJiAhaW5TcXVlZXplTGlzdCkpIHtcbiAgICAgICAgb3V0cHV0RGltcy5wdXNoKGRpbXNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXREaW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgdGhlIHNoYXBlIG9mIG91dHB1dCB0ZW5zb3IgeSA9IHVuc3F1ZWV6ZSh4LCBheGVzKVxuICAgKiBAcGFyYW0gZGltcyAtIHNoYXBlIG9mIGlucHV0IHRlbnNvclxuICAgKiBAcGFyYW0gYXhlcyAtIHVuc3F1ZWV6ZSBheGVzXG4gICAqL1xuICBzdGF0aWMgdW5zcXVlZXplU2hhcGUoZGltczogcmVhZG9ubHkgbnVtYmVyW10sIGF4ZXM6IHJlYWRvbmx5IG51bWJlcltdKTogcmVhZG9ubHkgbnVtYmVyW10ge1xuICAgIGNvbnN0IG91dHB1dERpbXMgPSBuZXcgQXJyYXk8bnVtYmVyPihkaW1zLmxlbmd0aCArIGF4ZXMubGVuZ3RoKTtcblxuICAgIC8vIGluaXRpYWxpemUgdGhlIGFycmF5IGVsZW1lbnRzIHRvIDBcbiAgICBvdXRwdXREaW1zLmZpbGwoMCk7XG5cbiAgICAvLyBzZXQgYWxsIGF4ZXMgaW5kaWNlcyB0byAxIGluIG91dHB1dERpbXMgYW5kIGNoZWNrIGZvciBkdXBsaWNhdGVzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBheGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBheGlzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMoYXhlc1tpXSwgb3V0cHV0RGltcy5sZW5ndGgpO1xuICAgICAgaWYgKGF4aXMgPj0gb3V0cHV0RGltcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJ2F4ZXMnIGhhcyBhbiBvdXQgb2YgcmFuZ2UgYXhpc1wiKTtcbiAgICAgIH1cbiAgICAgIGlmIChvdXRwdXREaW1zW2F4aXNdICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIidheGVzJyBoYXMgYSBkdXBsaWNhdGUgYXhpc1wiKTtcbiAgICAgIH1cblxuICAgICAgb3V0cHV0RGltc1theGlzXSA9IDE7XG4gICAgfVxuXG4gICAgLy8gZmlsbCBpbiB0aGUgemVybyBlbnRyaWVzIG9mIG91dHB1dERpbXMgd2l0aCB0aGUgaW5wdXQgdGVuc29yJ3Mgc2hhcGVcbiAgICBsZXQgaW5wdXREaW1zSXRlcmF0b3IgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0cHV0RGltcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKG91dHB1dERpbXNbaV0gPT09IDApIHtcbiAgICAgICAgb3V0cHV0RGltc1tpXSA9IGRpbXNbaW5wdXREaW1zSXRlcmF0b3IrK107XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gc2FuaXR5IGNoZWNrIGFzc2VydGlvbi4gJ2lucHV0RGltc0l0ZXJhdG9yJ1xuICAgIC8vIHNob3VsZCBiZSBlcXVhbCB0byB0aGUgbGVuZ3RoIG9mICdkaW1zJ1xuICAgIGlmIChpbnB1dERpbXNJdGVyYXRvciAhPT0gZGltcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndGhlIHVuc3F1ZWV6ZWQgZGltZW5zaW9uIGNvdWxkIG5vdCBiZSBlc3RhYmxpc2hlZCcpO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXREaW1zO1xuICB9XG59XG5cbi8vIGJ1bmNoIG9mIGhlbHBlciBtZXRob2RzIHRoYXQgZG8gYSB2YXJpZXR5IG9mIG1hdGggb3BlcmF0aW9uc1xuZXhwb3J0IGNsYXNzIE1hdGhVdGlsIHtcbiAgLy8geSA9ICh4KngpICsgeVxuICBzdGF0aWMgc3FyKFxuICAgIHRhcmdldDogbnVtYmVyW10gfCBUZW5zb3IuTnVtYmVyVHlwZSxcbiAgICBzb3VyY2U6IG51bWJlcltdIHwgVGVuc29yLk51bWJlclR5cGUsXG4gICAgdGFyZ2V0SW5kZXg6IG51bWJlcixcbiAgICBzb3VyY2VJbmRleDogbnVtYmVyLFxuICAgIGJsb2NrU2l6ZTogbnVtYmVyLFxuICApIHtcbiAgICBpZiAoc291cmNlSW5kZXggPCAwIHx8IHNvdXJjZUluZGV4ID49IHNvdXJjZS5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc291cmNlSW5kZXggb3V0IG9mIGJvdW5kcycpO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0SW5kZXggPCAwIHx8IHRhcmdldEluZGV4ID49IHRhcmdldC5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndGFyZ2V0SW5kZXggb3V0IG9mIGJvdW5kcycpO1xuICAgIH1cbiAgICBpZiAoc291cmNlSW5kZXggKyBibG9ja1NpemUgPiBzb3VyY2UubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NvdXJjZSBpbmRpY2VzIHRvIGJlIGNvcGllZCBhcmUgb3V0c2lkZSBib3VuZHMnKTtcbiAgICB9XG4gICAgaWYgKHRhcmdldEluZGV4ICsgYmxvY2tTaXplID4gdGFyZ2V0Lmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0YXJnZXQgYXJyYXkgaXMgdG9vIHNtYWxsIHRvIGhvbGQgcmVzdWx0Jyk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgYmxvY2tTaXplOyBvZmZzZXQrKykge1xuICAgICAgdGFyZ2V0W3RhcmdldEluZGV4ICsgb2Zmc2V0XSArPSBNYXRoLnBvdyhzb3VyY2Vbc291cmNlSW5kZXggKyBvZmZzZXRdLCAyKTtcbiAgICB9XG4gIH1cblxuICAvLyB5ID0gYXggKyB5XG4gIHN0YXRpYyBheHB5KFxuICAgIHRhcmdldDogbnVtYmVyW10gfCBUZW5zb3IuTnVtYmVyVHlwZSxcbiAgICBzb3VyY2U6IG51bWJlcltdIHwgVGVuc29yLk51bWJlclR5cGUsXG4gICAgdGFyZ2V0SW5kZXg6IG51bWJlcixcbiAgICBzb3VyY2VJbmRleDogbnVtYmVyLFxuICAgIGJsb2NrU2l6ZTogbnVtYmVyLFxuICAgIGFscGhhOiBudW1iZXIsXG4gICkge1xuICAgIGlmIChzb3VyY2VJbmRleCA8IDAgfHwgc291cmNlSW5kZXggPj0gc291cmNlLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2VJbmRleCBvdXQgb2YgYm91bmRzJyk7XG4gICAgfVxuICAgIGlmICh0YXJnZXRJbmRleCA8IDAgfHwgdGFyZ2V0SW5kZXggPj0gdGFyZ2V0Lmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0YXJnZXRJbmRleCBvdXQgb2YgYm91bmRzJyk7XG4gICAgfVxuICAgIGlmIChzb3VyY2VJbmRleCArIGJsb2NrU2l6ZSA+IHNvdXJjZS5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc291cmNlIGluZGljZXMgdG8gYmUgY29waWVkIGFyZSBvdXRzaWRlIGJvdW5kcycpO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0SW5kZXggKyBibG9ja1NpemUgPiB0YXJnZXQubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RhcmdldCBhcnJheSBpcyB0b28gc21hbGwgdG8gaG9sZCByZXN1bHQnKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBvZmZzZXQgPSAwOyBvZmZzZXQgPCBibG9ja1NpemU7IG9mZnNldCsrKSB7XG4gICAgICB0YXJnZXRbdGFyZ2V0SW5kZXggKyBvZmZzZXRdICs9IGFscGhhICogc291cmNlW3NvdXJjZUluZGV4ICsgb2Zmc2V0XTtcbiAgICB9XG4gIH1cblxuICAvLyB5ID0gcG93KHgsIGIpXG4gIHN0YXRpYyBwb3d4KFxuICAgIHRhcmdldDogbnVtYmVyW10gfCBUZW5zb3IuTnVtYmVyVHlwZSxcbiAgICBzb3VyY2U6IG51bWJlcltdIHwgVGVuc29yLk51bWJlclR5cGUsXG4gICAgdGFyZ2V0SW5kZXg6IG51bWJlcixcbiAgICBzb3VyY2VJbmRleDogbnVtYmVyLFxuICAgIGJsb2NrU2l6ZTogbnVtYmVyLFxuICAgIGI6IG51bWJlcixcbiAgKSB7XG4gICAgaWYgKHNvdXJjZUluZGV4IDwgMCB8fCBzb3VyY2VJbmRleCA+PSBzb3VyY2UubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NvdXJjZUluZGV4IG91dCBvZiBib3VuZHMnKTtcbiAgICB9XG4gICAgaWYgKHRhcmdldEluZGV4IDwgMCB8fCB0YXJnZXRJbmRleCA+PSB0YXJnZXQubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RhcmdldEluZGV4IG91dCBvZiBib3VuZHMnKTtcbiAgICB9XG4gICAgaWYgKHNvdXJjZUluZGV4ICsgYmxvY2tTaXplID4gc291cmNlLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2UgaW5kaWNlcyB0byBiZSBjb3BpZWQgYXJlIG91dHNpZGUgYm91bmRzJyk7XG4gICAgfVxuICAgIGlmICh0YXJnZXRJbmRleCArIGJsb2NrU2l6ZSA+IHRhcmdldC5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndGFyZ2V0IGFycmF5IGlzIHRvbyBzbWFsbCB0byBob2xkIHJlc3VsdCcpO1xuICAgIH1cblxuICAgIGZvciAobGV0IG9mZnNldCA9IDA7IG9mZnNldCA8IGJsb2NrU2l6ZTsgb2Zmc2V0KyspIHtcbiAgICAgIHRhcmdldFt0YXJnZXRJbmRleCArIG9mZnNldF0gPSBNYXRoLnBvdyhzb3VyY2Vbc291cmNlSW5kZXggKyBvZmZzZXRdLCBiKTtcbiAgICB9XG4gIH1cblxuICAvLyB5ID0geCAqIHlcbiAgc3RhdGljIG11bChcbiAgICB0YXJnZXQ6IG51bWJlcltdIHwgVGVuc29yLk51bWJlclR5cGUsXG4gICAgc291cmNlOiBudW1iZXJbXSB8IFRlbnNvci5OdW1iZXJUeXBlLFxuICAgIHRhcmdldEluZGV4OiBudW1iZXIsXG4gICAgc291cmNlSW5kZXg6IG51bWJlcixcbiAgICBibG9ja1NpemU6IG51bWJlcixcbiAgKSB7XG4gICAgaWYgKHNvdXJjZUluZGV4IDwgMCB8fCBzb3VyY2VJbmRleCA+PSBzb3VyY2UubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NvdXJjZUluZGV4IG91dCBvZiBib3VuZHMnKTtcbiAgICB9XG4gICAgaWYgKHRhcmdldEluZGV4IDwgMCB8fCB0YXJnZXRJbmRleCA+PSB0YXJnZXQubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RhcmdldEluZGV4IG91dCBvZiBib3VuZHMnKTtcbiAgICB9XG4gICAgaWYgKHNvdXJjZUluZGV4ICsgYmxvY2tTaXplID4gc291cmNlLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2UgaW5kaWNlcyB0byBiZSBjb3BpZWQgYXJlIG91dHNpZGUgYm91bmRzJyk7XG4gICAgfVxuICAgIGlmICh0YXJnZXRJbmRleCArIGJsb2NrU2l6ZSA+IHRhcmdldC5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndGFyZ2V0IGFycmF5IGlzIHRvbyBzbWFsbCB0byBob2xkIHJlc3VsdCcpO1xuICAgIH1cblxuICAgIGZvciAobGV0IG9mZnNldCA9IDA7IG9mZnNldCA8IGJsb2NrU2l6ZTsgb2Zmc2V0KyspIHtcbiAgICAgIHRhcmdldFt0YXJnZXRJbmRleCArIG9mZnNldF0gPSBzb3VyY2Vbc291cmNlSW5kZXggKyBvZmZzZXRdICogdGFyZ2V0W3RhcmdldEluZGV4ICsgb2Zmc2V0XTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFNwbGl0VXRpbCB7XG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIG5ldyBTaGFwZXMgZnJvbSBleGlzdGluZyBvbmUgYW5kIHRoZSBzcGxpdHMgZ2l2ZW4gYWxvbmcgdGhlIGF4aXMgcHJvdmlkZXNcbiAgICogQHBhcmFtIGRpbXMgU2hhcGUgb2YgdGhlIFRlbnNvciB0byBiZSBzcGxpdHRlZCBpbnRvIHR3byBvciBtb3JlIFNoYXBlc1xuICAgKiBAcGFyYW0gYXhpcyBUaGUgZGltZW5zaW9uIGFsb25nIHdoaWNoIHRoZSBUZW5zb3Igd2lsbCBiZSBzcGxpdFxuICAgKiBAcGFyYW0gc3BsaXRzIE9mZnNldHMgZm9yIHRoZSBzdGFydCBvZiBlYWNoIHNwbGl0XG4gICAqL1xuICBzdGF0aWMgc3BsaXRTaGFwZShcbiAgICBkaW1zOiByZWFkb25seSBudW1iZXJbXSxcbiAgICBheGlzOiBudW1iZXIsXG4gICAgc3BsaXQ6IG51bWJlcltdLFxuICAgIG51bU91dHB1dHM/OiBudW1iZXIsXG4gICk6IFtudW1iZXJbXVtdLCBudW1iZXJbXV0ge1xuICAgIGlmIChzcGxpdC5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmICghbnVtT3V0cHV0cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJuZWVkIHRvIGtub3cgbnVtYmVyIG9mIG91dHB1dHMgd2hlbiB0aGUgJ3NwbGl0JyBhdHRyaWJ1dGUgaXMgbm90IHNwZWNpZmllZFwiKTtcbiAgICAgIH1cbiAgICAgIFNwbGl0VXRpbC5kZXRlcm1pbmVTcGxpdChkaW1zW2F4aXNdLCBudW1PdXRwdXRzLCBzcGxpdCk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2hhcGVzOiBudW1iZXJbXVtdID0gW107XG4gICAgY29uc3Qgb2Zmc2V0cyA9IFswXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNwbGl0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoaSAhPT0gMCkge1xuICAgICAgICBvZmZzZXRzLnB1c2gob2Zmc2V0c1tpIC0gMV0gKyBzcGxpdFtpIC0gMV0pO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2hhcGUgPSBkaW1zLnNsaWNlKCk7XG4gICAgICBzaGFwZVtheGlzXSA9IHNwbGl0W2ldO1xuICAgICAgc2hhcGVzLnB1c2goc2hhcGUpO1xuICAgIH1cbiAgICByZXR1cm4gW3NoYXBlcywgb2Zmc2V0c107XG4gIH1cblxuICBzdGF0aWMgZGV0ZXJtaW5lU3BsaXQobnVtRWxlbWVudHNBbG9uZ0F4aXM6IG51bWJlciwgbnVtT3V0cHV0czogbnVtYmVyLCBzcGxpdDogbnVtYmVyW10pIHtcbiAgICAvLyBJZiAnc3BsaXQnIGlzIG5vdCBzcGVjaWZpZWQgYnkgdGhlIHVzZXIsIHdlIG5lZWQgdG8gcGFydGl0aW9uIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgZXF1YWxseSBhbW9uZyB0aGUgb3V0cHV0c1xuICAgIGlmIChudW1FbGVtZW50c0Fsb25nQXhpcyAlIG51bU91dHB1dHMgIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHNwbGl0IHRlbnNvciB0byBlcXVhbCBzaXplZCBwYXJ0cycpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bU91dHB1dHM7ICsraSkge1xuICAgICAgc3BsaXQucHVzaChudW1FbGVtZW50c0Fsb25nQXhpcyAvIG51bU91dHB1dHMpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgUmVkdWNlVXRpbCB7XG4gIC8qKlxuICAgKiBQZXJmb3JtIHJlZHVjZSBvcGVyYXRpb25zIG9uIHRoZSBzcGVjaWZpYyBvcGVyYXRvclxuICAgKiBAcGFyYW0gYSBJbnB1dCB0ZW5zb3IgZGF0YVxuICAgKiBAcGFyYW0gYXhlcyBUaGUgZGltZW5zaW9ucyBhbG9uZyB3aGljaCB0aGUgVGVuc29yIHdpbGwgYmUgcmVkdWNlZFxuICAgKiBAcGFyYW0ga2VlcGRpbXMgSWYgc2V0IHRvIHRydWUsIHRoZSBheGVzIHdoaWNoIGFyZSByZWR1Y2VkIGFyZSBsZWZ0IGluIHRoZVxuICAgKiAgICByZXN1bHQgYXMgZGltZW5zaW9ucyB3aXRoIHNpemUgb25lLlxuICAgKiBAcGFyYW0gb3AxIFRoZSBvcGVyYXRpb24gdG8gYmUgcGVyZm9ybWVkIG9uIGVhY2ggZWxlbWVudCBpbiB0aGUgdGVuc29yXG4gICAqIEBwYXJhbSBvcDIgVGhlIG9wZXJhdGlvbiB0byBiZSBwZXJmb3JtZWQgYmV0d2VlbiBlbGVtZW50cyBpbiB0aGUgdGVuc29yXG4gICAqL1xuICBzdGF0aWMgY2FsY1JlZHVjZShcbiAgICBhOiBUZW5zb3IsXG4gICAgYXhlczogbnVtYmVyW10sXG4gICAga2VlcGRpbXM6IGJvb2xlYW4sXG4gICAgb3AxOiAoYjogbnVtYmVyKSA9PiBudW1iZXIsXG4gICAgb3AyOiAoYTogbnVtYmVyLCBiOiBudW1iZXIpID0+IG51bWJlcixcbiAgKTogVGVuc29yIHtcbiAgICBjb25zdCBkaW1zID0gYS5kaW1zLnNsaWNlKDApO1xuICAgIC8vIGlmIGF4ZXMgaXMgbm90IHNldCwgcGVyZm9ybSByZWR1Y2Ugb24gYWxsIGF4ZXNcbiAgICBpZiAoYXhlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGRpbXMuZm9yRWFjaCgoX2QsIGluZCkgPT4gYXhlcy5wdXNoKGluZCkpO1xuICAgIH1cbiAgICAvLyBnZXQgYSB0ZW1wb3JhcnkgYnJvYWRjYXN0YWJsZSBvdXRwdXQgc2hhcGVcbiAgICBjb25zdCBvdXRwdXREaW1zID0gUmVkdWNlVXRpbC5jYWxjUmVkdWNlU2hhcGUoZGltcywgYXhlcywgdHJ1ZSk7XG5cbiAgICAvLyBsb29wIHRocm91Z2ggdGhlIG91dHB1dCBhbmQgY2FsY3VsYXRlIHJlc3VsdCBvbmUgYnkgb25lXG4gICAgY29uc3Qgc2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dERpbXMpO1xuICAgIGNvbnN0IHkgPSBuZXcgVGVuc29yKG91dHB1dERpbXMsIGEudHlwZSk7XG4gICAgY29uc3Qgc3RyaWRlcyA9IFNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyhvdXRwdXREaW1zKTtcbiAgICBjb25zdCBpbnB1dFN0cmlkZXMgPSBTaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXMoZGltcyk7XG4gICAgY29uc3QgaW5kaWNlc1kgPSBuZXcgQXJyYXkoZGltcy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICBjb25zdCBpbmRpY2VzID0gU2hhcGVVdGlsLm9mZnNldFRvSW5kaWNlcyhpLCBzdHJpZGVzKTtcbiAgICAgIC8vIG1hcCBpbmRleFxuICAgICAgQnJvYWRjYXN0VXRpbC5maWxsSW5kZXgoaW5kaWNlcywgZGltcywgaW5kaWNlc1kpO1xuICAgICAgeS5zZXQoXG4gICAgICAgIGluZGljZXMsXG4gICAgICAgIFJlZHVjZVV0aWwuY2FsY1JlZHVjZUJ5QXhpcyhcbiAgICAgICAgICBhLm51bWJlckRhdGEsXG4gICAgICAgICAgYXhlcyxcbiAgICAgICAgICBkaW1zLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgU2hhcGVVdGlsLmluZGljZXNUb09mZnNldChpbmRpY2VzWSwgaW5wdXRTdHJpZGVzKSxcbiAgICAgICAgICBvcDEsXG4gICAgICAgICAgb3AyLFxuICAgICAgICApLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoa2VlcGRpbXMpIHtcbiAgICAgIHJldHVybiB5O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBrZWVwZGltcyA9PSAwLCBjYWxjdWxhdGUgdGhlIGV4cGVjdGVkIHNoYXBlXG4gICAgICByZXR1cm4gbmV3IFRlbnNvcihcbiAgICAgICAgUmVkdWNlVXRpbC5jYWxjUmVkdWNlU2hhcGUoZGltcywgYXhlcywga2VlcGRpbXMpLFxuICAgICAgICB5LnR5cGUsXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICB5LmRhdGEsXG4gICAgICAgIHkuZGF0YUlkLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybSByZWR1Y2Ugb3BlcmF0aW9ucyBvbiB0aGUgc3BlY2lmaWMgb3BlcmF0b3Igb24gc3BlY2lmaWMgYXhlc1xuICAgKiBAcGFyYW0gYSBJbnB1dCB0ZW5zb3IgZGF0YVxuICAgKiBAcGFyYW0gYXhlcyBUaGUgZGltZW5zaW9ucyBhbG9uZyB3aGljaCB0aGUgVGVuc29yIHdpbGwgYmUgcmVkdWNlZFxuICAgKiBAcGFyYW0gZGltcyBUaGUgaW5wdXQgZGltZW5zaW9uLlxuICAgKiBAcGFyYW0gY3VyQXhpc0luZCBJbmRleCBpbiBheGVzIHNwZWNpZnlpbmcgdGhlIGN1cnJlbnQgZGltZW5zaW9uIGFsb25nXG4gICAqICAgICAgd2hpY2ggdGhlIHRlbnNvciB3aWxsIGJlIHJlZHVjZWRcbiAgICogQHBhcmFtIHBvcyBUaGUgY3VycmVudCBpbmRleCBvZiBlbGVtZW50IHRvIHBlcmZvcm0gb3BlcmF0aW9uXG4gICAqIEBwYXJhbSBvcDEgVGhlIG9wZXJhdGlvbiB0byBiZSBwZXJmb3JtZWQgb24gZWFjaCBlbGVtZW50IGluIHRoZSB0ZW5zb3JcbiAgICogQHBhcmFtIG9wMiBUaGUgb3BlcmF0aW9uIHRvIGJlIHBlcmZvcm1lZCBiZXR3ZWVuIGVsZW1lbnRzIGluIHRoZSB0ZW5zb3JcbiAgICovXG4gIHN0YXRpYyBjYWxjUmVkdWNlQnlBeGlzKFxuICAgIGlucHV0OiBUZW5zb3IuTnVtYmVyVHlwZSxcbiAgICBheGVzOiBudW1iZXJbXSxcbiAgICBkaW1zOiBudW1iZXJbXSxcbiAgICBjdXJBeGlzSW5kOiBudW1iZXIsXG4gICAgcG9zOiBudW1iZXIsXG4gICAgb3AxOiAoYjogbnVtYmVyKSA9PiBudW1iZXIsXG4gICAgb3AyOiAoYTogbnVtYmVyLCBiOiBudW1iZXIpID0+IG51bWJlcixcbiAgKTogbnVtYmVyIHtcbiAgICBsZXQgcmVzID0gMDtcbiAgICBpZiAoY3VyQXhpc0luZCA+PSBheGVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG9wMShpbnB1dFtwb3NdKTtcbiAgICB9XG4gICAgY29uc3QgYXhpcyA9IGF4ZXNbY3VyQXhpc0luZF07XG4gICAgY29uc3Qgc3RlcCA9IGF4aXMgPj0gZGltcy5sZW5ndGggPyAxIDogU2hhcGVVdGlsLnNpemUoZGltcy5zbGljZShheGlzICsgMSkpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGltc1theGlzXTsgaSsrKSB7XG4gICAgICByZXMgPVxuICAgICAgICBpID09PSAwXG4gICAgICAgICAgPyBSZWR1Y2VVdGlsLmNhbGNSZWR1Y2VCeUF4aXMoaW5wdXQsIGF4ZXMsIGRpbXMsIGN1ckF4aXNJbmQgKyAxLCBwb3MsIG9wMSwgb3AyKVxuICAgICAgICAgIDogb3AyKHJlcywgUmVkdWNlVXRpbC5jYWxjUmVkdWNlQnlBeGlzKGlucHV0LCBheGVzLCBkaW1zLCBjdXJBeGlzSW5kICsgMSwgcG9zLCBvcDEsIG9wMikpO1xuICAgICAgcG9zICs9IHN0ZXA7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBleHBlY3RlZCBzaGFwZSBvZiBhIHJlZHVjZSBvcGVyYXRpb25cbiAgICogQHBhcmFtIGRpbXMgVGhlIGlucHV0IHRlbnNvciBkaW1lbnNpb25cbiAgICogQHBhcmFtIGF4ZXMgVGhlIGRpbWVuc2lvbnMgYWxvbmcgd2hpY2ggdGhlIFRlbnNvciB3aWxsIGJlIHJlZHVjZWRcbiAgICogQHBhcmFtIGtlZXBkaW1zIElmIHNldCB0byB0cnVlLCB0aGUgYXhlcyB3aGljaCBhcmUgcmVkdWNlZCBhcmUgbGVmdCBpbiB0aGVcbiAgICogICAgcmVzdWx0IGFzIGRpbWVuc2lvbnMgd2l0aCBzaXplIG9uZS5cbiAgICovXG4gIHN0YXRpYyBjYWxjUmVkdWNlU2hhcGUoZGltczogcmVhZG9ubHkgbnVtYmVyW10sIGF4ZXM6IHJlYWRvbmx5IG51bWJlcltdLCBrZWVwRGltczogYm9vbGVhbik6IG51bWJlcltdIHtcbiAgICBjb25zdCBvdXRwdXREaW1zID0gZGltcy5zbGljZSgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGtlZXBEaW1zKSB7XG4gICAgICAgIG91dHB1dERpbXNbYXhlc1tpXV0gPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0RGltc1theGVzW2ldXSA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXREaW1zLmZpbHRlcigoZGltKSA9PiBkaW0gIT09IDApO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBQb29sQ29udlV0aWwge1xuICAvKipcbiAgICogQWRqdXN0IHRoZSBrZXJuZWwsIHN0cmlkZXMsIHBhZHMgdG8gY29ycmVjdCByYW5rLiBTZXQgdG8gZGVmYXVsdCB2YWx1ZSBpZiBub3QgcHJlc2VudFxuICAgKiBAcGFyYW0gaXNHbG9iYWxPcGVyYXRvciBJZiB0cnVlLCBwZXJmb3JtIGdsb2JhbCBwb29saW5nLlxuICAgKiBAcGFyYW0gaW5wdXREaW1zIFRoZSBpbnB1dCB0ZW5zb3IgZGltZW5zaW9uLlxuICAgKiBAcGFyYW0ga2VybmVsU2hhcGUgVGhlIHNpemUgb2YgdGhlIGtlcm5lbCBhbG9uZyBlYWNoIGF4aXMuXG4gICAqIEBwYXJhbSBzdHJpZGVzIFN0cmlkZSBhbG9uZyBlYWNoIGF4aXMuXG4gICAqIEBwYXJhbSBkaWxhdGlvbnMgRGlsYXRpb24gYWxvbmcgZWFjaCBheGlzLlxuICAgKiBAcGFyYW0gcGFkcyBQYWRkaW5nIGZvciB0aGUgYmVnaW5uaW5nIGFuZCBlbmRpbmcgYWxvbmcgZWFjaCBheGlzLlxuICAgKi9cbiAgc3RhdGljIGFkanVzdFBvb2xBdHRyaWJ1dGVzKFxuICAgIGlzR2xvYmFsT3BlcmF0b3I6IGJvb2xlYW4sXG4gICAgaW5wdXREaW1zOiByZWFkb25seSBudW1iZXJbXSxcbiAgICBrZXJuZWxTaGFwZTogbnVtYmVyW10sXG4gICAgc3RyaWRlczogbnVtYmVyW10sXG4gICAgZGlsYXRpb25zOiBudW1iZXJbXSxcbiAgICBwYWRzOiBudW1iZXJbXSxcbiAgKSB7XG4gICAgaWYgKCFpc0dsb2JhbE9wZXJhdG9yICYmIGtlcm5lbFNoYXBlLmxlbmd0aCAhPT0gaW5wdXREaW1zLmxlbmd0aCAtIDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbGVuZ3RoIG9mIHNwZWNpZmllZCBrZXJuZWwgc2hhcGVzIHNob3VsZCBiZSAyIGxlc3MgdGhhbiBsZW5ndGggb2YgaW5wdXQgZGltZW5zaW9ucycpO1xuICAgIH1cblxuICAgIGlmIChpc0dsb2JhbE9wZXJhdG9yKSB7XG4gICAgICAvLyBhZGp1c3Qga2VybmVsIHNoYXBlIHRvIGNvdmVyIHRoZSBpbnB1dCBkaW1zXG4gICAgICBmb3IgKGxldCBkaW0gPSAwOyBkaW0gPCBpbnB1dERpbXMubGVuZ3RoIC0gMjsgZGltKyspIHtcbiAgICAgICAgaWYgKGRpbSA+PSBrZXJuZWxTaGFwZS5sZW5ndGgpIHtcbiAgICAgICAgICBrZXJuZWxTaGFwZS5wdXNoKGlucHV0RGltc1tkaW0gKyAyXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAga2VybmVsU2hhcGVbZGltXSA9IGlucHV0RGltc1tkaW0gKyAyXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFkanVzdCBzdHJpZGVzIGxlbmd0aCB0byBtYXRjaCBrZXJuZWwgc2hhcGUgbGVuZ3RoXG4gICAgZm9yIChsZXQgZGltID0gMDsgZGltIDwga2VybmVsU2hhcGUubGVuZ3RoOyBkaW0rKykge1xuICAgICAgaWYgKGRpbSA8IHN0cmlkZXMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChzdHJpZGVzW2RpbV0gPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdHJpZGVzIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMScpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHJpZGVzLnB1c2goMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWRqdXN0IGRpbGF0aW9uIHZhbHVlXG4gICAgZm9yIChsZXQgZGltID0gMDsgZGltIDwga2VybmVsU2hhcGUubGVuZ3RoOyBkaW0rKykge1xuICAgICAgaWYgKGRpbSA8IGRpbGF0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGRpbGF0aW9uc1tkaW1dIDwgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZGlsYXRpb25zIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMScpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaWxhdGlvbnMucHVzaCgxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhZGp1c3QgcGFkcyBsZW5ndGggdG8gbWF0Y2ggMiAqIGtlcm5lbCBzaGFwZSBsZW5ndGhcbiAgICBmb3IgKGxldCBkaW0gPSAwOyBkaW0gPCBrZXJuZWxTaGFwZS5sZW5ndGggKiAyOyBkaW0rKykge1xuICAgICAgaWYgKGRpbSA8IHBhZHMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChwYWRzW2RpbV0gPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWQgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhZHMucHVzaCgwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzYW5pdHkgY2hlY2tzIGZvciB2YWx1ZXMgaW4ga2VybmVsIHNoYXBlcyBhbmQgcGFkc1xuICAgIGZvciAobGV0IGRpbSA9IDA7IGRpbSA8IGtlcm5lbFNoYXBlLmxlbmd0aDsgZGltKyspIHtcbiAgICAgIGlmIChrZXJuZWxTaGFwZVtkaW1dIDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdrZXJuZWwgc2hhcGVzIG5lZWQgdG8gYmUgZ3JlYXRlciB0aGFuIDAnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhZHNbZGltXSA+PSBrZXJuZWxTaGFwZVtkaW1dIHx8IHBhZHNbZGltICsga2VybmVsU2hhcGUubGVuZ3RoXSA+PSBrZXJuZWxTaGFwZVtkaW1dKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkcyBzaG91bGQgYmUgc21hbGxlciB0aGFuIGtlcm5lbCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGFkanVzdCBwYWQgdmFsdWVzIGJhc2VkIG9uICdhdXRvUGFkJyBhdHRyaWJ1dGVcbiAgc3RhdGljIGFkanVzdFBhZHNCYXNlZE9uQXV0b1BhZChcbiAgICBpbnB1dERpbXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIHN0cmlkZXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIGRpbGF0aW9uczogcmVhZG9ubHkgbnVtYmVyW10sXG4gICAga2VybmVsU2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIHBhZHM6IG51bWJlcltdLFxuICAgIGF1dG9QYWQ/OiBzdHJpbmcsXG4gICkge1xuICAgIGlmICghYXV0b1BhZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwYWRzLmxlbmd0aCAhPT0gMiAqIChpbnB1dERpbXMubGVuZ3RoIC0gMikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbGVuZ3RoIG9mIHBhZHMgc2hvdWxkIGJlIHR3aWNlIHRoZSBsZW5ndGggb2YgZGF0YSBkaW1lbnNpb25zJyk7XG4gICAgfVxuXG4gICAgaWYgKHN0cmlkZXMubGVuZ3RoICE9PSBpbnB1dERpbXMubGVuZ3RoIC0gMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdsZW5ndGggb2Ygc3RyaWRlcyBzaG91bGQgYmUgdGhlIGxlbmd0aCBvZiBkYXRhIGRpbWVuc2lvbnMnKTtcbiAgICB9XG5cbiAgICBpZiAoa2VybmVsU2hhcGUubGVuZ3RoICE9PSBpbnB1dERpbXMubGVuZ3RoIC0gMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdsZW5ndGggb2Yga2VybmVsIHNoYXBlcyBzaG91bGQgYmUgdGhlIGxlbmd0aCBvZiBkYXRhIGRpbWVuc2lvbnMnKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBkaW0gPSAwOyBkaW0gPCBpbnB1dERpbXMubGVuZ3RoIC0gMjsgZGltKyspIHtcbiAgICAgIFBvb2xDb252VXRpbC5hZGp1c3RQYWRBbmRSZXR1cm5TaGFwZShcbiAgICAgICAgaW5wdXREaW1zW2RpbSArIDJdLFxuICAgICAgICBzdHJpZGVzW2RpbV0sXG4gICAgICAgIGRpbGF0aW9uc1tkaW1dLFxuICAgICAgICBrZXJuZWxTaGFwZVtkaW1dLFxuICAgICAgICBwYWRzLFxuICAgICAgICBkaW0sXG4gICAgICAgIGRpbSArIGlucHV0RGltcy5sZW5ndGggLSAyLFxuICAgICAgICBhdXRvUGFkLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBvdXRwdXQgc2hhcGUgZm9yIFBvb2wgb3BzIGJhc2VkIG9uIGlucHV0IGF0dHJpYnV0ZXMuIChTaG91bGQgYmUgdXNlZCBvbmx5IGZvciBQb29sIG9wcylcbiAgICogQHBhcmFtIGlzR2xvYmFsT3BlcmF0b3IgSWYgdHJ1ZSwgcGVyZm9ybSBnbG9iYWwgcG9vbGluZy5cbiAgICogQHBhcmFtIGlucHV0RGltcyBUaGUgaW5wdXQgdGVuc29yIGRpbWVuc2lvbi4gKGlucHV0c1swXS5kaW1zKVxuICAgKiBAcGFyYW0gc3RyaWRlcyBTdHJpZGUgYWxvbmcgZWFjaCBheGlzLlxuICAgKiBAcGFyYW0gZGlsYXRpb25zIERpbGF0aW9uIGFsb25nIGVhY2ggYXhpcy5cbiAgICogQHBhcmFtIGtlcm5lbFNoYXBlIFRoZSBzaXplIG9mIHRoZSBrZXJuZWwgYWxvbmcgZWFjaCBheGlzLlxuICAgKiBAcGFyYW0gcGFkcyBQYWRkaW5nIGZvciB0aGUgYmVnaW5uaW5nIGFuZCBlbmRpbmcgYWxvbmcgZWFjaCBheGlzLlxuICAgKiBAcGFyYW0gYXV0b1BhZCBERVBSRUNBVEVEIGF0dHJpYnV0ZSBzdXBwb3J0ZWQgZm9yIGxlZ2FjeSBtb2RlbHMuIFNwZWNpZmllcyBob3cgdG8gaW1wbGljaXRseSBjYWxjdWxhdGUgcGFkcyBpbiBlYWNoXG4gICAqICAgICBkaW1lbnNpb24uIENhbiB0YWtlIHZhbHVlcyBOT1RTRVQsIFNBTUVfVVBQRVIsIFNBTUVfTE9XRVIsIG9yIFZBTElELlxuICAgKi9cbiAgc3RhdGljIGNvbXB1dGVQb29sT3V0cHV0U2hhcGUoXG4gICAgaXNHbG9iYWxPcGVyYXRvcjogYm9vbGVhbixcbiAgICBpbnB1dERpbXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIHN0cmlkZXM6IG51bWJlcltdLFxuICAgIGRpbGF0aW9uczogbnVtYmVyW10sXG4gICAga2VybmVsU2hhcGU6IG51bWJlcltdLFxuICAgIHBhZHM6IG51bWJlcltdLFxuICAgIGF1dG9QYWQ/OiBzdHJpbmcsXG4gICk6IG51bWJlcltdIHtcbiAgICBpZiAoaW5wdXREaW1zLmxlbmd0aCA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0IHNoYXBlIG11c3QgYmUgb2Ygc2l6ZSBncmVhdGVyIHRoYW4gMCcpO1xuICAgIH1cblxuICAgIC8vIEFkZCBiYXRjaCBzaXplIGFuZCBudW1iZXIgb2YgY2hhbm5lbHMgb2Ygb3V0cHV0XG4gICAgY29uc3Qgb3V0cHV0RGltcyA9IFtpbnB1dERpbXNbMF0sIGlucHV0RGltc1sxXV07XG5cbiAgICBQb29sQ29udlV0aWwuY29tcHV0ZVNoYXBlSGVscGVyKFxuICAgICAgaXNHbG9iYWxPcGVyYXRvcixcbiAgICAgIGlucHV0RGltcyxcbiAgICAgIG91dHB1dERpbXMsXG4gICAgICBzdHJpZGVzLFxuICAgICAgZGlsYXRpb25zLFxuICAgICAga2VybmVsU2hhcGUsXG4gICAgICBwYWRzLFxuICAgICAgYXV0b1BhZCxcbiAgICApO1xuICAgIHJldHVybiBvdXRwdXREaW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgb3V0cHV0IHNoYXBlIGZvciBDb252IG9wIGJhc2VkIG9uIGlucHV0IGF0dHJpYnV0ZXMuIChTaG91bGQgYmUgdXNlZCBvbmx5IGZvciBDb252IG9wKVxuICAgKiBAcGFyYW0gaW5wdXREaW1zIFRoZSBpbnB1dCB0ZW5zb3IgZGltZW5zaW9uLiAoaW5wdXRzWzBdLmRpbXMpXG4gICAqIEBwYXJhbSBmaWx0ZXJEaW1zIFRoZSBmaWx0ZXIgdGVuc29yIGRpbWVuc2lvbi4gKGlucHV0c1sxXS5kaW1zKVxuICAgKiBAcGFyYW0gc3RyaWRlcyBTdHJpZGUgYWxvbmcgZWFjaCBheGlzLlxuICAgKiBAcGFyYW0ga2VybmVsU2hhcGUgVGhlIHNpemUgb2YgdGhlIGtlcm5lbCBhbG9uZyBlYWNoIGF4aXMuXG4gICAqIEBwYXJhbSBwYWRzIFBhZGRpbmcgZm9yIHRoZSBiZWdpbm5pbmcgYW5kIGVuZGluZyBhbG9uZyBlYWNoIGF4aXMuXG4gICAqIEBwYXJhbSBhdXRvUGFkIERFUFJFQ0FURUQgYXR0cmlidXRlIHN1cHBvcnRlZCBmb3IgbGVnYWN5IG1vZGVscy4gU3BlY2lmaWVzIGhvdyB0byBpbXBsaWNpdGx5IGNhbGN1bGF0ZSBwYWRzIGluIGVhY2hcbiAgICogICAgIGRpbWVuc2lvbi4gQ2FuIHRha2UgdmFsdWVzIE5PVFNFVCwgU0FNRV9VUFBFUiwgU0FNRV9MT1dFUiwgb3IgVkFMSUQuXG4gICAqL1xuICBzdGF0aWMgY29tcHV0ZUNvbnZPdXRwdXRTaGFwZShcbiAgICBpbnB1dERpbXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIGZpbHRlckRpbXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIHN0cmlkZXM6IG51bWJlcltdLFxuICAgIGRpbGF0aW9uczogbnVtYmVyW10sXG4gICAga2VybmVsU2hhcGU6IG51bWJlcltdLFxuICAgIHBhZHM6IG51bWJlcltdLFxuICAgIGF1dG9QYWQ/OiBzdHJpbmcsXG4gICk6IG51bWJlcltdIHtcbiAgICBpZiAoaW5wdXREaW1zLmxlbmd0aCA8PSAwIHx8IGZpbHRlckRpbXMubGVuZ3RoIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbnB1dCB0ZW5zb3IgZGltcyBvciBpbnZhbGlkIGZpbHRlciB0ZW5zb3IgZGltcycpO1xuICAgIH1cblxuICAgIC8vIEFkZCBiYXRjaCBzaXplIGFuZCBudW1iZXIgb2YgY2hhbm5lbHMgb2Ygb3V0cHV0XG4gICAgY29uc3Qgb3V0cHV0RGltcyA9IFtpbnB1dERpbXNbMF0sIGZpbHRlckRpbXNbMF1dO1xuXG4gICAgUG9vbENvbnZVdGlsLmNvbXB1dGVTaGFwZUhlbHBlcihmYWxzZSwgaW5wdXREaW1zLCBvdXRwdXREaW1zLCBzdHJpZGVzLCBkaWxhdGlvbnMsIGtlcm5lbFNoYXBlLCBwYWRzLCBhdXRvUGFkKTtcbiAgICByZXR1cm4gb3V0cHV0RGltcztcbiAgfVxuXG4gIC8vIHdpbGwgY29tcHV0ZSBvdXRwdXQgc2hhcGVzIGZvciBkYXRhIGRpbWVuc2lvbnMgT05MWSAoaS5lLikgbm8gYmF0Y2ggc2l6ZSBhbmQgY2hhbm5lbHNcbiAgLy8gY2FsbGVkIGJ5IGNvbXB1dGVQb29sT3V0cHV0U2hhcGUoKSBhbmQgY29tcHV0ZUNvbnZPdXRwdXRTaGFwZSgpXG4gIC8vIGFkanVzdCBwYWRzIGJhc2VkIG9uICdhdXRvUGFkJyBhdHRyaWJ1dGUgcHJpb3IgdG8gc2hhcGUgY29tcHV0YXRpb25cbiAgcHJpdmF0ZSBzdGF0aWMgY29tcHV0ZVNoYXBlSGVscGVyKFxuICAgIGlzR2xvYmFsT3BlcmF0b3I6IGJvb2xlYW4sXG4gICAgaW5wdXREaW1zOiByZWFkb25seSBudW1iZXJbXSxcbiAgICBvdXRwdXREaW1zOiBudW1iZXJbXSxcbiAgICBzdHJpZGVzOiByZWFkb25seSBudW1iZXJbXSxcbiAgICBkaWxhdGlvbnM6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIGtlcm5lbFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgICBwYWRzOiBudW1iZXJbXSxcbiAgICBhdXRvUGFkPzogc3RyaW5nLFxuICApIHtcbiAgICBpZiAoaXNHbG9iYWxPcGVyYXRvcikge1xuICAgICAgZm9yIChsZXQgZGltID0gMDsgZGltIDwgaW5wdXREaW1zLmxlbmd0aCAtIDI7IGRpbSsrKSB7XG4gICAgICAgIG91dHB1dERpbXMucHVzaCgxKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgZGltID0gMDsgZGltIDwgaW5wdXREaW1zLmxlbmd0aCAtIDI7IGRpbSsrKSB7XG4gICAgICAgIG91dHB1dERpbXMucHVzaChcbiAgICAgICAgICBQb29sQ29udlV0aWwuYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUoXG4gICAgICAgICAgICBpbnB1dERpbXNbZGltICsgMl0sXG4gICAgICAgICAgICBzdHJpZGVzW2RpbV0sXG4gICAgICAgICAgICBkaWxhdGlvbnNbZGltXSxcbiAgICAgICAgICAgIGtlcm5lbFNoYXBlW2RpbV0sXG4gICAgICAgICAgICBwYWRzLFxuICAgICAgICAgICAgZGltLFxuICAgICAgICAgICAgZGltICsgaW5wdXREaW1zLmxlbmd0aCAtIDIsXG4gICAgICAgICAgICBhdXRvUGFkLFxuICAgICAgICAgICksXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gaGVscGVyIGZvciBjb21wdXRlU2hhcGVIZWxwZXIoKSBhbmQgYWRqdXN0UGFkc0Jhc2VkT25BdXRvUGFkKClcbiAgLy8gYWRqdXN0cyBwYWQgdmFsdWUgZm9yIGdpdmVuICdhdXRvUGFkJyBzdHJpbmcgYW5kIGNvbXB1dGVzIG91dHB1dCBzaGFwZSBhbG9uZyBhIHBhcnRpY3VsYXIgZGltZW5zaW9uXG4gIHByaXZhdGUgc3RhdGljIGFkanVzdFBhZEFuZFJldHVyblNoYXBlKFxuICAgIGluU2l6ZTogbnVtYmVyLFxuICAgIHN0cmlkZTogbnVtYmVyLFxuICAgIGRpbGF0aW9uOiBudW1iZXIsXG4gICAga2VybmVsOiBudW1iZXIsXG4gICAgcGFkczogbnVtYmVyW10sXG4gICAgcGFkSGVhZEluZGV4OiBudW1iZXIsXG4gICAgcGFkVGFpbEluZGV4OiBudW1iZXIsXG4gICAgYXV0b1BhZD86IHN0cmluZyxcbiAgKTogbnVtYmVyIHtcbiAgICBjb25zdCBka2VybmVsID0gZGlsYXRpb24gKiAoa2VybmVsIC0gMSkgKyAxO1xuICAgIGlmIChhdXRvUGFkICYmIGF1dG9QYWQgIT09ICdOT1RTRVQnKSB7XG4gICAgICBzd2l0Y2ggKGF1dG9QYWQpIHtcbiAgICAgICAgY2FzZSAnVkFMSUQnOlxuICAgICAgICAgIHBhZHNbcGFkSGVhZEluZGV4XSA9IDA7XG4gICAgICAgICAgcGFkc1twYWRUYWlsSW5kZXhdID0gMDtcbiAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcigoaW5TaXplIC0gZGtlcm5lbCkgLyBzdHJpZGUgKyAxKTtcbiAgICAgICAgY2FzZSAnU0FNRV9MT1dFUic6XG4gICAgICAgIGNhc2UgJ1NBTUVfVVBQRVInOlxuICAgICAgICAgIGlmIChkaWxhdGlvbiAhPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEaWxhdGlvbiBub3Qgc3VwcG9ydGVkIGZvciBTQU1FX1VQUEVSIG9yIFNBTUVfTE9XRVInKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbGVnYWN5VGFyZ2V0U2l6ZSA9IChpblNpemUgKyBzdHJpZGUgLSAxKSAvIHN0cmlkZTtcbiAgICAgICAgICAgIGNvbnN0IHBhZE5lZWRlZCA9IChsZWdhY3lUYXJnZXRTaXplIC0gMSkgKiBzdHJpZGUgKyBrZXJuZWwgLSBpblNpemU7XG4gICAgICAgICAgICBwYWRzW3BhZEhlYWRJbmRleF0gPSBhdXRvUGFkID09PSAnU0FNRV9MT1dFUicgPyBNYXRoLmZsb29yKChwYWROZWVkZWQgKyAxKSAvIDIpIDogTWF0aC5mbG9vcihwYWROZWVkZWQgLyAyKTtcbiAgICAgICAgICAgIHBhZHNbcGFkVGFpbEluZGV4XSA9IHBhZE5lZWRlZCAtIHBhZHNbcGFkSGVhZEluZGV4XTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKChpblNpemUgKyBwYWROZWVkZWQgLSBrZXJuZWwpIC8gc3RyaWRlICsgMSk7XG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgQXV0b1BhZCB0eXBlJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKChpblNpemUgKyBwYWRzW3BhZEhlYWRJbmRleF0gKyBwYWRzW3BhZFRhaWxJbmRleF0gLSBka2VybmVsKSAvIHN0cmlkZSArIDEpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgTUlOX0NMSVAgPSAtMy40MDI4MjM0NjYzODUyODg2ZTM4O1xuZXhwb3J0IGNvbnN0IE1BWF9DTElQID0gMy40MDI4MjM0NjYzODUyODg2ZTM4O1xuXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlVXRmOFN0cmluZyhidWZmZXI6IFVpbnQ4QXJyYXkpOiBzdHJpbmcge1xuICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGJ1ZmZlcik7XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEd1aWQgfSBmcm9tICdndWlkLXR5cGVzY3JpcHQnO1xuaW1wb3J0IExvbmcgZnJvbSAnbG9uZyc7XG5cbmltcG9ydCB7IG9ubnhydW50aW1lIH0gZnJvbSAnLi9vcnQtc2NoZW1hL2ZsYXRidWZmZXJzL29ydC1nZW5lcmF0ZWQnO1xuaW1wb3J0IHsgb25ueCB9IGZyb20gJy4vb3J0LXNjaGVtYS9wcm90b2J1Zi9vbm54JztcbmltcG9ydCB7IGRlY29kZVV0ZjhTdHJpbmcsIFByb3RvVXRpbCwgU2hhcGVVdGlsIH0gZnJvbSAnLi91dGlsJztcblxuaW1wb3J0IG9ydEZicyA9IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnM7XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBUZW5zb3Ige1xuICBleHBvcnQgaW50ZXJmYWNlIERhdGFUeXBlTWFwIHtcbiAgICBib29sOiBVaW50OEFycmF5O1xuICAgIGZsb2F0MzI6IEZsb2F0MzJBcnJheTtcbiAgICBmbG9hdDY0OiBGbG9hdDY0QXJyYXk7XG4gICAgc3RyaW5nOiBzdHJpbmdbXTtcbiAgICBpbnQ4OiBJbnQ4QXJyYXk7XG4gICAgdWludDg6IFVpbnQ4QXJyYXk7XG4gICAgaW50MTY6IEludDE2QXJyYXk7XG4gICAgdWludDE2OiBVaW50MTZBcnJheTtcbiAgICBpbnQzMjogSW50MzJBcnJheTtcbiAgICB1aW50MzI6IFVpbnQzMkFycmF5O1xuICAgIGludDY0OiBCaWdJbnQ2NEFycmF5O1xuICB9XG5cbiAgZXhwb3J0IHR5cGUgRGF0YVR5cGUgPSBrZXlvZiBEYXRhVHlwZU1hcDtcblxuICBleHBvcnQgdHlwZSBTdHJpbmdUeXBlID0gVGVuc29yLkRhdGFUeXBlTWFwWydzdHJpbmcnXTtcbiAgZXhwb3J0IHR5cGUgQm9vbGVhblR5cGUgPSBUZW5zb3IuRGF0YVR5cGVNYXBbJ2Jvb2wnXTtcbiAgZXhwb3J0IHR5cGUgSW50ZWdlclR5cGUgPVxuICAgIHwgVGVuc29yLkRhdGFUeXBlTWFwWydpbnQ4J11cbiAgICB8IFRlbnNvci5EYXRhVHlwZU1hcFsndWludDgnXVxuICAgIHwgVGVuc29yLkRhdGFUeXBlTWFwWydpbnQxNiddXG4gICAgfCBUZW5zb3IuRGF0YVR5cGVNYXBbJ3VpbnQxNiddXG4gICAgfCBUZW5zb3IuRGF0YVR5cGVNYXBbJ2ludDMyJ11cbiAgICB8IFRlbnNvci5EYXRhVHlwZU1hcFsndWludDMyJ107XG4gIGV4cG9ydCB0eXBlIEZsb2F0VHlwZSA9IFRlbnNvci5EYXRhVHlwZU1hcFsnZmxvYXQzMiddIHwgVGVuc29yLkRhdGFUeXBlTWFwWydmbG9hdDY0J107XG4gIGV4cG9ydCB0eXBlIE51bWJlclR5cGUgPSBCb29sZWFuVHlwZSB8IEludGVnZXJUeXBlIHwgRmxvYXRUeXBlO1xuXG4gIGV4cG9ydCB0eXBlIElkID0gR3VpZDtcbn1cblxudHlwZSBUZW5zb3JEYXRhID0gVGVuc29yLkRhdGFUeXBlTWFwW1RlbnNvci5EYXRhVHlwZV07XG5cbnR5cGUgRGF0YVByb3ZpZGVyID0gKGlkOiBUZW5zb3IuSWQpID0+IFRlbnNvckRhdGE7XG50eXBlIEFzeW5jRGF0YVByb3ZpZGVyID0gKGlkOiBUZW5zb3IuSWQpID0+IFByb21pc2U8VGVuc29yRGF0YT47XG5cbmV4cG9ydCBjbGFzcyBUZW5zb3Ige1xuICAvKipcbiAgICogZ2V0IHRoZSB1bmRlcmx5aW5nIHRlbnNvciBkYXRhXG4gICAqL1xuICBnZXQgZGF0YSgpOiBUZW5zb3JEYXRhIHtcbiAgICBpZiAodGhpcy5jYWNoZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhUHJvdmlkZXIhKHRoaXMuZGF0YUlkKTtcbiAgICAgIGlmIChkYXRhLmxlbmd0aCAhPT0gdGhpcy5zaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTGVuZ3RoIG9mIGRhdGEgcHJvdmlkZWQgYnkgdGhlIERhdGEgUHJvdmlkZXIgaXMgaW5jb25zaXN0ZW50IHdpdGggdGhlIGRpbXMgb2YgdGhpcyBUZW5zb3IuJyk7XG4gICAgICB9XG4gICAgICB0aGlzLmNhY2hlID0gZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2FjaGU7XG4gIH1cblxuICAvKipcbiAgICogZ2V0IHRoZSB1bmRlcmx5aW5nIHN0cmluZyB0ZW5zb3IgZGF0YS4gU2hvdWxkIG9ubHkgdXNlIHdoZW4gdHlwZSBpcyBTVFJJTkdcbiAgICovXG4gIGdldCBzdHJpbmdEYXRhKCkge1xuICAgIGlmICh0aGlzLnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdkYXRhIHR5cGUgaXMgbm90IHN0cmluZycpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmRhdGEgYXMgVGVuc29yLlN0cmluZ1R5cGU7XG4gIH1cblxuICAvKipcbiAgICogZ2V0IHRoZSB1bmRlcmx5aW5nIGludGVnZXIgdGVuc29yIGRhdGEuIFNob3VsZCBvbmx5IHVzZSB3aGVuIHR5cGUgaXMgb25lIG9mIHRoZSBmb2xsb3dpbmc6IChVSU5UOCwgSU5UOCwgVUlOVDE2LFxuICAgKiBJTlQxNiwgSU5UMzIsIFVJTlQzMiwgQk9PTClcbiAgICovXG4gIGdldCBpbnRlZ2VyRGF0YSgpIHtcbiAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgY2FzZSAndWludDgnOlxuICAgICAgY2FzZSAnaW50OCc6XG4gICAgICBjYXNlICd1aW50MTYnOlxuICAgICAgY2FzZSAnaW50MTYnOlxuICAgICAgY2FzZSAnaW50MzInOlxuICAgICAgY2FzZSAndWludDMyJzpcbiAgICAgIGNhc2UgJ2Jvb2wnOlxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhIGFzIFRlbnNvci5JbnRlZ2VyVHlwZTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZGF0YSB0eXBlIGlzIG5vdCBpbnRlZ2VyICh1aW50OCwgaW50OCwgdWludDE2LCBpbnQxNiwgaW50MzIsIHVpbnQzMiwgYm9vbCknKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogZ2V0IHRoZSB1bmRlcmx5aW5nIGZsb2F0IHRlbnNvciBkYXRhLiBTaG91bGQgb25seSB1c2Ugd2hlbiB0eXBlIGlzIG9uZSBvZiB0aGUgZm9sbG93aW5nOiAoRkxPQVQsIERPVUJMRSlcbiAgICovXG4gIGdldCBmbG9hdERhdGEoKSB7XG4gICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgIGNhc2UgJ2Zsb2F0MzInOlxuICAgICAgY2FzZSAnZmxvYXQ2NCc6XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEgYXMgVGVuc29yLkZsb2F0VHlwZTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZGF0YSB0eXBlIGlzIG5vdCBmbG9hdCAoZmxvYXQzMiwgZmxvYXQ2NCknKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogZ2V0IHRoZSB1bmRlcmx5aW5nIG51bWJlciB0ZW5zb3IgZGF0YS4gU2hvdWxkIG9ubHkgdXNlIHdoZW4gdHlwZSBpcyBvbmUgb2YgdGhlIGZvbGxvd2luZzogKFVJTlQ4LCBJTlQ4LCBVSU5UMTYsXG4gICAqIElOVDE2LCBJTlQzMiwgVUlOVDMyLCBCT09MLCBGTE9BVCwgRE9VQkxFKVxuICAgKi9cbiAgZ2V0IG51bWJlckRhdGEoKSB7XG4gICAgaWYgKHRoaXMudHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB0aGlzLmRhdGEgYXMgVGVuc29yLk51bWJlclR5cGU7XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3R5cGUgY2Fubm90IGJlIG5vbi1udW1iZXIgKHN0cmluZyknKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgdmFsdWUgb2YgYW4gZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kaWNlc1xuICAgKi9cbiAgZ2V0KGluZGljZXM6IHJlYWRvbmx5IG51bWJlcltdKTogVGVuc29yLkRhdGFUeXBlTWFwW1RlbnNvci5EYXRhVHlwZV1bbnVtYmVyXSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YVtTaGFwZVV0aWwuaW5kaWNlc1RvT2Zmc2V0KGluZGljZXMsIHRoaXMuc3RyaWRlcyldO1xuICB9XG5cbiAgLyoqXG4gICAqIHNldCB2YWx1ZSBvZiBhbiBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRpY2VzXG4gICAqL1xuICBzZXQoaW5kaWNlczogcmVhZG9ubHkgbnVtYmVyW10sIHZhbHVlOiBUZW5zb3IuRGF0YVR5cGVNYXBbVGVuc29yLkRhdGFUeXBlXVtudW1iZXJdKSB7XG4gICAgdGhpcy5kYXRhW1NoYXBlVXRpbC5pbmRpY2VzVG9PZmZzZXQoaW5kaWNlcywgdGhpcy5zdHJpZGVzKV0gPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgdGhlIHVuZGVybHlpbmcgdGVuc29yIGRhdGEgYXN5bmNocm9ub3VzbHlcbiAgICovXG4gIGFzeW5jIGdldERhdGEoKTogUHJvbWlzZTxUZW5zb3JEYXRhPiB7XG4gICAgaWYgKHRoaXMuY2FjaGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5jYWNoZSA9IGF3YWl0IHRoaXMuYXN5bmNEYXRhUHJvdmlkZXIhKHRoaXMuZGF0YUlkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2FjaGU7XG4gIH1cblxuICAvKipcbiAgICogZ2V0IHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHRlbnNvclxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IHNpemU6IG51bWJlcjtcblxuICBwcml2YXRlIF9zdHJpZGVzOiByZWFkb25seSBudW1iZXJbXTtcbiAgLyoqXG4gICAqIGdldCB0aGUgc3RyaWRlcyBmb3IgZWFjaCBkaW1lbnNpb25cbiAgICovXG4gIGdldCBzdHJpZGVzKCk6IHJlYWRvbmx5IG51bWJlcltdIHtcbiAgICBpZiAoIXRoaXMuX3N0cmlkZXMpIHtcbiAgICAgIHRoaXMuX3N0cmlkZXMgPSBTaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXModGhpcy5kaW1zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3N0cmlkZXM7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIHRlbnNvclxuICAgICAqL1xuICAgIHB1YmxpYyByZWFkb25seSBkaW1zOiByZWFkb25seSBudW1iZXJbXSxcbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIHR5cGUgb2YgdGhlIHRlbnNvclxuICAgICAqL1xuICAgIHB1YmxpYyByZWFkb25seSB0eXBlOiBUZW5zb3IuRGF0YVR5cGUsXG4gICAgcHJpdmF0ZSBkYXRhUHJvdmlkZXI/OiBEYXRhUHJvdmlkZXIsXG4gICAgcHJpdmF0ZSBhc3luY0RhdGFQcm92aWRlcj86IEFzeW5jRGF0YVByb3ZpZGVyLFxuICAgIHByaXZhdGUgY2FjaGU/OiBUZW5zb3JEYXRhLFxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgZGF0YSBJRCB0aGF0IHVzZWQgdG8gbWFwIHRvIGEgdGVuc29yIGRhdGFcbiAgICAgKi9cbiAgICBwdWJsaWMgcmVhZG9ubHkgZGF0YUlkOiBHdWlkID0gR3VpZC5jcmVhdGUoKSxcbiAgKSB7XG4gICAgdGhpcy5zaXplID0gU2hhcGVVdGlsLnZhbGlkYXRlRGltc0FuZENhbGNTaXplKGRpbXMpO1xuICAgIGNvbnN0IHNpemUgPSB0aGlzLnNpemU7XG4gICAgY29uc3QgZW1wdHkgPSBkYXRhUHJvdmlkZXIgPT09IHVuZGVmaW5lZCAmJiBhc3luY0RhdGFQcm92aWRlciA9PT0gdW5kZWZpbmVkICYmIGNhY2hlID09PSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoY2FjaGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGNhY2hlLmxlbmd0aCAhPT0gc2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklucHV0IGRpbXMgZG9lc24ndCBtYXRjaCBkYXRhIGxlbmd0aC5cIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoY2FjaGUgIT09IHVuZGVmaW5lZCAmJiAoIUFycmF5LmlzQXJyYXkoY2FjaGUpIHx8ICFjYWNoZS5ldmVyeSgoaSkgPT4gdHlwZW9mIGkgPT09ICdzdHJpbmcnKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2FjaGUgc2hvdWxkIGJlIGEgc3RyaW5nIGFycmF5Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbXB0eSkge1xuICAgICAgICB0aGlzLmNhY2hlID0gbmV3IEFycmF5PHN0cmluZz4oc2l6ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjYWNoZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gZGF0YXZpZXdDb25zdHJ1Y3Rvcih0eXBlKTtcbiAgICAgICAgaWYgKCEoY2FjaGUgaW5zdGFuY2VvZiBjb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBjYWNoZSBzaG91bGQgYmUgdHlwZSAke2NvbnN0cnVjdG9yLm5hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGVtcHR5KSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcihzaXplICogc2l6ZW9mKHR5cGUpKTtcbiAgICAgICAgdGhpcy5jYWNoZSA9IGNyZWF0ZVZpZXcoYnVmLCB0eXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29uc3RydWN0IG5ldyBUZW5zb3IgZnJvbSBhIE9OTlggVGVuc29yIG9iamVjdFxuICAgKiBAcGFyYW0gdGVuc29yUHJvdG8gdGhlIE9OTlggVGVuc29yXG4gICAqL1xuICBzdGF0aWMgZnJvbVByb3RvKHRlbnNvclByb3RvOiBvbm54LklUZW5zb3JQcm90byk6IFRlbnNvciB7XG4gICAgaWYgKCF0ZW5zb3JQcm90bykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgY29uc3RydWN0IFZhbHVlIGZyb20gYW4gZW1wdHkgdGVuc29yJyk7XG4gICAgfVxuICAgIGNvbnN0IHR5cGUgPSBQcm90b1V0aWwudGVuc29yRGF0YVR5cGVGcm9tUHJvdG8odGVuc29yUHJvdG8uZGF0YVR5cGUhKTtcbiAgICBjb25zdCBkaW1zID0gUHJvdG9VdGlsLnRlbnNvckRpbXNGcm9tUHJvdG8odGVuc29yUHJvdG8uZGltcyEpO1xuXG4gICAgY29uc3QgdmFsdWUgPSBuZXcgVGVuc29yKGRpbXMsIHR5cGUpO1xuXG4gICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBXaGVuIGl0J3MgU1RSSU5HIHR5cGUsIHRoZSB2YWx1ZSBzaG91bGQgYWx3YXlzIGJlIHN0b3JlZCBpbiBmaWVsZFxuICAgICAgLy8gJ3N0cmluZ0RhdGEnXG4gICAgICB0ZW5zb3JQcm90by5zdHJpbmdEYXRhIS5mb3JFYWNoKChzdHIsIGkpID0+IHtcbiAgICAgICAgdmFsdWUuZGF0YVtpXSA9IGRlY29kZVV0ZjhTdHJpbmcoc3RyKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICB0ZW5zb3JQcm90by5yYXdEYXRhICYmXG4gICAgICB0eXBlb2YgdGVuc29yUHJvdG8ucmF3RGF0YS5ieXRlTGVuZ3RoID09PSAnbnVtYmVyJyAmJlxuICAgICAgdGVuc29yUHJvdG8ucmF3RGF0YS5ieXRlTGVuZ3RoID4gMFxuICAgICkge1xuICAgICAgLy8gTk9UIGNvbnNpZGVyaW5nIHNlZ21lbnQgZm9yIG5vdyAoSU1QT1JUQU5UKVxuXG4gICAgICAvLyBwb3B1bGF0ZSB2YWx1ZSBmcm9tIHJhd0RhdGFcbiAgICAgIGNvbnN0IGRhdGFEZXN0ID0gdmFsdWUuZGF0YTtcbiAgICAgIGNvbnN0IGRhdGFTb3VyY2UgPSBuZXcgRGF0YVZpZXcoXG4gICAgICAgIHRlbnNvclByb3RvLnJhd0RhdGEuYnVmZmVyLFxuICAgICAgICB0ZW5zb3JQcm90by5yYXdEYXRhLmJ5dGVPZmZzZXQsXG4gICAgICAgIHRlbnNvclByb3RvLnJhd0RhdGEuYnl0ZUxlbmd0aCxcbiAgICAgICk7XG4gICAgICBjb25zdCBlbGVtZW50U2l6ZSA9IHNpemVvZlByb3RvKHRlbnNvclByb3RvLmRhdGFUeXBlISk7XG4gICAgICBjb25zdCBsZW5ndGggPSB0ZW5zb3JQcm90by5yYXdEYXRhLmJ5dGVMZW5ndGggLyBlbGVtZW50U2l6ZTtcblxuICAgICAgaWYgKHRlbnNvclByb3RvLnJhd0RhdGEuYnl0ZUxlbmd0aCAlIGVsZW1lbnRTaXplICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBidWZmZXIgbGVuZ3RoJyk7XG4gICAgICB9XG4gICAgICBpZiAoZGF0YURlc3QubGVuZ3RoICE9PSBsZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdidWZmZXIgbGVuZ3RoIG1pc21hdGNoJyk7XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgbiA9IHJlYWRQcm90byhkYXRhU291cmNlLCB0ZW5zb3JQcm90by5kYXRhVHlwZSEsIGkgKiBlbGVtZW50U2l6ZSk7XG4gICAgICAgIGRhdGFEZXN0W2ldID0gbjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcG9wdWxhdGUgdmFsdWUgZnJvbSBhcnJheVxuICAgICAgbGV0IGFycmF5OiBBcnJheTxudW1iZXIgfCBMb25nPjtcbiAgICAgIHN3aXRjaCAodGVuc29yUHJvdG8uZGF0YVR5cGUpIHtcbiAgICAgICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkZMT0FUOlxuICAgICAgICAgIGFycmF5ID0gdGVuc29yUHJvdG8uZmxvYXREYXRhITtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDMyOlxuICAgICAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UMTY6XG4gICAgICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMTY6XG4gICAgICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQ4OlxuICAgICAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDg6XG4gICAgICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5CT09MOlxuICAgICAgICAgIGFycmF5ID0gdGVuc29yUHJvdG8uaW50MzJEYXRhITtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDY0OlxuICAgICAgICAgIGFycmF5ID0gdGVuc29yUHJvdG8uaW50NjREYXRhITtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkRPVUJMRTpcbiAgICAgICAgICBhcnJheSA9IHRlbnNvclByb3RvLmRvdWJsZURhdGEhO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDMyOlxuICAgICAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDY0OlxuICAgICAgICAgIGFycmF5ID0gdGVuc29yUHJvdG8udWludDY0RGF0YSE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy8gc2hvdWxkIG5ldmVyIHJ1biBoZXJlXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnNwZWNpZmljIGVycm9yJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhcnJheSA9PT0gbnVsbCB8fCBhcnJheSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZmFpbGVkIHRvIHBvcHVsYXRlIGRhdGEgZnJvbSBhIHRlbnNvcnByb3RvIHZhbHVlJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGEgPSB2YWx1ZS5kYXRhO1xuICAgICAgaWYgKGRhdGEubGVuZ3RoICE9PSBhcnJheS5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcnJheSBsZW5ndGggbWlzbWF0Y2gnKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gYXJyYXlbaV07XG4gICAgICAgIGlmIChMb25nLmlzTG9uZyhlbGVtZW50KSkge1xuICAgICAgICAgIGRhdGFbaV0gPSBsb25nVG9OdW1iZXIoZWxlbWVudCwgdGVuc29yUHJvdG8uZGF0YVR5cGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGFbaV0gPSBlbGVtZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBuZXcgVGVuc29yIGZyb20gcmF3IGRhdGFcbiAgICogQHBhcmFtIGRhdGEgdGhlIHJhdyBkYXRhIG9iamVjdC4gU2hvdWxkIGJlIGEgc3RyaW5nIGFycmF5IGZvciAnc3RyaW5nJyB0ZW5zb3IsIGFuZCB0aGUgY29ycmVzcG9uZGluZyB0eXBlZCBhcnJheVxuICAgKiBmb3Igb3RoZXIgdHlwZXMgb2YgdGVuc29yLlxuICAgKiBAcGFyYW0gZGltcyB0aGUgZGltZW5zaW9ucyBvZiB0aGUgdGVuc29yXG4gICAqIEBwYXJhbSB0eXBlIHRoZSB0eXBlIG9mIHRoZSB0ZW5zb3JcbiAgICovXG4gIHN0YXRpYyBmcm9tRGF0YShkYXRhOiBUZW5zb3IuRGF0YVR5cGVNYXBbVGVuc29yLkRhdGFUeXBlXSwgZGltczogcmVhZG9ubHkgbnVtYmVyW10sIHR5cGU6IFRlbnNvci5EYXRhVHlwZSkge1xuICAgIHJldHVybiBuZXcgVGVuc29yKGRpbXMsIHR5cGUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkYXRhKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tT3J0VGVuc29yKG9ydFRlbnNvcjogb3J0RmJzLlRlbnNvcikge1xuICAgIGlmICghb3J0VGVuc29yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBjb25zdHJ1Y3QgVmFsdWUgZnJvbSBhbiBlbXB0eSB0ZW5zb3InKTtcbiAgICB9XG4gICAgY29uc3QgZGltcyA9IFByb3RvVXRpbC50ZW5zb3JEaW1zRnJvbU9SVEZvcm1hdChvcnRUZW5zb3IpO1xuICAgIGNvbnN0IHR5cGUgPSBQcm90b1V0aWwudGVuc29yRGF0YVR5cGVGcm9tUHJvdG8ob3J0VGVuc29yLmRhdGFUeXBlKCkpO1xuXG4gICAgY29uc3QgdmFsdWUgPSBuZXcgVGVuc29yKGRpbXMsIHR5cGUpO1xuXG4gICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBXaGVuIGl0J3MgU1RSSU5HIHR5cGUsIHRoZSB2YWx1ZSBzaG91bGQgYWx3YXlzIGJlIHN0b3JlZCBpbiBmaWVsZFxuICAgICAgLy8gJ3N0cmluZ0RhdGEnXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9ydFRlbnNvci5zdHJpbmdEYXRhTGVuZ3RoKCk7IGkrKykge1xuICAgICAgICB2YWx1ZS5kYXRhW2ldID0gb3J0VGVuc29yLnN0cmluZ0RhdGEoaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIG9ydFRlbnNvci5yYXdEYXRhQXJyYXkoKSAmJlxuICAgICAgdHlwZW9mIG9ydFRlbnNvci5yYXdEYXRhTGVuZ3RoKCkgPT09ICdudW1iZXInICYmXG4gICAgICBvcnRUZW5zb3IucmF3RGF0YUxlbmd0aCgpID4gMFxuICAgICkge1xuICAgICAgLy8gTk9UIGNvbnNpZGVyaW5nIHNlZ21lbnQgZm9yIG5vdyAoSU1QT1JUQU5UKVxuXG4gICAgICAvLyBwb3B1bGF0ZSB2YWx1ZSBmcm9tIHJhd0RhdGFcbiAgICAgIGNvbnN0IGRhdGFEZXN0ID0gdmFsdWUuZGF0YTtcbiAgICAgIGNvbnN0IGRhdGFTb3VyY2UgPSBuZXcgRGF0YVZpZXcoXG4gICAgICAgIG9ydFRlbnNvci5yYXdEYXRhQXJyYXkoKSEuYnVmZmVyLFxuICAgICAgICBvcnRUZW5zb3IucmF3RGF0YUFycmF5KCkhLmJ5dGVPZmZzZXQsXG4gICAgICAgIG9ydFRlbnNvci5yYXdEYXRhTGVuZ3RoKCksXG4gICAgICApO1xuICAgICAgY29uc3QgZWxlbWVudFNpemUgPSBzaXplb2ZQcm90byhvcnRUZW5zb3IuZGF0YVR5cGUoKSk7XG4gICAgICBjb25zdCBsZW5ndGggPSBvcnRUZW5zb3IucmF3RGF0YUxlbmd0aCgpIC8gZWxlbWVudFNpemU7XG5cbiAgICAgIGlmIChvcnRUZW5zb3IucmF3RGF0YUxlbmd0aCgpICUgZWxlbWVudFNpemUgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGJ1ZmZlciBsZW5ndGgnKTtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhRGVzdC5sZW5ndGggIT09IGxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2J1ZmZlciBsZW5ndGggbWlzbWF0Y2gnKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBuID0gcmVhZFByb3RvKGRhdGFTb3VyY2UsIG9ydFRlbnNvci5kYXRhVHlwZSgpLCBpICogZWxlbWVudFNpemUpO1xuICAgICAgICBkYXRhRGVzdFtpXSA9IG47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaXplb2YodHlwZTogVGVuc29yLkRhdGFUeXBlKTogbnVtYmVyIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnYm9vbCc6XG4gICAgY2FzZSAnaW50OCc6XG4gICAgY2FzZSAndWludDgnOlxuICAgICAgcmV0dXJuIDE7XG4gICAgY2FzZSAnaW50MTYnOlxuICAgIGNhc2UgJ3VpbnQxNic6XG4gICAgICByZXR1cm4gMjtcbiAgICBjYXNlICdpbnQzMic6XG4gICAgY2FzZSAndWludDMyJzpcbiAgICBjYXNlICdmbG9hdDMyJzpcbiAgICAgIHJldHVybiA0O1xuICAgIGNhc2UgJ2Zsb2F0NjQnOlxuICAgICAgcmV0dXJuIDg7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IGNhbGN1bGF0ZSBzaXplb2YoKSBvbiB0eXBlICR7dHlwZX1gKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaXplb2ZQcm90byh0eXBlOiBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlIHwgb3J0RmJzLlRlbnNvckRhdGFUeXBlKTogbnVtYmVyIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ4OlxuICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQ4OlxuICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5CT09MOlxuICAgICAgcmV0dXJuIDE7XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQxNjpcbiAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UMTY6XG4gICAgICByZXR1cm4gMjtcbiAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuRkxPQVQ6XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDMyOlxuICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMzI6XG4gICAgICByZXR1cm4gNDtcbiAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UNjQ6XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkRPVUJMRTpcbiAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDY0OlxuICAgICAgcmV0dXJuIDg7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IGNhbGN1bGF0ZSBzaXplb2YoKSBvbiB0eXBlICR7b25ueC5UZW5zb3JQcm90by5EYXRhVHlwZVt0eXBlXX1gKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVWaWV3KGRhdGFCdWZmZXI6IEFycmF5QnVmZmVyLCB0eXBlOiBUZW5zb3IuRGF0YVR5cGUpIHtcbiAgcmV0dXJuIG5ldyAoZGF0YXZpZXdDb25zdHJ1Y3Rvcih0eXBlKSkoZGF0YUJ1ZmZlcik7XG59XG5cbmZ1bmN0aW9uIGRhdGF2aWV3Q29uc3RydWN0b3IodHlwZTogVGVuc29yLkRhdGFUeXBlKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2Jvb2wnOlxuICAgIGNhc2UgJ3VpbnQ4JzpcbiAgICAgIHJldHVybiBVaW50OEFycmF5O1xuICAgIGNhc2UgJ2ludDgnOlxuICAgICAgcmV0dXJuIEludDhBcnJheTtcbiAgICBjYXNlICdpbnQxNic6XG4gICAgICByZXR1cm4gSW50MTZBcnJheTtcbiAgICBjYXNlICd1aW50MTYnOlxuICAgICAgcmV0dXJuIFVpbnQxNkFycmF5O1xuICAgIGNhc2UgJ2ludDMyJzpcbiAgICAgIHJldHVybiBJbnQzMkFycmF5O1xuICAgIGNhc2UgJ3VpbnQzMic6XG4gICAgICByZXR1cm4gVWludDMyQXJyYXk7XG4gICAgY2FzZSAnaW50NjQnOlxuICAgICAgcmV0dXJuIEJpZ0ludDY0QXJyYXk7XG4gICAgY2FzZSAnZmxvYXQzMic6XG4gICAgICByZXR1cm4gRmxvYXQzMkFycmF5O1xuICAgIGNhc2UgJ2Zsb2F0NjQnOlxuICAgICAgcmV0dXJuIEZsb2F0NjRBcnJheTtcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gc2hvdWxkIG5ldmVyIHJ1biB0byBoZXJlXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc3BlY2lmaWVkIGVycm9yJyk7XG4gIH1cbn1cblxuLy8gY29udmVydCBhIGxvbmcgbnVtYmVyIHRvIGEgMzItYml0IGludGVnZXIgKGNhc3QtZG93bilcbmZ1bmN0aW9uIGxvbmdUb051bWJlcihpOiBMb25nLCB0eXBlOiBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlIHwgb3J0RmJzLlRlbnNvckRhdGFUeXBlKTogbnVtYmVyIHtcbiAgLy8gSU5UNjQsIFVJTlQzMiwgVUlOVDY0XG4gIGlmICh0eXBlID09PSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDY0IHx8IHR5cGUgPT09IG9ydEZicy5UZW5zb3JEYXRhVHlwZS5JTlQ2NCkge1xuICAgIGlmIChpLmdyZWF0ZXJUaGFuT3JFcXVhbCgyMTQ3NDgzNjQ4KSB8fCBpLmxlc3NUaGFuKC0yMTQ3NDgzNjQ4KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW50NjQgaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChcbiAgICB0eXBlID09PSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQzMiB8fFxuICAgIHR5cGUgPT09IG9ydEZicy5UZW5zb3JEYXRhVHlwZS5VSU5UMzIgfHxcbiAgICB0eXBlID09PSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ2NCB8fFxuICAgIHR5cGUgPT09IG9ydEZicy5UZW5zb3JEYXRhVHlwZS5VSU5UNjRcbiAgKSB7XG4gICAgaWYgKGkuZ3JlYXRlclRoYW5PckVxdWFsKDQyOTQ5NjcyOTYpIHx8IGkubGVzc1RoYW4oMCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3VpbnQ2NCBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYG5vdCBhIExPTkcgdHlwZTogJHtvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlW3R5cGVdfWApO1xuICB9XG5cbiAgcmV0dXJuIGkudG9OdW1iZXIoKTtcbn1cblxuLy8gcmVhZCBvbmUgdmFsdWUgZnJvbSBUZW5zb3JQcm90b1xuZnVuY3Rpb24gcmVhZFByb3RvKFxuICB2aWV3OiBEYXRhVmlldyxcbiAgdHlwZTogb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZSB8IG9ydEZicy5UZW5zb3JEYXRhVHlwZSxcbiAgYnl0ZU9mZnNldDogbnVtYmVyLFxuKTogbnVtYmVyIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkJPT0w6XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ4OlxuICAgICAgcmV0dXJuIHZpZXcuZ2V0VWludDgoYnl0ZU9mZnNldCk7XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDg6XG4gICAgICByZXR1cm4gdmlldy5nZXRJbnQ4KGJ5dGVPZmZzZXQpO1xuICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMTY6XG4gICAgICByZXR1cm4gdmlldy5nZXRVaW50MTYoYnl0ZU9mZnNldCwgdHJ1ZSk7XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDE2OlxuICAgICAgcmV0dXJuIHZpZXcuZ2V0SW50MTYoYnl0ZU9mZnNldCwgdHJ1ZSk7XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkZMT0FUOlxuICAgICAgcmV0dXJuIHZpZXcuZ2V0RmxvYXQzMihieXRlT2Zmc2V0LCB0cnVlKTtcbiAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UMzI6XG4gICAgICByZXR1cm4gdmlldy5nZXRJbnQzMihieXRlT2Zmc2V0LCB0cnVlKTtcbiAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDMyOlxuICAgICAgcmV0dXJuIHZpZXcuZ2V0VWludDMyKGJ5dGVPZmZzZXQsIHRydWUpO1xuICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQ2NDpcbiAgICAgIHJldHVybiBsb25nVG9OdW1iZXIoXG4gICAgICAgIExvbmcuZnJvbUJpdHModmlldy5nZXRVaW50MzIoYnl0ZU9mZnNldCwgdHJ1ZSksIHZpZXcuZ2V0VWludDMyKGJ5dGVPZmZzZXQgKyA0LCB0cnVlKSwgZmFsc2UpLFxuICAgICAgICB0eXBlLFxuICAgICAgKTtcbiAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuRE9VQkxFOlxuICAgICAgcmV0dXJuIHZpZXcuZ2V0RmxvYXQ2NChieXRlT2Zmc2V0LCB0cnVlKTtcbiAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDY0OlxuICAgICAgcmV0dXJuIGxvbmdUb051bWJlcihcbiAgICAgICAgTG9uZy5mcm9tQml0cyh2aWV3LmdldFVpbnQzMihieXRlT2Zmc2V0LCB0cnVlKSwgdmlldy5nZXRVaW50MzIoYnl0ZU9mZnNldCArIDQsIHRydWUpLCB0cnVlKSxcbiAgICAgICAgdHlwZSxcbiAgICAgICk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IHJlYWQgZnJvbSBEYXRhVmlldyBmb3IgdHlwZSAke29ubnguVGVuc29yUHJvdG8uRGF0YVR5cGVbdHlwZV19YCk7XG4gIH1cbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuLyoqXG4gKiByZXByZXNlbnQgYSB2ZXJzaW9uIGlycmVsZXZhbnQgYWJzdHJhY3Rpb24gb2YgZm9yIEdMU0wgc291cmNlIGNvZGVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBHbHNsIHtcbiAgcmVhZG9ubHkgdmVyc2lvbjogc3RyaW5nO1xuICByZWFkb25seSBhdHRyaWJ1dGU6IHN0cmluZztcbiAgcmVhZG9ubHkgdmFyeWluZ1ZlcnRleDogc3RyaW5nO1xuICByZWFkb25seSB2YXJ5aW5nRnJhZzogc3RyaW5nO1xuICByZWFkb25seSB0ZXh0dXJlMkQ6IHN0cmluZztcbiAgcmVhZG9ubHkgb3V0cHV0OiBzdHJpbmc7XG4gIHJlYWRvbmx5IG91dHB1dERlY2xhcmF0aW9uOiBzdHJpbmc7XG59XG5cbmNvbnN0IEdMU0xfRVNfMl8wOiBHbHNsID0ge1xuICB2ZXJzaW9uOiAnJyxcbiAgYXR0cmlidXRlOiAnYXR0cmlidXRlJyxcbiAgdmFyeWluZ1ZlcnRleDogJ3ZhcnlpbmcnLFxuICB2YXJ5aW5nRnJhZzogJ3ZhcnlpbmcnLFxuICB0ZXh0dXJlMkQ6ICd0ZXh0dXJlMkQnLFxuICBvdXRwdXQ6ICdnbF9GcmFnQ29sb3InLFxuICBvdXRwdXREZWNsYXJhdGlvbjogJycsXG59O1xuY29uc3QgR0xTTF9FU18zXzA6IEdsc2wgPSB7XG4gIHZlcnNpb246ICcjdmVyc2lvbiAzMDAgZXMnLFxuICBhdHRyaWJ1dGU6ICdpbicsXG4gIHZhcnlpbmdWZXJ0ZXg6ICdvdXQnLFxuICB2YXJ5aW5nRnJhZzogJ2luJyxcbiAgdGV4dHVyZTJEOiAndGV4dHVyZScsXG4gIG91dHB1dDogJ291dHB1dENvbG9yJyxcbiAgb3V0cHV0RGVjbGFyYXRpb246ICdvdXQgdmVjNCBvdXRwdXRDb2xvcjsnLFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEdsc2wodmVyc2lvbjogMSB8IDIpIHtcbiAgcmV0dXJuIHZlcnNpb24gPT09IDEgPyBHTFNMX0VTXzJfMCA6IEdMU0xfRVNfM18wO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmVydGV4U2hhZGVyU291cmNlKHZlcnNpb246IDEgfCAyKTogc3RyaW5nIHtcbiAgY29uc3QgZ2xzbCA9IGdldEdsc2wodmVyc2lvbik7XG4gIHJldHVybiBgJHtnbHNsLnZlcnNpb259XG4gICAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgICAke2dsc2wuYXR0cmlidXRlfSB2ZWMzIHBvc2l0aW9uO1xuICAgICAgJHtnbHNsLmF0dHJpYnV0ZX0gdmVjMiB0ZXh0dXJlQ29vcmQ7XG5cbiAgICAgICR7Z2xzbC52YXJ5aW5nVmVydGV4fSB2ZWMyIFRleENvb3JkcztcblxuICAgICAgdm9pZCBtYWluKClcbiAgICAgIHtcbiAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQocG9zaXRpb24sIDEuMCk7XG4gICAgICAgICAgVGV4Q29vcmRzID0gdGV4dHVyZUNvb3JkO1xuICAgICAgfWA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGcmFnU2hhZGVyUHJlYW1ibGUodmVyc2lvbjogMSB8IDIpOiBzdHJpbmcge1xuICBjb25zdCBnbHNsID0gZ2V0R2xzbCh2ZXJzaW9uKTtcbiAgcmV0dXJuIGAke2dsc2wudmVyc2lvbn1cbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgcHJlY2lzaW9uIGhpZ2hwIGludDtcbiAgICBwcmVjaXNpb24gaGlnaHAgc2FtcGxlcjJEO1xuICAgICR7Z2xzbC52YXJ5aW5nRnJhZ30gdmVjMiBUZXhDb29yZHM7XG4gICAgJHtnbHNsLm91dHB1dERlY2xhcmF0aW9ufVxuICAgIGNvbnN0IHZlYzIgaGFsZkNSID0gdmVjMigwLjUsIDAuNSk7XG5cbiAgICAvLyBDdXN0b20gdmVjdG9yIHR5cGVzIHRvIGhhbmRsZSBoaWdoZXIgZGltZW5hbGl0aWVzLlxuICAgIHN0cnVjdCBpdmVjNVxuICAgIHtcbiAgICAgIGludCB4O1xuICAgICAgaW50IHk7XG4gICAgICBpbnQgejtcbiAgICAgIGludCB3O1xuICAgICAgaW50IHU7XG4gICAgfTtcblxuICAgIHN0cnVjdCBpdmVjNlxuICAgIHtcbiAgICAgIGludCB4O1xuICAgICAgaW50IHk7XG4gICAgICBpbnQgejtcbiAgICAgIGludCB3O1xuICAgICAgaW50IHU7XG4gICAgICBpbnQgdjtcbiAgICB9O1xuXG4gICAgaW50IGltb2QoaW50IHgsIGludCB5KSB7XG4gICAgICByZXR1cm4geCAtIHkgKiAoeCAvIHkpO1xuICAgIH1cblxuICAgIGA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREZWZhdWx0RnJhZ1NoYWRlck1haW4odmVyc2lvbjogMSB8IDIsIG91dHB1dFNoYXBlTGVuZ3RoOiBudW1iZXIpOiBzdHJpbmcge1xuICBjb25zdCBnbHNsID0gZ2V0R2xzbCh2ZXJzaW9uKTtcbiAgcmV0dXJuIGBcbiAgdm9pZCBtYWluKCkge1xuICAgIGludCBpbmRpY2VzWyR7b3V0cHV0U2hhcGVMZW5ndGh9XTtcbiAgICB0b1ZlYyhUZXhDb29yZHMsIGluZGljZXMpO1xuICAgIHZlYzQgcmVzdWx0ID0gdmVjNChwcm9jZXNzKGluZGljZXMpKTtcbiAgICAke2dsc2wub3V0cHV0fSA9IHJlc3VsdDtcbiAgfVxuICBgO1xufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBUZW5zb3IgfSBmcm9tICcuLi8uLi90ZW5zb3InO1xuXG4vKipcbiAqIExheW91dCBpbmZvIGlzIHVzZWQgZm9yIG1hcHBpbmcgbi1kaW1lbnNpb25hbCBhcnJheSB0byAyRCB0ZXh0dXJlc1xuICogVGhlIGxheW91dCBpcyBjcmVhdGVkIGJ5IHRoZSBUZXh0dXJlTGF5b3V0U3RyYXRlZ3kgYmFzZWQgb25cbiAqIHRoZSBUZW5zb3IncyBkaW1lbnNpb25zIGFuZCBzdHJpZGVzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGV4dHVyZUxheW91dCB7XG4gIHdpZHRoOiBudW1iZXI7XG4gIGhlaWdodDogbnVtYmVyO1xuICAvKipcbiAgICogc3BlY2lmeSB0aGUgbnVtYmVyIG9mIHZhbHVlIHRoYXQgZW5jb2RlZCBpbiBhIHNpbmdsZSBwaXhlbFxuICAgKi9cbiAgY2hhbm5lbHM6IDEgfCAyIHwgMyB8IDQ7XG4gIC8qKlxuICAgKiB3aGV0aGVyIGluIHBhY2tlZCBtb2RlIG9yIG5vdFxuICAgKi9cbiAgaXNQYWNrZWQ/OiBib29sZWFuO1xuICAvKipcbiAgICogdGhlIG5vcm1hbGl6ZWQgc2hhcGVcbiAgICovXG4gIHNoYXBlOiByZWFkb25seSBudW1iZXJbXTtcbiAgLyoqXG4gICAqIHRoZSBzdHJpZGUgb2YgZWFjaCBkaW1lbnNpb25zLCBjYWxjdWxhdGVkIGFjY29yZGluZyB0byBzaGFwZVxuICAgKi9cbiAgc3RyaWRlczogcmVhZG9ubHkgbnVtYmVyW107XG4gIC8qKlxuICAgKiB0aGUgb3JpZ2luYWwgc2hhcGUoZGltcykgb2YgdGhlIGNvcnJlc3BvbmRpbmcgdGVuc29yXG4gICAqL1xuICB1bnBhY2tlZFNoYXBlOiByZWFkb25seSBudW1iZXJbXTtcblxuICByZXZlcnNlZFdIPzogYm9vbGVhbjtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgVGV4dHVyZURhdGEgZXh0ZW5kcyBUZXh0dXJlTGF5b3V0IHtcbiAgdGVuc29yOiBUZW5zb3I7XG4gIHRleHR1cmU6IFdlYkdMVGV4dHVyZTtcbn1cblxuZXhwb3J0IGVudW0gVGV4dHVyZVR5cGUge1xuICB1bnBhY2tlZCwgLy8gPC0tIG5vcm1hbCB1bnBhY2tlZCB0ZXh0dXJlXG4gIHVucGFja2VkUmV2ZXJzZWQsIC8vIDwtLSB1bnBhY2tlZCB0ZXh0dXJlIHVzZWQgaW4gb2xkIE9OTlguanMgaW1wbGVtZW50YXRpb24gKGRlcHJlY2F0ZWQpXG4gIHBhY2tlZCwgLy8gPC0tIG5vcm1hbCBwYWNrZWQgdGV4dHVyZVxuICBkb3dubG9hZFVpbnQ4QXNGbG9hdCwgLy8gPC0tIE9OTFkgdXNlZCBpbiB0ZXh0dXJlIGRvd25sb2FkaW5nIGZvciBpT1MgZGV2aWNlc1xuICBwYWNrZWRMYXN0RGltZW5zaW9uLCAvLyA8LS0gT05MWSB1c2VkIGluIG9sZCBPTk5YLmpzIENvbnYgaW1wbGVtZW50YXRpb24gZm9yIGlucHV0IFcgKGRlcHJlY2F0ZWQpXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGVuc29ySW5mbyB7XG4gIGlkPzogVGVuc29yLklkO1xuICBkaW1zOiByZWFkb25seSBudW1iZXJbXTtcbiAgdHlwZTogVGVuc29yLkRhdGFUeXBlO1xuICB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvZ3JhbVZhcmlhYmxlIHtcbiAgdHlwZTogJ2Zsb2F0JyB8ICdpbnQnO1xuICBuYW1lOiBzdHJpbmc7XG4gIGFycmF5TGVuZ3RoPzogbnVtYmVyO1xuICBkYXRhOiBudW1iZXIgfCBudW1iZXJbXTtcbn1cblxuLyoqXG4gKiBBIHNldCBvZiBtZXRhZGF0YSBvZiBhIHNoYWRlciBwcm9ncmFtLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFByb2dyYW1NZXRhZGF0YSB7XG4gIC8qKlxuICAgKiB0aGUgbmFtZSBvZiB0aGUgcHJvZ3JhbS4gdXNlZCBmb3IgZGVidWdnaW5nIGFuZCBwcm9maWxpbmdcbiAgICovXG4gIG5hbWU6IHN0cmluZztcbiAgLyoqXG4gICAqIHRleHR1cmUgdHlwZXMgZm9yIGVhY2ggaW5wdXRcbiAgICovXG4gIGlucHV0VHlwZXM6IFRleHR1cmVUeXBlW107XG4gIC8qKlxuICAgKiBuYW1lcyBvZiBlYWNoIGlucHV0XG4gICAqL1xuICBpbnB1dE5hbWVzOiBzdHJpbmdbXTtcbiAgLyoqXG4gICAqIGFuIG9wdGlvbmFsIHN0cmluZyBhcyBhIGNhY2hlIGhpbnQgaW4gdGhlIGFydGlmYWN0IGNhY2hlXG4gICAqL1xuICBjYWNoZUhpbnQ/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogQSBQcm9ncmFtSW5mb0xvYWRlciBhbGxvd3NcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQcm9ncmFtSW5mb0xvYWRlciBleHRlbmRzIFByb2dyYW1NZXRhZGF0YSB7XG4gIC8qKlxuICAgKiBhIGZ1bmN0aW9uIHRvIGdldCB0aGUgcHJvZ3JhbSBpbmZvXG4gICAqL1xuICBnZXQoKTogUHJvZ3JhbUluZm87XG59XG5cbi8qKlxuICogQSBzZXQgb2YgZGF0YSB0aGF0IHJlcHJlc2VudCBhIHNoYWRlciBwcm9ncmFtXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUHJvZ3JhbUluZm8gZXh0ZW5kcyBQcm9ncmFtTWV0YWRhdGEge1xuICAvKipcbiAgICogaW5mb3JtYXRpb24gb2YgdW5pZm9ybSB2YXJpYWJsZXNcbiAgICovXG4gIHZhcmlhYmxlcz86IFByb2dyYW1WYXJpYWJsZVtdO1xuICAvKipcbiAgICogdGVuc29yIGluZm8gZm9yIG91dHB1dFxuICAgKi9cbiAgb3V0cHV0OiBUZW5zb3JJbmZvO1xuICAvKipcbiAgICogdGhlIHNoYWRlcidzIHByb2Nlc3Npbmcgc291cmNlIGNvZGVcbiAgICovXG4gIHNoYWRlclNvdXJjZTogc3RyaW5nO1xuICAvKipcbiAgICogd2hldGhlciB0aGUgc2hhZGVyIHNvdXJjZSBjb250YWlucyBhIGN1c3RvbWl6ZWQgbWFpbiBmdW5jdGlvbiBpbXBsZW1lbnRhdGlvblxuICAgKi9cbiAgaGFzTWFpbj86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmFyaWFibGVJbmZvIHtcbiAgdHlwZTogJ2Zsb2F0JyB8ICdpbnQnO1xuICBuYW1lOiBzdHJpbmc7XG4gIGFycmF5TGVuZ3RoPzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb2dyYW1WYXJpYWJsZSB7XG4gIHR5cGU6ICdmbG9hdCcgfCAnaW50JztcbiAgbmFtZTogc3RyaW5nO1xuICBhcnJheUxlbmd0aD86IG51bWJlcjtcbiAgZGF0YTogbnVtYmVyIHwgbnVtYmVyW107XG59XG5cbi8qKlxuICogSW5mb3JtYXRpb24gb2YgdW5pZm9ybXMgdGhhdCBzaGFkZXIgdXNlc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFVuaWZvcm1JbmZvIHtcbiAgdHlwZTogJ3NhbXBsZXIyRCcgfCBWYXJpYWJsZUluZm9bJ3R5cGUnXTtcbiAgbmFtZTogc3RyaW5nO1xuICBhcnJheUxlbmd0aD86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVbmlmb3JtTG9jYXRpb24gZXh0ZW5kcyBVbmlmb3JtSW5mbyB7XG4gIGxvY2F0aW9uOiBXZWJHTFVuaWZvcm1Mb2NhdGlvbjtcbn1cblxuLyoqXG4gKiBBcnRpZmFjdCBpcyB0aGUgcmVzdWx0IG9mIGNvbXBpbGF0aW9uXG4gKiBJdCBkb2VzIG5vdCBjb250YWluIGlucHV0IG9mIG91dHB1dCBkYXRhXG4gKiBIb3dldmVyIGFueXRoaW5nIHRoYXQgY291bGQgYmUgcnVuIGFzIGEgXCJwcm9ncmFtXCJcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBcnRpZmFjdCB7XG4gIHByb2dyYW1JbmZvOiBQcm9ncmFtSW5mbztcbiAgcHJvZ3JhbTogV2ViR0xQcm9ncmFtO1xuICB1bmlmb3JtTG9jYXRpb25zOiBVbmlmb3JtTG9jYXRpb25bXTtcbiAgYXR0cmliTG9jYXRpb25zOiB7IHBvc2l0aW9uOiBudW1iZXI7IHRleHR1cmVDb29yZDogbnVtYmVyIH07XG59XG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgQXJ0aWZhY3Qge1xuICB0eXBlIFVuaWZvcm1Mb2NhdGlvbnMgPSBBcnRpZmFjdFsndW5pZm9ybUxvY2F0aW9ucyddO1xuICB0eXBlIEF0dHJpYkxvY2F0aW9ucyA9IEFydGlmYWN0WydhdHRyaWJMb2NhdGlvbnMnXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVbmlmb3JtRGF0YSB7XG4gIFtuYW1lOiBzdHJpbmddOiBudW1iZXIgfCBudW1iZXJbXTtcbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnLi4vLi4vdXRpbCc7XG4vKipcbiAqIEdpdmVuIGEgbm9uIFJHQkEgc2hhcGUgY2FsY3VsYXRlIHRoZSBSIHZlcnNpb25cbiAqIEl0IGlzIGFzc3VtZWQgdGhhdCB0aGUgZGltZW5zaW9ucyBhcmUgbXVsdGlwbGVzIG9mIGdpdmVuIGNoYW5uZWxzXG4gKiBOT1RFOiBpdCBpcyBhbHdheXMgdGhlIGxhc3QgZGltIHRoYXQgZ2V0cyBwYWNrZWQuXG4gKiBAcGFyYW0gdW5wYWNrZWRTaGFwZSBvcmlnaW5hbCBzaGFwZSB0byBjcmVhdGUgYSBwYWNrZWQgdmVyc2lvbiBmcm9tXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQYWNrZWRTaGFwZSh1bnBhY2tlZFNoYXBlOiByZWFkb25seSBudW1iZXJbXSk6IHJlYWRvbmx5IG51bWJlcltdIHtcbiAgY29uc3QgbGVuID0gdW5wYWNrZWRTaGFwZS5sZW5ndGg7XG4gIHJldHVybiB1bnBhY2tlZFNoYXBlLnNsaWNlKDAsIGxlbiAtIDEpLmNvbmNhdCh1bnBhY2tlZFNoYXBlW2xlbiAtIDFdIC8gNCk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZXBlYXRlZFRyeShcbiAgY2hlY2tGbjogKCkgPT4gYm9vbGVhbixcbiAgZGVsYXlGbiA9IChfY291bnRlcjogbnVtYmVyKSA9PiAwLFxuICBtYXhDb3VudGVyPzogbnVtYmVyLFxuKTogUHJvbWlzZTx2b2lkPiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgbGV0IHRyeUNvdW50ID0gMDtcblxuICAgIGNvbnN0IHRyeUZuID0gKCkgPT4ge1xuICAgICAgaWYgKGNoZWNrRm4oKSkge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdHJ5Q291bnQrKztcblxuICAgICAgY29uc3QgbmV4dEJhY2tvZmYgPSBkZWxheUZuKHRyeUNvdW50KTtcblxuICAgICAgaWYgKG1heENvdW50ZXIgIT0gbnVsbCAmJiB0cnlDb3VudCA+PSBtYXhDb3VudGVyKSB7XG4gICAgICAgIHJlamVjdCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZXRUaW1lb3V0KHRyeUZuLCBuZXh0QmFja29mZik7XG4gICAgfTtcblxuICAgIHRyeUZuKCk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyB0aGUgZnVuY3Rpb24gbmFtZSBmcm9tIGFuIGlucHV0IHNhbXBsZXIgbmFtZS5cbiAqIEBwYXJhbSBzYW1wbGVyTmFtZSBOYW1lIG9mIHRoZSBzYW1wbGVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVTaGFkZXJGdW5jTmFtZUZyb21JbnB1dFNhbXBsZXJOYW1lKHNhbXBsZXJOYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICBhc3NlcnQodHlwZW9mIHNhbXBsZXJOYW1lICE9PSAndW5kZWZpbmVkJyAmJiBzYW1wbGVyTmFtZS5sZW5ndGggIT09IDAsICgpID0+ICdlbXB0eSBzdHJpbmcgZm91bmQgZm9yIHNhbXBsZXIgbmFtZScpO1xuICByZXR1cm4gJ2dldCcgKyBzYW1wbGVyTmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHNhbXBsZXJOYW1lLnNsaWNlKDEpO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyB0aGUgZnVuY3Rpb24gbmFtZSBmcm9tIGFuIGlucHV0IHNhbXBsZXIgbmFtZSBhdCBvdXRwdXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0gc2FtcGxlck5hbWUgTmFtZSBvZiB0aGUgc2FtcGxlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlU2hhZGVyRnVuY05hbWVGcm9tSW5wdXRTYW1wbGVyTmFtZUF0T3V0Q29vcmRzKHNhbXBsZXJOYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICBhc3NlcnQodHlwZW9mIHNhbXBsZXJOYW1lICE9PSAndW5kZWZpbmVkJyAmJiBzYW1wbGVyTmFtZS5sZW5ndGggIT09IDAsICgpID0+ICdlbXB0eSBzdHJpbmcgZm91bmQgZm9yIHNhbXBsZXIgbmFtZScpO1xuICByZXR1cm4gJ2dldCcgKyBzYW1wbGVyTmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHNhbXBsZXJOYW1lLnNsaWNlKDEpICsgJ0F0T3V0Q29vcmRzJztcbn1cblxuLyoqIFJldHVybnMgYSBuZXcgaW5wdXQgc2hhcGUgKGEgY29weSkgdGhhdCBoYXMgYSBzcXVlZXplZCBsb2dpY2FsIHNoYXBlLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNxdWVlemVJbnB1dFNoYXBlKGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBzcXVlZXplZFNoYXBlOiBudW1iZXJbXSk6IG51bWJlcltdIHtcbiAgLy8gRGVlcCBjb3B5LlxuICBsZXQgbmV3SW5wdXRTaGFwZTogbnVtYmVyW10gPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGlucHV0U2hhcGUpKTtcbiAgbmV3SW5wdXRTaGFwZSA9IHNxdWVlemVkU2hhcGU7XG4gIHJldHVybiBuZXdJbnB1dFNoYXBlO1xufVxuXG4vKiogUmV0dXJucyBhIGxpc3Qgb2Ygc3F1ZWV6ZWQgcGFyYW1ldGVycyBmb3Igc2hhZGVyIGZ1bmN0aW9ucyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNxdWVlemVkUGFyYW1zKHBhcmFtczogc3RyaW5nW10sIGtlcHREaW1zOiBudW1iZXJbXSk6IHN0cmluZyB7XG4gIHJldHVybiBrZXB0RGltcy5tYXAoKGQpID0+IHBhcmFtc1tkXSkuam9pbignLCAnKTtcbn1cblxuLyoqIFJldHVybnMgdGhlIGRhdGEgdHlwZSBmb3IgZGlmZmVyZW50IHJhbmtzLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENvb3Jkc0RhdGFUeXBlKHJhbms6IG51bWJlcik6IHN0cmluZyB7XG4gIGlmIChyYW5rIDw9IDEpIHtcbiAgICByZXR1cm4gJ2ludCc7XG4gIH0gZWxzZSBpZiAocmFuayA9PT0gMikge1xuICAgIHJldHVybiAnaXZlYzInO1xuICB9IGVsc2UgaWYgKHJhbmsgPT09IDMpIHtcbiAgICByZXR1cm4gJ2l2ZWMzJztcbiAgfSBlbHNlIGlmIChyYW5rID09PSA0KSB7XG4gICAgcmV0dXJuICdpdmVjNCc7XG4gIH0gZWxzZSBpZiAocmFuayA9PT0gNSkge1xuICAgIHJldHVybiAnaXZlYzUnO1xuICB9IGVsc2UgaWYgKHJhbmsgPT09IDYpIHtcbiAgICByZXR1cm4gJ2l2ZWM2JztcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBFcnJvcihgR1BVIGZvciByYW5rICR7cmFua30gaXMgbm90IHlldCBzdXBwb3J0ZWRgKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0R2xDaGFubmVscyhyYW5rID0gNik6IHN0cmluZ1tdIHtcbiAgcmV0dXJuIFsneCcsICd5JywgJ3onLCAndycsICd1JywgJ3YnXS5zbGljZSgwLCByYW5rKTtcbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgZ2V0R2xDaGFubmVscyB9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFZlY0NoYW5uZWxzKG5hbWU6IHN0cmluZywgcmFuazogbnVtYmVyKTogc3RyaW5nW10ge1xuICByZXR1cm4gZ2V0R2xDaGFubmVscyhyYW5rKS5tYXAoKGQpID0+IGAke25hbWV9LiR7ZH1gKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldENoYW5uZWxzKG5hbWU6IHN0cmluZywgcmFuazogbnVtYmVyKTogc3RyaW5nW10ge1xuICBpZiAocmFuayA9PT0gMSkge1xuICAgIHJldHVybiBbbmFtZV07XG4gIH1cbiAgcmV0dXJuIGdldFZlY0NoYW5uZWxzKG5hbWUsIHJhbmspO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdW5wYWNrRnJvbUNoYW5uZWwoKTogc3RyaW5nIHtcbiAgcmV0dXJuIGBcbiAgICBmbG9hdCBnZXRDaGFubmVsKHZlYzQgZnJhZywgaW50IGRpbSkge1xuICAgICAgaW50IG1vZENvb3JkID0gaW1vZChkaW0sIDIpO1xuICAgICAgcmV0dXJuIG1vZENvb3JkID09IDAgPyBmcmFnLnIgOiBmcmFnLmc7XG4gICAgfVxuXG4gICAgZmxvYXQgZ2V0Q2hhbm5lbCh2ZWM0IGZyYWcsIHZlYzIgaW5uZXJEaW1zKSB7XG4gICAgICB2ZWMyIG1vZENvb3JkID0gbW9kKGlubmVyRGltcywgMi4pO1xuICAgICAgcmV0dXJuIG1vZENvb3JkLnggPT0gMC4gP1xuICAgICAgICAobW9kQ29vcmQueSA9PSAwLiA/IGZyYWcuciA6IGZyYWcuZykgOlxuICAgICAgICAobW9kQ29vcmQueSA9PSAwLiA/IGZyYWcuYiA6IGZyYWcuYSk7XG4gICAgfVxuICBgO1xufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBUZW5zb3IgfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHsgZ2V0R2xzbCB9IGZyb20gJy4uL2dsc2wtc291cmNlJztcbmltcG9ydCB7IFdlYkdMSW5mZXJlbmNlSGFuZGxlciB9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7IFByb2dyYW1JbmZvLCBQcm9ncmFtSW5mb0xvYWRlciwgVGV4dHVyZVR5cGUgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBnZXRDb29yZHNEYXRhVHlwZSB9IGZyb20gJy4uL3V0aWxzJztcblxuaW1wb3J0IHsgZ2V0Q2hhbm5lbHMgfSBmcm9tICcuL3BhY2tpbmctdXRpbHMnO1xuXG5jb25zdCBwYWNrUHJvZ3JhbU1ldGFkYXRhID0ge1xuICBuYW1lOiAncGFjaycsXG4gIGlucHV0TmFtZXM6IFsnQSddLFxuICBpbnB1dFR5cGVzOiBbVGV4dHVyZVR5cGUudW5wYWNrZWRSZXZlcnNlZF0sXG59O1xuXG5jb25zdCBjcmVhdGVQYWNrUHJvZ3JhbUluZm8gPSAoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dDogVGVuc29yKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBnbHNsID0gZ2V0R2xzbChoYW5kbGVyLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbik7XG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dC5kaW1zO1xuXG4gIGNvbnN0IGlucHV0UmFuayA9IGlucHV0U2hhcGUubGVuZ3RoO1xuICAvLyBjcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlIHdvbid0IGNoYW5nZSBvdXRwdXQgcmFuay4gTmVlZCB0byB2ZXJpZnkgYnkgcnVubmluZyB0ZXN0c1xuICBjb25zdCBvdXRwdXRSYW5rID0gaW5wdXQuZGltcy5sZW5ndGg7XG5cbiAgY29uc3QgY29vcmRzRGF0YVR5cGUgPSBnZXRDb29yZHNEYXRhVHlwZShvdXRwdXRSYW5rKTtcbiAgY29uc3QgY2hhbm5lbHMgPSBnZXRDaGFubmVscygncmMnLCBvdXRwdXRSYW5rKTtcbiAgY29uc3Qgc2V0dXAgPSBnZXRTZXR1cChvdXRwdXRSYW5rLCBjaGFubmVscywgaW5wdXRTaGFwZVtpbnB1dFNoYXBlLmxlbmd0aCAtIDJdLCBpbnB1dFNoYXBlW2lucHV0U2hhcGUubGVuZ3RoIC0gMV0pO1xuXG4gIGxldCByZXZlcnNlZElucHV0V0g7XG4gIGlmIChpbnB1dFJhbmsgPT09IDApIHtcbiAgICByZXZlcnNlZElucHV0V0ggPSBbMSwgMV07XG4gIH0gZWxzZSBpZiAoaW5wdXRSYW5rID09PSAxKSB7XG4gICAgcmV2ZXJzZWRJbnB1dFdIID0gW2lucHV0U2hhcGVbMF0sIDFdO1xuICB9IGVsc2Uge1xuICAgIHJldmVyc2VkSW5wdXRXSCA9IFtpbnB1dFNoYXBlW291dHB1dFJhbmsgLSAxXSwgaW5wdXRTaGFwZVtvdXRwdXRSYW5rIC0gMl1dO1xuICB9XG4gIGNvbnN0IG91dE9mQm91bmRzQ29uZGl0aW9uID0gZ2V0T3V0T2ZCb3VuZHNDb25kaXRpb24ob3V0cHV0UmFuaywgcmV2ZXJzZWRJbnB1dFdILCBjaGFubmVscyk7XG4gIGNvbnN0IG91dHB1dCA9IGdldE91dHB1dChpbnB1dFNoYXBlLCBjaGFubmVscyk7XG5cbiAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgJHtjb29yZHNEYXRhVHlwZX0gcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcblxuICAgICAgICAgIGlmKCR7b3V0T2ZCb3VuZHNDb25kaXRpb259KSB7XG4gICAgICAgICAgICAke2dsc2wub3V0cHV0fSA9IHZlYzQoMCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICR7c2V0dXB9XG5cbiAgICAgICAgICAgICR7Z2xzbC5vdXRwdXR9ID0gdmVjNCgke291dHB1dH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgYDtcbiAgcmV0dXJuIHtcbiAgICAuLi5wYWNrUHJvZ3JhbU1ldGFkYXRhLFxuICAgIGhhc01haW46IHRydWUsXG4gICAgb3V0cHV0OiB7IGRpbXM6IGlucHV0LmRpbXMsIHR5cGU6IGlucHV0LnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS5wYWNrZWQgfSxcbiAgICBzaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlUGFja1Byb2dyYW1JbmZvTG9hZGVyID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXQ6IFRlbnNvcik6IFByb2dyYW1JbmZvTG9hZGVyID0+ICh7XG4gIC4uLnBhY2tQcm9ncmFtTWV0YWRhdGEsXG4gIGdldDogKCkgPT4gY3JlYXRlUGFja1Byb2dyYW1JbmZvKGhhbmRsZXIsIGlucHV0KSxcbn0pO1xuXG4vKipcbiAqIGNoZWNrIG91dHB1dCBjb29yZGluYXRlIGxvY2F0aW9uIGFuZCByZXR1cm4gZmFsc2UgaWYgaXQgaXMgb3V0c2lkZSBpbnB1dCdzIHdpZHRoL2hlaWdodCBib3VuZGFyeVxuICovXG5mdW5jdGlvbiBnZXRPdXRPZkJvdW5kc0NvbmRpdGlvbihyYW5rOiBudW1iZXIsIHNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgZGltczogc3RyaW5nW10pOiBzdHJpbmcge1xuICBpZiAocmFuayA9PT0gMCkge1xuICAgIHJldHVybiAnZmFsc2UnO1xuICB9XG4gIGlmIChyYW5rID09PSAxKSB7XG4gICAgcmV0dXJuIGByYyA+ICR7c2hhcGVbMF19YDtcbiAgfVxuXG4gIGxldCBjb25kID0gJyc7XG4gIGZvciAobGV0IGkgPSByYW5rIC0gMjsgaSA8IHJhbms7IGkrKykge1xuICAgIGNvbmQgKz0gYCR7ZGltc1tpXX0gPj0gJHtzaGFwZVtpIC0gcmFuayArIDJdfWA7XG4gICAgaWYgKGkgPCByYW5rIC0gMSkge1xuICAgICAgY29uZCArPSAnfHwnO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25kO1xufVxuXG4vKipcbiAqIGNvZGUgc25pcHBldCB0byBzYW1wbGUgaW5wdXQgdGV4dHVyZSB3aXRoIG91dHB1dCBjb29yZGluYXRlc1xuICovXG5mdW5jdGlvbiBnZXRPdXRwdXQoc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBkaW1zOiBzdHJpbmdbXSk6IHN0cmluZyB7XG4gIGNvbnN0IHJhbmsgPSBzaGFwZS5sZW5ndGg7XG5cbiAgaWYgKHJhbmsgPT09IDApIHtcbiAgICByZXR1cm4gJ2dldEEoKSwgMCwgMCwgMCc7XG4gIH1cblxuICBpZiAocmFuayA9PT0gMSkge1xuICAgIHJldHVybiBgZ2V0QShyYyksXG4gICAgICAgICAgICByYyArIDEgPj0gJHtzaGFwZVswXX0gPyAwLiA6IGdldEEocmMgKyAxKSxcbiAgICAgICAgICAgIDAsIDBgO1xuICB9XG5cbiAgY29uc3QgY29vcmQwMCA9ICdyLCBjJztcbiAgY29uc3QgY29vcmQwMSA9ICdyLCBjcDEnO1xuICBjb25zdCBjb29yZDEwID0gJ3JwMSwgYyc7XG4gIGNvbnN0IGNvb3JkMTEgPSAncnAxLCBjcDEnO1xuICBsZXQgRCA9ICcnO1xuICBpZiAocmFuayA+IDIpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmsgLSAyOyArK2kpIHtcbiAgICAgIEQgPSBEICsgYCR7ZGltc1tpXX0sYDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGBnZXRBKCR7RH0ke2Nvb3JkMDB9KSxcbiAgICAgICAgICByRWRnZSA/IDAuIDogZ2V0QSgke0R9JHtjb29yZDEwfSksXG4gICAgICAgICAgY0VkZ2UgPyAwLiA6IGdldEEoJHtEfSR7Y29vcmQwMX0pLFxuICAgICAgICAgIHJFZGdlIHx8IGNFZGdlID8gMC4gOiBnZXRBKCR7RH0ke2Nvb3JkMTF9KWA7XG59XG5cbi8qKlxuICogY29kZSBzbmlwcGV0IHRvIHNldHVwIDQgY29vcmRpbmF0ZXMgYW5kIGVkZ2UgY29uZGl0aW9uc1xuICovXG5mdW5jdGlvbiBnZXRTZXR1cChyYW5rOiBudW1iZXIsIGRpbXM6IHN0cmluZ1tdLCByb3dzOiBudW1iZXIsIGNvbHM6IG51bWJlcik6IHN0cmluZyB7XG4gIGlmIChyYW5rID09PSAwIHx8IHJhbmsgPT09IDEpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgLy8gcmFuayA+PSAyIGZvciB3aWR0aCtoZWlnaHQgcGFjay5cbiAgZWxzZSB7XG4gICAgY29uc3Qgc2V0dXAgPSBgXG4gICAgaW50IHIgPSAke2RpbXNbcmFuayAtIDJdfTtcbiAgICBpbnQgYyA9ICR7ZGltc1tyYW5rIC0gMV19O1xuICAgIGludCBycDEgPSAke2RpbXNbcmFuayAtIDJdfSArIDE7XG4gICAgaW50IGNwMSA9ICR7ZGltc1tyYW5rIC0gMV19ICsgMTtcbiAgICBib29sIHJFZGdlID0gcnAxID49ICR7Y29sc307XG4gICAgYm9vbCBjRWRnZSA9IGNwMSA+PSAke3Jvd3N9O1xuICAgIGA7XG4gICAgcmV0dXJuIHNldHVwO1xuICB9XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi8uLi91dGlsJztcbmltcG9ydCB7IGdldEdsc2wgfSBmcm9tICcuLi9nbHNsLXNvdXJjZSc7XG5pbXBvcnQgeyBXZWJHTEluZmVyZW5jZUhhbmRsZXIgfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQgeyBQcm9ncmFtSW5mbywgUHJvZ3JhbUluZm9Mb2FkZXIsIFByb2dyYW1NZXRhZGF0YSwgVGV4dHVyZVR5cGUgfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IHVucGFja0Zyb21DaGFubmVsIH0gZnJvbSAnLi9wYWNraW5nLXV0aWxzJztcblxuY29uc3QgY3JlYXRlUGFja2VkUmVzaGFwZTNEUHJvZ3JhbU1ldGFkYXRhID0gKG91dHB1dFNoYXBlM0Q6IHJlYWRvbmx5IG51bWJlcltdKSA9PiAoe1xuICBuYW1lOiAnUmVzaGFwZSAocGFja2VkKScsXG4gIGlucHV0VHlwZXM6IFtUZXh0dXJlVHlwZS5wYWNrZWRdLFxuICBpbnB1dE5hbWVzOiBbJ0EnXSxcbiAgY2FjaGVIaW50OiBgJHtvdXRwdXRTaGFwZTNEfWAsXG59KTtcblxuY29uc3QgY3JlYXRlUGFja2VkUmVzaGFwZTNEUHJvZ3JhbUluZm8gPSAoXG4gIGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXQzRDogVGVuc29yLFxuICBtZXRhZGF0YTogUHJvZ3JhbU1ldGFkYXRhLFxuICBvdXRwdXRTaGFwZTNEOiByZWFkb25seSBudW1iZXJbXSxcbik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgaW5wdXRTaGFwZTNEID0gaW5wdXQzRC5kaW1zIGFzIFtudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgY29uc3Qgc3F1ZWV6ZWRPdXRwdXRTaGFwZSA9IG91dHB1dFNoYXBlM0QgYXMgW251bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuXG4gIGxldCBtYWluTG9vcCA9ICcnO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIGxldCBvdXRwdXRDb29yZHMgPSAnJztcbiAgICBzd2l0Y2ggKGkpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgb3V0cHV0Q29vcmRzID0gJ291dHB1dENvb3JkcyA9IHJjOyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgICBvdXRwdXRDb29yZHMgPSAnb3V0cHV0Q29vcmRzID0gaXZlYzMocmMueCwgcmMueSsxLCByYy56KTsnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgb3V0cHV0Q29vcmRzID0gJ291dHB1dENvb3JkcyA9IGl2ZWMzKHJjLngsIHJjLnksIHJjLnorMSk7JztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIG91dHB1dENvb3JkcyA9ICdvdXRwdXRDb29yZHMgPSBpdmVjMyhyYy54LCByYy55KzEsIHJjLnorMSk7JztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICB9XG5cbiAgICBtYWluTG9vcCArPSBgXG4gICAgICAgICR7b3V0cHV0Q29vcmRzfVxuICAgICAgICAke2kgPiAwID8gJ2lmKG91dHB1dENvb3Jkcy55IDwgcm93cyAmJiBvdXRwdXRDb29yZHMueiA8IGNvbHMpeycgOiAnJ31cbiAgICAgICAgICBpbnQgZmxhdHRlbmVkSW5kZXggPSBnZXRGbGF0dGVuZWRJbmRleChvdXRwdXRDb29yZHMpO1xuXG4gICAgICAgICAgaXZlYzMgaW5wdXRSQyA9IGlucHV0Q29vcmRzRnJvbVJlc2hhcGVkT3V0Q29vcmRzKGZsYXR0ZW5lZEluZGV4KTtcbiAgICAgICAgICB2ZWMyIGlubmVyRGltcyA9IHZlYzIoZmxvYXQoaW5wdXRSQy55KSxmbG9hdChpbnB1dFJDLnopKTtcblxuICAgICAgICAgIHJlc3VsdFske2l9XSA9IGdldENoYW5uZWwoZ2V0QShpbnB1dFJDLngsIGlucHV0UkMueSwgaW5wdXRSQy56KSwgaW5uZXJEaW1zKTtcblxuICAgICAgICAke2kgPiAwID8gJ30nIDogJyd9XG4gICAgICBgO1xuICB9XG4gIGNvbnN0IGdsc2wgPSBnZXRHbHNsKGhhbmRsZXIuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKTtcblxuICBjb25zdCBzaGFkZXJTb3VyY2UgPSBgXG4gICAgICAke2dldFJlc2hhcGVkSW5wdXRDb29yZHMoaW5wdXRTaGFwZTNEKX1cbiAgICAgICR7Z2V0RmxhdHRlbmVkSW5kZXhGcm9tM0Qoc3F1ZWV6ZWRPdXRwdXRTaGFwZSl9XG4gICAgICAke3VucGFja0Zyb21DaGFubmVsKCl9XG5cbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgaXZlYzMgcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcblxuICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoMC4wKTtcblxuICAgICAgICBpdmVjMyBvdXRwdXRDb29yZHM7XG4gICAgICAgIGludCByb3dzID0gJHtzcXVlZXplZE91dHB1dFNoYXBlWzJdfTtcbiAgICAgICAgaW50IGNvbHMgPSAke3NxdWVlemVkT3V0cHV0U2hhcGVbMV19O1xuXG4gICAgICAgICR7bWFpbkxvb3B9XG4gICAgICAgICR7Z2xzbC5vdXRwdXR9ID0gcmVzdWx0O1xuICAgICAgfVxuICAgIGA7XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5tZXRhZGF0YSxcbiAgICBvdXRwdXQ6IHsgZGltczogc3F1ZWV6ZWRPdXRwdXRTaGFwZSwgdHlwZTogaW5wdXQzRC50eXBlLCB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGUucGFja2VkIH0sXG4gICAgc2hhZGVyU291cmNlLFxuICAgIGhhc01haW46IHRydWUsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlUGFja2VkUmVzaGFwZTNEUHJvZ3JhbUluZm9Mb2FkZXIgPSAoXG4gIGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXQzRDogVGVuc29yLFxuICBvdXRwdXRTaGFwZTNEOiByZWFkb25seSBudW1iZXJbXSxcbik6IFByb2dyYW1JbmZvTG9hZGVyID0+IHtcbiAgY29uc3QgbWV0YWRhdGEgPSBjcmVhdGVQYWNrZWRSZXNoYXBlM0RQcm9ncmFtTWV0YWRhdGEob3V0cHV0U2hhcGUzRCk7XG4gIHJldHVybiB7IC4uLm1ldGFkYXRhLCBnZXQ6ICgpID0+IGNyZWF0ZVBhY2tlZFJlc2hhcGUzRFByb2dyYW1JbmZvKGhhbmRsZXIsIGlucHV0M0QsIG1ldGFkYXRhLCBvdXRwdXRTaGFwZTNEKSB9O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHByb2Nlc3NEaW1zM0Qoc2hhcGU6IEFycmF5TGlrZTxudW1iZXI+KTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdIHtcbiAgaWYgKHNoYXBlLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbMSwgMSwgMV07XG4gIH1cbiAgLy8gVE9ETzogc3F1ZWV6ZSBvdGhlciBzaGFwZXMgdG8gMkQgY2FzZVxuICBsZXQgYmF0Y2ggPSAxO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNoYXBlLmxlbmd0aCAtIDI7ICsraSkge1xuICAgIGJhdGNoICo9IHNoYXBlW2ldO1xuICB9XG4gIHJldHVybiBbYmF0Y2gsIHNoYXBlLmxlbmd0aCA+IDEgPyBzaGFwZVtzaGFwZS5sZW5ndGggLSAyXSA6IDEsIHNoYXBlW3NoYXBlLmxlbmd0aCAtIDFdXTtcbn1cblxuLy8gRm9yIHBhY2tlZCByZXNoYXBlLCB3ZSBuZWVkIHRvIHJlLWFycmFuZ2UgdGV4ZWwgZGF0YSBmb3Igb3V0cHV0IHNoYXBlLlxuLy8gT3VyIHBhY2sgaXMgZGVzaWduZWQgdG8gcGFjayBhIDJ4MiB0aWxlIGluIGxhc3QgaCBhbmQgdyBkaW1lbnNpb24sIHNvXG4vLyBmb3IgdGhlIHJlc2hhcGVkIG5ldyB0ZW5zb3IsIHdlIGp1c3QgbmVlZCB0byByZS1hcnJhbmdlIHRoZSBsYXN0IGggYW5kXG4vLyB3IGRpbWVuc2lvbi4gRm9yIGFueSBzaGFwZSB0aGF0IGlzIG5vdCBpbiAzRCwgaS5lLiBbYmF0Y2gsIFcsIEhdLCB3ZVxuLy8gZmlyc3QgY29udmVydCBpdCB0byAzRCBieSBjb2xsYXBzaW5nIG90aGVyIGRpbWVuc2lvbiB0byBiYXRjaCBkaW0sIHRoZW5cbi8vIHByb2Nlc3Mgd2l0aCB0aGUgbGFzdCB0d28gZGltZW5zaW9ucy5cbi8vIE5vdGU6IHdlIG9ubHkgbmVlZCB0aGUgc2hhcGUgdGVuc29yIHRvIGNhbGN1bGF0ZSBvdXRwdXQgc2hhcGUsIHNvIHRoZVxuLy8gY29udGVudCBpbiBzaGFwZSB0ZW5zb3IgaXMgbmV2ZXIgdXBsb2FkZWQgdG8gR1BVLiBJdCBpcyBhbHdheXMga2VwdCBpbiBDUFUuXG4vLyBUT0RPOiBvcHRpbWl6ZSB0aGUgYWxnb3JpdGhtIC0tIGluIHNvbWUgY2FzZXMsIGlmIHRoZSBsYXN0IHR3byBkaW1zIGFyZVxuLy8gdGhlIHNhbWUgYmV0d2VlbiBpbnB1dCBzaGFwZSBhbmQgb3V0cHV0IHNoYXBlLCB0aGUgcGFja2VkIHJlc2hhcGUgY2FuIGJlXG4vLyB0cmVhdGVkIGFzIG5vLW9wLlxuZXhwb3J0IGZ1bmN0aW9uIGlzUmVzaGFwZUNoZWFwKGRpbXM6IHJlYWRvbmx5IG51bWJlcltdLCByZXNoYXBlZERpbXM6IHJlYWRvbmx5IG51bWJlcltdKSB7XG4gIGxldCBpc0NoZWFwUmVzaGFwZSA9IGZhbHNlO1xuICBpZiAoZGltcy5sZW5ndGggPT09IDAgfHwgcmVzaGFwZWREaW1zLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIHNjYWxhclxuICAgIGlzQ2hlYXBSZXNoYXBlID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChkaW1zLmxlbmd0aCA8IDIgfHwgcmVzaGFwZWREaW1zLmxlbmd0aCA8IDIpIHtcbiAgICAvLyAxRFxuICAgIGlzQ2hlYXBSZXNoYXBlID0gZGltc1tkaW1zLmxlbmd0aCAtIDFdID09PSByZXNoYXBlZERpbXNbcmVzaGFwZWREaW1zLmxlbmd0aCAtIDFdO1xuICB9IGVsc2Uge1xuICAgIC8vIDJEICtcbiAgICBpc0NoZWFwUmVzaGFwZSA9XG4gICAgICBkaW1zW2RpbXMubGVuZ3RoIC0gMV0gPT09IHJlc2hhcGVkRGltc1tyZXNoYXBlZERpbXMubGVuZ3RoIC0gMV0gJiZcbiAgICAgIGRpbXNbZGltcy5sZW5ndGggLSAyXSA9PT0gcmVzaGFwZWREaW1zW3Jlc2hhcGVkRGltcy5sZW5ndGggLSAyXTtcbiAgfVxuXG4gIHJldHVybiBpc0NoZWFwUmVzaGFwZTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVzaGFwZWRJbnB1dENvb3JkcyhzaGFwZTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdKTogc3RyaW5nIHtcbiAgY29uc3Qgc3RyaWRlcyA9IFNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyhzaGFwZSk7XG4gIGNvbnN0IGNvb3JkcyA9IFsnYicsICdyJywgJ2MnXTtcbiAgY29uc3QgaW5kZXggPSAnaW5kZXgnO1xuICBjb25zdCBjb29yZHNGcm9tSW5kZXhTbmlwcGV0ID0gc3RyaWRlc1xuICAgIC5tYXAoKHN0cmlkZSwgaSkgPT4ge1xuICAgICAgY29uc3QgbGluZTEgPSBgaW50ICR7Y29vcmRzW2ldfSA9ICR7aW5kZXh9IC8gJHtzdHJpZGV9YDtcbiAgICAgIGNvbnN0IGxpbmUyID1cbiAgICAgICAgaSA9PT0gc3RyaWRlcy5sZW5ndGggLSAxXG4gICAgICAgICAgPyBgaW50ICR7Y29vcmRzW2kgKyAxXX0gPSAke2luZGV4fSAtICR7Y29vcmRzW2ldfSAqICR7c3RyaWRlfWBcbiAgICAgICAgICA6IGBpbmRleCAtPSAke2Nvb3Jkc1tpXX0gKiAke3N0cmlkZX1gO1xuICAgICAgcmV0dXJuIGAke2xpbmUxfTsgJHtsaW5lMn07YDtcbiAgICB9KVxuICAgIC5qb2luKCcnKTtcblxuICByZXR1cm4gYFxuICAgIGl2ZWMzIGlucHV0Q29vcmRzRnJvbVJlc2hhcGVkT3V0Q29vcmRzKGludCBpbmRleCkge1xuICAgICAgJHtjb29yZHNGcm9tSW5kZXhTbmlwcGV0fVxuICAgICAgcmV0dXJuIGl2ZWMzKGIsIHIsIGMpO1xuICAgIH1cbiAgYDtcbn1cblxuZnVuY3Rpb24gZ2V0RmxhdHRlbmVkSW5kZXhGcm9tM0Qoc2hhcGU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSk6IHN0cmluZyB7XG4gIGNvbnN0IHN0cmlkZXMgPSBTaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXMoc2hhcGUpO1xuXG4gIHJldHVybiBgXG4gIGludCBnZXRGbGF0dGVuZWRJbmRleChpdmVjMyBjb29yZHMpIHtcbiAgICAvLyByZXZlcnNlIHksIHogb3JkZXJcbiAgICByZXR1cm4gY29vcmRzLnggKiAke3N0cmlkZXNbMF19ICsgY29vcmRzLnogKiAke3N0cmlkZXNbMV19ICsgY29vcmRzLnk7XG4gIH1cbmA7XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IGdldEdsc2wgfSBmcm9tICcuLi9nbHNsLXNvdXJjZSc7XG5pbXBvcnQgeyBXZWJHTEluZmVyZW5jZUhhbmRsZXIgfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQgeyBUZXh0dXJlRGF0YSwgVGV4dHVyZVR5cGUgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBjb25zdCBlbmNvZGVBc1VpbnQ4ID0gKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXQ6IFRleHR1cmVEYXRhKTogVGV4dHVyZURhdGEgPT4ge1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IGlucHV0LnNoYXBlO1xuICBjb25zdCBnbHNsID0gZ2V0R2xzbChpbmZlcmVuY2VIYW5kbGVyLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbik7XG4gIC8qKlxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vdGVuc29yZmxvdy90ZmpzLWNvcmUvYmxvYi9tYXN0ZXIvc3JjL2tlcm5lbHMvd2ViZ2wvZW5jb2RlX2Zsb2F0X2dwdS50c1xuICAgKi9cbiAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgIGNvbnN0IGZsb2F0IEZMT0FUX01BWCA9IDEuNzAxNDExODRlMzg7XG4gICAgY29uc3QgZmxvYXQgRkxPQVRfTUlOID0gMS4xNzU0OTQzNWUtMzg7XG5cbiAgICBib29sIGlzTmFOKGZsb2F0IHZhbCkge1xuICAgICAgcmV0dXJuICh2YWwgPCAxLjAgfHwgMC4wIDwgdmFsIHx8IHZhbCA9PSAwLjApID8gZmFsc2UgOiB0cnVlO1xuICAgIH1cblxuICAgIGhpZ2hwIHZlYzQgZW5jb2RlQXNVaW50OChoaWdocCBmbG9hdCB2KSB7XG4gICAgICBpZiAoaXNOYU4odikpIHtcbiAgICAgICAgcmV0dXJuIHZlYzQoMjU1LCAyNTUsIDI1NSwgMjU1KTtcbiAgICAgIH1cblxuICAgICAgaGlnaHAgZmxvYXQgYXYgPSBhYnModik7XG5cbiAgICAgIGlmKGF2IDwgRkxPQVRfTUlOKSB7XG4gICAgICAgIHJldHVybiB2ZWM0KDAuMCwgMC4wLCAwLjAsIDAuMCk7XG4gICAgICB9IGVsc2UgaWYodiA+IEZMT0FUX01BWCkge1xuICAgICAgICByZXR1cm4gdmVjNCgwLjAsIDAuMCwgMTI4LjAsIDEyNy4wKSAvIDI1NS4wO1xuICAgICAgfSBlbHNlIGlmKHYgPCAtRkxPQVRfTUFYKSB7XG4gICAgICAgIHJldHVybiB2ZWM0KDAuMCwgMC4wLCAgMTI4LjAsIDI1NS4wKSAvIDI1NS4wO1xuICAgICAgfVxuXG4gICAgICBoaWdocCB2ZWM0IGMgPSB2ZWM0KDAsMCwwLDApO1xuXG4gICAgICBoaWdocCBmbG9hdCBlID0gZmxvb3IobG9nMihhdikpO1xuICAgICAgaGlnaHAgZmxvYXQgbSA9IGV4cDIoZnJhY3QobG9nMihhdikpKSAtIDEuMDtcblxuICAgICAgY1syXSA9IGZsb29yKDEyOC4wICogbSk7XG4gICAgICBtIC09IGNbMl0gLyAxMjguMDtcbiAgICAgIGNbMV0gPSBmbG9vcigzMjc2OC4wICogbSk7XG4gICAgICBtIC09IGNbMV0gLyAzMjc2OC4wO1xuICAgICAgY1swXSA9IGZsb29yKDgzODg2MDguMCAqIG0pO1xuXG4gICAgICBoaWdocCBmbG9hdCBlYmlhcyA9IGUgKyAxMjcuMDtcbiAgICAgIGNbM10gPSBmbG9vcihlYmlhcyAvIDIuMCk7XG4gICAgICBlYmlhcyAtPSBjWzNdICogMi4wO1xuICAgICAgY1syXSArPSBmbG9vcihlYmlhcykgKiAxMjguMDtcblxuICAgICAgY1szXSArPSAxMjguMCAqIHN0ZXAoMC4wLCAtdik7XG5cbiAgICAgIHJldHVybiBjIC8gMjU1LjA7XG4gICAgfVxuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgZmxvYXQgdmFsdWUgPSAke2dsc2wudGV4dHVyZTJEfShYLFRleENvb3JkcykucjtcbiAgICAgICR7Z2xzbC5vdXRwdXR9ID0gZW5jb2RlQXNVaW50OCh2YWx1ZSk7XG4gICAgfWA7XG4gIGNvbnN0IHByb2dyYW1JbmZvID0ge1xuICAgIG5hbWU6ICdVaW50OEVuY29kZScsXG4gICAgaW5wdXRUeXBlczogW1RleHR1cmVUeXBlLnVucGFja2VkXSxcbiAgICBpbnB1dE5hbWVzOiBbJ1gnXSxcbiAgICBvdXRwdXQ6IHsgZGltczogb3V0cHV0U2hhcGUsIHR5cGU6IGlucHV0LnRlbnNvci50eXBlLCB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGUuZG93bmxvYWRVaW50OEFzRmxvYXQgfSxcbiAgICBzaGFkZXJTb3VyY2UsXG4gICAgaGFzTWFpbjogdHJ1ZSxcbiAgfTtcbiAgcmV0dXJuIGluZmVyZW5jZUhhbmRsZXIuZXhlY3V0ZVByb2dyYW0ocHJvZ3JhbUluZm8sIFtpbnB1dC50ZW5zb3JdKTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQgeyBnZXRHbHNsIH0gZnJvbSAnLi4vZ2xzbC1zb3VyY2UnO1xuaW1wb3J0IHsgV2ViR0xJbmZlcmVuY2VIYW5kbGVyIH0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHsgUHJvZ3JhbUluZm8sIFByb2dyYW1JbmZvTG9hZGVyLCBUZXh0dXJlVHlwZSB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGdldENvb3Jkc0RhdGFUeXBlIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5pbXBvcnQgeyBnZXRDaGFubmVscywgdW5wYWNrRnJvbUNoYW5uZWwgfSBmcm9tICcuL3BhY2tpbmctdXRpbHMnO1xuXG5jb25zdCB1bnBhY2tQcm9ncmFtTWV0YWRhdGEgPSB7XG4gIG5hbWU6ICd1bnBhY2snLFxuICBpbnB1dE5hbWVzOiBbJ0EnXSxcbiAgaW5wdXRUeXBlczogW1RleHR1cmVUeXBlLnBhY2tlZF0sXG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlVW5wYWNrUHJvZ3JhbUluZm8gPSAoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dDogVGVuc29yKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCByYW5rID0gaW5wdXQuZGltcy5sZW5ndGg7XG5cbiAgY29uc3QgY2hhbm5lbHMgPSBnZXRDaGFubmVscygncmMnLCByYW5rKTtcbiAgY29uc3QgaW5uZXJEaW1zID0gY2hhbm5lbHMuc2xpY2UoLTIpO1xuICBjb25zdCBjb29yZHNEYXRhVHlwZSA9IGdldENvb3Jkc0RhdGFUeXBlKHJhbmspO1xuICBjb25zdCB1bnBhY2tDaGFubmVsID0gdW5wYWNrRnJvbUNoYW5uZWwoKTtcbiAgY29uc3QgaXNTY2FsYXIgPSBpbnB1dC5kaW1zLmxlbmd0aCA9PT0gMDtcbiAgY29uc3Qgc291cmNlQ29vcmRzID0gaXNTY2FsYXIgPyAnJyA6IGdldFNvdXJjZUNvb3JkcyhyYW5rLCBjaGFubmVscyk7XG4gIGNvbnN0IGNvb3JkcyA9IHJhbmsgPD0gMSA/ICdyYycgOiBgdmVjMigke2lubmVyRGltcy5qb2luKCcsJyl9KWA7XG4gIGNvbnN0IGdsc2wgPSBnZXRHbHNsKGhhbmRsZXIuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICR7dW5wYWNrQ2hhbm5lbH1cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICAke2Nvb3Jkc0RhdGFUeXBlfSByYyA9IGdldE91dHB1dENvb3JkcygpO1xuXG4gICAgICAgLy8gU2FtcGxlIHRoZSB0ZXh0dXJlIHdpdGggdGhlIGNvb3JkcyB0byBnZXQgdGhlIHJnYmEgY2hhbm5lbCB2YWx1ZS5cbiAgICAgICB2ZWM0IHBhY2tlZElucHV0ID0gZ2V0QSgke3NvdXJjZUNvb3Jkc30pO1xuXG4gICAgICAgJHtnbHNsLm91dHB1dH0gPSB2ZWM0KGdldENoYW5uZWwocGFja2VkSW5wdXQsICR7Y29vcmRzfSksIDAsIDAsIDApO1xuICAgICB9XG4gICBgO1xuXG4gIHJldHVybiB7XG4gICAgLi4udW5wYWNrUHJvZ3JhbU1ldGFkYXRhLFxuICAgIGhhc01haW46IHRydWUsXG4gICAgb3V0cHV0OiB7IGRpbXM6IGlucHV0LmRpbXMsIHR5cGU6IGlucHV0LnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS51bnBhY2tlZCB9LFxuICAgIHNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVVbnBhY2tQcm9ncmFtSW5mb0xvYWRlciA9IChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0OiBUZW5zb3IpOiBQcm9ncmFtSW5mb0xvYWRlciA9PiAoe1xuICAuLi51bnBhY2tQcm9ncmFtTWV0YWRhdGEsXG4gIGdldDogKCkgPT4gY3JlYXRlVW5wYWNrUHJvZ3JhbUluZm8oaGFuZGxlciwgaW5wdXQpLFxufSk7XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUNvb3JkcyhyYW5rOiBudW1iZXIsIGRpbXM6IHN0cmluZ1tdKTogc3RyaW5nIHtcbiAgaWYgKHJhbmsgPT09IDEpIHtcbiAgICByZXR1cm4gJ3JjJztcbiAgfVxuXG4gIGxldCBjb29yZHMgPSAnJztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5rOyBpKyspIHtcbiAgICBjb29yZHMgKz0gZGltc1tpXTtcbiAgICBpZiAoaSA8IHJhbmsgLSAxKSB7XG4gICAgICBjb29yZHMgKz0gJywnO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY29vcmRzO1xufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICcuLi8uLi9pbnN0cnVtZW50JztcblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIEVuY29kZXIge1xuICBleHBvcnQgaW50ZXJmYWNlIERhdGFUeXBlTWFwIHtcbiAgICBmbG9hdDogRmxvYXQzMkFycmF5O1xuICAgIGJ5dGU6IFVpbnQ4QXJyYXk7XG4gICAgaW50OiBVaW50MzJBcnJheTtcbiAgfVxuICBleHBvcnQgdHlwZSBEYXRhVHlwZSA9IGtleW9mIERhdGFUeXBlTWFwO1xuICB0eXBlIERhdGFBcnJheVR5cGUgPSBEYXRhVHlwZU1hcFtEYXRhVHlwZV07XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvbiAqL1xuZXhwb3J0IGNvbnN0IGVudW0gRW5jb2RlclVzYWdlIHtcbiAgRGVmYXVsdCA9IDAsXG4gIFVwbG9hZE9ubHksXG4gIERvd25sb2FkNEJ5dGVzQXNGbG9hdDMyLFxufVxuLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb24gKi9cblxuLyoqXG4gKiBBYnN0cmFjdGlvbiBmb3IgbWFwcGluZyBkYXRhIHR5cGVzIHRvIHRleHR1cmUgdGV4bGV0c1xuICogRW5jb2RpbmcgbWVhbnMgaG93IGEgRmxvYXQzMiBpcyBtYXBwZWQgdG8gMSBvciA0IGNoYW5uZWxzIGZvciBlYWNoIHRleGxldFxuICogRGVjb2RpbmcgbWVhbnMgaG93IGEgdGV4bGV0J3MgY2hhbm5lbHMgYXJlIG1hcHBlZCB0byBhIHJlc3VsdGluZyBGbG9hdDMyXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRGF0YUVuY29kZXIge1xuICBpbnRlcm5hbEZvcm1hdDogbnVtYmVyO1xuICBmb3JtYXQ6IG51bWJlcjtcbiAgdGV4dHVyZVR5cGU6IG51bWJlcjtcbiAgY2hhbm5lbFNpemU6IG51bWJlcjtcbiAgZW5jb2RlKHNyYzogRW5jb2Rlci5EYXRhQXJyYXlUeXBlLCB0ZXh0dXJlU2l6ZTogbnVtYmVyKTogRW5jb2Rlci5EYXRhQXJyYXlUeXBlO1xuICBhbGxvY2F0ZShzaXplOiBudW1iZXIpOiBFbmNvZGVyLkRhdGFBcnJheVR5cGU7XG4gIGRlY29kZShidWZmZXI6IEVuY29kZXIuRGF0YUFycmF5VHlwZSwgZGF0YVNpemU6IG51bWJlcik6IEVuY29kZXIuRGF0YUFycmF5VHlwZTtcbn1cbi8qKlxuICogV2ViR0wyIGRhdGEgZW5jb2RlclxuICogVXNlcyBSMzJGIGFzIHRoZSBmb3JtYXQgZm9yIHRleGxldFxuICovXG5leHBvcnQgY2xhc3MgUmVkRmxvYXQzMkRhdGFFbmNvZGVyIGltcGxlbWVudHMgRGF0YUVuY29kZXIge1xuICBpbnRlcm5hbEZvcm1hdDogbnVtYmVyO1xuICBmb3JtYXQ6IG51bWJlcjtcbiAgdGV4dHVyZVR5cGU6IG51bWJlcjtcbiAgY2hhbm5lbFNpemU6IG51bWJlcjtcbiAgY29uc3RydWN0b3IoZ2w6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQsIGNoYW5uZWxzID0gMSkge1xuICAgIGlmIChjaGFubmVscyA9PT0gMSkge1xuICAgICAgdGhpcy5pbnRlcm5hbEZvcm1hdCA9IGdsLlIzMkY7XG4gICAgICB0aGlzLmZvcm1hdCA9IGdsLlJFRDtcbiAgICAgIHRoaXMudGV4dHVyZVR5cGUgPSBnbC5GTE9BVDtcbiAgICAgIHRoaXMuY2hhbm5lbFNpemUgPSBjaGFubmVscztcbiAgICB9IGVsc2UgaWYgKGNoYW5uZWxzID09PSA0KSB7XG4gICAgICB0aGlzLmludGVybmFsRm9ybWF0ID0gZ2wuUkdCQTMyRjtcbiAgICAgIHRoaXMuZm9ybWF0ID0gZ2wuUkdCQTtcbiAgICAgIHRoaXMudGV4dHVyZVR5cGUgPSBnbC5GTE9BVDtcbiAgICAgIHRoaXMuY2hhbm5lbFNpemUgPSBjaGFubmVscztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG51bWJlciBvZiBjaGFubmVsczogJHtjaGFubmVsc31gKTtcbiAgICB9XG4gIH1cbiAgZW5jb2RlKHNyYzogRW5jb2Rlci5EYXRhQXJyYXlUeXBlLCB0ZXh0dXJlU2l6ZTogbnVtYmVyKTogRW5jb2Rlci5EYXRhQXJyYXlUeXBlIHtcbiAgICBsZXQgcmVzdWx0OiBGbG9hdDMyQXJyYXk7XG4gICAgbGV0IHNvdXJjZTogRmxvYXQzMkFycmF5O1xuICAgIGlmIChzcmMuY29uc3RydWN0b3IgIT09IEZsb2F0MzJBcnJheSkge1xuICAgICAgTG9nZ2VyLndhcm5pbmcoJ0VuY29kZXInLCAnZGF0YSB3YXMgbm90IG9mIHR5cGUgRmxvYXQzMjsgY3JlYXRpbmcgbmV3IEZsb2F0MzJBcnJheScpO1xuICAgICAgc291cmNlID0gbmV3IEZsb2F0MzJBcnJheShzcmMpO1xuICAgIH1cbiAgICBpZiAodGV4dHVyZVNpemUgKiB0aGlzLmNoYW5uZWxTaXplID4gc3JjLmxlbmd0aCkge1xuICAgICAgTG9nZ2VyLndhcm5pbmcoJ0VuY29kZXInLCAnU291cmNlIGRhdGEgdG9vIHNtYWxsLiBBbGxvY2F0aW5nIGxhcmdlciBhcnJheScpO1xuICAgICAgc291cmNlID0gc3JjIGFzIEZsb2F0MzJBcnJheTtcbiAgICAgIHJlc3VsdCA9IHRoaXMuYWxsb2NhdGUodGV4dHVyZVNpemUgKiB0aGlzLmNoYW5uZWxTaXplKSBhcyBGbG9hdDMyQXJyYXk7XG4gICAgICBzb3VyY2UuZm9yRWFjaCgodiwgaSkgPT4gKHJlc3VsdFtpXSA9IHYpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc291cmNlID0gc3JjIGFzIEZsb2F0MzJBcnJheTtcbiAgICAgIHJlc3VsdCA9IHNvdXJjZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBhbGxvY2F0ZShzaXplOiBudW1iZXIpOiBFbmNvZGVyLkRhdGFBcnJheVR5cGUge1xuICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KHNpemUgKiA0KTtcbiAgfVxuICBkZWNvZGUoYnVmZmVyOiBFbmNvZGVyLkRhdGFBcnJheVR5cGUsIGRhdGFTaXplOiBudW1iZXIpOiBGbG9hdDMyQXJyYXkge1xuICAgIGlmICh0aGlzLmNoYW5uZWxTaXplID09PSAxKSB7XG4gICAgICBjb25zdCBmaWx0ZXJlZERhdGEgPSAoYnVmZmVyIGFzIEZsb2F0MzJBcnJheSkuZmlsdGVyKChfdmFsdWUsIGluZGV4KSA9PiBpbmRleCAlIDQgPT09IDApLnN1YmFycmF5KDAsIGRhdGFTaXplKTtcbiAgICAgIHJldHVybiBmaWx0ZXJlZERhdGE7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXIuc3ViYXJyYXkoMCwgZGF0YVNpemUpIGFzIEZsb2F0MzJBcnJheTtcbiAgfVxufVxuLyoqXG4gKiBEYXRhIGVuY29kZXIgZm9yIFdlYkdMIDEgd2l0aCBzdXBwb3J0IGZvciBmbG9hdGluZyBwb2ludCB0ZXh0dXJlXG4gKi9cbmV4cG9ydCBjbGFzcyBSR0JBRmxvYXREYXRhRW5jb2RlciBpbXBsZW1lbnRzIERhdGFFbmNvZGVyIHtcbiAgaW50ZXJuYWxGb3JtYXQ6IG51bWJlcjtcbiAgZm9ybWF0OiBudW1iZXI7XG4gIHRleHR1cmVUeXBlOiBudW1iZXI7XG4gIGNoYW5uZWxTaXplOiBudW1iZXI7XG4gIGNvbnN0cnVjdG9yKGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIGNoYW5uZWxzID0gMSwgdGV4dHVyZVR5cGU/OiBudW1iZXIpIHtcbiAgICBpZiAoY2hhbm5lbHMgIT09IDEgJiYgY2hhbm5lbHMgIT09IDQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBudW1iZXIgb2YgY2hhbm5lbHM6ICR7Y2hhbm5lbHN9YCk7XG4gICAgfVxuICAgIHRoaXMuaW50ZXJuYWxGb3JtYXQgPSBnbC5SR0JBO1xuICAgIHRoaXMuZm9ybWF0ID0gZ2wuUkdCQTtcbiAgICB0aGlzLmNoYW5uZWxTaXplID0gY2hhbm5lbHM7XG4gICAgdGhpcy50ZXh0dXJlVHlwZSA9IHRleHR1cmVUeXBlIHx8IGdsLkZMT0FUO1xuICB9XG4gIGVuY29kZShzcmM6IEZsb2F0MzJBcnJheSwgdGV4dHVyZVNpemU6IG51bWJlcik6IEVuY29kZXIuRGF0YUFycmF5VHlwZSB7XG4gICAgbGV0IGRlc3QgPSBzcmM7XG4gICAgaWYgKHRoaXMuY2hhbm5lbFNpemUgPT09IDEpIHtcbiAgICAgIExvZ2dlci52ZXJib3NlKCdFbmNvZGVyJywgJ0V4cGxvZGluZyBpbnRvIGEgbGFyZ2VyIGFycmF5Jyk7XG4gICAgICBkZXN0ID0gdGhpcy5hbGxvY2F0ZSh0ZXh0dXJlU2l6ZSkgYXMgRmxvYXQzMkFycmF5O1xuICAgICAgc3JjLmZvckVhY2goKHYsIGkpID0+IChkZXN0W2kgKiA0XSA9IHYpKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG4gIH1cbiAgYWxsb2NhdGUoc2l6ZTogbnVtYmVyKTogRW5jb2Rlci5EYXRhQXJyYXlUeXBlIHtcbiAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShzaXplICogNCk7XG4gIH1cbiAgZGVjb2RlKGJ1ZmZlcjogRW5jb2Rlci5EYXRhQXJyYXlUeXBlLCBkYXRhU2l6ZTogbnVtYmVyKTogRmxvYXQzMkFycmF5IHtcbiAgICBpZiAodGhpcy5jaGFubmVsU2l6ZSA9PT0gMSkge1xuICAgICAgY29uc3QgZmlsdGVyZWREYXRhID0gKGJ1ZmZlciBhcyBGbG9hdDMyQXJyYXkpLmZpbHRlcigoX3ZhbHVlLCBpbmRleCkgPT4gaW5kZXggJSA0ID09PSAwKS5zdWJhcnJheSgwLCBkYXRhU2l6ZSk7XG4gICAgICByZXR1cm4gZmlsdGVyZWREYXRhO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyLnN1YmFycmF5KDAsIGRhdGFTaXplKSBhcyBGbG9hdDMyQXJyYXk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFVpbnQ4RGF0YUVuY29kZXIgaW1wbGVtZW50cyBEYXRhRW5jb2RlciB7XG4gIGludGVybmFsRm9ybWF0OiBudW1iZXI7XG4gIGZvcm1hdDogbnVtYmVyO1xuICB0ZXh0dXJlVHlwZTogbnVtYmVyO1xuICBjaGFubmVsU2l6ZSA9IDQ7XG4gIGNvbnN0cnVjdG9yKGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIGNoYW5uZWxzID0gMSkge1xuICAgIGlmIChjaGFubmVscyA9PT0gMSkge1xuICAgICAgdGhpcy5pbnRlcm5hbEZvcm1hdCA9IGdsLkFMUEhBO1xuICAgICAgdGhpcy5mb3JtYXQgPSBnbC5BTFBIQTsgLy8gbm90IHRlc3RlZFxuICAgICAgdGhpcy50ZXh0dXJlVHlwZSA9IGdsLlVOU0lHTkVEX0JZVEU7XG4gICAgICB0aGlzLmNoYW5uZWxTaXplID0gY2hhbm5lbHM7XG4gICAgfSBlbHNlIGlmIChjaGFubmVscyA9PT0gNCkge1xuICAgICAgdGhpcy5pbnRlcm5hbEZvcm1hdCA9IGdsLlJHQkE7XG4gICAgICB0aGlzLmZvcm1hdCA9IGdsLlJHQkE7XG4gICAgICB0aGlzLnRleHR1cmVUeXBlID0gZ2wuVU5TSUdORURfQllURTtcbiAgICAgIHRoaXMuY2hhbm5lbFNpemUgPSBjaGFubmVscztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG51bWJlciBvZiBjaGFubmVsczogJHtjaGFubmVsc31gKTtcbiAgICB9XG4gIH1cbiAgZW5jb2RlKHNyYzogVWludDhBcnJheSwgX3RleHR1cmVTaXplOiBudW1iZXIpOiBFbmNvZGVyLkRhdGFBcnJheVR5cGUge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShzcmMuYnVmZmVyLCBzcmMuYnl0ZU9mZnNldCwgc3JjLmJ5dGVMZW5ndGgpO1xuICB9XG4gIGFsbG9jYXRlKHNpemU6IG51bWJlcik6IEVuY29kZXIuRGF0YUFycmF5VHlwZSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHNpemUgKiB0aGlzLmNoYW5uZWxTaXplKTtcbiAgfVxuICBkZWNvZGUoYnVmZmVyOiBFbmNvZGVyLkRhdGFBcnJheVR5cGUsIGRhdGFTaXplOiBudW1iZXIpOiBVaW50OEFycmF5IHtcbiAgICBpZiAoYnVmZmVyIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgcmV0dXJuIGJ1ZmZlci5zdWJhcnJheSgwLCBkYXRhU2l6ZSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBhcnJheSB0eXBlOiAke2J1ZmZlci5jb25zdHJ1Y3Rvcn1gKTtcbiAgfVxufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcblxuaW1wb3J0IHsgVGV4dHVyZUxheW91dFN0cmF0ZWd5LCBXaWR0aEhlaWdodFByZWZzIH0gZnJvbSAnLi90ZXh0dXJlLWxheW91dC1zdHJhdGVneSc7XG5pbXBvcnQgeyBUZXh0dXJlTGF5b3V0LCBUZXh0dXJlVHlwZSB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgY29uc3QgY3JlYXRlVGV4dHVyZUxheW91dEZyb21UZXh0dXJlVHlwZSA9IChcbiAgdGV4dHVyZUxheW91dFN0cmF0ZWd5OiBUZXh0dXJlTGF5b3V0U3RyYXRlZ3ksXG4gIHNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgdGV4dHVyZVR5cGU6IFRleHR1cmVUeXBlLFxuKTogVGV4dHVyZUxheW91dCA9PiB7XG4gIGNvbnN0IGNoYW5uZWwgPSB0ZXh0dXJlVHlwZSA9PT0gVGV4dHVyZVR5cGUudW5wYWNrZWQgfHwgdGV4dHVyZVR5cGUgPT09IFRleHR1cmVUeXBlLnVucGFja2VkUmV2ZXJzZWQgPyAxIDogNDtcbiAgY29uc3QgaXNQYWNrZWQgPSB0ZXh0dXJlVHlwZSA9PT0gVGV4dHVyZVR5cGUucGFja2VkO1xuICBjb25zdCByZXZlcnNlV0ggPSB0ZXh0dXJlVHlwZSA9PT0gVGV4dHVyZVR5cGUudW5wYWNrZWRSZXZlcnNlZCB8fCB0ZXh0dXJlVHlwZSA9PT0gVGV4dHVyZVR5cGUucGFja2VkO1xuICBjb25zdCBicmVha0F4aXMgPSB0ZXh0dXJlVHlwZSA9PT0gVGV4dHVyZVR5cGUucGFja2VkTGFzdERpbWVuc2lvbiA/IHNoYXBlLmxlbmd0aCAtIDEgOiB1bmRlZmluZWQ7XG4gIGNvbnN0IHVucGFja2VkU2hhcGUgPVxuICAgIHRleHR1cmVUeXBlID09PSBUZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9uXG4gICAgICA/IHNoYXBlLm1hcCgoZCwgaSkgPT4gKGkgPT09IHNoYXBlLmxlbmd0aCAtIDEgPyBkICogNCA6IGQpKVxuICAgICAgOiB1bmRlZmluZWQ7XG4gIHJldHVybiBjcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlKHRleHR1cmVMYXlvdXRTdHJhdGVneSwgc2hhcGUsIGNoYW5uZWwsIHVucGFja2VkU2hhcGUsIHtcbiAgICBpc1BhY2tlZCxcbiAgICByZXZlcnNlV0gsXG4gICAgYnJlYWtBeGlzLFxuICB9KTtcbn07XG5cbmV4cG9ydCBjb25zdCBjYWxjdWxhdGVUZXh0dXJlV2lkdGhBbmRIZWlnaHQgPSAoXG4gIHRleHR1cmVMYXlvdXRTdHJhdGVneTogVGV4dHVyZUxheW91dFN0cmF0ZWd5LFxuICBzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZSxcbik6IFtudW1iZXIsIG51bWJlcl0gPT4ge1xuICBjb25zdCBsYXlvdXQgPSBjcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVRleHR1cmVUeXBlKHRleHR1cmVMYXlvdXRTdHJhdGVneSwgc2hhcGUsIHRleHR1cmVUeXBlKTtcbiAgcmV0dXJuIFtsYXlvdXQud2lkdGgsIGxheW91dC5oZWlnaHRdO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBUZXh0dXJlTGF5b3V0IG9iamVjdCBmcm9tIHNoYXBlLlxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlVGV4dHVyZUxheW91dEZyb21TaGFwZSA9IChcbiAgdGV4dHVyZUxheW91dFN0cmF0ZWd5OiBUZXh0dXJlTGF5b3V0U3RyYXRlZ3ksXG4gIHNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgY2hhbm5lbHM6IDEgfCA0ID0gMSxcbiAgdW5wYWNrZWRTaGFwZT86IHJlYWRvbmx5IG51bWJlcltdLFxuICBwcmVmcz86IFdpZHRoSGVpZ2h0UHJlZnMsXG4pOiBUZXh0dXJlTGF5b3V0ID0+IHtcbiAgY29uc3QgaXNQYWNrZWQgPSAhIShwcmVmcyAmJiBwcmVmcy5pc1BhY2tlZCk7XG4gIGNvbnN0IFt3aWR0aCwgaGVpZ2h0XSA9IHRleHR1cmVMYXlvdXRTdHJhdGVneS5jb21wdXRlVGV4dHVyZVdIKGlzUGFja2VkID8gdW5wYWNrZWRTaGFwZSB8fCBzaGFwZSA6IHNoYXBlLCBwcmVmcyk7XG4gIGNvbnN0IHJhbmsgPSBzaGFwZS5sZW5ndGg7XG4gIGxldCBpbmZlcnJlZERpbXMgPSBzaGFwZS5zbGljZSgwKTtcbiAgaWYgKHJhbmsgPT09IDApIHtcbiAgICBpbmZlcnJlZERpbXMgPSBbMV07XG4gIH1cbiAgaWYgKGNoYW5uZWxzID09PSAxKSB7XG4gICAgLy8gdW5wYWNrZWRTaGFwZSB3aWxsIHRha2UgYHNoYXBlYCBhbmQgbm90IGBpbmZlcnJlZERpbXNgIHNvIGFzIHRvIGNyZWF0ZSBhIHNjYWxhciBUZW5zb3IgaWYgbmVlZCBiZVxuICAgIHVucGFja2VkU2hhcGUgPSBzaGFwZTtcbiAgfSBlbHNlIGlmIChpc1BhY2tlZCkge1xuICAgIGlmIChjaGFubmVscyAhPT0gNCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdhIHBhY2tlZCB0ZXh0dXJlIG11c3QgYmUgNC1jaGFubmVsJyk7XG4gICAgfVxuICAgIHVucGFja2VkU2hhcGUgPSBzaGFwZTtcbiAgICBpZiAocmFuayA+IDApIHtcbiAgICAgIGluZmVycmVkRGltc1tyYW5rIC0gMV0gPSBNYXRoLmNlaWwoaW5mZXJyZWREaW1zW3JhbmsgLSAxXSAvIDIpO1xuICAgIH1cbiAgICBpZiAocmFuayA+IDEpIHtcbiAgICAgIGluZmVycmVkRGltc1tyYW5rIC0gMl0gPSBNYXRoLmNlaWwoaW5mZXJyZWREaW1zW3JhbmsgLSAyXSAvIDIpO1xuICAgIH1cbiAgfSBlbHNlIGlmICghdW5wYWNrZWRTaGFwZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5wYWNrZWQgc2hhcGUgaXMgbmVlZGVkIHdoZW4gdXNpbmcgY2hhbm5lbHMgPiAxJyk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgY2hhbm5lbHMsXG4gICAgaXNQYWNrZWQsXG4gICAgc2hhcGU6IGluZmVycmVkRGltcyxcbiAgICBzdHJpZGVzOiBTaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXMoaW5mZXJyZWREaW1zKSxcbiAgICB1bnBhY2tlZFNoYXBlLFxuICAgIHJldmVyc2VkV0g6IHByZWZzICYmIHByZWZzLnJldmVyc2VXSCxcbiAgfTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEluZmVyZW5jZUhhbmRsZXIgfSBmcm9tICcuLi8uLi9iYWNrZW5kJztcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJy4uLy4uL2luc3RydW1lbnQnO1xuaW1wb3J0IHsgVGVuc29yIH0gZnJvbSAnLi4vLi4vdGVuc29yJztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuXG5pbXBvcnQgeyBjcmVhdGVQYWNrUHJvZ3JhbUluZm9Mb2FkZXIgfSBmcm9tICcuL29wcy9wYWNrJztcbmltcG9ydCB7IGNyZWF0ZVBhY2tlZFJlc2hhcGUzRFByb2dyYW1JbmZvTG9hZGVyLCBpc1Jlc2hhcGVDaGVhcCwgcHJvY2Vzc0RpbXMzRCB9IGZyb20gJy4vb3BzL3Jlc2hhcGUtcGFja2VkJztcbmltcG9ydCB7IGVuY29kZUFzVWludDggfSBmcm9tICcuL29wcy91aW50OC1lbmNvZGUnO1xuaW1wb3J0IHsgY3JlYXRlVW5wYWNrUHJvZ3JhbUluZm9Mb2FkZXIgfSBmcm9tICcuL29wcy91bnBhY2snO1xuaW1wb3J0IHsgV2ViR0xTZXNzaW9uSGFuZGxlciB9IGZyb20gJy4vc2Vzc2lvbi1oYW5kbGVyJztcbmltcG9ydCB7IEVuY29kZXJVc2FnZSB9IGZyb20gJy4vdGV4dHVyZS1kYXRhLWVuY29kZXInO1xuaW1wb3J0IHtcbiAgY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0LFxuICBjcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlLFxuICBjcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVRleHR1cmVUeXBlLFxufSBmcm9tICcuL3RleHR1cmUtbGF5b3V0JztcbmltcG9ydCB7IEFydGlmYWN0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbUluZm9Mb2FkZXIsIFRleHR1cmVEYXRhLCBUZXh0dXJlTGF5b3V0LCBUZXh0dXJlVHlwZSB9IGZyb20gJy4vdHlwZXMnO1xuXG5jb25zdCBnZXRQcm9ncmFtSW5mb1VuaXF1ZUtleSA9IChcbiAgcHJvZ3JhbUluZm86IFByb2dyYW1JbmZvIHwgUHJvZ3JhbUluZm9Mb2FkZXIsXG4gIGlucHV0VGV4dHVyZURhdGFzOiBUZXh0dXJlRGF0YVtdLFxuKTogc3RyaW5nID0+IHtcbiAgY29uc3QgaW5wdXRzID0gaW5wdXRUZXh0dXJlRGF0YXNcbiAgICAubWFwKCh0ZXh0dXJlKSA9PiBgJHt0ZXh0dXJlLnVucGFja2VkU2hhcGUuam9pbignLCcpfTske3RleHR1cmUud2lkdGh9eCR7dGV4dHVyZS5oZWlnaHR9YClcbiAgICAuam9pbignXycpO1xuICBsZXQga2V5ID0gcHJvZ3JhbUluZm8ubmFtZTtcbiAgaWYgKHByb2dyYW1JbmZvLmNhY2hlSGludCkge1xuICAgIGtleSArPSAnWycgKyBwcm9ncmFtSW5mby5jYWNoZUhpbnQgKyAnXSc7XG4gIH1cbiAga2V5ICs9ICc6JyArIGlucHV0cztcbiAgcmV0dXJuIGtleTtcbn07XG5cbmV4cG9ydCBjbGFzcyBXZWJHTEluZmVyZW5jZUhhbmRsZXIgaW1wbGVtZW50cyBJbmZlcmVuY2VIYW5kbGVyIHtcbiAgcHJpdmF0ZSBwYWNrZWRUZXh0dXJlRGF0YUNhY2hlOiBNYXA8VGVuc29yLklkLCBUZXh0dXJlRGF0YT47XG4gIHByaXZhdGUgdW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlOiBNYXA8VGVuc29yLklkLCBUZXh0dXJlRGF0YT47XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBzZXNzaW9uOiBXZWJHTFNlc3Npb25IYW5kbGVyKSB7XG4gICAgdGhpcy5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlID0gbmV3IE1hcCgpO1xuICAgIHRoaXMudW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlID0gbmV3IE1hcCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIFt3aWR0aCwgaGVpZ2h0XVxuICAgKi9cbiAgY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0KHNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgdGV4dHVyZVR5cGU6IFRleHR1cmVUeXBlKTogW251bWJlciwgbnVtYmVyXSB7XG4gICAgcmV0dXJuIGNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodCh0aGlzLnNlc3Npb24ubGF5b3V0U3RyYXRlZ3ksIHNoYXBlLCB0ZXh0dXJlVHlwZSk7XG4gIH1cblxuICBleGVjdXRlUHJvZ3JhbShwcm9ncmFtOiBQcm9ncmFtSW5mbyB8IFByb2dyYW1JbmZvTG9hZGVyLCBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvcltdKTogVGV4dHVyZURhdGEge1xuICAgIGlmIChpbnB1dHMubGVuZ3RoIDwgcHJvZ3JhbS5pbnB1dE5hbWVzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnB1dCBzaXplIG11c3RuJ3QgYmUgbGVzcyB0aGFuICR7cHJvZ3JhbS5pbnB1dE5hbWVzLmxlbmd0aH0uYCk7XG4gICAgfVxuICAgIGlmIChwcm9ncmFtLmlucHV0TmFtZXMubGVuZ3RoICE9PSBwcm9ncmFtLmlucHV0VHlwZXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0IG5hbWVzIHNpemUgZG9lcyBub3QgbWF0Y2ggaW5wdXQgdHlwZXMnKTtcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgdGV4dHVyZSBpbmZvIGZvciBpbnB1dFxuICAgIGNvbnN0IGlucHV0VGV4dHVyZURhdGFzOiBUZXh0dXJlRGF0YVtdID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9ncmFtLmlucHV0TmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlucHV0VGV4dHVyZURhdGFzW2ldID0gdGhpcy5nZXRPckNyZWF0ZVRleHR1cmVEYXRhKGlucHV0c1tpXSwgcHJvZ3JhbS5pbnB1dFR5cGVzW2ldKTtcbiAgICB9XG5cbiAgICBjb25zdCBrZXkgPSBnZXRQcm9ncmFtSW5mb1VuaXF1ZUtleShwcm9ncmFtLCBpbnB1dFRleHR1cmVEYXRhcyk7XG4gICAgbGV0IGFydGlmYWN0ID0gdGhpcy5zZXNzaW9uLnByb2dyYW1NYW5hZ2VyLmdldEFydGlmYWN0KGtleSk7XG4gICAgY29uc3QgcHJvZ3JhbUluZm8gPSBhcnRpZmFjdFxuICAgICAgPyBhcnRpZmFjdC5wcm9ncmFtSW5mb1xuICAgICAgOiB0eXBlb2YgKHByb2dyYW0gYXMgUHJvZ3JhbUluZm9Mb2FkZXIpLmdldCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IChwcm9ncmFtIGFzIFByb2dyYW1JbmZvTG9hZGVyKS5nZXQoKVxuICAgICAgICA6IChwcm9ncmFtIGFzIFByb2dyYW1JbmZvKTtcblxuICAgIC8vIGNyZWF0ZSB0ZXh0dXJlIGluZm8gZm9yIG91dHB1dFxuICAgIGNvbnN0IG91dHB1dFRleHR1cmVMYXlvdXQgPSBjcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVRleHR1cmVUeXBlKFxuICAgICAgdGhpcy5zZXNzaW9uLmxheW91dFN0cmF0ZWd5LFxuICAgICAgcHJvZ3JhbUluZm8ub3V0cHV0LmRpbXMsXG4gICAgICBwcm9ncmFtSW5mby5vdXRwdXQudGV4dHVyZVR5cGUsXG4gICAgKTtcbiAgICBjb25zdCBvdXRwdXRUZXh0dXJlRGF0YSA9IHRoaXMuY3JlYXRlVGV4dHVyZURhdGEob3V0cHV0VGV4dHVyZUxheW91dCwgcHJvZ3JhbUluZm8ub3V0cHV0LnR5cGUpO1xuXG4gICAgaWYgKCFhcnRpZmFjdCkge1xuICAgICAgYXJ0aWZhY3QgPSB0aGlzLnNlc3Npb24ucHJvZ3JhbU1hbmFnZXIuYnVpbGQocHJvZ3JhbUluZm8sIGlucHV0VGV4dHVyZURhdGFzLCBvdXRwdXRUZXh0dXJlRGF0YSk7XG4gICAgICB0aGlzLnNlc3Npb24ucHJvZ3JhbU1hbmFnZXIuc2V0QXJ0aWZhY3Qoa2V5LCBhcnRpZmFjdCk7XG4gICAgfVxuXG4gICAgdGhpcy5ydW5Qcm9ncmFtKGFydGlmYWN0LCBpbnB1dFRleHR1cmVEYXRhcywgb3V0cHV0VGV4dHVyZURhdGEpO1xuICAgIHJldHVybiBvdXRwdXRUZXh0dXJlRGF0YTtcbiAgfVxuXG4gIHJ1bihwcm9ncmFtOiBQcm9ncmFtSW5mb0xvYWRlciwgaW5wdXRzOiByZWFkb25seSBUZW5zb3JbXSk6IFRlbnNvciB7XG4gICAgY29uc3Qgb3V0cHV0VGV4dHVyZURhdGEgPSB0aGlzLmV4ZWN1dGVQcm9ncmFtKHByb2dyYW0sIGlucHV0cyk7XG4gICAgcmV0dXJuIG91dHB1dFRleHR1cmVEYXRhLnRlbnNvcjtcbiAgfVxuXG4gIHByaXZhdGUgcnVuUHJvZ3JhbShhcnRpZmFjdDogQXJ0aWZhY3QsIGlucHV0czogVGV4dHVyZURhdGFbXSwgb3V0cHV0OiBUZXh0dXJlRGF0YSk6IHZvaWQge1xuICAgIC8vIGlucHV0IHNob3VsZCBtYXRjaFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoISFpbnB1dHNbaV0uaXNQYWNrZWQgIT09IChhcnRpZmFjdC5wcm9ncmFtSW5mby5pbnB1dFR5cGVzW2ldID09PSBUZXh0dXJlVHlwZS5wYWNrZWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW5wdXRbJHtpfV0gcHJvcGVydHkgcGFja2VkIGluY29uc2lzdGVudGApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIG91dHB1dCBzaG91bGQgbWF0Y2hcbiAgICBpZiAoISFvdXRwdXQuaXNQYWNrZWQgIT09IChhcnRpZmFjdC5wcm9ncmFtSW5mby5vdXRwdXQudGV4dHVyZVR5cGUgPT09IFRleHR1cmVUeXBlLnBhY2tlZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignb3V0cHV0IHByb3BlcnR5IHBhY2tlZCBpbmNvbnNpc3RlbnQnKTtcbiAgICB9XG5cbiAgICB0aGlzLnNlc3Npb24ucHJvZ3JhbU1hbmFnZXIucnVuKGFydGlmYWN0LCBpbnB1dHMsIG91dHB1dCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgVGV4dHVyZURhdGEgb2JqZWN0IGZyb20gYSB0ZW5zb3IuXG4gICAqIFVzYWdlID0gRW5jb2RlclVzYWdlLlVwbG9hZE9ubHkuXG4gICAqIElmIGEgcmVsYXRlZCB0ZXh0dXJlIGRhdGEgaXMgZm91bmQgaW4gY2FjaGUsIHJldHVybnMgaXQ7XG4gICAqIE90aGVyd2lzZTpcbiAgICogICBDcmVhdGVzIGEgbmV3IHRleHR1cmUgbGF5b3V0IGlmIG5vdCBwcm92aWRlZDtcbiAgICogICBDcmVhdGVzIFdlYkdMVGV4dHVyZSB3aXRoIHRoZSBsYXlvdXQ7XG4gICAqICAgVXBsb2FkIHRlbnNvciBkYXRhIHRvIHRoZSB0ZXh0dXJlO1xuICAgKiAgIENyZWF0ZXMgYSB0ZXh0dXJlIGRhdGEgb2JqZWN0IGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gdGVuc29yLlxuICAgKiBAcGFyYW0gdGVuc29yIHRoZSB0ZW5zb3Igd2l0aCBkYXRhIHRvIHVwbG9hZFxuICAgKi9cbiAgcHJpdmF0ZSBnZXRPckNyZWF0ZVRleHR1cmVEYXRhKHRlbnNvcjogVGVuc29yLCB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGUpIHtcbiAgICBsZXQgdGQgPSB0aGlzLmdldFRleHR1cmVEYXRhKHRlbnNvci5kYXRhSWQsIHRleHR1cmVUeXBlID09PSBUZXh0dXJlVHlwZS5wYWNrZWQpO1xuXG4gICAgaWYgKCF0ZCkge1xuICAgICAgLy8gY2hlY2sgaWYgd2UgaGF2ZSB0ZXh0dXJlIGRhdGEgaW4gZGlmZmVyZW50IHR5cGVcbiAgICAgIHRkID0gdGhpcy5nZXRUZXh0dXJlRGF0YSh0ZW5zb3IuZGF0YUlkLCB0ZXh0dXJlVHlwZSAhPT0gVGV4dHVyZVR5cGUucGFja2VkKTtcbiAgICAgIGlmICh0ZCkge1xuICAgICAgICBpZiAodGV4dHVyZVR5cGUgPT09IFRleHR1cmVUeXBlLnBhY2tlZCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhY2sodGQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLnVucGFjayh0ZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRkKSB7XG4gICAgICBjb25zdCBsYXlvdXQgPSBjcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVRleHR1cmVUeXBlKHRoaXMuc2Vzc2lvbi5sYXlvdXRTdHJhdGVneSwgdGVuc29yLmRpbXMsIHRleHR1cmVUeXBlKTtcblxuICAgICAgaWYgKHRleHR1cmVUeXBlID09PSBUZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9uKSB7XG4gICAgICAgIGNvbnN0IGdyb3VwID0gMTtcbiAgICAgICAgY29uc3QgY2hhbm5lbHMgPSA0O1xuICAgICAgICBjb25zdCBzaGFwZSA9IHRlbnNvci5kaW1zO1xuICAgICAgICBpZiAoc2hhcGUubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgLy8gcHJlLXByb2Nlc3NpbmcgZm9yIGtlcm5lbCBkYXRhIG9mIENvbnYuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBUT0RPOiBjdXJyZW50bHkgdGhpcyBpcyBhIGhhY2tpbmcgdG8gb3ZlcndyaXRlIENvbnYncyB3ZWlnaHQuIFRoZSBjb3JyZWN0IHdheSB0byBkbyB0aGlzIHNob3VsZCBiZTpcbiAgICAgICAgICAvLyAxLiBpbXBsZW1lbnQgdGV4dHVyZSBiYXNlZCBjb25zdC1mb2xkaW5nXG4gICAgICAgICAgLy8gMi4gY3JlYXRlIGEgV2ViR0wgcHJvZ3JhbSBcInByZXByb2Nlc3NDb252V2VpZ2h0XCIgdG8gZG8gdGhlIHNhbWUgd29yayBhcyBiZWxvd1xuICAgICAgICAgIC8vIDMuIHJ1biB0aGUgcHJvZ3JhbSBiZWZvcmUgZG90UHJvZHVjdC5cbiAgICAgICAgICAvL1xuICAgICAgICAgIGNvbnN0IGFkanVzdGVkS2VybmVsU2hhcGUgPSBbc2hhcGVbMF0sIE1hdGguY2VpbCgoc2hhcGVbMV0gKiBzaGFwZVsyXSAqIHNoYXBlWzNdKSAvIGNoYW5uZWxzKV07XG4gICAgICAgICAgY29uc3QgYWRqdXN0ZWRMYXlvdXQgPSBjcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVRleHR1cmVUeXBlKFxuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLmxheW91dFN0cmF0ZWd5LFxuICAgICAgICAgICAgYWRqdXN0ZWRLZXJuZWxTaGFwZSxcbiAgICAgICAgICAgIHRleHR1cmVUeXBlLFxuICAgICAgICAgICk7XG4gICAgICAgICAgbGV0IGJ1ZmZlciA9IHRlbnNvci5udW1iZXJEYXRhO1xuICAgICAgICAgIGlmICgoc2hhcGVbMV0gKiBzaGFwZVsyXSAqIHNoYXBlWzNdKSAlIGNoYW5uZWxzICE9PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBudW1GZWF0dXJlTWFwcyA9IHNoYXBlWzBdO1xuICAgICAgICAgICAgY29uc3Qgb2xkUm93U2l6ZSA9IHNoYXBlWzFdICogc2hhcGVbMl0gKiBzaGFwZVszXTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1Jvd1NpemUgPSBNYXRoLmNlaWwoKG9sZFJvd1NpemUgKiBncm91cCkgLyBjaGFubmVscykgKiBjaGFubmVscztcbiAgICAgICAgICAgIGNvbnN0IG5ld1NpemUgPSBudW1GZWF0dXJlTWFwcyAqIG5ld1Jvd1NpemU7XG4gICAgICAgICAgICBidWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KG5ld1NpemUpO1xuICAgICAgICAgICAgZm9yIChsZXQgZiA9IDA7IGYgPCBudW1GZWF0dXJlTWFwczsgKytmKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG9sZE9mZnNldCA9IGYgKiBvbGRSb3dTaXplO1xuICAgICAgICAgICAgICBjb25zdCBuZXdPZmZzZXQgPSBmICogbmV3Um93U2l6ZSArIChmICUgZ3JvdXApICogb2xkUm93U2l6ZTtcbiAgICAgICAgICAgICAgYnVmZmVyLnNldCh0ZW5zb3IubnVtYmVyRGF0YS5zdWJhcnJheShvbGRPZmZzZXQsIG9sZE9mZnNldCArIG9sZFJvd1NpemUpLCBuZXdPZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVUZXh0dXJlRGF0YShhZGp1c3RlZExheW91dCwgdGVuc29yLnR5cGUsIGJ1ZmZlciwgdGVuc29yLCBFbmNvZGVyVXNhZ2UuVXBsb2FkT25seSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRleHR1cmVUeXBlID09PSBUZXh0dXJlVHlwZS5wYWNrZWQpIHtcbiAgICAgICAgY29uc3QgdW5wYWNrZWRUZXh0dXJlTGF5b3V0ID0gY3JlYXRlVGV4dHVyZUxheW91dEZyb21TaGFwZSh0aGlzLnNlc3Npb24ubGF5b3V0U3RyYXRlZ3ksIHRlbnNvci5kaW1zLCAxLCBbXSwge1xuICAgICAgICAgIHJldmVyc2VXSDogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHVucGFja2VkVGV4dHVyZURhdGEgPSB0aGlzLmNyZWF0ZVRleHR1cmVEYXRhKFxuICAgICAgICAgIHVucGFja2VkVGV4dHVyZUxheW91dCxcbiAgICAgICAgICB0ZW5zb3IudHlwZSxcbiAgICAgICAgICB0ZW5zb3IubnVtYmVyRGF0YSxcbiAgICAgICAgICB0ZW5zb3IsXG4gICAgICAgICAgRW5jb2RlclVzYWdlLlVwbG9hZE9ubHksXG4gICAgICAgICk7XG4gICAgICAgIHRkID0gdGhpcy5wYWNrKHVucGFja2VkVGV4dHVyZURhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGQgPSB0aGlzLmNyZWF0ZVRleHR1cmVEYXRhKGxheW91dCwgdGVuc29yLnR5cGUsIHRlbnNvci5udW1iZXJEYXRhLCB0ZW5zb3IsIEVuY29kZXJVc2FnZS5VcGxvYWRPbmx5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRkO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIFRleHR1cmVEYXRhIG9iamVjdCB1c2luZyB0aGUgZ2l2ZW4gZGF0YSBhbmQgYmluZCB0byB0aGUgZ2l2ZW4gdGVuc29yLlxuICAgKiBVc2FnZSA9IEVuY29kZXJVc2FnZS5VcGxvYWRPbmx5LlxuICAgKiBOT1RFOiB0aGlzIGZ1bmN0aW9uIGlzIGEgaGFjayBmb3IgQ29udiBpbXBsZW1lbnRhdGlvbi4gc2hvdWxkIHJlbW92ZSB0aGlzIGZ1bmN0aW9uLCBhZnRlciByZXdyaXRpbmcgQ29udlxuICAgKiBpbXBsZW1lbnRhdGlvbiBieSBHcmFwaC5UcmFuc2Zvcm1lclxuICAgKiBAcGFyYW0gZGF0YVR5cGUgdGhlIHRlbnNvciBkYXRhIHR5cGVcbiAgICogQHBhcmFtIGRhdGEgdGhlIGFjdHVhbCBkYXRhIHRvIHVwbG9hZFxuICAgKiBAcGFyYW0gdGVuc29yIHRoZSB0ZW5zb3IgdG8gYmluZC4gdGVuc29yJ3MgZGF0YSBpcyBpZ25vcmVkLlxuICAgKi9cbiAgY3JlYXRlVGV4dHVyZURhdGFGcm9tTGF5b3V0QmluZFRlbnNvcihcbiAgICBsYXlvdXQ6IFRleHR1cmVMYXlvdXQsXG4gICAgZGF0YVR5cGU6IFRlbnNvci5EYXRhVHlwZSxcbiAgICBkYXRhOiBUZW5zb3IuTnVtYmVyVHlwZSxcbiAgICB0ZW5zb3I6IFRlbnNvcixcbiAgKTogVGV4dHVyZURhdGEge1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZVRleHR1cmVEYXRhKGxheW91dCwgZGF0YVR5cGUsIGRhdGEsIHRlbnNvciwgRW5jb2RlclVzYWdlLlVwbG9hZE9ubHkpO1xuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVUZXh0dXJlRGF0YShcbiAgICBsYXlvdXQ6IFRleHR1cmVMYXlvdXQsXG4gICAgZGF0YVR5cGU6IFRlbnNvci5EYXRhVHlwZSxcbiAgICBkYXRhPzogVGVuc29yLk51bWJlclR5cGUsXG4gICAgdGVuc29yPzogVGVuc29yLFxuICAgIHVzYWdlPzogRW5jb2RlclVzYWdlLFxuICApOiBUZXh0dXJlRGF0YSB7XG4gICAgTG9nZ2VyLnZlcmJvc2UoJ0luZmVyZW5jZUhhbmRsZXInLCBgQ3JlYXRpbmcgVGV4dHVyZURhdGE6IGxheW91dDpbJHtKU09OLnN0cmluZ2lmeShsYXlvdXQpfV1gKTtcbiAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy5zZXNzaW9uLnRleHR1cmVNYW5hZ2VyLmNyZWF0ZVRleHR1cmVGcm9tTGF5b3V0KGRhdGFUeXBlLCBsYXlvdXQsIGRhdGEsIHVzYWdlKTtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVUZXh0dXJlRGF0YUZyb21UZXh0dXJlKGxheW91dCwgZGF0YVR5cGUsIHRleHR1cmUsIHRlbnNvcik7XG4gIH1cblxuICByZXNoYXBlVW5wYWNrZWQoaW5wdXQ6IFRlbnNvciwgcmVzaGFwZWREaW1zOiByZWFkb25seSBudW1iZXJbXSk6IFRlbnNvciB7XG4gICAgY29uc3QgaW5wdXRURCA9IHRoaXMuZ2V0T3JDcmVhdGVUZXh0dXJlRGF0YShpbnB1dCwgVGV4dHVyZVR5cGUudW5wYWNrZWQpO1xuICAgIGNvbnN0IG5ld1RleHR1cmVMYXlvdXQ6IFRleHR1cmVMYXlvdXQgPSB7XG4gICAgICBjaGFubmVsczogaW5wdXRURC5jaGFubmVscyxcbiAgICAgIGhlaWdodDogaW5wdXRURC5oZWlnaHQsXG4gICAgICB3aWR0aDogaW5wdXRURC53aWR0aCxcbiAgICAgIC8vIGhhbmRsZSByZXNoYXBpbmcgaW50byBzY2FsYXIgVGVuc29yc1xuICAgICAgc2hhcGU6IHJlc2hhcGVkRGltcy5sZW5ndGggIT09IDAgPyByZXNoYXBlZERpbXMgOiBbMV0sXG4gICAgICBzdHJpZGVzOiBTaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXMocmVzaGFwZWREaW1zKSxcbiAgICAgIHVucGFja2VkU2hhcGU6IHJlc2hhcGVkRGltcyxcbiAgICB9O1xuICAgIGNvbnN0IG5ld1RleHR1cmVEYXRhID0gdGhpcy5jcmVhdGVUZXh0dXJlRGF0YUZyb21UZXh0dXJlKG5ld1RleHR1cmVMYXlvdXQsIGlucHV0LnR5cGUsIGlucHV0VEQudGV4dHVyZSk7XG4gICAgcmV0dXJuIG5ld1RleHR1cmVEYXRhLnRlbnNvcjtcbiAgfVxuXG4gIHJlc2hhcGVQYWNrZWQoaW5wdXQ6IFRlbnNvciwgcmVzaGFwZWREaW1zOiByZWFkb25seSBudW1iZXJbXSk6IFRlbnNvciB7XG4gICAgY29uc3QgaW5wdXRURCA9IHRoaXMuZ2V0T3JDcmVhdGVUZXh0dXJlRGF0YShpbnB1dCwgVGV4dHVyZVR5cGUucGFja2VkKTtcblxuICAgIC8vIGNoZWNrIGlmIHRoZSByZXNoYXBlIGlzICdjaGVhcCdcbiAgICBpZiAoaXNSZXNoYXBlQ2hlYXAoaW5wdXQuZGltcywgcmVzaGFwZWREaW1zKSkge1xuICAgICAgY29uc3QgbmV3VGV4dHVyZUxheW91dDogVGV4dHVyZUxheW91dCA9IHtcbiAgICAgICAgY2hhbm5lbHM6IGlucHV0VEQuY2hhbm5lbHMsXG4gICAgICAgIGhlaWdodDogaW5wdXRURC5oZWlnaHQsXG4gICAgICAgIHdpZHRoOiBpbnB1dFRELndpZHRoLFxuICAgICAgICAvLyBoYW5kbGUgcmVzaGFwaW5nIGludG8gc2NhbGFyIFRlbnNvcnNcbiAgICAgICAgc2hhcGU6IHJlc2hhcGVkRGltcy5sZW5ndGggIT09IDAgPyByZXNoYXBlZERpbXMgOiBbMV0sXG4gICAgICAgIHN0cmlkZXM6IFNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyhyZXNoYXBlZERpbXMpLFxuICAgICAgICB1bnBhY2tlZFNoYXBlOiByZXNoYXBlZERpbXMsXG4gICAgICAgIGlzUGFja2VkOiB0cnVlLFxuICAgICAgfTtcbiAgICAgIGNvbnN0IG5ld1RleHR1cmVEYXRhID0gdGhpcy5jcmVhdGVUZXh0dXJlRGF0YUZyb21UZXh0dXJlKG5ld1RleHR1cmVMYXlvdXQsIGlucHV0LnR5cGUsIGlucHV0VEQudGV4dHVyZSk7XG4gICAgICByZXR1cm4gbmV3VGV4dHVyZURhdGEudGVuc29yO1xuICAgIH1cblxuICAgIGNvbnN0IHNxdWVlemVkSW5wdXRTaGFwZSA9IHByb2Nlc3NEaW1zM0QoaW5wdXQuZGltcyk7XG4gICAgY29uc3Qgc3F1ZWV6ZWRPdXRwdXRTaGFwZSA9IHByb2Nlc3NEaW1zM0QocmVzaGFwZWREaW1zKTtcblxuICAgIGNvbnN0IHNxdWVlemVkSW5wdXRUZW5zb3IgPSB0aGlzLnJlc2hhcGVQYWNrZWQoaW5wdXQsIHNxdWVlemVkSW5wdXRTaGFwZSk7XG4gICAgY29uc3Qgc3F1ZWV6ZWRPdXRwdXRUZW5zb3IgPSB0aGlzLnJ1bihcbiAgICAgIGNyZWF0ZVBhY2tlZFJlc2hhcGUzRFByb2dyYW1JbmZvTG9hZGVyKHRoaXMsIHNxdWVlemVkSW5wdXRUZW5zb3IsIHNxdWVlemVkT3V0cHV0U2hhcGUpLFxuICAgICAgW3NxdWVlemVkSW5wdXRUZW5zb3JdLFxuICAgICk7XG4gICAgY29uc3Qgb3V0cHV0VGVuc29yID0gdGhpcy5yZXNoYXBlUGFja2VkKHNxdWVlemVkT3V0cHV0VGVuc29yLCByZXNoYXBlZERpbXMpO1xuICAgIHJldHVybiBvdXRwdXRUZW5zb3I7XG4gIH1cblxuICBjYXN0KGlucHV0OiBUZW5zb3IsIHR5cGU6IFRlbnNvci5EYXRhVHlwZSk6IFRlbnNvciB7XG4gICAgY29uc3QgaW5wdXRURCA9IHRoaXMuZ2V0T3JDcmVhdGVUZXh0dXJlRGF0YShpbnB1dCwgVGV4dHVyZVR5cGUudW5wYWNrZWQpO1xuICAgIGNvbnN0IG5ld1RleHR1cmVEYXRhID0gdGhpcy5jcmVhdGVUZXh0dXJlRGF0YUZyb21UZXh0dXJlKGlucHV0VEQgYXMgVGV4dHVyZUxheW91dCwgdHlwZSwgaW5wdXRURC50ZXh0dXJlKTtcbiAgICByZXR1cm4gbmV3VGV4dHVyZURhdGEudGVuc29yO1xuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVUZXh0dXJlRGF0YUZyb21UZXh0dXJlKFxuICAgIGxheW91dDogVGV4dHVyZUxheW91dCxcbiAgICBkYXRhVHlwZTogVGVuc29yLkRhdGFUeXBlLFxuICAgIHRleHR1cmU6IFdlYkdMVGV4dHVyZSxcbiAgICB0ZW5zb3I/OiBUZW5zb3IsXG4gICAgdGVuc29ySWQ/OiBUZW5zb3IuSWQsXG4gICkge1xuICAgIGNvbnN0IHRleHR1cmVEYXRhOiBUZXh0dXJlRGF0YSA9IHtcbiAgICAgIC4uLmxheW91dCxcbiAgICAgIHRlbnNvcjpcbiAgICAgICAgdGVuc29yIHx8XG4gICAgICAgIG5ldyBUZW5zb3IoXG4gICAgICAgICAgbGF5b3V0LnVucGFja2VkU2hhcGUsXG4gICAgICAgICAgZGF0YVR5cGUsXG4gICAgICAgICAgKF9pZDogVGVuc29yLklkKSA9PiB0aGlzLnJlYWRUZXh0dXJlKHRleHR1cmVEYXRhKSxcbiAgICAgICAgICBhc3luYyAoX2lkOiBUZW5zb3IuSWQpID0+IHRoaXMucmVhZFRleHR1cmVBc3luYyh0ZXh0dXJlRGF0YSksXG4gICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgIHRlbnNvcklkLFxuICAgICAgICApLFxuICAgICAgdGV4dHVyZSxcbiAgICB9O1xuICAgIHRoaXMuc2V0VGV4dHVyZURhdGEodGV4dHVyZURhdGEudGVuc29yLmRhdGFJZCwgdGV4dHVyZURhdGEsIGxheW91dC5pc1BhY2tlZCk7XG4gICAgcmV0dXJuIHRleHR1cmVEYXRhO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRUZXh0dXJlRGF0YSh0ZW5zb3JJZDogVGVuc29yLklkLCBpc1BhY2tlZCA9IGZhbHNlKTogVGV4dHVyZURhdGEgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLnNlc3Npb24uaXNJbml0aWFsaXplcih0ZW5zb3JJZClcbiAgICAgID8gdGhpcy5zZXNzaW9uLmdldFRleHR1cmVEYXRhKHRlbnNvcklkLCBpc1BhY2tlZClcbiAgICAgIDogaXNQYWNrZWRcbiAgICAgICAgPyB0aGlzLnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUuZ2V0KHRlbnNvcklkKVxuICAgICAgICA6IHRoaXMudW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlLmdldCh0ZW5zb3JJZCk7XG4gIH1cbiAgc2V0VGV4dHVyZURhdGEodGVuc29ySWQ6IFRlbnNvci5JZCwgdGQ6IFRleHR1cmVEYXRhLCBpc1BhY2tlZCA9IGZhbHNlKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuc2Vzc2lvbi5pc0luaXRpYWxpemVyKHRlbnNvcklkKSkge1xuICAgICAgdGhpcy5zZXNzaW9uLnNldFRleHR1cmVEYXRhKHRlbnNvcklkLCB0ZCwgaXNQYWNrZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAoaXNQYWNrZWQgPyB0aGlzLnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUgOiB0aGlzLnVucGFja2VkVGV4dHVyZURhdGFDYWNoZSkuc2V0KHRlbnNvcklkLCB0ZCk7XG4gICAgfVxuICB9XG4gIGlzVGV4dHVyZUxheW91dENhY2hlZCh0ZW5zb3I6IFRlbnNvciwgaXNQYWNrZWQgPSBmYWxzZSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhIXRoaXMuZ2V0VGV4dHVyZURhdGEodGVuc29yLmRhdGFJZCwgaXNQYWNrZWQpO1xuICB9XG5cbiAgZGlzcG9zZSgpOiB2b2lkIHtcbiAgICB0aGlzLnNlc3Npb24udGV4dHVyZU1hbmFnZXIuY2xlYXJBY3RpdmVUZXh0dXJlcygpO1xuICAgIHRoaXMucGFja2VkVGV4dHVyZURhdGFDYWNoZS5mb3JFYWNoKCh0ZCkgPT4gdGhpcy5zZXNzaW9uLnRleHR1cmVNYW5hZ2VyLnJlbGVhc2VUZXh0dXJlKHRkKSk7XG4gICAgdGhpcy5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlID0gbmV3IE1hcCgpO1xuICAgIHRoaXMudW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlLmZvckVhY2goKHRkKSA9PiB0aGlzLnNlc3Npb24udGV4dHVyZU1hbmFnZXIucmVsZWFzZVRleHR1cmUodGQpKTtcbiAgICB0aGlzLnVucGFja2VkVGV4dHVyZURhdGFDYWNoZSA9IG5ldyBNYXAoKTtcbiAgfVxuXG4gIHJlYWRUZXh0dXJlKHRleHR1cmVEYXRhOiBUZXh0dXJlRGF0YSk6IFRlbnNvci5OdW1iZXJUeXBlIHtcbiAgICBpZiAodGV4dHVyZURhdGEuaXNQYWNrZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlYWRUZXh0dXJlKHRoaXMudW5wYWNrKHRleHR1cmVEYXRhKSk7XG4gICAgfVxuICAgIGlmICghdGhpcy5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LmlzRmxvYXQzMkRvd25sb2FkU3VwcG9ydGVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXNzaW9uLnRleHR1cmVNYW5hZ2VyLnJlYWRVaW50OFRleHR1cmVBc0Zsb2F0KGVuY29kZUFzVWludDgodGhpcywgdGV4dHVyZURhdGEpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc2Vzc2lvbi50ZXh0dXJlTWFuYWdlci5yZWFkVGV4dHVyZSh0ZXh0dXJlRGF0YSwgdGV4dHVyZURhdGEudGVuc29yLnR5cGUsIHRleHR1cmVEYXRhLmNoYW5uZWxzKTtcbiAgfVxuXG4gIGFzeW5jIHJlYWRUZXh0dXJlQXN5bmModGV4dHVyZURhdGE6IFRleHR1cmVEYXRhKTogUHJvbWlzZTxUZW5zb3IuTnVtYmVyVHlwZT4ge1xuICAgIGlmICh0ZXh0dXJlRGF0YS5pc1BhY2tlZCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVhZFRleHR1cmVBc3luYyh0aGlzLnVucGFjayh0ZXh0dXJlRGF0YSkpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC5pc0Zsb2F0MzJEb3dubG9hZFN1cHBvcnRlZCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2Vzc2lvbi50ZXh0dXJlTWFuYWdlci5yZWFkVWludDhUZXh0dXJlQXNGbG9hdChlbmNvZGVBc1VpbnQ4KHRoaXMsIHRleHR1cmVEYXRhKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNlc3Npb24udGV4dHVyZU1hbmFnZXIucmVhZFRleHR1cmVBc3luYyh0ZXh0dXJlRGF0YSwgdGV4dHVyZURhdGEudGVuc29yLnR5cGUsIHRleHR1cmVEYXRhLmNoYW5uZWxzKTtcbiAgfVxuXG4gIHBhY2soaW5wdXQ6IFRleHR1cmVEYXRhKTogVGV4dHVyZURhdGEge1xuICAgIGNvbnN0IG91dHB1dFRleHR1cmVEYXRhID0gdGhpcy5leGVjdXRlUHJvZ3JhbShjcmVhdGVQYWNrUHJvZ3JhbUluZm9Mb2FkZXIodGhpcywgaW5wdXQudGVuc29yKSwgW2lucHV0LnRlbnNvcl0pO1xuICAgIHJldHVybiBvdXRwdXRUZXh0dXJlRGF0YTtcbiAgfVxuXG4gIHVucGFjayhpbnB1dDogVGV4dHVyZURhdGEpOiBUZXh0dXJlRGF0YSB7XG4gICAgY29uc3Qgb3V0cHV0VGV4dHVyZURhdGEgPSB0aGlzLmV4ZWN1dGVQcm9ncmFtKGNyZWF0ZVVucGFja1Byb2dyYW1JbmZvTG9hZGVyKHRoaXMsIGlucHV0LnRlbnNvciksIFtpbnB1dC50ZW5zb3JdKTtcbiAgICByZXR1cm4gb3V0cHV0VGV4dHVyZURhdGE7XG4gIH1cbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuY2xhc3MgQXR0cmlidXRlV2l0aENhY2hlS2V5SW1wbCB7XG4gIGNvbnN0cnVjdG9yKGF0dHJpYnV0ZTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIGF0dHJpYnV0ZSk7XG4gIH1cblxuICBwcml2YXRlIGtleTogc3RyaW5nO1xuICBwdWJsaWMgZ2V0IGNhY2hlS2V5KCk6IHN0cmluZyB7XG4gICAgaWYgKCF0aGlzLmtleSkge1xuICAgICAgdGhpcy5rZXkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKVxuICAgICAgICAuc29ydCgpXG4gICAgICAgIC5tYXAoKG5hbWUpID0+IGAkeyh0aGlzIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KVtuYW1lXX1gKVxuICAgICAgICAuam9pbignOycpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5rZXk7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBjYWNoZUtleTogc3RyaW5nO1xufVxuXG5leHBvcnQgY29uc3QgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5ID0gPFQgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4oXG4gIGF0dHJpYnV0ZTogVCxcbik6IFQgJiBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgPT4gbmV3IEF0dHJpYnV0ZVdpdGhDYWNoZUtleUltcGwoYXR0cmlidXRlKSBhcyB1bmtub3duIGFzIFQgJiBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXk7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vLi4vLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7IEdyYXBoIH0gZnJvbSAnLi4vLi4vLi4vZ3JhcGgnO1xuaW1wb3J0IHsgT3BlcmF0b3JJbXBsZW1lbnRhdGlvbiwgT3BlcmF0b3JJbml0aWFsaXphdGlvbiB9IGZyb20gJy4uLy4uLy4uL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBUZW5zb3IgfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHsgZ2V0R2xzbCB9IGZyb20gJy4uL2dsc2wtc291cmNlJztcbmltcG9ydCB7IFdlYkdMSW5mZXJlbmNlSGFuZGxlciB9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7IFByb2dyYW1JbmZvLCBUZXh0dXJlVHlwZSB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBCYXRjaE5vcm1hbGl6YXRpb25BdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgZXBzaWxvbjogbnVtYmVyO1xuICBtb21lbnR1bTogbnVtYmVyO1xuICBzcGF0aWFsOiBudW1iZXI7XG59XG5cbmNvbnN0IGJhdGNoTm9ybWFsaXphdGlvblByb2dyYW1NZXRhZGF0YSA9IHtcbiAgbmFtZTogJ0JhdGNoTm9ybWFsaXphdGlvbicsXG4gIGlucHV0TmFtZXM6IFsnQScsICdTY2FsZScsICdCJywgJ01lYW4nLCAnVmFyaWFuY2UnXSxcbiAgaW5wdXRUeXBlczogW1xuICAgIFRleHR1cmVUeXBlLnVucGFja2VkLFxuICAgIFRleHR1cmVUeXBlLnVucGFja2VkLFxuICAgIFRleHR1cmVUeXBlLnVucGFja2VkLFxuICAgIFRleHR1cmVUeXBlLnVucGFja2VkLFxuICAgIFRleHR1cmVUeXBlLnVucGFja2VkLFxuICBdLFxufTtcblxuZXhwb3J0IGNvbnN0IGJhdGNoTm9ybWFsaXphdGlvbjogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxCYXRjaE5vcm1hbGl6YXRpb25BdHRyaWJ1dGVzPiA9IChcbiAgaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBpbnB1dHM6IFRlbnNvcltdLFxuICBhdHRyaWJ1dGVzOiBCYXRjaE5vcm1hbGl6YXRpb25BdHRyaWJ1dGVzLFxuKTogVGVuc29yW10gPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuICBjb25zdCBvdXRwdXQgPSBpbmZlcmVuY2VIYW5kbGVyLnJ1bihcbiAgICB7XG4gICAgICAuLi5iYXRjaE5vcm1hbGl6YXRpb25Qcm9ncmFtTWV0YWRhdGEsXG4gICAgICBjYWNoZUhpbnQ6IGF0dHJpYnV0ZXMuY2FjaGVLZXksXG4gICAgICBnZXQ6ICgpID0+IGNyZWF0ZUJhdGNoTm9ybWFsaXphdGlvblByb2dyYW1JbmZvKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0cywgYXR0cmlidXRlcyksXG4gICAgfSxcbiAgICBpbnB1dHMsXG4gICk7XG4gIHJldHVybiBbb3V0cHV0XTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUJhdGNoTm9ybWFsaXphdGlvbkF0dHJpYnV0ZXM6IE9wZXJhdG9ySW5pdGlhbGl6YXRpb248QmF0Y2hOb3JtYWxpemF0aW9uQXR0cmlidXRlcz4gPSAoXG4gIG5vZGU6IEdyYXBoLk5vZGUsXG4pOiBCYXRjaE5vcm1hbGl6YXRpb25BdHRyaWJ1dGVzID0+IHtcbiAgY29uc3QgZXBzaWxvbiA9IG5vZGUuYXR0cmlidXRlcy5nZXRGbG9hdCgnZXBzaWxvbicsIDFlLTUpO1xuICBjb25zdCBtb21lbnR1bSA9IG5vZGUuYXR0cmlidXRlcy5nZXRGbG9hdCgnbW9tZW50dW0nLCAwLjkpO1xuICBjb25zdCBzcGF0aWFsID0gbm9kZS5hdHRyaWJ1dGVzLmdldEludCgnc3BhdGlhbCcsIDEpO1xuICByZXR1cm4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHsgZXBzaWxvbiwgbW9tZW50dW0sIHNwYXRpYWwgfSk7XG59O1xuXG5jb25zdCBjcmVhdGVCYXRjaE5vcm1hbGl6YXRpb25Qcm9ncmFtSW5mbyA9IChcbiAgaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBpbnB1dHM6IFRlbnNvcltdLFxuICBhdHRyaWJ1dGVzOiBCYXRjaE5vcm1hbGl6YXRpb25BdHRyaWJ1dGVzLFxuKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBnbHNsID0gZ2V0R2xzbChpbmZlcmVuY2VIYW5kbGVyLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbik7XG4gIGNvbnN0IHJhbmsgPSBpbnB1dHNbMF0uZGltcy5sZW5ndGg7XG4gIGNvbnN0IFtzY2FsZVdpZHRoLCBzY2FsZUhlaWdodF0gPSBpbmZlcmVuY2VIYW5kbGVyLmNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodChcbiAgICBpbnB1dHNbMV0uZGltcyxcbiAgICBUZXh0dXJlVHlwZS51bnBhY2tlZCxcbiAgKTtcbiAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICBmbG9hdCBwcm9jZXNzKGludFske3Jhbmt9XSBpbmRpY2VzKSB7XG4gICAgdmVjMiBwb3NpdGlvbiA9IG9mZnNldFRvQ29vcmRzKGluZGljZXNbMV0sICR7c2NhbGVXaWR0aH0sICR7c2NhbGVIZWlnaHR9KTtcbiAgICBmbG9hdCBzY2FsZSA9IGdldENvbG9yQXNGbG9hdCgke2dsc2wudGV4dHVyZTJEfShTY2FsZSwgcG9zaXRpb24pKTtcbiAgICBmbG9hdCBtZWFuID0gZ2V0Q29sb3JBc0Zsb2F0KCR7Z2xzbC50ZXh0dXJlMkR9KE1lYW4sIHBvc2l0aW9uKSk7XG4gICAgZmxvYXQgdmFyaWFuY2UgPSBnZXRDb2xvckFzRmxvYXQoJHtnbHNsLnRleHR1cmUyRH0oVmFyaWFuY2UsIHBvc2l0aW9uKSk7XG4gICAgZmxvYXQgYiA9IGdldENvbG9yQXNGbG9hdCgke2dsc2wudGV4dHVyZTJEfShCLCBwb3NpdGlvbikpO1xuXG4gICAgcmV0dXJuIHNjYWxlICogKCAoX0EoaW5kaWNlcykgLSBtZWFuKSAvIHNxcnQodmFyaWFuY2UgKyBmbG9hdCgke2F0dHJpYnV0ZXMuZXBzaWxvbn0pKSApICsgYjtcbiAgfWA7XG4gIHJldHVybiB7XG4gICAgLi4uYmF0Y2hOb3JtYWxpemF0aW9uUHJvZ3JhbU1ldGFkYXRhLFxuICAgIG91dHB1dDogeyBkaW1zOiBpbnB1dHNbMF0uZGltcywgdHlwZTogaW5wdXRzWzBdLnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS51bnBhY2tlZCB9LFxuICAgIHNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogVGVuc29yW10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gNSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQmF0Y2hOb3JtYWxpemF0aW9uIHJlcXVpcmVzIDUgaW5wdXRzLicpO1xuICB9XG5cbiAgY29uc3QgWCA9IGlucHV0c1swXTtcbiAgY29uc3Qgc2NhbGUgPSBpbnB1dHNbMV07XG4gIGNvbnN0IEIgPSBpbnB1dHNbMl07XG4gIGNvbnN0IG1lYW4gPSBpbnB1dHNbM107XG4gIGNvbnN0IHZhcl8gPSBpbnB1dHNbNF07XG5cbiAgLy8gaW5wdXQgc2hvdWxkIGF0bGVhc3QgaGF2ZSB0aHJlZSBkaW1lbnNpb25zIC0gTixDLGRpbTEsLi4uLGRpbW5cbiAgLy8gb3RoZXIgaW5wdXRzIGNhbiBoYXZlIG9ubHkgb25lIGRpbWVuc2lvbnNcbiAgaWYgKFxuICAgIFguZGltcy5sZW5ndGggPCAzIHx8XG4gICAgc2NhbGUuZGltcy5sZW5ndGggIT09IDEgfHxcbiAgICBCLmRpbXMubGVuZ3RoICE9PSAxIHx8XG4gICAgbWVhbi5kaW1zLmxlbmd0aCAhPT0gMSB8fFxuICAgIHZhcl8uZGltcy5sZW5ndGggIT09IDFcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGlucHV0IHNoYXBlLicpO1xuICB9XG4gIGlmIChcbiAgICBzY2FsZS5kaW1zWzBdICE9PSBYLmRpbXNbMV0gfHxcbiAgICBCLmRpbXNbMF0gIT09IFguZGltc1sxXSB8fFxuICAgIG1lYW4uZGltc1swXSAhPT0gWC5kaW1zWzFdIHx8XG4gICAgdmFyXy5kaW1zWzBdICE9PSBYLmRpbXNbMV1cbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGlucHV0IHNoYXBlLicpO1xuICB9XG4gIGlmIChcbiAgICAoWC50eXBlICE9PSAnZmxvYXQzMicgJiYgWC50eXBlICE9PSAnZmxvYXQ2NCcpIHx8XG4gICAgKHNjYWxlLnR5cGUgIT09ICdmbG9hdDMyJyAmJiBzY2FsZS50eXBlICE9PSAnZmxvYXQ2NCcpIHx8XG4gICAgKEIudHlwZSAhPT0gJ2Zsb2F0MzInICYmIEIudHlwZSAhPT0gJ2Zsb2F0NjQnKSB8fFxuICAgIChtZWFuLnR5cGUgIT09ICdmbG9hdDMyJyAmJiBtZWFuLnR5cGUgIT09ICdmbG9hdDY0JykgfHxcbiAgICAodmFyXy50eXBlICE9PSAnZmxvYXQzMicgJiYgdmFyXy50eXBlICE9PSAnZmxvYXQ2NCcpXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbnB1dCB0ZW5zb3IgdHlwZXMuJyk7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IFByb2dyYW1JbmZvLCBUZXh0dXJlTGF5b3V0IH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBXZWJHTENvbnRleHQgfSBmcm9tICcuL3dlYmdsLWNvbnRleHQnO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb24gKi9cbmV4cG9ydCBlbnVtIEZ1bmN0aW9uVHlwZSB7XG4gIFZhbHVlQmFzZWQsXG4gIFBvc2l0aW9uYWwsXG59XG5leHBvcnQgaW50ZXJmYWNlIEdsc2xGdW5jdGlvbjxUIGV4dGVuZHMgRnVuY3Rpb25UeXBlPiB7XG4gIGJvZHk6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICB0eXBlOiBUO1xufVxuZXhwb3J0IHR5cGUgR2xzbFZhbHVlRnVuY3Rpb24gPSBHbHNsRnVuY3Rpb248RnVuY3Rpb25UeXBlLlZhbHVlQmFzZWQ+O1xuZXhwb3J0IGludGVyZmFjZSBHbHNsUG9zaXRpb25hbEZ1bmN0aW9uIGV4dGVuZHMgR2xzbEZ1bmN0aW9uPEZ1bmN0aW9uVHlwZS5Qb3NpdGlvbmFsPiB7XG4gIGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdO1xuICBvdXRwdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW107XG59XG5cbmV4cG9ydCBjbGFzcyBHbHNsQ29udGV4dCB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBnbENvbnRleHQ6IFdlYkdMQ29udGV4dCxcbiAgICBwdWJsaWMgcHJvZ3JhbUluZm86IFByb2dyYW1JbmZvLFxuICAgIHB1YmxpYyBpbnB1dFRleHR1cmVMYXlvdXRzOiBUZXh0dXJlTGF5b3V0W10sXG4gICAgcHVibGljIG91dHB1dFRleHR1cmVMYXlvdXQ6IFRleHR1cmVMYXlvdXQsXG4gICkge31cbn1cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBHbHNsTGliIHtcbiAgY29uc3RydWN0b3IocHVibGljIGNvbnRleHQ6IEdsc2xDb250ZXh0KSB7fVxuICBhYnN0cmFjdCBnZXRGdW5jdGlvbnMoKTogeyBbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmUgfTtcbiAgYWJzdHJhY3QgZ2V0Q3VzdG9tVHlwZXMoKTogeyBbbmFtZTogc3RyaW5nXTogc3RyaW5nIH07XG59XG5cbi8vIGFic3RyYWN0aW9uIHRvIHJlcHJlc2VudCBhIEdMU0wgbGlicmFyeSByb3V0aW5lIGFuZCBpdCdzIGRlcGVuZGVuY2llc1xuZXhwb3J0IGNsYXNzIEdsc2xMaWJSb3V0aW5lIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIHJvdXRpbmVCb2R5OiBzdHJpbmcsXG4gICAgcHVibGljIGRlcGVuZGVuY2llcz86IHN0cmluZ1tdLFxuICApIHt9XG59XG5cbi8vIGFic3RyYWN0aW9uIHRvIHJlcHJlc2VudCBhIEdMU0wgbGlicmFyeSByb3V0aW5lIGFuZCBpdCdzIGRlcGVuZGVuY2llcyBBUyBHUkFQSCBOb2Rlc1xuLy8gdGhpcyBsZXZlbCBvZiBhYnN0cmFjdGlvbiBpcyB1c2VkIHRvIHRvcG9sb2dpY2FsbHkgc29ydCByb3V0aW5lcyBiZWZvcmUgZnJhZ21lbnQgc2hhZGUgaW5jbHVzaW9uXG5leHBvcnQgY2xhc3MgR2xzbExpYlJvdXRpbmVOb2RlIHtcbiAgZGVwZW5kZW5jaWVzOiBHbHNsTGliUm91dGluZU5vZGVbXTtcbiAgcm91dGluZUJvZHk6IHN0cmluZztcbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIG5hbWU6IHN0cmluZyxcbiAgICByb3V0aW5lQm9keT86IHN0cmluZyxcbiAgICBkZXBlbmRlbmNpZXM/OiBHbHNsTGliUm91dGluZU5vZGVbXSxcbiAgKSB7XG4gICAgaWYgKGRlcGVuZGVuY2llcykge1xuICAgICAgdGhpcy5kZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVwZW5kZW5jaWVzID0gW107XG4gICAgfVxuXG4gICAgaWYgKHJvdXRpbmVCb2R5KSB7XG4gICAgICB0aGlzLnJvdXRpbmVCb2R5ID0gcm91dGluZUJvZHk7XG4gICAgfVxuICB9XG4gIGFkZERlcGVuZGVuY3kobm9kZTogR2xzbExpYlJvdXRpbmVOb2RlKSB7XG4gICAgaWYgKG5vZGUpIHtcbiAgICAgIHRoaXMuZGVwZW5kZW5jaWVzLnB1c2gobm9kZSk7XG4gICAgfVxuICB9XG59XG5cbi8vIHRvcG9sb2dpY2FsbHkgc29ydCBHTFNMIGxpYnJhcnkgcm91dGluZXMgKGdyYXBoIG5vZGVzIGFic3RyYWN0aW9uKSBiZWZvcmUgc2hhZGVyIHNjcmlwdCBpbmNsdXNpb25cbmV4cG9ydCBjbGFzcyBUb3BvbG9naWNhbFNvcnRHbHNsUm91dGluZXMge1xuICBzdGF0aWMgcmV0dXJuT3JkZXJlZE5vZGVzKG5vZGVzOiBHbHNsTGliUm91dGluZU5vZGVbXSk6IEdsc2xMaWJSb3V0aW5lTm9kZVtdIHtcbiAgICBpZiAoIW5vZGVzIHx8IG5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGlmIChub2Rlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBub2RlcztcbiAgICB9XG5cbiAgICBjb25zdCBjeWNsZUNoZWNrID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gICAgY29uc3QgYWxyZWFkeVRyYXZlcnNlZCA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheTxHbHNsTGliUm91dGluZU5vZGU+KCk7XG5cbiAgICB0aGlzLmNyZWF0ZU9yZGVyZWROb2Rlcyhub2RlcywgY3ljbGVDaGVjaywgYWxyZWFkeVRyYXZlcnNlZCwgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgY3JlYXRlT3JkZXJlZE5vZGVzKFxuICAgIGdyYXBoTm9kZXM6IEdsc2xMaWJSb3V0aW5lTm9kZVtdLFxuICAgIGN5Y2xlQ2hlY2s6IFNldDxzdHJpbmc+LFxuICAgIGFscmVhZHlUcmF2ZXJzZWQ6IFNldDxzdHJpbmc+LFxuICAgIHJlc3VsdDogR2xzbExpYlJvdXRpbmVOb2RlW10sXG4gICkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JhcGhOb2Rlcy5sZW5ndGg7ICsraSkge1xuICAgICAgdGhpcy5kZnNUcmF2ZXJzZShncmFwaE5vZGVzW2ldLCBjeWNsZUNoZWNrLCBhbHJlYWR5VHJhdmVyc2VkLCByZXN1bHQpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIGRmc1RyYXZlcnNlKFxuICAgIHJvb3Q6IEdsc2xMaWJSb3V0aW5lTm9kZSxcbiAgICBjeWNsZUNoZWNrOiBTZXQ8c3RyaW5nPixcbiAgICBhbHJlYWR5VHJhdmVyc2VkOiBTZXQ8c3RyaW5nPixcbiAgICByZXN1bHQ6IEdsc2xMaWJSb3V0aW5lTm9kZVtdLFxuICApIHtcbiAgICAvLyBpZiB0aGlzIHJvb3QgaGFzIGFscmVhZHkgYmVlbiB0cmF2ZXJzZWQgcmV0dXJuXG4gICAgaWYgKCFyb290IHx8IGFscmVhZHlUcmF2ZXJzZWQuaGFzKHJvb3QubmFtZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBjeWNsaWMgZGVwZW5kZW5jeSBoYXMgYmVlbiBkZXRlY3RlZFxuICAgIGlmIChjeWNsZUNoZWNrLmhhcyhyb290Lm5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDeWNsaWMgZGVwZW5kZW5jeSBkZXRlY3RlZC4gQ2FuJ3QgdG9wb2xvZ2ljYWxseSBzb3J0IHJvdXRpbmVzIG5lZWRlZCBmb3Igc2hhZGVyLlwiKTtcbiAgICB9XG5cbiAgICAvLyBob2xkIHRoaXMgbm9kZSB0byBkZXRlY3QgY3ljbGVzIGlmIGFueVxuICAgIGN5Y2xlQ2hlY2suYWRkKHJvb3QubmFtZSk7XG5cbiAgICAvLyB0cmF2ZXJzZSBjaGlsZHJlbiBpbiBhIGRmcyBmYXNoaW9uXG4gICAgY29uc3QgZGVwZW5kZW5jaWVzID0gcm9vdC5kZXBlbmRlbmNpZXM7XG4gICAgaWYgKGRlcGVuZGVuY2llcyAmJiBkZXBlbmRlbmNpZXMubGVuZ3RoID4gMCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZXBlbmRlbmNpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdGhpcy5kZnNUcmF2ZXJzZShkZXBlbmRlbmNpZXNbaV0sIGN5Y2xlQ2hlY2ssIGFscmVhZHlUcmF2ZXJzZWQsIHJlc3VsdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWRkIHRvIHJlc3VsdCBob2xkZXJcbiAgICByZXN1bHQucHVzaChyb290KTtcblxuICAgIC8vIG1hcmsgdGhpcyBub2RlIGFzIHRyYXZlcnNlZCBzbyB0aGF0IHdlIGRvbid0IHRyYXZlcnNlIGZyb20gdGhpcyBhZ2FpblxuICAgIGFscmVhZHlUcmF2ZXJzZWQuYWRkKHJvb3QubmFtZSk7XG5cbiAgICAvLyByZWxlYXNlIHRoZSBob2xkXG4gICAgY3ljbGVDaGVjay5kZWxldGUocm9vdC5uYW1lKTtcbiAgfVxufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBUZW5zb3IgfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHsgQnJvYWRjYXN0VXRpbCwgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBGdW5jdGlvblR5cGUsIEdsc2xWYWx1ZUZ1bmN0aW9uIH0gZnJvbSAnLi4vZ2xzbC1kZWZpbml0aW9ucyc7XG5pbXBvcnQgeyBnZXRHbHNsIH0gZnJvbSAnLi4vZ2xzbC1zb3VyY2UnO1xuaW1wb3J0IHsgV2ViR0xJbmZlcmVuY2VIYW5kbGVyIH0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHsgUHJvZ3JhbUluZm8sIFByb2dyYW1JbmZvTG9hZGVyLCBUZXh0dXJlVHlwZSB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xBZGQoKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICBjb25zdCBuYW1lID0gJ2FkZF8nO1xuICBjb25zdCBib2R5ID0gYFxuICBmbG9hdCAke25hbWV9KGZsb2F0IGEsIGZsb2F0IGIpIHtcbiAgICByZXR1cm4gYSArIGI7XG4gIH1cbiAgdmVjNCAke25hbWV9KHZlYzQgdjEsIHZlYzQgdjIpIHtcbiAgICByZXR1cm4gdjEgKyB2MjtcbiAgfVxuICBgO1xuICByZXR1cm4geyBib2R5LCBuYW1lLCB0eXBlOiBGdW5jdGlvblR5cGUuVmFsdWVCYXNlZCB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xEaXYoKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICBjb25zdCBuYW1lID0gJ2Rpdl8nO1xuICBjb25zdCBib2R5ID0gYFxuICBmbG9hdCAke25hbWV9KGZsb2F0IGEsIGZsb2F0IGIpIHtcbiAgICByZXR1cm4gYSAvIGI7XG4gIH1cbiAgdmVjNCAke25hbWV9KHZlYzQgdjEsIHZlYzQgdjIpIHtcbiAgICByZXR1cm4gdjEgLyB2MjtcbiAgfVxuICBgO1xuICByZXR1cm4geyBib2R5LCBuYW1lLCB0eXBlOiBGdW5jdGlvblR5cGUuVmFsdWVCYXNlZCB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xNdWwoKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICBjb25zdCBuYW1lID0gJ211bF8nO1xuICBjb25zdCBib2R5ID0gYFxuICBmbG9hdCAke25hbWV9KGZsb2F0IGEsIGZsb2F0IGIpIHtcbiAgICByZXR1cm4gYSAqIGI7XG4gIH1cbiAgdmVjNCAke25hbWV9KHZlYzQgdjEsIHZlYzQgdjIpIHtcbiAgICByZXR1cm4gdjEgKiB2MjtcbiAgfVxuICBgO1xuICByZXR1cm4geyBib2R5LCBuYW1lLCB0eXBlOiBGdW5jdGlvblR5cGUuVmFsdWVCYXNlZCB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xTdWIoKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICBjb25zdCBuYW1lID0gJ3N1Yl8nO1xuICBjb25zdCBib2R5ID0gYFxuICBmbG9hdCAke25hbWV9KGZsb2F0IGEsIGZsb2F0IGIpIHtcbiAgICByZXR1cm4gYSAtIGI7XG4gIH1cbiAgdmVjNCAke25hbWV9KHZlYzQgdjEsIHZlYzQgdjIpIHtcbiAgICByZXR1cm4gdjEgLSB2MjtcbiAgfVxuICBgO1xuICByZXR1cm4geyBib2R5LCBuYW1lLCB0eXBlOiBGdW5jdGlvblR5cGUuVmFsdWVCYXNlZCB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xFcXVhbCgpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIGNvbnN0IG5hbWUgPSAnZXF1YWxfJztcbiAgY29uc3QgYm9keSA9IGBcbiAgZmxvYXQgJHtuYW1lfShmbG9hdCBhLCBmbG9hdCBiKSB7XG4gICAgcmV0dXJuIGZsb2F0KGEgPT0gYik7XG4gIH1cbiAgdmVjNCAke25hbWV9KHZlYzQgdjEsIHZlYzQgdjIpIHtcbiAgICByZXR1cm4gdmVjNChlcXVhbCh2MSwgdjIpKTtcbiAgfVxuICBgO1xuICByZXR1cm4geyBib2R5LCBuYW1lLCB0eXBlOiBGdW5jdGlvblR5cGUuVmFsdWVCYXNlZCB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xHcmVhdGVyKCk6IEdsc2xWYWx1ZUZ1bmN0aW9uIHtcbiAgY29uc3QgbmFtZSA9ICdncmVhdGVyXyc7XG4gIGNvbnN0IGJvZHkgPSBgXG4gIGZsb2F0ICR7bmFtZX0oZmxvYXQgYSwgZmxvYXQgYikge1xuICAgIHJldHVybiBmbG9hdChhID4gYik7XG4gIH1cbiAgdmVjNCAke25hbWV9KHZlYzQgdjEsIHZlYzQgdjIpIHtcbiAgICByZXR1cm4gdmVjNCggdjEuciA+IHYyLnIgLFxuICAgICAgdjEuZyA+IHYyLmcsXG4gICAgICB2MS5iID4gdjIuYixcbiAgICAgIHYxLmEgPiB2Mi5hICk7XG4gIH1cbiAgYDtcbiAgcmV0dXJuIHsgYm9keSwgbmFtZSwgdHlwZTogRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWQgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnbHNsTGVzcygpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIGNvbnN0IG5hbWUgPSAnbGVzc18nO1xuICBjb25zdCBib2R5ID0gYFxuICBmbG9hdCAke25hbWV9KGZsb2F0IGEsIGZsb2F0IGIpIHtcbiAgICByZXR1cm4gZmxvYXQoYSA8IGIpO1xuICB9XG4gIHZlYzQgJHtuYW1lfSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XG4gICAgcmV0dXJuIHZlYzQoIHYxLnIgPCB2Mi5yICxcbiAgICAgICAgICAgICAgICB2MS5nIDwgdjIuZyxcbiAgICAgICAgICAgICAgICB2MS5iIDwgdjIuYixcbiAgICAgICAgICAgICAgICB2MS5hIDwgdjIuYSApO1xuICB9XG4gIGA7XG4gIHJldHVybiB7IGJvZHksIG5hbWUsIHR5cGU6IEZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkIH07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbEFuZCgpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIGNvbnN0IG5hbWUgPSAnYW5kXyc7XG4gIGNvbnN0IGJvZHkgPSBgXG4gIGZsb2F0ICR7bmFtZX0oZmxvYXQgYSwgZmxvYXQgYikge1xuICAgIHJldHVybiBmbG9hdCggYm9vbChhKSAmJiBib29sKGIpICk7XG4gIH1cbiAgdmVjNCAke25hbWV9KHZlYzQgdjEsIHZlYzQgdjIpIHtcbiAgICBidmVjNCBiMSA9IGJ2ZWM0KHYxKTtcbiAgICBidmVjNCBiMiA9IGJ2ZWM0KHYyKTtcbiAgICByZXR1cm4gdmVjNCggYjEuciAmJiBiMi5yICxcbiAgICAgICAgICAgICAgICBiMS5nICYmIGIyLmcsXG4gICAgICAgICAgICAgICAgYjEuYiAmJiBiMi5iLFxuICAgICAgICAgICAgICAgIGIxLmEgJiYgYjIuYSApO1xuICB9XG4gIGA7XG4gIHJldHVybiB7IGJvZHksIG5hbWUsIHR5cGU6IEZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkIH07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbE9yKCk6IEdsc2xWYWx1ZUZ1bmN0aW9uIHtcbiAgY29uc3QgbmFtZSA9ICdvcl8nO1xuICBjb25zdCBib2R5ID0gYFxuICBmbG9hdCAke25hbWV9KGZsb2F0IGEsIGZsb2F0IGIpIHtcbiAgICByZXR1cm4gZmxvYXQoIGJvb2woYSkgfHwgYm9vbChiKSApO1xuICB9XG4gIHZlYzQgJHtuYW1lfSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XG4gICAgYnZlYzQgYjEgPSBidmVjNCh2MSk7XG4gICAgYnZlYzQgYjIgPSBidmVjNCh2Mik7XG4gICAgcmV0dXJuIHZlYzQoIGIxLnIgfHwgYjIuciAsXG4gICAgICAgICAgICAgICAgYjEuZyB8fCBiMi5nLFxuICAgICAgICAgICAgICAgIGIxLmIgfHwgYjIuYixcbiAgICAgICAgICAgICAgICBiMS5hIHx8IGIyLmEgKTtcbiAgfVxuICBgO1xuICByZXR1cm4geyBib2R5LCBuYW1lLCB0eXBlOiBGdW5jdGlvblR5cGUuVmFsdWVCYXNlZCB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xYb3IoKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICBjb25zdCBuYW1lID0gJ3hvcl8nO1xuICBjb25zdCBib2R5ID0gYFxuICBmbG9hdCAke25hbWV9KGZsb2F0IGEsIGZsb2F0IGIpIHtcbiAgICByZXR1cm4gZmxvYXQoIGJvb2woYSkgXl4gYm9vbChiKSApO1xuICB9XG4gIHZlYzQgJHtuYW1lfSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XG4gICAgYnZlYzQgYjEgPSBidmVjNCh2MSk7XG4gICAgYnZlYzQgYjIgPSBidmVjNCh2Mik7XG4gICAgcmV0dXJuIHZlYzQoIGIxLnIgXl4gYjIuciAsXG4gICAgICAgICAgICAgICAgYjEuZyBeXiBiMi5nLFxuICAgICAgICAgICAgICAgIGIxLmIgXl4gYjIuYixcbiAgICAgICAgICAgICAgICBiMS5hIF5eIGIyLmEgKTtcbiAgfVxuICBgO1xuICByZXR1cm4geyBib2R5LCBuYW1lLCB0eXBlOiBGdW5jdGlvblR5cGUuVmFsdWVCYXNlZCB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xQb3coKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICByZXR1cm4gZ2xzbEJ1aWx0aW5CaW5hcnkoJ3BvdycpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xQUmVsdSgpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIGNvbnN0IG5hbWUgPSAncHJlbHVfJztcbiAgY29uc3QgYm9keSA9IGBcbiAgZmxvYXQgJHtuYW1lfShmbG9hdCBhLCBmbG9hdCBiKSB7XG4gICAgcmV0dXJuIGEgPCAwLjAgPyBhICogYjogYTtcbiAgfVxuICB2ZWM0ICR7bmFtZX0odmVjNCB2MSwgdmVjNCB2Mikge1xuICAgIHJldHVybiB2ZWM0KFxuICAgICAgdjEuciA8IDAuMCA/IHYxLnIgKiB2Mi5yOiB2MS5yLFxuICAgICAgdjEuZyA8IDAuMCA/IHYxLmcgKiB2Mi5nOiB2MS5nLFxuICAgICAgdjEuYiA8IDAuMCA/IHYxLmIgKiB2Mi5iOiB2MS5iLFxuICAgICAgdjEuYSA8IDAuMCA/IHYxLmEgKiB2Mi5hOiB2MS5hXG4gICAgICApO1xuICB9XG4gIGA7XG4gIHJldHVybiB7IGJvZHksIG5hbWUsIHR5cGU6IEZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkIH07XG59XG5cbmZ1bmN0aW9uIGdsc2xCdWlsdGluQmluYXJ5KGZuYW1lOiBzdHJpbmcpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIGNvbnN0IG5hbWUgPSBgJHtmbmFtZX1fYDtcbiAgY29uc3QgYm9keSA9IGBcbiAgZmxvYXQgJHtuYW1lfShmbG9hdCBhLCBmbG9hdCBiKSB7XG4gICAgcmV0dXJuICR7Zm5hbWV9KGEsIGIpO1xuICB9XG4gIHZlYzQgJHtuYW1lfSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XG4gICAgcmV0dXJuICR7Zm5hbWV9KHYxLCB2Mik7XG4gIH1cbiAgYDtcbiAgcmV0dXJuIHsgYm9keSwgbmFtZSwgdHlwZTogRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWQgfTtcbn1cblxuY29uc3QgY3JlYXRlQmluYXJ5UHJvZ3JhbUluZm9Mb2FkZXIgPSAoXG4gIGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXRzOiBUZW5zb3JbXSxcbiAgZ2xzbEZ1bmM6IEdsc2xWYWx1ZUZ1bmN0aW9uLFxuICBvdXRwdXRUZW5zb3JUeXBlOiBUZW5zb3IuRGF0YVR5cGUgPSBpbnB1dHNbMF0udHlwZSxcbiAgY2FjaGVLZXk/OiBzdHJpbmcsXG4pOiBQcm9ncmFtSW5mb0xvYWRlciA9PiB7XG4gIGNvbnN0IHRleHR1cmVUeXBlID0gaGFuZGxlci5zZXNzaW9uLnBhY2sgPyBUZXh0dXJlVHlwZS5wYWNrZWQgOiBUZXh0dXJlVHlwZS51bnBhY2tlZDtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBnbHNsRnVuYy5uYW1lLFxuICAgIGlucHV0TmFtZXM6IFsnQScsICdCJ10sXG4gICAgaW5wdXRUeXBlczogW3RleHR1cmVUeXBlLCB0ZXh0dXJlVHlwZV0sXG4gICAgY2FjaGVIaW50OiBjYWNoZUtleSxcbiAgICBnZXQ6ICgpID0+IGNyZWF0ZUJpbmFyeVByb2dyYW1JbmZvKGhhbmRsZXIsIGlucHV0cywgZ2xzbEZ1bmMsIG91dHB1dFRlbnNvclR5cGUpLFxuICB9O1xufTtcblxuY29uc3QgY3JlYXRlQmluYXJ5UHJvZ3JhbUluZm8gPSAoXG4gIGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXRzOiBUZW5zb3JbXSxcbiAgZ2xzbEZ1bmM6IEdsc2xWYWx1ZUZ1bmN0aW9uLFxuICBvdXRwdXRUZW5zb3JUeXBlOiBUZW5zb3IuRGF0YVR5cGUgPSBpbnB1dHNbMF0udHlwZSxcbik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgdGV4dHVyZVR5cGUgPSBoYW5kbGVyLnNlc3Npb24ucGFjayA/IFRleHR1cmVUeXBlLnBhY2tlZCA6IFRleHR1cmVUeXBlLnVucGFja2VkO1xuICBjb25zdCBpc0Jyb2FkY2FzdCA9ICFTaGFwZVV0aWwuYXJlRXF1YWwoaW5wdXRzWzBdLmRpbXMsIGlucHV0c1sxXS5kaW1zKTtcbiAgbGV0IG91dHB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG5cbiAgY29uc3QgdXNlUGFja2VkVGV4dHVyZSA9IGhhbmRsZXIuc2Vzc2lvbi5wYWNrO1xuXG4gIGlmIChpc0Jyb2FkY2FzdCkge1xuICAgIGNvbnN0IGNhbGN1bGF0ZWRTaGFwZSA9IEJyb2FkY2FzdFV0aWwuY2FsY1NoYXBlKGlucHV0c1swXS5kaW1zLCBpbnB1dHNbMV0uZGltcywgZmFsc2UpO1xuICAgIGlmICghY2FsY3VsYXRlZFNoYXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBwZXJmb3JtIGJpbmFyeSBvcCBvbiB0aGUgZ2l2ZW4gdGVuc29yc1wiKTtcbiAgICB9XG4gICAgb3V0cHV0U2hhcGUgPSBjYWxjdWxhdGVkU2hhcGU7XG4gICAgY29uc3Qgb3V0cHV0UmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aDtcbiAgICBjb25zdCBhUmFuayA9IGlucHV0c1swXS5kaW1zLmxlbmd0aCAhPT0gMCA/IGlucHV0c1swXS5kaW1zLmxlbmd0aCA6IDE7XG4gICAgY29uc3QgYlJhbmsgPSBpbnB1dHNbMV0uZGltcy5sZW5ndGggIT09IDAgPyBpbnB1dHNbMV0uZGltcy5sZW5ndGggOiAxO1xuICAgIGNvbnN0IGFCY2FzdCA9IGlucHV0c1swXS5kaW1zLmxlbmd0aCAhPT0gMCA/ICdiY2FzdEluZGljZXNfQShpbmRpY2VzLCBhaW5kaWNlcyk7JyA6ICdhaW5kaWNlc1swXSA9IDA7JztcbiAgICBjb25zdCBiQmNhc3QgPSBpbnB1dHNbMV0uZGltcy5sZW5ndGggIT09IDAgPyAnYmNhc3RJbmRpY2VzX0IoaW5kaWNlcywgYmluZGljZXMpOycgOiAnYmluZGljZXNbMF0gPSAwOyc7XG5cbiAgICBjb25zdCBnbHNsID0gZ2V0R2xzbChoYW5kbGVyLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbik7XG4gICAgY29uc3Qgc2hhZGVyU291cmNlID0gdXNlUGFja2VkVGV4dHVyZVxuICAgICAgPyBgXG4gICAgICAke2dsc2xGdW5jLmJvZHl9XG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIHZlYzQgYSA9IGdldEFBdE91dENvb3JkcygpO1xuICAgICAgICB2ZWM0IGIgPSBnZXRCQXRPdXRDb29yZHMoKTtcbiAgICAgICAgdmVjNCByZXN1bHQgPSAke2dsc2xGdW5jLm5hbWV9KGEsIGIpO1xuICAgICAgICAke2dsc2wub3V0cHV0fSA9IHJlc3VsdDtcbiAgICAgIH1gXG4gICAgICA6IGBcbiAgICAgICR7Z2xzbEZ1bmMuYm9keX1cbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbJHtvdXRwdXRSYW5rfV0pIHtcbiAgICAgICAgaW50IGFpbmRpY2VzWyR7YVJhbmt9XTtcbiAgICAgICAgaW50IGJpbmRpY2VzWyR7YlJhbmt9XTtcbiAgICAgICAgJHthQmNhc3R9XG4gICAgICAgICR7YkJjYXN0fVxuICAgICAgICByZXR1cm4gJHtnbHNsRnVuYy5uYW1lfShfQShhaW5kaWNlcyksIF9CKGJpbmRpY2VzKSk7XG4gICAgICB9YDtcblxuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBnbHNsRnVuYy5uYW1lLFxuICAgICAgaW5wdXROYW1lczogWydBJywgJ0InXSxcbiAgICAgIGlucHV0VHlwZXM6IFt0ZXh0dXJlVHlwZSwgdGV4dHVyZVR5cGVdLFxuICAgICAgb3V0cHV0OiB7IGRpbXM6IG91dHB1dFNoYXBlLCB0eXBlOiBvdXRwdXRUZW5zb3JUeXBlLCB0ZXh0dXJlVHlwZSB9LFxuICAgICAgc2hhZGVyU291cmNlLFxuICAgICAgaGFzTWFpbjogdXNlUGFja2VkVGV4dHVyZSxcbiAgICB9O1xuICB9XG4gIGNvbnN0IGdsc2wgPSBnZXRHbHNsKGhhbmRsZXIuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICR7Z2xzbEZ1bmMuYm9keX1cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICB2ZWM0IHYxID0gJHtnbHNsLnRleHR1cmUyRH0oQSwgVGV4Q29vcmRzKTtcbiAgICAgIHZlYzQgdjIgPSAke2dsc2wudGV4dHVyZTJEfShCLCBUZXhDb29yZHMpO1xuICAgICAgdmVjNCByZXN1bHQgPSAke2dsc2xGdW5jLm5hbWV9KHYxLCB2Mik7XG4gICAgICAke2dsc2wub3V0cHV0fSA9IHJlc3VsdDtcbiAgICB9XG4gICAgYDtcblxuICByZXR1cm4ge1xuICAgIG5hbWU6IGdsc2xGdW5jLm5hbWUsXG4gICAgaW5wdXROYW1lczogWydBJywgJ0InXSxcbiAgICBpbnB1dFR5cGVzOiBbdGV4dHVyZVR5cGUsIHRleHR1cmVUeXBlXSxcbiAgICBvdXRwdXQ6IHsgZGltczogaW5wdXRzWzBdLmRpbXMsIHR5cGU6IG91dHB1dFRlbnNvclR5cGUsIHRleHR1cmVUeXBlIH0sXG4gICAgc2hhZGVyU291cmNlLFxuICAgIGhhc01haW46IHRydWUsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgYWRkID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdID0+IFtcbiAgaGFuZGxlci5ydW4oY3JlYXRlQmluYXJ5UHJvZ3JhbUluZm9Mb2FkZXIoaGFuZGxlciwgaW5wdXRzLCBnbHNsQWRkKCkpLCBpbnB1dHMpLFxuXTtcblxuZXhwb3J0IGNvbnN0IGFuZCA9IChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSA9PiBbXG4gIGhhbmRsZXIucnVuKGNyZWF0ZUJpbmFyeVByb2dyYW1JbmZvTG9hZGVyKGhhbmRsZXIsIGlucHV0cywgZ2xzbEFuZCgpLCAnYm9vbCcpLCBpbnB1dHMpLFxuXTtcblxuZXhwb3J0IGNvbnN0IGRpdiA9IChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSA9PiBbXG4gIGhhbmRsZXIucnVuKGNyZWF0ZUJpbmFyeVByb2dyYW1JbmZvTG9hZGVyKGhhbmRsZXIsIGlucHV0cywgZ2xzbERpdigpKSwgaW5wdXRzKSxcbl07XG5cbmV4cG9ydCBjb25zdCBlcXVhbCA9IChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSA9PiBbXG4gIGhhbmRsZXIucnVuKGNyZWF0ZUJpbmFyeVByb2dyYW1JbmZvTG9hZGVyKGhhbmRsZXIsIGlucHV0cywgZ2xzbEVxdWFsKCksICdib29sJyksIGlucHV0cyksXG5dO1xuXG5leHBvcnQgY29uc3QgZ3JlYXRlciA9IChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSA9PiBbXG4gIGhhbmRsZXIucnVuKGNyZWF0ZUJpbmFyeVByb2dyYW1JbmZvTG9hZGVyKGhhbmRsZXIsIGlucHV0cywgZ2xzbEdyZWF0ZXIoKSwgJ2Jvb2wnKSwgaW5wdXRzKSxcbl07XG5cbmV4cG9ydCBjb25zdCBsZXNzID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdID0+IFtcbiAgaGFuZGxlci5ydW4oY3JlYXRlQmluYXJ5UHJvZ3JhbUluZm9Mb2FkZXIoaGFuZGxlciwgaW5wdXRzLCBnbHNsTGVzcygpLCAnYm9vbCcpLCBpbnB1dHMpLFxuXTtcblxuZXhwb3J0IGNvbnN0IG11bCA9IChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSA9PiBbXG4gIGhhbmRsZXIucnVuKGNyZWF0ZUJpbmFyeVByb2dyYW1JbmZvTG9hZGVyKGhhbmRsZXIsIGlucHV0cywgZ2xzbE11bCgpKSwgaW5wdXRzKSxcbl07XG5cbmV4cG9ydCBjb25zdCBvciA9IChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSA9PiBbXG4gIGhhbmRsZXIucnVuKGNyZWF0ZUJpbmFyeVByb2dyYW1JbmZvTG9hZGVyKGhhbmRsZXIsIGlucHV0cywgZ2xzbE9yKCksICdib29sJyksIGlucHV0cyksXG5dO1xuXG5leHBvcnQgY29uc3QgcG93ID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdID0+IFtcbiAgaGFuZGxlci5ydW4oY3JlYXRlQmluYXJ5UHJvZ3JhbUluZm9Mb2FkZXIoaGFuZGxlciwgaW5wdXRzLCBnbHNsUG93KCkpLCBpbnB1dHMpLFxuXTtcblxuZXhwb3J0IGNvbnN0IHBSZWx1ID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdID0+IFtcbiAgaGFuZGxlci5ydW4oY3JlYXRlQmluYXJ5UHJvZ3JhbUluZm9Mb2FkZXIoaGFuZGxlciwgaW5wdXRzLCBnbHNsUFJlbHUoKSksIGlucHV0cyksXG5dO1xuXG5leHBvcnQgY29uc3Qgc3ViID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdID0+IFtcbiAgaGFuZGxlci5ydW4oY3JlYXRlQmluYXJ5UHJvZ3JhbUluZm9Mb2FkZXIoaGFuZGxlciwgaW5wdXRzLCBnbHNsU3ViKCkpLCBpbnB1dHMpLFxuXTtcblxuZXhwb3J0IGNvbnN0IHhvciA9IChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSA9PiBbXG4gIGhhbmRsZXIucnVuKGNyZWF0ZUJpbmFyeVByb2dyYW1JbmZvTG9hZGVyKGhhbmRsZXIsIGlucHV0cywgZ2xzbFhvcigpLCAnYm9vbCcpLCBpbnB1dHMpLFxuXTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgR3JhcGggfSBmcm9tICcuLi8uLi8uLi9ncmFwaCc7XG5pbXBvcnQgeyBPcGVyYXRvckltcGxlbWVudGF0aW9uLCBPcGVyYXRvckluaXRpYWxpemF0aW9uIH0gZnJvbSAnLi4vLi4vLi4vb3BlcmF0b3JzJztcbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQgeyBQcm90b1V0aWwgfSBmcm9tICcuLi8uLi8uLi91dGlsJztcbmltcG9ydCB7IFdlYkdMSW5mZXJlbmNlSGFuZGxlciB9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcblxuZXhwb3J0IGNvbnN0IGNhc3Q6IE9wZXJhdG9ySW1wbGVtZW50YXRpb248VGVuc29yLkRhdGFUeXBlPiA9IChcbiAgaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBpbnB1dHM6IFRlbnNvcltdLFxuICB0bzogVGVuc29yLkRhdGFUeXBlLFxuKTogVGVuc29yW10gPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuICByZXR1cm4gW2hhbmRsZXIuY2FzdChpbnB1dHNbMF0sIHRvKV07XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VDYXN0QXR0cmlidXRlczogT3BlcmF0b3JJbml0aWFsaXphdGlvbjxUZW5zb3IuRGF0YVR5cGU+ID0gKG5vZGU6IEdyYXBoLk5vZGUpOiBUZW5zb3IuRGF0YVR5cGUgPT5cbiAgUHJvdG9VdGlsLnRlbnNvckRhdGFUeXBlRnJvbVByb3RvKG5vZGUuYXR0cmlidXRlcy5nZXRJbnQoJ3RvJykpO1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IFRlbnNvcltdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhc3QgcmVxdWlyZXMgMSBpbnB1dC4nKTtcbiAgfVxuXG4gIGlmIChpbnB1dHNbMF0udHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgdHlwZS4nKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgVGVuc29yIH0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7IGdldEdsc2wgfSBmcm9tICcuLi9nbHNsLXNvdXJjZSc7XG5pbXBvcnQgeyBXZWJHTEluZmVyZW5jZUhhbmRsZXIgfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQgeyBQcm9ncmFtSW5mbywgUHJvZ3JhbUluZm9Mb2FkZXIsIFByb2dyYW1NZXRhZGF0YSwgVGV4dHVyZVR5cGUgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBnZXRDb29yZHNEYXRhVHlwZSwgZ2V0R2xDaGFubmVscyB9IGZyb20gJy4uL3V0aWxzJztcblxuaW1wb3J0IHsgQ29uY2F0QXR0cmlidXRlcyB9IGZyb20gJy4vY29uY2F0JztcbmltcG9ydCB7IGdldENoYW5uZWxzLCB1bnBhY2tGcm9tQ2hhbm5lbCB9IGZyb20gJy4vcGFja2luZy11dGlscyc7XG5cbmNvbnN0IGNyZWF0ZVBhY2tlZENvbmNhdFByb2dyYW1NZXRhZGF0YSA9IChpbnB1dENvdW50OiBudW1iZXIsIGNhY2hlSGludDogc3RyaW5nKSA9PiAoe1xuICBuYW1lOiAnQ29uY2F0IChwYWNrZWQpJyxcbiAgaW5wdXROYW1lczogQXJyYXkuZnJvbSh7IGxlbmd0aDogaW5wdXRDb3VudCB9LCAoX3YsIGkpID0+IGBYJHtpfWApLFxuICBpbnB1dFR5cGVzOiBBcnJheShpbnB1dENvdW50KS5maWxsKFRleHR1cmVUeXBlLnBhY2tlZCksXG4gIGNhY2hlSGludCxcbn0pO1xuXG5jb25zdCBjcmVhdGVQYWNrZWRDb25jYXRQcm9ncmFtSW5mbyA9IChcbiAgaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBtZXRhZGF0YTogUHJvZ3JhbU1ldGFkYXRhLFxuICBpbnB1dHM6IFRlbnNvcltdLFxuICBheGlzOiBudW1iZXIsXG4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcy5zbGljZSgpO1xuICBpZiAoYXhpcyA+PSBpbnB1dFNoYXBlLmxlbmd0aCB8fCBheGlzIDwgLTEgKiBpbnB1dFNoYXBlLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImF4aXMgc3BlY2lmaWVkIGZvciBjb25jYXQgZG9lc24ndCBtYXRjaCBpbnB1dCBkaW1lbnNpb25hbGl0eVwiKTtcbiAgfVxuICBpZiAoYXhpcyA8IDApIHtcbiAgICBheGlzID0gaW5wdXRTaGFwZS5sZW5ndGggKyBheGlzO1xuICB9XG4gIC8vIGVuc3VyZSBhbGwgb2YgdGhlIG5vbi1jb25jYXRlbmF0ZWQgYXhlcyBtYXRjaCBlYWNoIG90aGVyXG4gIC8vIGNhbGN1bGF0ZSB0aGUgc2hhcGUgb2YgdGhlIG91dHB1dCB0ZW5zb3Igd2hpbGUgd2UgZG8gdGhhdFxuICBjb25zdCBvdXRwdXRTaGFwZSA9IGlucHV0U2hhcGUuc2xpY2UoMCk7XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgaW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZGF0YU5TaGFwZSA9IGlucHV0c1tpXS5kaW1zLnNsaWNlKCk7XG4gICAgZm9yIChsZXQgYXhpc0luZGV4ID0gMDsgYXhpc0luZGV4IDwgaW5wdXRTaGFwZS5sZW5ndGg7IGF4aXNJbmRleCsrKSB7XG4gICAgICAvLyBhZGQgdG8gdGhlIHBsYWNlaG9sZGVyIGZvciBjb21wdXRpbmcgb3V0cHV0IHNoYXBlXG4gICAgICBpZiAoYXhpc0luZGV4ID09PSBheGlzKSB7XG4gICAgICAgIG91dHB1dFNoYXBlW2F4aXNdICs9IGRhdGFOU2hhcGVbYXhpc0luZGV4XTtcbiAgICAgIH1cbiAgICAgIC8vIGVuc3VyZSBhbGwgbm9uLWNhbmNhdGVuYXRlZCBheGVzIG1hdGNoIGVhY2ggb3RoZXJcbiAgICAgIGVsc2UgaWYgKGlucHV0U2hhcGVbYXhpc0luZGV4XSAhPT0gZGF0YU5TaGFwZVtheGlzSW5kZXhdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbm9uIGNvbmNhdCBkaW1lbnNpb25zIG11c3QgbWF0Y2gnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCByYW5rID0gb3V0cHV0U2hhcGUubGVuZ3RoO1xuICBjb25zdCBjb29yZHMgPSBnZXRDaGFubmVscygnY29vcmRzJywgcmFuayk7XG4gIGNvbnN0IGR0eXBlID0gZ2V0Q29vcmRzRGF0YVR5cGUocmFuayk7XG4gIGNvbnN0IHVucGFja0NoYW5uZWwgPSB1bnBhY2tGcm9tQ2hhbm5lbCgpO1xuXG4gIGNvbnN0IHNoYXBlcyA9IGlucHV0cy5tYXAoKGkpID0+IGkuZGltcyk7XG4gIGNvbnN0IGNoYW5uZWxzID0gZ2V0R2xDaGFubmVscyhyYW5rKTtcbiAgY29uc3Qgb2Zmc2V0czogbnVtYmVyW10gPSBuZXcgQXJyYXkoc2hhcGVzLmxlbmd0aCAtIDEpO1xuXG4gIG9mZnNldHNbMF0gPSBzaGFwZXNbMF1bYXhpc107XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgb2Zmc2V0cy5sZW5ndGg7IGkrKykge1xuICAgIG9mZnNldHNbaV0gPSBvZmZzZXRzW2kgLSAxXSArIHNoYXBlc1tpXVtheGlzXTtcbiAgfVxuXG4gIGNvbnN0IGNoYW5uZWwgPSBjaGFubmVsc1theGlzXTtcbiAgY29uc3QgbGFzdENoYW5uZWxzID0gY2hhbm5lbHMuc2xpY2UoLTIpO1xuICBjb25zdCBhbGxDaGFubmVscyA9IGNoYW5uZWxzLmpvaW4oKTtcblxuICBsZXQgZ2V0VmFsdWVTbmlwcGV0ID0gYGlmICgke2NoYW5uZWx9IDwgJHtvZmZzZXRzWzBdfSkge1xuICAgICAgICByZXR1cm4gZ2V0Q2hhbm5lbChcbiAgICAgICAgICAgIGdldFgwKCR7YWxsQ2hhbm5lbHN9KSwgdmVjMigke2xhc3RDaGFubmVscy5qb2luKCl9KSk7XG4gICAgICAgIH1gO1xuICBmb3IgKGxldCBpID0gMTsgaSA8IG9mZnNldHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzaGlmdCA9IG9mZnNldHNbaSAtIDFdO1xuICAgIGdldFZhbHVlU25pcHBldCArPSBgXG4gICAgICAgICAgICBpZiAoJHtjaGFubmVsfSA8ICR7b2Zmc2V0c1tpXX0gICYmICR7Y2hhbm5lbH0gPj0gJHtvZmZzZXRzW2kgLSAxXX0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldENoYW5uZWwoXG4gICAgICAgICAgICAgICAgZ2V0WCR7aX0oJHtnZXRTaGlmdGVkQ2hhbm5lbHNTbmlwcGV0KGNoYW5uZWxzLCBjaGFubmVsLCBzaGlmdCl9KSxcbiAgICAgICAgICAgICAgICB2ZWMyKCR7Z2V0U2hpZnRlZENoYW5uZWxzU25pcHBldChsYXN0Q2hhbm5lbHMsIGNoYW5uZWwsIHNoaWZ0KX0pKTtcbiAgICAgICAgICAgIH1gO1xuICB9XG4gIGNvbnN0IGxhc3RJbmRleCA9IG9mZnNldHMubGVuZ3RoO1xuICBjb25zdCBzaGlmdCA9IG9mZnNldHNbb2Zmc2V0cy5sZW5ndGggLSAxXTtcbiAgZ2V0VmFsdWVTbmlwcGV0ICs9IGBcbiAgICAgICAgICAgIHJldHVybiBnZXRDaGFubmVsKFxuICAgICAgICAgICAgICBnZXRYJHtsYXN0SW5kZXh9KCR7Z2V0U2hpZnRlZENoYW5uZWxzU25pcHBldChjaGFubmVscywgY2hhbm5lbCwgc2hpZnQpfSksXG4gICAgICAgICAgICAgIHZlYzIoJHtnZXRTaGlmdGVkQ2hhbm5lbHNTbmlwcGV0KGxhc3RDaGFubmVscywgY2hhbm5lbCwgc2hpZnQpfSkpO2A7XG5cbiAgY29uc3QgZ2xzbCA9IGdldEdsc2woaGFuZGxlci5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pO1xuXG4gIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgICAgICAke3VucGFja0NoYW5uZWx9XG4gICAgICAgICAgZmxvYXQgZ2V0VmFsdWUoJHtjaGFubmVscy5tYXAoKHgpID0+ICdpbnQgJyArIHgpfSkge1xuICAgICAgICAgICAgJHtnZXRWYWx1ZVNuaXBwZXR9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgJHtkdHlwZX0gY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgICAgICBpbnQgbGFzdERpbSA9IGNvb3Jkcy4ke2NoYW5uZWxzW3JhbmsgLSAxXX07XG4gICAgICAgICAgICBjb29yZHMuJHtjaGFubmVsc1tyYW5rIC0gMV19ID0gY29vcmRzLiR7Y2hhbm5lbHNbcmFuayAtIDJdfTtcbiAgICAgICAgICAgIGNvb3Jkcy4ke2NoYW5uZWxzW3JhbmsgLSAyXX0gPSBsYXN0RGltO1xuXG4gICAgICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoZ2V0VmFsdWUoJHtjb29yZHN9KSwgMC4sIDAuLCAwLik7XG5cbiAgICAgICAgICAgICR7Y29vcmRzW3JhbmsgLSAxXX0gPSAke2Nvb3Jkc1tyYW5rIC0gMV19ICsgMTtcbiAgICAgICAgICAgIGlmICgke2Nvb3Jkc1tyYW5rIC0gMV19IDwgJHtvdXRwdXRTaGFwZVtyYW5rIC0gMV19KSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5nID0gZ2V0VmFsdWUoJHtjb29yZHN9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgJHtjb29yZHNbcmFuayAtIDJdfSA9ICR7Y29vcmRzW3JhbmsgLSAyXX0gKyAxO1xuICAgICAgICAgICAgaWYgKCR7Y29vcmRzW3JhbmsgLSAyXX0gPCAke291dHB1dFNoYXBlW3JhbmsgLSAyXX0pIHtcbiAgICAgICAgICAgICAgcmVzdWx0LmEgPSBnZXRWYWx1ZSgke2Nvb3Jkc30pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAke2Nvb3Jkc1tyYW5rIC0gMV19ID0gJHtjb29yZHNbcmFuayAtIDFdfSAtIDE7XG4gICAgICAgICAgICBpZiAoJHtjb29yZHNbcmFuayAtIDJdfSA8ICR7b3V0cHV0U2hhcGVbcmFuayAtIDJdfSAmJlxuICAgICAgICAgICAgICAgICR7Y29vcmRzW3JhbmsgLSAxXX0gPCAke291dHB1dFNoYXBlW3JhbmsgLSAxXX0pIHtcbiAgICAgICAgICAgICAgcmVzdWx0LmIgPSBnZXRWYWx1ZSgke2Nvb3Jkc30pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJHtnbHNsLm91dHB1dH0gPSByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICBgO1xuXG4gIHJldHVybiB7XG4gICAgLi4ubWV0YWRhdGEsXG4gICAgb3V0cHV0OiB7IGRpbXM6IG91dHB1dFNoYXBlLCB0eXBlOiBpbnB1dHNbMF0udHlwZSwgdGV4dHVyZVR5cGU6IFRleHR1cmVUeXBlLnBhY2tlZCB9LFxuICAgIHNoYWRlclNvdXJjZSxcbiAgICBoYXNNYWluOiB0cnVlLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVBhY2tlZENvbmNhdFByb2dyYW1JbmZvTG9hZGVyID0gKFxuICBoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsXG4gIGlucHV0czogVGVuc29yW10sXG4gIGF0dHJpYnV0ZXM6IENvbmNhdEF0dHJpYnV0ZXMsXG4pOiBQcm9ncmFtSW5mb0xvYWRlciA9PiB7XG4gIGNvbnN0IG1ldGFkYXRhID0gY3JlYXRlUGFja2VkQ29uY2F0UHJvZ3JhbU1ldGFkYXRhKGlucHV0cy5sZW5ndGgsIGF0dHJpYnV0ZXMuY2FjaGVLZXkpO1xuICByZXR1cm4geyAuLi5tZXRhZGF0YSwgZ2V0OiAoKSA9PiBjcmVhdGVQYWNrZWRDb25jYXRQcm9ncmFtSW5mbyhoYW5kbGVyLCBtZXRhZGF0YSwgaW5wdXRzLCBhdHRyaWJ1dGVzLmF4aXMpIH07XG59O1xuXG5jb25zdCBnZXRTaGlmdGVkQ2hhbm5lbHNTbmlwcGV0ID0gKGNoYW5uZWxzOiBzdHJpbmdbXSwgY2hhbm5lbDogc3RyaW5nLCBzaGlmdDogbnVtYmVyKTogc3RyaW5nID0+IHtcbiAgY29uc3QgY2hhbm5lbElkeCA9IGNoYW5uZWxzLmluZGV4T2YoY2hhbm5lbCk7XG4gIGNvbnN0IHJlcyA9IGNoYW5uZWxzLm1hcCgoYywgaWR4KSA9PiB7XG4gICAgaWYgKGlkeCA9PT0gY2hhbm5lbElkeCkge1xuICAgICAgcmV0dXJuIGAke2N9IC0gJHtzaGlmdH1gO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYztcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzLmpvaW4oKTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vLi4vLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7IEdyYXBoIH0gZnJvbSAnLi4vLi4vLi4vZ3JhcGgnO1xuaW1wb3J0IHsgT3BlcmF0b3JJbXBsZW1lbnRhdGlvbiwgT3BlcmF0b3JJbml0aWFsaXphdGlvbiB9IGZyb20gJy4uLy4uLy4uL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBUZW5zb3IgfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHsgV2ViR0xJbmZlcmVuY2VIYW5kbGVyIH0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHsgUHJvZ3JhbUluZm8sIFByb2dyYW1JbmZvTG9hZGVyLCBQcm9ncmFtTWV0YWRhdGEsIFRleHR1cmVUeXBlIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBjcmVhdGVQYWNrZWRDb25jYXRQcm9ncmFtSW5mb0xvYWRlciB9IGZyb20gJy4vY29uY2F0LXBhY2tlZCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29uY2F0QXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IGF4aXM6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNvbnN0IGNvbmNhdDogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxDb25jYXRBdHRyaWJ1dGVzPiA9IChcbiAgaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBpbnB1dHM6IFRlbnNvcltdLFxuICBhdHRyaWJ1dGVzOiBDb25jYXRBdHRyaWJ1dGVzLFxuKTogVGVuc29yW10gPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuICBpZiAoaW5mZXJlbmNlSGFuZGxlci5zZXNzaW9uLnBhY2sgJiYgaW5wdXRzWzBdLmRpbXMubGVuZ3RoID4gMSkge1xuICAgIGNvbnN0IG91dHB1dCA9IGluZmVyZW5jZUhhbmRsZXIucnVuKFxuICAgICAgY3JlYXRlUGFja2VkQ29uY2F0UHJvZ3JhbUluZm9Mb2FkZXIoaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzLCBhdHRyaWJ1dGVzKSxcbiAgICAgIGlucHV0cyxcbiAgICApO1xuICAgIHJldHVybiBbb3V0cHV0XTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBvdXRwdXQgPSBpbmZlcmVuY2VIYW5kbGVyLnJ1bihcbiAgICAgIGNyZWF0ZVVucGFja2VkQ29uY2F0UHJvZ3JhbUluZm9Mb2FkZXIoaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzLCBhdHRyaWJ1dGVzKSxcbiAgICAgIGlucHV0cyxcbiAgICApO1xuICAgIHJldHVybiBbb3V0cHV0XTtcbiAgfVxufTtcblxuY29uc3QgY3JlYXRlVW5wYWNrZWRDb25jYXRQcm9ncmFtTWV0YWRhdGEgPSAoaW5wdXRDb3VudDogbnVtYmVyLCBjYWNoZUhpbnQ6IHN0cmluZykgPT4gKHtcbiAgbmFtZTogJ0NvbmNhdCcsXG4gIGlucHV0TmFtZXM6IEFycmF5LmZyb20oeyBsZW5ndGg6IGlucHV0Q291bnQgfSwgKF92LCBpKSA9PiBgWCR7aX1gKSxcbiAgaW5wdXRUeXBlczogQXJyYXkoaW5wdXRDb3VudCkuZmlsbChUZXh0dXJlVHlwZS51bnBhY2tlZCksXG4gIGNhY2hlSGludCxcbn0pO1xuXG5jb25zdCBjcmVhdGVVbnBhY2tlZENvbmNhdFByb2dyYW1JbmZvID0gKFxuICBfaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBtZXRhZGF0YTogUHJvZ3JhbU1ldGFkYXRhLFxuICBpbnB1dHM6IFRlbnNvcltdLFxuICBheGlzOiBudW1iZXIsXG4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcy5zbGljZSgpO1xuICBpZiAoYXhpcyA+PSBpbnB1dFNoYXBlLmxlbmd0aCB8fCBheGlzIDwgLTEgKiBpbnB1dFNoYXBlLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImF4aXMgc3BlY2lmaWVkIGZvciBjb25jYXQgZG9lc24ndCBtYXRjaCBpbnB1dCBkaW1lbnNpb25hbGl0eVwiKTtcbiAgfVxuICBpZiAoYXhpcyA8IDApIHtcbiAgICBheGlzID0gaW5wdXRTaGFwZS5sZW5ndGggKyBheGlzO1xuICB9XG4gIC8vIGVuc3VyZSBhbGwgb2YgdGhlIG5vbi1jb25jYXRlbmF0ZWQgYXhlcyBtYXRjaCBlYWNoIG90aGVyXG4gIC8vIGNhbGN1bGF0ZSB0aGUgc2hhcGUgb2YgdGhlIG91dHB1dCB0ZW5zb3Igd2hpbGUgd2UgZG8gdGhhdFxuICBjb25zdCBvdXRwdXRTaGFwZSA9IGlucHV0U2hhcGUuc2xpY2UoMCk7XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgaW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZGF0YU5TaGFwZSA9IGlucHV0c1tpXS5kaW1zLnNsaWNlKCk7XG4gICAgZm9yIChsZXQgYXhpc0luZGV4ID0gMDsgYXhpc0luZGV4IDwgaW5wdXRTaGFwZS5sZW5ndGg7IGF4aXNJbmRleCsrKSB7XG4gICAgICAvLyBhZGQgdG8gdGhlIHBsYWNlaG9sZGVyIGZvciBjb21wdXRpbmcgb3V0cHV0IHNoYXBlXG4gICAgICBpZiAoYXhpc0luZGV4ID09PSBheGlzKSB7XG4gICAgICAgIG91dHB1dFNoYXBlW2F4aXNdICs9IGRhdGFOU2hhcGVbYXhpc0luZGV4XTtcbiAgICAgIH1cbiAgICAgIC8vIGVuc3VyZSBhbGwgbm9uLWNhbmNhdGVuYXRlZCBheGVzIG1hdGNoIGVhY2ggb3RoZXJcbiAgICAgIGVsc2UgaWYgKGlucHV0U2hhcGVbYXhpc0luZGV4XSAhPT0gZGF0YU5TaGFwZVtheGlzSW5kZXhdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbm9uIGNvbmNhdCBkaW1lbnNpb25zIG11c3QgbWF0Y2gnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCByYW5rID0gb3V0cHV0U2hhcGUubGVuZ3RoO1xuXG4gIGNvbnN0IHNpemVJbkNvbmNhdEF4aXMgPSBuZXcgQXJyYXk8bnVtYmVyPihpbnB1dHMubGVuZ3RoKTtcbiAgbGV0IHByZXZpb3VzU3VtID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplSW5Db25jYXRBeGlzLmxlbmd0aDsgKytpKSB7XG4gICAgcHJldmlvdXNTdW0gKz0gaW5wdXRzW2ldLmRpbXNbYXhpc107XG4gICAgc2l6ZUluQ29uY2F0QXhpc1tpXSA9IHByZXZpb3VzU3VtO1xuICB9XG5cbiAgbGV0IGdldFRleHR1cmVJbmRleFdoZXJlRGF0YVJlc2lkZXNNZXRob2QgPSAnJztcbiAgLy8gaW4gbW9zdCBjYXNlcyBsaW5lYXIgc2VhcmNoIGlzIHN1ZmZpY2llbnQsIGFzIGluIG1vc3Qgc2NlbmFyaW9zLCBvbmx5IDIgdGVuc29ycyBhcmUgY29uY2F0ZW5hdGVkXG4gIGlmIChpbnB1dHMubGVuZ3RoIDwgNSkge1xuICAgIGdldFRleHR1cmVJbmRleFdoZXJlRGF0YVJlc2lkZXNNZXRob2QgPSBnZXRUZXh0dXJlSW5kZXhXaGVyZURhdGFSZXNpZGVzTGluZWFyU2VhcmNoKHNpemVJbkNvbmNhdEF4aXMpO1xuICB9IGVsc2Uge1xuICAgIGdldFRleHR1cmVJbmRleFdoZXJlRGF0YVJlc2lkZXNNZXRob2QgPSBnZXRUZXh0dXJlSW5kZXhXaGVyZURhdGFSZXNpZGVzQmluYXJ5U2VhcmNoKHNpemVJbkNvbmNhdEF4aXMpO1xuICB9XG5cbiAgY29uc3QgZmV0Y2hEYXRhRnJvbUNvcnJlY3RUZXh0dXJlTWV0aG9kID0gZ2V0RmV0Y2hEYXRhRnJvbUNvcnJlY3RUZXh0dXJlTWV0aG9kKGlucHV0cy5sZW5ndGgsIHJhbmspO1xuICBjb25zdCBnZXRTaXplSW5Db25jYXRBeGlzVmFsdWVGcm9tSW5kZXhNZXRob2QgPSBnZXRHZXRTaXplSW5Db25jYXRBeGlzVmFsdWVGcm9tSW5kZXhNZXRob2Qoc2l6ZUluQ29uY2F0QXhpcyk7XG4gIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgICAgJHtmZXRjaERhdGFGcm9tQ29ycmVjdFRleHR1cmVNZXRob2R9XG4gICAgICAgICR7Z2V0U2l6ZUluQ29uY2F0QXhpc1ZhbHVlRnJvbUluZGV4TWV0aG9kfVxuICAgICAgICAke2dldFRleHR1cmVJbmRleFdoZXJlRGF0YVJlc2lkZXNNZXRob2R9XG4gICAgICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbJHtyYW5rfV0pIHtcbiAgICAgICAgICBpbnQgdGV4dHVyZUluZGV4ID0gZ2V0VGV4dHVyZVdoZXJlRGF0YVJlc2lkZXMgKGluZGljZXNbJHtheGlzfV0pO1xuXG4gICAgICAgICAgaWYodGV4dHVyZUluZGV4ICE9IDApIHtcbiAgICAgICAgICAgIGluZGljZXNbJHtheGlzfV0gPSBpbmRpY2VzWyR7YXhpc31dIC0gaW50KGdldFNpemVJbkNvbmNhdEF4aXNWYWx1ZUZyb21JbmRleCh0ZXh0dXJlSW5kZXgtaW50KDEpKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGZldGNoRGF0YUZyb21Db3JyZWN0VGV4dHVyZSh0ZXh0dXJlSW5kZXgsIGluZGljZXMpO1xuICAgICAgICB9YDtcbiAgcmV0dXJuIHtcbiAgICAuLi5tZXRhZGF0YSxcbiAgICBvdXRwdXQ6IHsgZGltczogb3V0cHV0U2hhcGUsIHR5cGU6IGlucHV0c1swXS50eXBlLCB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGUudW5wYWNrZWQgfSxcbiAgICBzaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG5jb25zdCBjcmVhdGVVbnBhY2tlZENvbmNhdFByb2dyYW1JbmZvTG9hZGVyID0gKFxuICBoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsXG4gIGlucHV0czogVGVuc29yW10sXG4gIGF0dHJpYnV0ZXM6IENvbmNhdEF0dHJpYnV0ZXMsXG4pOiBQcm9ncmFtSW5mb0xvYWRlciA9PiB7XG4gIGNvbnN0IG1ldGFkYXRhID0gY3JlYXRlVW5wYWNrZWRDb25jYXRQcm9ncmFtTWV0YWRhdGEoaW5wdXRzLmxlbmd0aCwgYXR0cmlidXRlcy5jYWNoZUtleSk7XG4gIHJldHVybiB7IC4uLm1ldGFkYXRhLCBnZXQ6ICgpID0+IGNyZWF0ZVVucGFja2VkQ29uY2F0UHJvZ3JhbUluZm8oaGFuZGxlciwgbWV0YWRhdGEsIGlucHV0cywgYXR0cmlidXRlcy5heGlzKSB9O1xufTtcblxuY29uc3QgZ2V0VGV4dHVyZUluZGV4V2hlcmVEYXRhUmVzaWRlc0xpbmVhclNlYXJjaCA9IChzaXplSW5Db25jYXRBeGlzOiBudW1iZXJbXSk6IHN0cmluZyA9PiB7XG4gIGNvbnN0IHNlYXJjaEF4aXMgPSBzaXplSW5Db25jYXRBeGlzLm1hcChcbiAgICAoc2l6ZSwgaSkgPT4gYGlmKGluZGV4PCR7c2l6ZX0pIHtyZXR1cm4gJHtpfTt9XG5gLFxuICApO1xuICByZXR1cm4gYGludCBnZXRUZXh0dXJlV2hlcmVEYXRhUmVzaWRlcyhpbnQgaW5kZXgpIHtcbiAgICAgICR7c2VhcmNoQXhpcy5qb2luKCcnKX1cbiAgICB9YDtcbn07XG5cbi8vIFRPRE86IEltcGxlbWVudCBCaW5hcnlTZWFyY2ggaW4gR0xTTFxuY29uc3QgZ2V0VGV4dHVyZUluZGV4V2hlcmVEYXRhUmVzaWRlc0JpbmFyeVNlYXJjaCA9IChzaXplSW5Db25jYXRBeGlzOiBudW1iZXJbXSk6IHN0cmluZyA9PlxuICBnZXRUZXh0dXJlSW5kZXhXaGVyZURhdGFSZXNpZGVzTGluZWFyU2VhcmNoKHNpemVJbkNvbmNhdEF4aXMpO1xuXG5jb25zdCBnZXRGZXRjaERhdGFGcm9tQ29ycmVjdFRleHR1cmVNZXRob2QgPSAobnVtYmVyT2ZUZW5zb3JzOiBudW1iZXIsIHRlbnNvclJhbms6IG51bWJlcikgPT4ge1xuICBjb25zdCBjb2RlTGluZXM6IHN0cmluZ1tdID0gW2BmbG9hdCBmZXRjaERhdGFGcm9tQ29ycmVjdFRleHR1cmUoaW50IHRleHR1cmVJbmRleCwgaW50IGluZGljZXNbJHt0ZW5zb3JSYW5rfV0pIHtgXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZlRlbnNvcnM7ICsraSkge1xuICAgIGlmIChpID09PSAwKSB7XG4gICAgICBjb2RlTGluZXMucHVzaCgnXFx0JyArIGBpZiAodGV4dHVyZUluZGV4ID09ICR7aX0pIHsgcmV0dXJuIF9YJHtpfShpbmRpY2VzKTsgfWApO1xuICAgIH0gZWxzZSBpZiAoaSA9PT0gbnVtYmVyT2ZUZW5zb3JzIC0gMSkge1xuICAgICAgY29kZUxpbmVzLnB1c2goJ1xcdCcgKyBgZWxzZSB7IHJldHVybiBfWCR7aX0oaW5kaWNlcyk7IH1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29kZUxpbmVzLnB1c2goJ1xcdCcgKyBgZWxzZSBpZiAodGV4dHVyZUluZGV4ID09ICR7aX0pIHsgcmV0dXJuIF9YJHtpfShpbmRpY2VzKTsgfWApO1xuICAgIH1cbiAgfVxuICBjb2RlTGluZXMucHVzaCgnXFx0JyArICd9Jyk7XG4gIHJldHVybiBjb2RlTGluZXMuam9pbignXFxuJyk7XG59O1xuXG5jb25zdCBnZXRHZXRTaXplSW5Db25jYXRBeGlzVmFsdWVGcm9tSW5kZXhNZXRob2QgPSAoc2l6ZUluQ29uY2F0QXhpczogbnVtYmVyW10pOiBzdHJpbmcgPT4ge1xuICBjb25zdCBjb2RlTGluZXM6IHN0cmluZ1tdID0gWydpbnQgZ2V0U2l6ZUluQ29uY2F0QXhpc1ZhbHVlRnJvbUluZGV4KGludCBpbmRleCkgeyddO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemVJbkNvbmNhdEF4aXMubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgY29kZUxpbmVzLnB1c2goJ1xcdCcgKyBgaWYgKGluZGV4ID09ICR7aX0pIHsgcmV0dXJuICR7c2l6ZUluQ29uY2F0QXhpc1tpXX07IH1gKTtcbiAgICB9IGVsc2UgaWYgKGkgPT09IHNpemVJbkNvbmNhdEF4aXMubGVuZ3RoIC0gMSkge1xuICAgICAgY29kZUxpbmVzLnB1c2goJ1xcdCcgKyBgZWxzZSB7IHJldHVybiAke3NpemVJbkNvbmNhdEF4aXNbaV19OyB9YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGVMaW5lcy5wdXNoKCdcXHQnICsgYGVsc2UgaWYgKGluZGV4ID09ICR7aX0pIHsgcmV0dXJuICR7c2l6ZUluQ29uY2F0QXhpc1tpXX07IH1gKTtcbiAgICB9XG4gIH1cbiAgY29kZUxpbmVzLnB1c2goJ1xcdCcgKyAnfScpO1xuXG4gIHJldHVybiBjb2RlTGluZXMuam9pbignXFxuJyk7XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VDb25jYXRBdHRyaWJ1dGVzOiBPcGVyYXRvckluaXRpYWxpemF0aW9uPENvbmNhdEF0dHJpYnV0ZXM+ID0gKG5vZGU6IEdyYXBoLk5vZGUpOiBDb25jYXRBdHRyaWJ1dGVzID0+XG4gIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7IGF4aXM6IG5vZGUuYXR0cmlidXRlcy5nZXRJbnQoJ2F4aXMnKSB9KTtcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiBUZW5zb3JbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoIDwgMSkge1xuICAgIHRocm93IG5ldyBFcnJvcigndG9vIGZldyBpbnB1dHMnKTtcbiAgfVxuXG4gIGNvbnN0IGlucHV0VHlwZSA9IGlucHV0c1swXS50eXBlO1xuICBjb25zdCBpbnB1dERpbWVuc2lvbmFsaXR5ID0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoO1xuXG4gIC8vIFRPRE86IFN1cHBvcnQgc3RyaW5nIGNvbmNhdFxuICBpZiAoaW5wdXRUeXBlID09PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignc3RyaW5nIHRlbnNvciBpcyBub3Qgc3VwcG9ydGVkIHlldCcpO1xuICB9XG5cbiAgZm9yIChjb25zdCBpbnB1dCBvZiBpbnB1dHMpIHtcbiAgICAvLyBtYWtlIHN1cmUgdHlwZXMgb2YgYWxsIGlucHV0cyBtYXRjaFxuICAgIGlmIChpbnB1dC50eXBlICE9PSBpbnB1dFR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW5wdXQgdGVuc29ycyBzaG91bGQgYmUgb25lIHR5cGUnKTtcbiAgICB9XG5cbiAgICAvLyBtYWtlIHN1cmUgdGhlIGRpbWVuc2lvbmFsaXR5IG9mIGFsbCBpbnB1dHMgYXJlIHRoZSBzYW1lXG4gICAgaWYgKGlucHV0LmRpbXMubGVuZ3RoICE9PSBpbnB1dERpbWVuc2lvbmFsaXR5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0IHRlbnNvcnMgc2hvdWxkIGhhdmUgdGhlIHNhbWUgc2hhcGUnKTtcbiAgICB9XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vLi4vLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7IEdyYXBoIH0gZnJvbSAnLi4vLi4vLi4vZ3JhcGgnO1xuaW1wb3J0IHsgVGVuc29yIH0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7IE1BWF9DTElQLCBNSU5fQ0xJUCB9IGZyb20gJy4uLy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgRnVuY3Rpb25UeXBlLCBHbHNsVmFsdWVGdW5jdGlvbiB9IGZyb20gJy4uL2dsc2wtZGVmaW5pdGlvbnMnO1xuaW1wb3J0IHsgZ2V0R2xzbCB9IGZyb20gJy4uL2dsc2wtc291cmNlJztcbmltcG9ydCB7IFdlYkdMSW5mZXJlbmNlSGFuZGxlciB9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7IFByb2dyYW1JbmZvLCBQcm9ncmFtSW5mb0xvYWRlciwgUHJvZ3JhbU1ldGFkYXRhLCBUZXh0dXJlVHlwZSB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xBYnMoKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICByZXR1cm4gZ2xzbEJ1aWx0aW5VbmFyeSgnYWJzJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbEFjb3MoKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICByZXR1cm4gZ2xzbEJ1aWx0aW5VbmFyeSgnYWNvcycpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xBc2luKCk6IEdsc2xWYWx1ZUZ1bmN0aW9uIHtcbiAgcmV0dXJuIGdsc2xCdWlsdGluVW5hcnkoJ2FzaW4nKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnbHNsQXRhbigpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIHJldHVybiBnbHNsQnVpbHRpblVuYXJ5KCdhdGFuJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbENlaWwoKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICByZXR1cm4gZ2xzbEJ1aWx0aW5VbmFyeSgnY2VpbCcpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xDb3MoKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICByZXR1cm4gZ2xzbEJ1aWx0aW5VbmFyeSgnY29zJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbEVsdShhbHBoYTogbnVtYmVyKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICBjb25zdCBuYW1lID0gJ2VsdSc7XG4gIGNvbnN0IGJvZHkgPSBgXG4gIGNvbnN0IGZsb2F0IGFscGhhID0gZmxvYXQoJHthbHBoYX0pO1xuXG4gIGZsb2F0ICR7bmFtZX1fKGZsb2F0IGEpIHtcbiAgICByZXR1cm4gYSA+PSAwLjAgPyBhOiAoZXhwKGEpIC0gMS4wKSAqIGFscGhhO1xuICB9XG4gIHZlYzQgJHtuYW1lfV8odmVjNCB2KSB7XG4gICAgcmV0dXJuIHZlYzQoJHtuYW1lfV8odi54KSwgJHtuYW1lfV8odi55KSwgJHtuYW1lfV8odi56KSwgJHtuYW1lfV8odi53KSk7XG4gIH1cbiAgYDtcbiAgcmV0dXJuIHsgYm9keSwgbmFtZSwgdHlwZTogRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWQgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnbHNsRXhwKCk6IEdsc2xWYWx1ZUZ1bmN0aW9uIHtcbiAgcmV0dXJuIGdsc2xCdWlsdGluVW5hcnkoJ2V4cCcpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xGbG9vcigpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIHJldHVybiBnbHNsQnVpbHRpblVuYXJ5KCdmbG9vcicpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xDbGlwKG1pbjogbnVtYmVyLCBtYXg6IG51bWJlcik6IEdsc2xWYWx1ZUZ1bmN0aW9uIHtcbiAgY29uc3QgbmFtZSA9ICdjbGlwJztcbiAgY29uc3QgYm9keSA9IGBcbiAgY29uc3QgZmxvYXQgbWluID0gZmxvYXQoJHttaW59KTtcbiAgY29uc3QgZmxvYXQgbWF4ID0gZmxvYXQoJHttYXh9KTtcblxuICBmbG9hdCAke25hbWV9XyhmbG9hdCBhKSB7XG4gICAgcmV0dXJuIGNsYW1wKGEsIG1pbiwgbWF4KTtcbiAgfVxuICB2ZWM0ICR7bmFtZX1fKHZlYzQgdikge1xuICAgIHJldHVybiBjbGFtcCh2LCBtaW4sIG1heCk7XG4gIH1cbiAgYDtcbiAgcmV0dXJuIHsgYm9keSwgbmFtZSwgdHlwZTogRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWQgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnbHNsSWRlbnRpdHkoKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICBjb25zdCBuYW1lID0gJ2luZGVudGl0eSc7XG4gIGNvbnN0IGJvZHkgPSBgXG4gIGZsb2F0ICR7bmFtZX1fKGZsb2F0IGEpIHtcbiAgICByZXR1cm4gYTtcbiAgfVxuICB2ZWM0ICR7bmFtZX1fKHZlYzQgdikge1xuICAgIHJldHVybiB2O1xuICB9XG4gIGA7XG4gIHJldHVybiB7IGJvZHksIG5hbWUsIHR5cGU6IEZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkIH07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbExlYWt5UmVsdShhbHBoYTogbnVtYmVyKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICBjb25zdCBuYW1lID0gJ2xlYWt5UmVsdSc7XG4gIGNvbnN0IGJvZHkgPSBgXG4gIGNvbnN0IGZsb2F0IGFscGhhID0gZmxvYXQoJHthbHBoYX0pO1xuXG4gIGZsb2F0ICR7bmFtZX1fKGZsb2F0IGEpIHtcbiAgICByZXR1cm4gYSA8IDAuMCA/IGEgKiBhbHBoYSA6IGE7XG4gIH1cbiAgdmVjNCAke25hbWV9Xyh2ZWM0IHYpIHtcbiAgICByZXR1cm4gdmVjNCgke25hbWV9Xyh2LngpLCAke25hbWV9Xyh2LnkpLCAke25hbWV9Xyh2LnopLCAke25hbWV9Xyh2LncpKTtcbiAgfVxuICBgO1xuICByZXR1cm4geyBib2R5LCBuYW1lLCB0eXBlOiBGdW5jdGlvblR5cGUuVmFsdWVCYXNlZCB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xMb2coKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICByZXR1cm4gZ2xzbEJ1aWx0aW5VbmFyeSgnbG9nJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbE5lZygpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIGNvbnN0IG5hbWUgPSAnbmVnJztcbiAgY29uc3QgYm9keSA9IGBcbiAgZmxvYXQgJHtuYW1lfV8oZmxvYXQgYSkge1xuICAgIHJldHVybiAtYTtcbiAgfVxuICB2ZWM0ICR7bmFtZX1fKHZlYzQgdikge1xuICAgIHJldHVybiAtdjtcbiAgfVxuICBgO1xuICByZXR1cm4geyBib2R5LCBuYW1lLCB0eXBlOiBGdW5jdGlvblR5cGUuVmFsdWVCYXNlZCB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xOb3QoKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICBjb25zdCBuYW1lID0gJ25vdCc7XG4gIGNvbnN0IGJvZHkgPSBgXG4gIGZsb2F0ICR7bmFtZX1fKGZsb2F0IGEpIHtcbiAgICByZXR1cm4gZmxvYXQoICEgYm9vbChhKSApO1xuICB9XG4gIGJvb2wgJHtuYW1lfV8oYm9vbCBhKSB7XG4gICAgcmV0dXJuICFhO1xuICB9XG4gIHZlYzQgJHtuYW1lfV8odmVjNCB2KSB7XG4gICAgcmV0dXJuIHZlYzQoIWJvb2wodi54KSwgIWJvb2wodi55KSwgIWJvb2wodi56KSwgIWJvb2wodi53KSk7XG4gIH1cbiAgYnZlYzQgJHtuYW1lfV8oYnZlYzQgdikge1xuICAgIHJldHVybiBidmVjNCghdi54LCAhdi55LCAhdi56LCAhdi53KTtcbiAgfVxuICBgO1xuICByZXR1cm4geyBib2R5LCBuYW1lLCB0eXBlOiBGdW5jdGlvblR5cGUuVmFsdWVCYXNlZCB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xTaW4oKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICByZXR1cm4gZ2xzbEJ1aWx0aW5VbmFyeSgnc2luJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbFJlbHUoKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICBjb25zdCBuYW1lID0gJ3JlbHUnO1xuICBjb25zdCBib2R5ID0gYFxuICBmbG9hdCAke25hbWV9XyhmbG9hdCBhKSB7XG4gICAgcmV0dXJuIG1heCggYSwgMC4wICk7XG4gIH1cbiAgdmVjNCAke25hbWV9Xyh2ZWM0IHYpIHtcbiAgICByZXR1cm4gbWF4KCB2LCAwLjAgKTtcbiAgfVxuICBgO1xuICByZXR1cm4geyBib2R5LCBuYW1lLCB0eXBlOiBGdW5jdGlvblR5cGUuVmFsdWVCYXNlZCB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xTaWdtb2lkKCk6IEdsc2xWYWx1ZUZ1bmN0aW9uIHtcbiAgY29uc3QgbmFtZSA9ICdzaWdtb2lkJztcbiAgY29uc3QgYm9keSA9IGBcbiAgZmxvYXQgJHtuYW1lfV8oZmxvYXQgYSkge1xuICAgIHJldHVybiAxLjAgLyAoMS4wICsgZXhwKC1hKSk7XG4gIH1cbiAgdmVjNCAke25hbWV9Xyh2ZWM0IHYpIHtcbiAgICByZXR1cm4gMS4wIC8gKDEuMCArIGV4cCgtdikpO1xuICB9XG4gIGA7XG4gIHJldHVybiB7IGJvZHksIG5hbWUsIHR5cGU6IEZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkIH07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbFNxcnQoKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICByZXR1cm4gZ2xzbEJ1aWx0aW5VbmFyeSgnc3FydCcpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xUYW4oKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICByZXR1cm4gZ2xzbEJ1aWx0aW5VbmFyeSgndGFuJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbFRhbmgoKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICBjb25zdCBuYW1lID0gJ3RhbmgnO1xuICBjb25zdCBib2R5ID0gYFxuICBmbG9hdCAke25hbWV9XyhmbG9hdCBhKSB7XG4gICAgYSA9IGNsYW1wKGEsIC0xMC4sIDEwLik7XG4gICAgYSA9IGV4cCgyLiphKTtcbiAgICByZXR1cm4gKGEgLSAxLikgLyAoYSArIDEuKTtcbiAgfVxuICB2ZWM0ICR7bmFtZX1fKHZlYzQgdikge1xuICAgIHYgPSBjbGFtcCh2LCAtMTAuLCAxMC4pO1xuICAgIHYgPSBleHAoMi4qdik7XG4gICAgcmV0dXJuICh2IC0gMS4pIC8gKHYgKyAxLik7XG4gIH1cbiAgYDtcbiAgcmV0dXJuIHsgYm9keSwgbmFtZSwgdHlwZTogRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWQgfTtcbn1cbmZ1bmN0aW9uIGdsc2xCdWlsdGluVW5hcnkobmFtZTogc3RyaW5nKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICBjb25zdCBib2R5ID0gYFxuICBmbG9hdCAke25hbWV9XyhmbG9hdCBhKSB7XG4gICAgcmV0dXJuICR7bmFtZX0oYSk7XG4gIH1cbiAgdmVjNCAke25hbWV9Xyh2ZWM0IHYpIHtcbiAgICByZXR1cm4gJHtuYW1lfSh2KTtcbiAgfVxuICBgO1xuICByZXR1cm4geyBib2R5LCBuYW1lLCB0eXBlOiBGdW5jdGlvblR5cGUuVmFsdWVCYXNlZCB9O1xufVxuXG4vLy8vL1xuLy8vLy9cbi8vLy8vXG5cbmNvbnN0IGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8gPSAoXG4gIGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgbWV0YWRhdGE6IFByb2dyYW1NZXRhZGF0YSxcbiAgaW5wdXQ6IFRlbnNvcixcbiAgZ2xzbEZ1bmM6IEdsc2xWYWx1ZUZ1bmN0aW9uLFxuKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCB0ZXh0dXJlVHlwZSA9IGhhbmRsZXIuc2Vzc2lvbi5wYWNrID8gVGV4dHVyZVR5cGUucGFja2VkIDogVGV4dHVyZVR5cGUudW5wYWNrZWQ7XG4gIGNvbnN0IGdsc2wgPSBnZXRHbHNsKGhhbmRsZXIuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgcmV0dXJuIHtcbiAgICAuLi5tZXRhZGF0YSxcbiAgICBvdXRwdXQ6IHsgZGltczogaW5wdXQuZGltcywgdHlwZTogaW5wdXQudHlwZSwgdGV4dHVyZVR5cGUgfSxcbiAgICBzaGFkZXJTb3VyY2U6IGBcbiAgICAgJHtnbHNsRnVuYy5ib2R5fVxuICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgdmVjNCB2ID0gJHtnbHNsLnRleHR1cmUyRH0oQSwgVGV4Q29vcmRzKTtcbiAgICAgICB2ID0gJHtnbHNsRnVuYy5uYW1lfV8odik7XG4gICAgICAgJHtnbHNsLm91dHB1dH0gPSB2O1xuICAgICB9XG4gICAgIGAsXG4gICAgaGFzTWFpbjogdHJ1ZSxcbiAgfTtcbn07XG5cbmNvbnN0IGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm9Mb2FkZXIgPSAoXG4gIGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXQ6IFRlbnNvcixcbiAgZ2xzbEZ1bmM6IEdsc2xWYWx1ZUZ1bmN0aW9uLFxuICBjYWNoZUtleT86IHN0cmluZyxcbik6IFByb2dyYW1JbmZvTG9hZGVyID0+IHtcbiAgY29uc3QgdGV4dHVyZVR5cGUgPSBoYW5kbGVyLnNlc3Npb24ucGFjayA/IFRleHR1cmVUeXBlLnBhY2tlZCA6IFRleHR1cmVUeXBlLnVucGFja2VkO1xuICBjb25zdCBtZXRhZGF0YSA9IHsgbmFtZTogZ2xzbEZ1bmMubmFtZSwgaW5wdXRUeXBlczogW3RleHR1cmVUeXBlXSwgaW5wdXROYW1lczogWydBJ10sIGNhY2hlSGludDogY2FjaGVLZXkgfTtcbiAgcmV0dXJuIHsgLi4ubWV0YWRhdGEsIGdldDogKCkgPT4gY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhoYW5kbGVyLCBtZXRhZGF0YSwgaW5wdXQsIGdsc2xGdW5jKSB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGFicyA9IChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSA9PiBbXG4gIGhhbmRsZXIucnVuKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm9Mb2FkZXIoaGFuZGxlciwgaW5wdXRzWzBdLCBnbHNsQWJzKCkpLCBpbnB1dHMpLFxuXTtcblxuZXhwb3J0IGNvbnN0IGFjb3MgPSAoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10gPT4gW1xuICBoYW5kbGVyLnJ1bihjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvTG9hZGVyKGhhbmRsZXIsIGlucHV0c1swXSwgZ2xzbEFjb3MoKSksIGlucHV0cyksXG5dO1xuXG5leHBvcnQgY29uc3QgYXNpbiA9IChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSA9PiBbXG4gIGhhbmRsZXIucnVuKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm9Mb2FkZXIoaGFuZGxlciwgaW5wdXRzWzBdLCBnbHNsQXNpbigpKSwgaW5wdXRzKSxcbl07XG5cbmV4cG9ydCBjb25zdCBhdGFuID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdID0+IFtcbiAgaGFuZGxlci5ydW4oY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mb0xvYWRlcihoYW5kbGVyLCBpbnB1dHNbMF0sIGdsc2xBdGFuKCkpLCBpbnB1dHMpLFxuXTtcblxuZXhwb3J0IGludGVyZmFjZSBDbGlwQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IG1pbjogbnVtYmVyO1xuICByZWFkb25seSBtYXg6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNvbnN0IGNsaXAgPSAoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdLCBhdHRyaWJ1dGVzOiBDbGlwQXR0cmlidXRlcyk6IFRlbnNvcltdID0+IFtcbiAgaGFuZGxlci5ydW4oXG4gICAgY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mb0xvYWRlcihcbiAgICAgIGhhbmRsZXIsXG4gICAgICBpbnB1dHNbMF0sXG4gICAgICBnbHNsQ2xpcChhdHRyaWJ1dGVzLm1pbiwgYXR0cmlidXRlcy5tYXgpLFxuICAgICAgYXR0cmlidXRlcy5jYWNoZUtleSxcbiAgICApLFxuICAgIGlucHV0cyxcbiAgKSxcbl07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUNsaXBBdHRyaWJ1dGVzID0gKG5vZGU6IEdyYXBoLk5vZGUpOiBDbGlwQXR0cmlidXRlcyA9PlxuICBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe1xuICAgIG1pbjogbm9kZS5hdHRyaWJ1dGVzLmdldEZsb2F0KCdtaW4nLCBNSU5fQ0xJUCksXG4gICAgbWF4OiBub2RlLmF0dHJpYnV0ZXMuZ2V0RmxvYXQoJ21heCcsIE1BWF9DTElQKSxcbiAgfSk7XG5cbmV4cG9ydCBjb25zdCBjbGlwVjExID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdID0+IHtcbiAgY29uc3QgYXR0cmlidXRlcyA9IGdlbmVyYXRlQ2xpcEF0dHJpYnV0ZXNGcm9tSW5wdXRzKGhhbmRsZXIsIGlucHV0cyk7XG4gIHJldHVybiBjbGlwKGhhbmRsZXIsIFtpbnB1dHNbMF1dLCBhdHRyaWJ1dGVzKTtcbn07XG5cbmNvbnN0IGdlbmVyYXRlQ2xpcEF0dHJpYnV0ZXNGcm9tSW5wdXRzID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IENsaXBBdHRyaWJ1dGVzID0+IHtcbiAgaWYgKFxuICAgIGlucHV0cy5sZW5ndGggPj0gMyAmJlxuICAgICghaGFuZGxlci5zZXNzaW9uLmlzSW5pdGlhbGl6ZXIoaW5wdXRzWzFdLmRhdGFJZCkgfHwgIWhhbmRsZXIuc2Vzc2lvbi5pc0luaXRpYWxpemVyKGlucHV0c1syXS5kYXRhSWQpKVxuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2R5bmFtaWMgY2xpcCBhdHRyaWJ1dGVzIGFyZSBub3QgYWxsb3dlZCcpO1xuICB9XG5cbiAgY29uc3QgbWluID0gaW5wdXRzLmxlbmd0aCA+PSAzID8gaW5wdXRzWzFdLm51bWJlckRhdGFbMF0gOiBNSU5fQ0xJUDtcbiAgY29uc3QgbWF4ID0gaW5wdXRzLmxlbmd0aCA+PSAzID8gaW5wdXRzWzJdLm51bWJlckRhdGFbMF0gOiBNQVhfQ0xJUDtcbiAgcmV0dXJuIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7IG1pbiwgbWF4IH0pO1xufTtcblxuZXhwb3J0IGNvbnN0IGNlaWwgPSAoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10gPT4gW1xuICBoYW5kbGVyLnJ1bihjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvTG9hZGVyKGhhbmRsZXIsIGlucHV0c1swXSwgZ2xzbENlaWwoKSksIGlucHV0cyksXG5dO1xuXG5leHBvcnQgY29uc3QgY29zID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdID0+IFtcbiAgaGFuZGxlci5ydW4oY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mb0xvYWRlcihoYW5kbGVyLCBpbnB1dHNbMF0sIGdsc2xDb3MoKSksIGlucHV0cyksXG5dO1xuXG5leHBvcnQgaW50ZXJmYWNlIEVsdUF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBhbHBoYTogbnVtYmVyO1xufVxuXG5leHBvcnQgY29uc3QgZWx1ID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSwgYXR0cmlidXRlczogRWx1QXR0cmlidXRlcyk6IFRlbnNvcltdID0+IFtcbiAgaGFuZGxlci5ydW4oXG4gICAgY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mb0xvYWRlcihoYW5kbGVyLCBpbnB1dHNbMF0sIGdsc2xFbHUoYXR0cmlidXRlcy5hbHBoYSksIGF0dHJpYnV0ZXMuY2FjaGVLZXkpLFxuICAgIGlucHV0cyxcbiAgKSxcbl07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUVsdUF0dHJpYnV0ZXMgPSAobm9kZTogR3JhcGguTm9kZSk6IEVsdUF0dHJpYnV0ZXMgPT5cbiAgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHsgYWxwaGE6IG5vZGUuYXR0cmlidXRlcy5nZXRGbG9hdCgnYWxwaGEnLCAxLjApIH0pO1xuXG5leHBvcnQgY29uc3QgZXhwID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdID0+IFtcbiAgaGFuZGxlci5ydW4oY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mb0xvYWRlcihoYW5kbGVyLCBpbnB1dHNbMF0sIGdsc2xFeHAoKSksIGlucHV0cyksXG5dO1xuXG5leHBvcnQgY29uc3QgZmxvb3IgPSAoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10gPT4gW1xuICBoYW5kbGVyLnJ1bihjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvTG9hZGVyKGhhbmRsZXIsIGlucHV0c1swXSwgZ2xzbEZsb29yKCkpLCBpbnB1dHMpLFxuXTtcblxuZXhwb3J0IGNvbnN0IGlkZW50aXR5ID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdID0+IFtcbiAgaGFuZGxlci5ydW4oY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mb0xvYWRlcihoYW5kbGVyLCBpbnB1dHNbMF0sIGdsc2xJZGVudGl0eSgpKSwgaW5wdXRzKSxcbl07XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGVha3lSZWx1QXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IGFscGhhOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjb25zdCBsZWFreVJlbHUgPSAoXG4gIGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXRzOiBUZW5zb3JbXSxcbiAgYXR0cmlidXRlczogTGVha3lSZWx1QXR0cmlidXRlcyxcbik6IFRlbnNvcltdID0+IFtcbiAgaGFuZGxlci5ydW4oXG4gICAgY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mb0xvYWRlcihoYW5kbGVyLCBpbnB1dHNbMF0sIGdsc2xMZWFreVJlbHUoYXR0cmlidXRlcy5hbHBoYSksIGF0dHJpYnV0ZXMuY2FjaGVLZXkpLFxuICAgIGlucHV0cyxcbiAgKSxcbl07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUxlYWt5UmVsdUF0dHJpYnV0ZXMgPSAobm9kZTogR3JhcGguTm9kZSk6IExlYWt5UmVsdUF0dHJpYnV0ZXMgPT5cbiAgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHsgYWxwaGE6IG5vZGUuYXR0cmlidXRlcy5nZXRGbG9hdCgnYWxwaGEnLCAwLjAxKSB9KTtcblxuZXhwb3J0IGNvbnN0IGxvZyA9IChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSA9PiBbXG4gIGhhbmRsZXIucnVuKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm9Mb2FkZXIoaGFuZGxlciwgaW5wdXRzWzBdLCBnbHNsTG9nKCkpLCBpbnB1dHMpLFxuXTtcblxuZXhwb3J0IGNvbnN0IG5lZyA9IChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSA9PiBbXG4gIGhhbmRsZXIucnVuKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm9Mb2FkZXIoaGFuZGxlciwgaW5wdXRzWzBdLCBnbHNsTmVnKCkpLCBpbnB1dHMpLFxuXTtcblxuZXhwb3J0IGNvbnN0IG5vdCA9IChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSA9PiBbXG4gIGhhbmRsZXIucnVuKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm9Mb2FkZXIoaGFuZGxlciwgaW5wdXRzWzBdLCBnbHNsTm90KCkpLCBpbnB1dHMpLFxuXTtcblxuZXhwb3J0IGNvbnN0IHJlbHUgPSAoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10gPT4gW1xuICBoYW5kbGVyLnJ1bihjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvTG9hZGVyKGhhbmRsZXIsIGlucHV0c1swXSwgZ2xzbFJlbHUoKSksIGlucHV0cyksXG5dO1xuXG5leHBvcnQgY29uc3Qgc2lnbW9pZCA9IChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSA9PiBbXG4gIGhhbmRsZXIucnVuKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm9Mb2FkZXIoaGFuZGxlciwgaW5wdXRzWzBdLCBnbHNsU2lnbW9pZCgpKSwgaW5wdXRzKSxcbl07XG5cbmV4cG9ydCBjb25zdCBzaW4gPSAoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10gPT4gW1xuICBoYW5kbGVyLnJ1bihjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvTG9hZGVyKGhhbmRsZXIsIGlucHV0c1swXSwgZ2xzbFNpbigpKSwgaW5wdXRzKSxcbl07XG5cbmV4cG9ydCBjb25zdCBzcXJ0ID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdID0+IFtcbiAgaGFuZGxlci5ydW4oY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mb0xvYWRlcihoYW5kbGVyLCBpbnB1dHNbMF0sIGdsc2xTcXJ0KCkpLCBpbnB1dHMpLFxuXTtcblxuZXhwb3J0IGNvbnN0IHRhbiA9IChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSA9PiBbXG4gIGhhbmRsZXIucnVuKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm9Mb2FkZXIoaGFuZGxlciwgaW5wdXRzWzBdLCBnbHNsVGFuKCkpLCBpbnB1dHMpLFxuXTtcblxuZXhwb3J0IGNvbnN0IHRhbmggPSAoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10gPT4gW1xuICBoYW5kbGVyLnJ1bihjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvTG9hZGVyKGhhbmRsZXIsIGlucHV0c1swXSwgZ2xzbFRhbmgoKSksIGlucHV0cyksXG5dO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBBdHRyaWJ1dGUgfSBmcm9tICcuLi8uLi8uLi9hdHRyaWJ1dGUnO1xuaW1wb3J0IHsgTUFYX0NMSVAsIE1JTl9DTElQIH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBHbHNsVmFsdWVGdW5jdGlvbiB9IGZyb20gJy4uL2dsc2wtZGVmaW5pdGlvbnMnO1xuXG5pbXBvcnQgeyBnbHNsQ2xpcCwgZ2xzbFJlbHUsIGdsc2xTaWdtb2lkIH0gZnJvbSAnLi91bmFyeS1vcCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcyB7XG4gIHJlYWRvbmx5IGFjdGl2YXRpb246IHN0cmluZztcbiAgcmVhZG9ubHkgY2xpcE1pbj86IG51bWJlcjtcbiAgcmVhZG9ubHkgY2xpcE1heD86IG51bWJlcjtcbiAgcmVhZG9ubHkgYWN0aXZhdGlvbkNhY2hlS2V5OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRBY3RpdmF0aW9uU25pcHBldChhdHRyaWJ1dGVzOiBJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzKSB7XG4gIGxldCBmdW5jOiBHbHNsVmFsdWVGdW5jdGlvbjtcbiAgc3dpdGNoIChhdHRyaWJ1dGVzLmFjdGl2YXRpb24pIHtcbiAgICBjYXNlICdSZWx1JzpcbiAgICAgIGZ1bmMgPSBnbHNsUmVsdSgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnU2lnbW9pZCc6XG4gICAgICBmdW5jID0gZ2xzbFNpZ21vaWQoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ0NsaXAnOlxuICAgICAgZnVuYyA9IGdsc2xDbGlwKGF0dHJpYnV0ZXMuY2xpcE1pbiEsIGF0dHJpYnV0ZXMuY2xpcE1heCEpO1xuICAgICAgYnJlYWs7XG4gICAgLy8gVE9ETzogYWRkaW5nIG90aGVyIGFjdGl2YXRpb25zIHRoYXQgY2FuIGJlIGZ1c2VkLlxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4geyBhY3RpdmF0aW9uRnVuY3Rpb246ICcnLCBhcHBseUFjdGl2YXRpb246ICcnIH07XG4gIH1cblxuICBjb25zdCBhY3RpdmF0aW9uTmFtZSA9IGZ1bmMubmFtZTtcbiAgY29uc3QgYWN0aXZhdGlvbkZ1bmN0aW9uID0gZnVuYy5ib2R5O1xuICBjb25zdCBhcHBseUFjdGl2YXRpb24gPSBgdmFsdWUgPSAke2FjdGl2YXRpb25OYW1lfV8odmFsdWUpO2A7XG4gIHJldHVybiB7IGFjdGl2YXRpb25GdW5jdGlvbiwgYXBwbHlBY3RpdmF0aW9uIH07XG59XG5cbmV4cG9ydCBjb25zdCBwYXJzZUludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogQXR0cmlidXRlKTogSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IGFjdGl2YXRpb24gPSBhdHRyaWJ1dGVzLmdldFN0cmluZygnYWN0aXZhdGlvbicsICcnKTtcblxuICBpZiAoYWN0aXZhdGlvbiA9PT0gJ0NsaXAnKSB7XG4gICAgY29uc3QgW2NsaXBNaW4sIGNsaXBNYXhdID0gYXR0cmlidXRlcy5nZXRGbG9hdHMoJ2FjdGl2YXRpb25fcGFyYW1zJywgW01JTl9DTElQLCBNQVhfQ0xJUF0pO1xuICAgIHJldHVybiB7IGFjdGl2YXRpb24sIGNsaXBNYXgsIGNsaXBNaW4sIGFjdGl2YXRpb25DYWNoZUtleTogYCR7YWN0aXZhdGlvbn06JHtjbGlwTWlufSwke2NsaXBNYXh9YCB9O1xuICB9XG4gIHJldHVybiB7IGFjdGl2YXRpb24sIGFjdGl2YXRpb25DYWNoZUtleTogYWN0aXZhdGlvbiB9O1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnLi4vLi4vLi4vaW5zdHJ1bWVudCc7XG5pbXBvcnQgeyBUZW5zb3IgfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHsgZ2V0R2xzbCB9IGZyb20gJy4uL2dsc2wtc291cmNlJztcbmltcG9ydCB7IFdlYkdMSW5mZXJlbmNlSGFuZGxlciB9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7IFByb2dyYW1JbmZvLCBQcm9ncmFtSW5mb0xvYWRlciwgUHJvZ3JhbU1ldGFkYXRhLCBUZXh0dXJlVHlwZSB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHsgY2FsY3VsYXRlT3V0cHV0U2hhcGUsIENvbnZBdHRyaWJ1dGVzIH0gZnJvbSAnLi9jb252JztcbmltcG9ydCB7IGdldEFjdGl2YXRpb25TbmlwcGV0IH0gZnJvbSAnLi9mdXNlLXV0aWxzJztcblxuY29uc3QgY3JlYXRlVW5wYWNrZWRHcm91cGVkQ29udlByb2dyYW1NZXRhZGF0YSA9IChoYXNCaWFzOiBib29sZWFuLCBjYWNoZUhpbnQ6IHN0cmluZyk6IFByb2dyYW1NZXRhZGF0YSA9PiAoe1xuICBuYW1lOiAnR3JvdXBlZENvbnYnLFxuICBpbnB1dE5hbWVzOiBoYXNCaWFzID8gWydYJywgJ1cnLCAnQmlhcyddIDogWydYJywgJ1cnXSxcbiAgaW5wdXRUeXBlczogaGFzQmlhc1xuICAgID8gW1RleHR1cmVUeXBlLnVucGFja2VkLCBUZXh0dXJlVHlwZS51bnBhY2tlZCwgVGV4dHVyZVR5cGUudW5wYWNrZWRdXG4gICAgOiBbVGV4dHVyZVR5cGUudW5wYWNrZWQsIFRleHR1cmVUeXBlLnVucGFja2VkXSxcbiAgY2FjaGVIaW50LFxufSk7XG5cbmNvbnN0IGNyZWF0ZVVucGFja2VkR3JvdXBlZENvbnZQcm9ncmFtSW5mbyA9IChcbiAgaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvcltdLFxuICBtZXRhZGF0YTogUHJvZ3JhbU1ldGFkYXRhLFxuICBhdHRyaWJ1dGVzOiBDb252QXR0cmlidXRlcyxcbik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgaGFzQmlhcyA9IGlucHV0cy5sZW5ndGggPiAyO1xuICBjb25zdCBwcm9jZXNzQmlhcyA9IGhhc0JpYXMgPyAndmFsdWUgKz0gZ2V0QmlhcyhvdXRwdXRfY2hhbm5lbCk7JyA6ICcnO1xuICBjb25zdCB4U2hhcGUgPSBpbnB1dHNbMF0uZGltcy5zbGljZSgpO1xuICBjb25zdCB3U2hhcGUgPSBpbnB1dHNbMV0uZGltcy5zbGljZSgpO1xuICBjb25zdCBvdXRwdXRDaGFubmVsc1Blckdyb3VwID0gd1NoYXBlWzBdIC8gYXR0cmlidXRlcy5ncm91cDtcbiAgTG9nZ2VyLnZlcmJvc2UoXG4gICAgJ0dyb3VwZWRDb252JyxcbiAgICBgYXV0cFBhZDoke2F0dHJpYnV0ZXMuYXV0b1BhZH0sIGRpbGF0aW9uczoke2F0dHJpYnV0ZXMuZGlsYXRpb25zfSwgZ3JvdXA6JHthdHRyaWJ1dGVzLmdyb3VwfSwga2VybmVsU2hhcGU6JHtcbiAgICAgIGF0dHJpYnV0ZXMua2VybmVsU2hhcGVcbiAgICB9LCBwYWRzOiR7YXR0cmlidXRlcy5wYWRzfSwgc3RyaWRlczoke2F0dHJpYnV0ZXMuc3RyaWRlc31gLFxuICApO1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IGNhbGN1bGF0ZU91dHB1dFNoYXBlKHhTaGFwZSwgd1NoYXBlLCBhdHRyaWJ1dGVzLmRpbGF0aW9ucywgYXR0cmlidXRlcy5wYWRzLCBhdHRyaWJ1dGVzLnN0cmlkZXMpO1xuICBjb25zdCBnbHNsID0gZ2V0R2xzbChpbmZlcmVuY2VIYW5kbGVyLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbik7XG4gIGNvbnN0IHsgYWN0aXZhdGlvbkZ1bmN0aW9uLCBhcHBseUFjdGl2YXRpb24gfSA9IGdldEFjdGl2YXRpb25TbmlwcGV0KGF0dHJpYnV0ZXMpO1xuXG4gIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgY29uc3QgaXZlYzIgc3RyaWRlcyA9IGl2ZWMyKCR7YXR0cmlidXRlcy5zdHJpZGVzWzBdfSwgJHthdHRyaWJ1dGVzLnN0cmlkZXNbMV19KTtcbiAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKCR7YXR0cmlidXRlcy5wYWRzWzBdfSwgJHthdHRyaWJ1dGVzLnBhZHNbMV19KTtcbiAgJHthY3RpdmF0aW9uRnVuY3Rpb259XG4gIHZvaWQgbWFpbigpIHtcbiAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICBpbnQgYmF0Y2ggPSBjb29yZHMueDtcbiAgICBpbnQgb3V0cHV0X2NoYW5uZWwgPSBjb29yZHMueTtcbiAgICBpdmVjMiB4UkNDb3JuZXIgPSBjb29yZHMuencgKiBzdHJpZGVzIC0gcGFkcztcbiAgICBpbnQgZ3JvdXBfaWQgPSBvdXRwdXRfY2hhbm5lbCAvICR7b3V0cHV0Q2hhbm5lbHNQZXJHcm91cH07XG5cbiAgICBmbG9hdCB2YWx1ZSA9IDAuMDtcbiAgICBmb3IgKGludCB3SW5DaGFubmVsID0gMDsgd0luQ2hhbm5lbCA8ICR7d1NoYXBlWzFdfTsgd0luQ2hhbm5lbCsrKSB7XG4gICAgICBpbnQgaW5wdXRfY2hhbm5lbCA9IGdyb3VwX2lkICogJHt3U2hhcGVbMV19ICsgd0luQ2hhbm5lbDtcbiAgICAgIGZvciAoaW50IHdIZWlnaHQgPSAwOyB3SGVpZ2h0IDwgJHt3U2hhcGVbMl19OyB3SGVpZ2h0KyspIHtcbiAgICAgICAgaW50IHhIZWlnaHQgPSB4UkNDb3JuZXIueCArIHdIZWlnaHQgKiAke2F0dHJpYnV0ZXMuZGlsYXRpb25zWzBdfTtcblxuICAgICAgICBpZiAoeEhlaWdodCA8IDAgfHwgeEhlaWdodCA+PSAke3hTaGFwZVsyXX0pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaW50IHdXaWR0aCA9IDA7IHdXaWR0aCA8ICR7d1NoYXBlWzNdfTsgd1dpZHRoKyspIHtcbiAgICAgICAgICBpbnQgeFdpZHRoID0geFJDQ29ybmVyLnkgKyB3V2lkdGggKiAke2F0dHJpYnV0ZXMuZGlsYXRpb25zWzFdfTtcbiAgICAgICAgICBpZiAoeFdpZHRoIDwgMCB8fCB4V2lkdGggPj0gJHt4U2hhcGVbM119KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmbG9hdCB4VmFsID0gZ2V0WChiYXRjaCwgaW5wdXRfY2hhbm5lbCwgeFdpZHRoLCB4SGVpZ2h0KTtcbiAgICAgICAgICBmbG9hdCB3VmFsID0gZ2V0VyhvdXRwdXRfY2hhbm5lbCwgd0luQ2hhbm5lbCwgd1dpZHRoLCB3SGVpZ2h0KTtcbiAgICAgICAgICB2YWx1ZSArPSB4VmFsKndWYWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgJHtwcm9jZXNzQmlhc31cbiAgICAke2FwcGx5QWN0aXZhdGlvbn1cbiAgICAke2dsc2wub3V0cHV0fSA9IHZlYzQodmFsdWUsIC4wLCAuMCwgLjApO1xuICB9XG5gO1xuICByZXR1cm4ge1xuICAgIC4uLm1ldGFkYXRhLFxuICAgIG91dHB1dDogeyBkaW1zOiBvdXRwdXRTaGFwZSwgdHlwZTogaW5wdXRzWzBdLnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS51bnBhY2tlZCB9LFxuICAgIHNoYWRlclNvdXJjZSxcbiAgICBoYXNNYWluOiB0cnVlLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVVucGFja2VkR3JvdXBlZENvbnZQcm9ncmFtSW5mb0xvYWRlciA9IChcbiAgaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvcltdLFxuICBhdHRyaWJ1dGVzOiBDb252QXR0cmlidXRlcyxcbik6IFByb2dyYW1JbmZvTG9hZGVyID0+IHtcbiAgY29uc3QgbWV0YWRhdGEgPSBjcmVhdGVVbnBhY2tlZEdyb3VwZWRDb252UHJvZ3JhbU1ldGFkYXRhKGlucHV0cy5sZW5ndGggPiAyLCBhdHRyaWJ1dGVzLmNhY2hlS2V5KTtcbiAgcmV0dXJuIHtcbiAgICAuLi5tZXRhZGF0YSxcbiAgICBnZXQ6ICgpID0+IGNyZWF0ZVVucGFja2VkR3JvdXBlZENvbnZQcm9ncmFtSW5mbyhpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMsIG1ldGFkYXRhLCBhdHRyaWJ1dGVzKSxcbiAgfTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQgeyBnZXRHbHNsIH0gZnJvbSAnLi4vZ2xzbC1zb3VyY2UnO1xuaW1wb3J0IHsgV2ViR0xJbmZlcmVuY2VIYW5kbGVyIH0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHsgUHJvZ3JhbUluZm8sIFByb2dyYW1JbmZvTG9hZGVyLCBQcm9ncmFtTWV0YWRhdGEsIFRleHR1cmVUeXBlIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBDb252QXR0cmlidXRlcyB9IGZyb20gJy4vY29udic7XG5pbXBvcnQgeyB1bnBhY2tGcm9tQ2hhbm5lbCB9IGZyb20gJy4vcGFja2luZy11dGlscyc7XG5cbmNvbnN0IGNyZWF0ZVBhY2tlZEltMkNvbFByb2dyYW1NZXRhZGF0YSA9IChjYWNoZUhpbnQ6IHN0cmluZykgPT4gKHtcbiAgbmFtZTogJ0ltMkNvbCAocGFja2VkKScsXG4gIGlucHV0TmFtZXM6IFsnQSddLFxuICBpbnB1dFR5cGVzOiBbVGV4dHVyZVR5cGUucGFja2VkXSxcbiAgY2FjaGVIaW50LFxufSk7XG5cbmNvbnN0IGNyZWF0ZVBhY2tlZEltMkNvbFByb2dyYW1JbmZvID0gKFxuICBpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsXG4gIG1ldGFkYXRhOiBQcm9ncmFtTWV0YWRhdGEsXG4gIHg6IFRlbnNvcixcbiAgdzogVGVuc29yLFxuICBvdXRwdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gIGF0dHJpYnV0ZXM6IENvbnZBdHRyaWJ1dGVzLFxuKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCB4c2hhcGUgPSB4LmRpbXM7XG4gIGNvbnN0IHdzaGFwZSA9IHcuZGltcztcbiAgY29uc3Qgcm93RGltID0gMjtcbiAgY29uc3QgY29sRGltID0gMztcbiAgY29uc3QgcmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aDtcbiAgY29uc3QgaW0yY29sU2hhcGUgPSBbd3NoYXBlWzFdICogd3NoYXBlWzJdICogd3NoYXBlWzNdLCBvdXRwdXRTaGFwZVsyXSAqIG91dHB1dFNoYXBlWzNdXTtcbiAgY29uc3Qga2VybmVsU2l6ZSA9IHdzaGFwZVsyXSAqIHdzaGFwZVszXTtcbiAgY29uc3QgdW5wYWNrQ2hhbm5lbCA9IHVucGFja0Zyb21DaGFubmVsKCk7XG4gIGNvbnN0IGdsc2wgPSBnZXRHbHNsKGluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgbGV0IHVucm9sbGVkID0gJyc7XG5cbiAgZm9yIChsZXQgcm93ID0gMDsgcm93IDw9IDE7IHJvdysrKSB7XG4gICAgZm9yIChsZXQgY29sID0gMDsgY29sIDw9IDE7IGNvbCsrKSB7XG4gICAgICB1bnJvbGxlZCArPSBgXG4gICAgICAgICAgICBibG9ja0luZGV4ID0gcmMueCArICR7Y29sfTtcbiAgICAgICAgICAgIHBvcyA9IHJjLnkgKyAke3Jvd307XG5cbiAgICAgICAgICAgIGlmKGJsb2NrSW5kZXggPCAke2ltMmNvbFNoYXBlWzFdfSAmJiBwb3MgPCAke2ltMmNvbFNoYXBlWzBdfSkge1xuICAgICAgICAgICAgICBvZmZzZXRZID0gaW50KGJsb2NrSW5kZXggLyAoJHtvdXRwdXRTaGFwZVtyYW5rIC0gMV19KSkgKiAke2F0dHJpYnV0ZXMuc3RyaWRlc1swXX0gLVxuICAgICAgICAgICAgICAgICR7YXR0cmlidXRlcy5wYWRzWzBdfTtcbiAgICAgICAgICAgICAgZDAgPSBvZmZzZXRZICsgJHthdHRyaWJ1dGVzLmRpbGF0aW9uc1swXX0gKiAoaW1vZChwb3MsICR7a2VybmVsU2l6ZX0pIC8gJHt3c2hhcGVbMl19KTtcblxuICAgICAgICAgICAgICBpZihkMCA8ICR7eHNoYXBlW3Jvd0RpbV19ICYmIGQwID49IDApIHtcbiAgICAgICAgICAgICAgICBvZmZzZXRYID0gaW1vZChibG9ja0luZGV4LCAke291dHB1dFNoYXBlW3JhbmsgLSAxXX0pICogJHthdHRyaWJ1dGVzLnN0cmlkZXNbMV19IC1cbiAgICAgICAgICAgICAgICAgICR7YXR0cmlidXRlcy5wYWRzWzFdfTtcbiAgICAgICAgICAgICAgICBkMSA9IG9mZnNldFggKyAke2F0dHJpYnV0ZXMuZGlsYXRpb25zWzFdfSAqIGltb2QoaW1vZChwb3MsICR7a2VybmVsU2l6ZX0pLCAke3dzaGFwZVsyXX0pO1xuXG4gICAgICAgICAgICAgICAgaWYoZDEgPCAke3hzaGFwZVtjb2xEaW1dfSAmJiBkMSA+PSAwKSB7XG5cbiAgICAgICAgICAgICAgICAgIGNoID0gaW50KGZsb2F0KHBvcykvICR7a2VybmVsU2l6ZX0uKTtcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJEaW1zID0gdmVjMihkMCwgZDEpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbJHtyb3cgKiAyICsgY29sfV0gPSBnZXRDaGFubmVsKFxuICAgICAgICAgICAgICAgICAgICAgIGdldEEoMCwgY2gsIGludChpbm5lckRpbXMueCksXG4gICAgICAgICAgICAgICAgICAgICAgaW50KGlubmVyRGltcy55KSksIGlubmVyRGltcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBgO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgICR7dW5wYWNrQ2hhbm5lbH1cblxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICBpdmVjMiByYyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNCgwLjApO1xuICAgICAgICAgIGludCBibG9ja0luZGV4LCBwb3MsIG9mZnNldFksIGQwLCBvZmZzZXRYLCBkMSwgY2g7XG4gICAgICAgICAgdmVjMiBpbm5lckRpbXM7XG4gICAgICAgICAgJHt1bnJvbGxlZH1cbiAgICAgICAgICAke2dsc2wub3V0cHV0fSA9IHJlc3VsdDtcbiAgICAgIH1cbiAgICAgICAgICAgIGA7XG4gIHJldHVybiB7XG4gICAgLi4ubWV0YWRhdGEsXG4gICAgb3V0cHV0OiB7IGRpbXM6IGltMmNvbFNoYXBlLCB0eXBlOiB4LnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS5wYWNrZWQgfSxcbiAgICBzaGFkZXJTb3VyY2UsXG4gICAgaGFzTWFpbjogdHJ1ZSxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVQYWNrZWRJbTJDb2xQcm9ncmFtSW5mb0xvYWRlciA9IChcbiAgaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICB4OiBUZW5zb3IsXG4gIHc6IFRlbnNvcixcbiAgb3V0cHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICBhdHRyaWJ1dGVzOiBDb252QXR0cmlidXRlcyxcbik6IFByb2dyYW1JbmZvTG9hZGVyID0+IHtcbiAgY29uc3QgbWV0YWRhdGEgPSBjcmVhdGVQYWNrZWRJbTJDb2xQcm9ncmFtTWV0YWRhdGEoYXR0cmlidXRlcy5jYWNoZUtleSk7XG4gIHJldHVybiB7XG4gICAgLi4ubWV0YWRhdGEsXG4gICAgZ2V0OiAoKSA9PiBjcmVhdGVQYWNrZWRJbTJDb2xQcm9ncmFtSW5mbyhpbmZlcmVuY2VIYW5kbGVyLCBtZXRhZGF0YSwgeCwgdywgb3V0cHV0U2hhcGUsIGF0dHJpYnV0ZXMpLFxuICB9O1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgR3JhcGggfSBmcm9tICcuLi8uLi8uLi9ncmFwaCc7XG5pbXBvcnQgeyBPcGVyYXRvckltcGxlbWVudGF0aW9uLCBPcGVyYXRvckluaXRpYWxpemF0aW9uIH0gZnJvbSAnLi4vLi4vLi4vb3BlcmF0b3JzJztcbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQgeyBCcm9hZGNhc3RVdGlsLCBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi8uLi91dGlsJztcbmltcG9ydCB7IFdlYkdMSW5mZXJlbmNlSGFuZGxlciB9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7IFByb2dyYW1JbmZvLCBQcm9ncmFtSW5mb0xvYWRlciwgUHJvZ3JhbU1ldGFkYXRhLCBUZXh0dXJlVHlwZSB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGdldENvb3Jkc0RhdGFUeXBlLCBnZXRHbENoYW5uZWxzIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5pbXBvcnQgeyBnZXRBY3RpdmF0aW9uU25pcHBldCwgSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcywgcGFyc2VJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzIH0gZnJvbSAnLi9mdXNlLXV0aWxzJztcbmltcG9ydCB7IGNyZWF0ZVBhY2tlZE1hdG11bFByb2dyYW1JbmZvTG9hZGVyIH0gZnJvbSAnLi9tYXRtdWwtcGFjayc7XG5cbmV4cG9ydCBjb25zdCBtYXRNdWw6IE9wZXJhdG9ySW1wbGVtZW50YXRpb248SW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcz4gPSAoXG4gIGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXRzOiBUZW5zb3JbXSxcbiAgYXR0cmlidXRlczogSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcyxcbik6IFRlbnNvcltdID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoaW5wdXRzKTtcblxuICBpZiAoaW5mZXJlbmNlSGFuZGxlci5zZXNzaW9uLnBhY2spIHtcbiAgICByZXR1cm4gW2luZmVyZW5jZUhhbmRsZXIucnVuKGNyZWF0ZVBhY2tlZE1hdG11bFByb2dyYW1JbmZvTG9hZGVyKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0cywgYXR0cmlidXRlcyksIGlucHV0cyldO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbaW5mZXJlbmNlSGFuZGxlci5ydW4oY3JlYXRlTWF0bXVsUHJvZ3JhbUluZm9Mb2FkZXIoaW5wdXRzLCBhdHRyaWJ1dGVzKSwgaW5wdXRzKV07XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZU1hdE11bEF0dHJpYnV0ZXM6IE9wZXJhdG9ySW5pdGlhbGl6YXRpb248SW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcz4gPSAoXG4gIG5vZGU6IEdyYXBoLk5vZGUsXG4pOiBJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzID0+IHBhcnNlSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcyhub2RlLmF0dHJpYnV0ZXMpO1xuXG5jb25zdCBjcmVhdGVNYXRtdWxQcm9ncmFtTWV0YWRhdGEgPSAoaGFzQmlhczogYm9vbGVhbiwgY2FjaGVIaW50OiBzdHJpbmcpID0+ICh7XG4gIG5hbWU6ICdNYXRNdWwnLFxuICBpbnB1dE5hbWVzOiBoYXNCaWFzID8gWydBJywgJ0InLCAnQmlhcyddIDogWydBJywgJ0InXSxcbiAgaW5wdXRUeXBlczogaGFzQmlhc1xuICAgID8gW1RleHR1cmVUeXBlLnVucGFja2VkLCBUZXh0dXJlVHlwZS51bnBhY2tlZCwgVGV4dHVyZVR5cGUudW5wYWNrZWRdXG4gICAgOiBbVGV4dHVyZVR5cGUudW5wYWNrZWQsIFRleHR1cmVUeXBlLnVucGFja2VkXSxcbiAgY2FjaGVIaW50LFxufSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZU1hdG11bFByb2dyYW1JbmZvKFxuICBtZXRhZGF0YTogUHJvZ3JhbU1ldGFkYXRhLFxuICBpbnB1dHM6IFRlbnNvcltdLFxuICBhY3RpdmF0aW9uQXR0cmlidXRlczogSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcyxcbik6IFByb2dyYW1JbmZvIHtcbiAgY29uc3QgYVNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gIGNvbnN0IGJTaGFwZSA9IGlucHV0c1sxXS5kaW1zO1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IEJyb2FkY2FzdFV0aWwuY2FsY1NoYXBlKGFTaGFwZSwgYlNoYXBlLCB0cnVlKTtcbiAgaWYgKCFvdXRwdXRTaGFwZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHVzZSBtYXRtdWwgb24gdGhlIGdpdmVuIHRlbnNvcnNcIik7XG4gIH1cbiAgY29uc3QgY29vcmRzRGF0YVR5cGUgPSBnZXRDb29yZHNEYXRhVHlwZShvdXRwdXRTaGFwZS5sZW5ndGgpO1xuICBjb25zdCBhbGxHbENoYW5uZWxzID0gZ2V0R2xDaGFubmVscygpO1xuICBjb25zdCB7IGFjdGl2YXRpb25GdW5jdGlvbiwgYXBwbHlBY3RpdmF0aW9uIH0gPSBnZXRBY3RpdmF0aW9uU25pcHBldChhY3RpdmF0aW9uQXR0cmlidXRlcyk7XG5cbiAgY29uc3QgaGFzQmlhcyA9IGlucHV0cy5sZW5ndGggPiAyO1xuICBjb25zdCBwcm9jZXNzQmlhcyA9IGhhc0JpYXMgPyAndmFsdWUgKz0gZ2V0Qmlhc0Zvck1hdG11bCgpOycgOiAnJztcbiAgY29uc3QgZ2V0Qmlhc0Zvck1hdG11bFNuaXBwZXQgPSBoYXNCaWFzXG4gICAgPyBgJHtnZXRCaWFzRm9yTWF0bXVsKGNvb3Jkc0RhdGFUeXBlLCBhbGxHbENoYW5uZWxzLCBpbnB1dHNbMl0uZGltcywgb3V0cHV0U2hhcGUsIGZhbHNlKX1gXG4gICAgOiAnJztcblxuICBjb25zdCByYW5rID0gb3V0cHV0U2hhcGUubGVuZ3RoO1xuICBjb25zdCBhcmFuayA9IGFTaGFwZS5sZW5ndGg7XG4gIGNvbnN0IGJyYW5rID0gYlNoYXBlLmxlbmd0aDtcbiAgY29uc3Qgc2hhcmVkRGltID0gYVNoYXBlW2FTaGFwZS5sZW5ndGggLSAxXTtcbiAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICR7YWN0aXZhdGlvbkZ1bmN0aW9ufVxuICAgICR7Z2V0Qmlhc0Zvck1hdG11bFNuaXBwZXR9XG4gICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske3Jhbmt9XSkge1xuICAgICAgICBpbnQgYVske2FyYW5rfV07XG4gICAgICAgIGludCBiWyR7YnJhbmt9XTtcbiAgICAgICAgYmNhc3RNYXRtdWxJbmRpY2VzX0EoaW5kaWNlcywgYSk7XG4gICAgICAgIGJjYXN0TWF0bXVsSW5kaWNlc19CKGluZGljZXMsIGIpO1xuXG4gICAgICAgIGZsb2F0IHZhbHVlO1xuICAgICAgICBmb3IgKGludCBrPTA7IGs8JHtzaGFyZWREaW19OyArK2spIHtcbiAgICAgICAgICAgIGFbJHthcmFuayAtIDF9XSA9IGs7XG4gICAgICAgICAgICBiWyR7YnJhbmsgLSAyfV0gPSBrO1xuICAgICAgICAgICAgdmFsdWUgKz0gX0EoYSkgKiBfQihiKTtcbiAgICAgICAgfVxuICAgICAgICAke3Byb2Nlc3NCaWFzfVxuICAgICAgICAke2FwcGx5QWN0aXZhdGlvbn1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1gO1xuICByZXR1cm4ge1xuICAgIC4uLm1ldGFkYXRhLFxuICAgIG91dHB1dDogeyBkaW1zOiBvdXRwdXRTaGFwZSwgdHlwZTogaW5wdXRzWzBdLnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS51bnBhY2tlZCB9LFxuICAgIHNoYWRlclNvdXJjZSxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU1hdG11bFByb2dyYW1JbmZvTG9hZGVyKFxuICBpbnB1dHM6IFRlbnNvcltdLFxuICBhY3RpdmF0aW9uQXR0cmlidXRlczogSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcyxcbik6IFByb2dyYW1JbmZvTG9hZGVyIHtcbiAgY29uc3QgbWV0YWRhdGEgPSBjcmVhdGVNYXRtdWxQcm9ncmFtTWV0YWRhdGEoaW5wdXRzLmxlbmd0aCA+IDIsIGFjdGl2YXRpb25BdHRyaWJ1dGVzLmFjdGl2YXRpb25DYWNoZUtleSk7XG4gIHJldHVybiB7IC4uLm1ldGFkYXRhLCBnZXQ6ICgpID0+IGNyZWF0ZU1hdG11bFByb2dyYW1JbmZvKG1ldGFkYXRhLCBpbnB1dHMsIGFjdGl2YXRpb25BdHRyaWJ1dGVzKSB9O1xufVxuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IFRlbnNvcltdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01hdE11bCByZXF1aXJlcyAyIGlucHV0cy4nKTtcbiAgfVxuXG4gIGlmIChpbnB1dHNbMF0uZGltc1tpbnB1dHNbMF0uZGltcy5sZW5ndGggLSAxXSAhPT0gaW5wdXRzWzFdLmRpbXNbaW5wdXRzWzFdLmRpbXMubGVuZ3RoIC0gMl0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NoYXJlZCBkaW1lbnNpb24gZG9lcyBub3QgbWF0Y2guJyk7XG4gIH1cblxuICBpZiAoXG4gICAgKGlucHV0c1swXS50eXBlICE9PSAnZmxvYXQzMicgJiYgaW5wdXRzWzBdLnR5cGUgIT09ICdmbG9hdDY0JykgfHxcbiAgICAoaW5wdXRzWzFdLnR5cGUgIT09ICdmbG9hdDMyJyAmJiBpbnB1dHNbMV0udHlwZSAhPT0gJ2Zsb2F0NjQnKVxuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0cyBzaG91bGQgYmUgZmxvYXQgdHlwZScpO1xuICB9XG5cbiAgaWYgKGlucHV0c1swXS50eXBlICE9PSBpbnB1dHNbMV0udHlwZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW5wdXRzIHR5cGVzIHNob3VsZCBtYXRjaCcpO1xuICB9XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Qmlhc0Zvck1hdG11bChcbiAgY29vcmRzRGF0YVR5cGU6IHN0cmluZyxcbiAgYWxsR2xDaGFubmVsczogcmVhZG9ubHkgc3RyaW5nW10sXG4gIGluU2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICBvdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gIGlzUGFja2VkOiBib29sZWFuLFxuKTogc3RyaW5nIHtcbiAgbGV0IHVucGFja2VkQ29vcmRzU25pcHBldCA9ICcnO1xuICBjb25zdCBpblJhbmsgPSBpblNoYXBlLmxlbmd0aDtcbiAgY29uc3Qgb3V0UmFuayA9IG91dFNoYXBlLmxlbmd0aDtcbiAgY29uc3QgcmFua0RpZmYgPSBvdXRSYW5rIC0gaW5SYW5rO1xuICBpZiAob3V0UmFuayA8IDIgJiYgaW5SYW5rID4gMCkge1xuICAgIHVucGFja2VkQ29vcmRzU25pcHBldCA9ICdjb29yZHMnO1xuICB9IGVsc2Uge1xuICAgIHVucGFja2VkQ29vcmRzU25pcHBldCA9IGluU2hhcGUubWFwKChfcywgaSkgPT4gYGNvb3Jkcy4ke2FsbEdsQ2hhbm5lbHNbaSArIHJhbmtEaWZmXX1gKS5qb2luKCcsICcpO1xuICB9XG4gIGNvbnN0IGJyb2FkY2FzdERpbXMgPSBCcm9hZGNhc3RVdGlsLmdldEJyb2FkY2FzdERpbXMoaW5TaGFwZSwgb3V0U2hhcGUpO1xuICBjb25zdCBjb29yZHNTbmlwcGV0ID0gYnJvYWRjYXN0RGltcy5tYXAoKGQpID0+IGBjb29yZHMuJHthbGxHbENoYW5uZWxzW2QgKyByYW5rRGlmZl19ID0gMDtgKS5qb2luKCdcXG4nKTtcbiAgY29uc3QgaW5TaXplID0gU2hhcGVVdGlsLnNpemUoaW5TaGFwZSk7XG4gIGNvbnN0IGlzSW5wdXRTY2FsYXIgPSBpblNpemUgPT09IDE7XG4gIGxldCBvdXRwdXQgPSAndmVjNChvdXRwdXRWYWx1ZS54eCwgb3V0cHV0VmFsdWUueXkpJztcbiAgaWYgKGlzSW5wdXRTY2FsYXIpIHtcbiAgICBvdXRwdXQgPSAndmVjNChvdXRwdXRWYWx1ZS54KSc7XG4gIH1cbiAgY29uc3QgZ2V0Qmlhc0Zvck1hdG11bFNvdXJjZSA9IGlzUGFja2VkXG4gICAgPyBgXG52ZWM0IGdldEJpYXNGb3JNYXRtdWwoKSB7XG4gICR7Y29vcmRzRGF0YVR5cGV9IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAke2Nvb3Jkc1NuaXBwZXR9XG4gIHZlYzQgb3V0cHV0VmFsdWUgPSBnZXRCaWFzKCR7dW5wYWNrZWRDb29yZHNTbmlwcGV0fSk7XG4gIHJldHVybiAke291dHB1dH07XG59YFxuICAgIDogYFxuZmxvYXQgZ2V0Qmlhc0Zvck1hdG11bCgpIHtcbiAgJHtjb29yZHNEYXRhVHlwZX0gY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICR7Y29vcmRzU25pcHBldH1cbiAgcmV0dXJuIGdldEJpYXMoY29vcmRzLngpO1xufWA7XG5cbiAgcmV0dXJuIGdldEJpYXNGb3JNYXRtdWxTb3VyY2U7XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQgeyBCcm9hZGNhc3RVdGlsLCBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi8uLi91dGlsJztcbmltcG9ydCB7IGdldEdsc2wgfSBmcm9tICcuLi9nbHNsLXNvdXJjZSc7XG5pbXBvcnQgeyBXZWJHTEluZmVyZW5jZUhhbmRsZXIgfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQgeyBQcm9ncmFtSW5mbywgUHJvZ3JhbUluZm9Mb2FkZXIsIFByb2dyYW1NZXRhZGF0YSwgVGV4dHVyZVR5cGUgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBnZXRDb29yZHNEYXRhVHlwZSwgZ2V0R2xDaGFubmVscyB9IGZyb20gJy4uL3V0aWxzJztcblxuaW1wb3J0IHsgZ2V0QWN0aXZhdGlvblNuaXBwZXQsIEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMgfSBmcm9tICcuL2Z1c2UtdXRpbHMnO1xuaW1wb3J0IHsgZ2V0Qmlhc0Zvck1hdG11bCB9IGZyb20gJy4vbWF0bXVsJztcblxuY29uc3QgY3JlYXRlUGFja2VkTWF0bXVsUHJvZ3JhbU1ldGFkYXRhID0gKGhhc0JpYXM6IGJvb2xlYW4sIGNhY2hlSGludDogc3RyaW5nKSA9PiAoe1xuICBuYW1lOiAnTWF0TXVsIChwYWNrZWQpJyxcbiAgaW5wdXROYW1lczogaGFzQmlhcyA/IFsnQScsICdCJywgJ0JpYXMnXSA6IFsnQScsICdCJ10sXG4gIGlucHV0VHlwZXM6IGhhc0JpYXNcbiAgICA/IFtUZXh0dXJlVHlwZS5wYWNrZWQsIFRleHR1cmVUeXBlLnBhY2tlZCwgVGV4dHVyZVR5cGUucGFja2VkXVxuICAgIDogW1RleHR1cmVUeXBlLnBhY2tlZCwgVGV4dHVyZVR5cGUucGFja2VkXSxcbiAgY2FjaGVIaW50LFxufSk7XG5cbmNvbnN0IGNyZWF0ZVBhY2tlZE1hdG11bFByb2dyYW1JbmZvID0gKFxuICBpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsXG4gIG1ldGFkYXRhOiBQcm9ncmFtTWV0YWRhdGEsXG4gIGlucHV0czogVGVuc29yW10sXG4gIGFjdGl2YXRpb25BdHRyaWJ1dGVzOiBJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzLFxuKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBoYXNCaWFzID0gaW5wdXRzLmxlbmd0aCA+IDI7XG4gIGNvbnN0IHByb2Nlc3NCaWFzID0gaGFzQmlhcyA/ICd2YWx1ZSArPSBnZXRCaWFzRm9yTWF0bXVsKCk7JyA6ICcnO1xuICBjb25zdCBhU2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgY29uc3QgYlNoYXBlID0gaW5wdXRzWzFdLmRpbXM7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gQnJvYWRjYXN0VXRpbC5jYWxjU2hhcGUoYVNoYXBlLCBiU2hhcGUsIHRydWUpO1xuICBjb25zdCBpc0Jyb2FkY2FzdCA9ICFTaGFwZVV0aWwuYXJlRXF1YWwoaW5wdXRzWzBdLmRpbXMsIGlucHV0c1sxXS5kaW1zKTtcblxuICBpZiAoIW91dHB1dFNoYXBlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgdXNlIG1hdG11bCBvbiB0aGUgZ2l2ZW4gdGVuc29yc1wiKTtcbiAgfVxuICBjb25zdCBzaGFyZWREaW0gPSBhU2hhcGVbYVNoYXBlLmxlbmd0aCAtIDFdO1xuICBjb25zdCBzaGFyZWREaW1JbmRleCA9IE1hdGguY2VpbChzaGFyZWREaW0gLyAyKTtcbiAgY29uc3QgYVJhbmsgPSBhU2hhcGUubGVuZ3RoO1xuICBjb25zdCBiUmFuayA9IGJTaGFwZS5sZW5ndGg7XG5cbiAgY29uc3QgZ2xzbCA9IGdldEdsc2woaW5mZXJlbmNlSGFuZGxlci5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pO1xuICBjb25zdCBjb29yZHNEYXRhVHlwZSA9IGdldENvb3Jkc0RhdGFUeXBlKG91dHB1dFNoYXBlLmxlbmd0aCk7XG4gIGNvbnN0IG91dFJhbmsgPSBvdXRwdXRTaGFwZS5sZW5ndGg7XG4gIGNvbnN0IGFsbEdsQ2hhbm5lbHMgPSBnZXRHbENoYW5uZWxzKCk7XG4gIGNvbnN0IHsgYWN0aXZhdGlvbkZ1bmN0aW9uLCBhcHBseUFjdGl2YXRpb24gfSA9IGdldEFjdGl2YXRpb25TbmlwcGV0KGFjdGl2YXRpb25BdHRyaWJ1dGVzKTtcblxuICBjb25zdCBnZXRCaWFzRm9yTWF0bXVsU25pcHBldCA9IGhhc0JpYXNcbiAgICA/IGAke2dldEJpYXNGb3JNYXRtdWwoY29vcmRzRGF0YVR5cGUsIGFsbEdsQ2hhbm5lbHMsIGlucHV0c1syXS5kaW1zLCBvdXRwdXRTaGFwZSwgdHJ1ZSl9YFxuICAgIDogJyc7XG5cbiAgY29uc3QgZ2V0QmNhc3RlZFNhbXBsZXJGb3JNYXRtdWxTbmlwcGV0ID0gaXNCcm9hZGNhc3RcbiAgICA/IGAke2dldEJjYXN0U2FtcGxlckZvck1hdG11bChjb29yZHNEYXRhVHlwZSwgYWxsR2xDaGFubmVscywgaW5wdXRzLCBvdXRwdXRTaGFwZSl9YFxuICAgIDogJyc7XG5cbiAgY29uc3QgZ2V0U2FtcGxlckFJbkxvb3BTbmlwcGV0ID0gaXNCcm9hZGNhc3QgPyAnZ2V0QUF0T3V0Q29vcmRzTWF0bXVsKGkpJyA6IGBnZXRBKCR7Z2V0QShhbGxHbENoYW5uZWxzLCBhUmFuayl9KWA7XG4gIGNvbnN0IGdldFNhbXBsZXJCSW5Mb29wU25pcHBldCA9IGlzQnJvYWRjYXN0ID8gJ2dldEJBdE91dENvb3Jkc01hdG11bChpKScgOiBgZ2V0Qigke2dldEIoYWxsR2xDaGFubmVscywgYlJhbmspfSlgO1xuICBjb25zdCBnZXRPdXRwdXRDb29yZHNTbmlwcGV0ID0gaXNCcm9hZGNhc3RcbiAgICA/ICcnXG4gICAgOiBgJHtjb29yZHNEYXRhVHlwZX0gcmMgPVxuICAgICAgICAgIGdldE91dHB1dENvb3JkcygpOyBpbnQgbGFzdERpbSA9IHJjLiR7YWxsR2xDaGFubmVsc1tvdXRSYW5rIC0gMV19OyByYy4ke2FsbEdsQ2hhbm5lbHNbb3V0UmFuayAtIDFdfSA9XG4gICAgICAgICAgcmMuJHthbGxHbENoYW5uZWxzW291dFJhbmsgLSAyXX07IHJjLiR7YWxsR2xDaGFubmVsc1tvdXRSYW5rIC0gMl19ID0gbGFzdERpbTtcbiAgICAgIGA7XG4gIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgICAgICAgICR7Z2V0QmNhc3RlZFNhbXBsZXJGb3JNYXRtdWxTbmlwcGV0fVxuICAgICAgICAgICAgJHtnZXRCaWFzRm9yTWF0bXVsU25pcHBldH1cbiAgICAgICAgICAgICR7YWN0aXZhdGlvbkZ1bmN0aW9ufVxuICAgICAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgICAke2dldE91dHB1dENvb3Jkc1NuaXBwZXR9XG5cbiAgICAgICAgICAgICAgdmVjNCB2YWx1ZSA9IHZlYzQoMCk7XG4gICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgJHtzaGFyZWREaW1JbmRleH07IGkrKykge1xuICAgICAgICAgICAgICAgIHZlYzQgYSA9ICR7Z2V0U2FtcGxlckFJbkxvb3BTbmlwcGV0fTtcbiAgICAgICAgICAgICAgICB2ZWM0IGIgPSAke2dldFNhbXBsZXJCSW5Mb29wU25pcHBldH07XG5cbiAgICAgICAgICAgICAgICB2YWx1ZSArPSAoYS5ycmJiICogYi5yZ3JnKTtcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSAoYS5nZ2FhICogYi5iYWJhKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAke3Byb2Nlc3NCaWFzfVxuICAgICAgICAgICAgICAke2FwcGx5QWN0aXZhdGlvbn1cbiAgICAgICAgICAgICAgJHtnbHNsLm91dHB1dH0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1gO1xuICByZXR1cm4ge1xuICAgIC4uLm1ldGFkYXRhLFxuICAgIG91dHB1dDogeyBkaW1zOiBvdXRwdXRTaGFwZSwgdHlwZTogaW5wdXRzWzBdLnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS5wYWNrZWQgfSxcbiAgICBzaGFkZXJTb3VyY2UsXG4gICAgaGFzTWFpbjogdHJ1ZSxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVQYWNrZWRNYXRtdWxQcm9ncmFtSW5mb0xvYWRlciA9IChcbiAgaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBpbnB1dHM6IFRlbnNvcltdLFxuICBhY3RpdmF0aW9uQXR0cmlidXRlczogSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcyxcbik6IFByb2dyYW1JbmZvTG9hZGVyID0+IHtcbiAgY29uc3QgbWV0YWRhdGEgPSBjcmVhdGVQYWNrZWRNYXRtdWxQcm9ncmFtTWV0YWRhdGEoaW5wdXRzLmxlbmd0aCA+IDIsIGFjdGl2YXRpb25BdHRyaWJ1dGVzLmFjdGl2YXRpb25DYWNoZUtleSk7XG4gIHJldHVybiB7XG4gICAgLi4ubWV0YWRhdGEsXG4gICAgZ2V0OiAoKSA9PiBjcmVhdGVQYWNrZWRNYXRtdWxQcm9ncmFtSW5mbyhpbmZlcmVuY2VIYW5kbGVyLCBtZXRhZGF0YSwgaW5wdXRzLCBhY3RpdmF0aW9uQXR0cmlidXRlcyksXG4gIH07XG59O1xuXG5mdW5jdGlvbiBnZXRCY2FzdFNhbXBsZXJGb3JNYXRtdWwoXG4gIGNvb3Jkc0RhdGFUeXBlOiBzdHJpbmcsXG4gIGFsbEdsQ2hhbm5lbHM6IHJlYWRvbmx5IHN0cmluZ1tdLFxuICBpbnB1dHM6IFRlbnNvcltdLFxuICBvdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4pOiBzdHJpbmcge1xuICBsZXQgdW5wYWNrZWRBQ29vcmRzU25pcHBldCA9IFtdO1xuICBsZXQgdW5wYWNrZWRCQ29vcmRzU25pcHBldCA9IFtdO1xuXG4gIGNvbnN0IGluQVNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gIGNvbnN0IGluQlNoYXBlID0gaW5wdXRzWzFdLmRpbXM7XG5cbiAgY29uc3QgaW5BUmFuayA9IGluQVNoYXBlLmxlbmd0aDtcbiAgY29uc3QgaW5CUmFuayA9IGluQlNoYXBlLmxlbmd0aDtcblxuICBjb25zdCBvdXRSYW5rID0gb3V0U2hhcGUubGVuZ3RoO1xuICBjb25zdCByYW5rQURpZmYgPSBvdXRSYW5rIC0gaW5BUmFuaztcbiAgY29uc3QgcmFua0JEaWZmID0gb3V0UmFuayAtIGluQlJhbms7XG5cbiAgdW5wYWNrZWRBQ29vcmRzU25pcHBldCA9IGluQVNoYXBlLm1hcCgoX3MsIGkpID0+IGBjb29yZHMuJHthbGxHbENoYW5uZWxzW2kgKyByYW5rQURpZmZdfWApO1xuICB1bnBhY2tlZEFDb29yZHNTbmlwcGV0W2luQVJhbmsgLSAxXSA9ICdpKjInO1xuICB1bnBhY2tlZEFDb29yZHNTbmlwcGV0LmpvaW4oJywgJyk7XG4gIHVucGFja2VkQkNvb3Jkc1NuaXBwZXQgPSBpbkJTaGFwZS5tYXAoKF9zLCBpKSA9PiBgY29vcmRzLiR7YWxsR2xDaGFubmVsc1tpICsgcmFua0JEaWZmXX1gKTtcbiAgdW5wYWNrZWRCQ29vcmRzU25pcHBldFtpbkJSYW5rIC0gMl0gPSAnaSoyJztcbiAgdW5wYWNrZWRCQ29vcmRzU25pcHBldC5qb2luKCcsICcpO1xuXG4gIGNvbnN0IGJyb2FkY2FzdEFEaW1zID0gQnJvYWRjYXN0VXRpbC5nZXRCcm9hZGNhc3REaW1zKGluQVNoYXBlLCBvdXRTaGFwZSk7XG4gIGNvbnN0IGJyb2FkY2FzdEJEaW1zID0gQnJvYWRjYXN0VXRpbC5nZXRCcm9hZGNhc3REaW1zKGluQlNoYXBlLCBvdXRTaGFwZSk7XG5cbiAgY29uc3QgY29vcmRzQVNuaXBwZXQgPSBicm9hZGNhc3RBRGltcy5tYXAoKGQpID0+IGBjb29yZHMuJHthbGxHbENoYW5uZWxzW2QgKyByYW5rQURpZmZdfSA9IDA7YCkuam9pbignXFxuJyk7XG4gIGNvbnN0IGNvb3Jkc0JTbmlwcGV0ID0gYnJvYWRjYXN0QkRpbXMubWFwKChkKSA9PiBgY29vcmRzLiR7YWxsR2xDaGFubmVsc1tkICsgcmFua0JEaWZmXX0gPSAwO2ApLmpvaW4oJ1xcbicpO1xuICBjb25zdCBzd2FwRGltU25pcHBldCA9IGBpbnQgbGFzdERpbSA9IGNvb3Jkcy4ke2FsbEdsQ2hhbm5lbHNbb3V0UmFuayAtIDFdfTtcbiAgY29vcmRzLiR7YWxsR2xDaGFubmVsc1tvdXRSYW5rIC0gMV19ID0gY29vcmRzLiR7YWxsR2xDaGFubmVsc1tvdXRSYW5rIC0gMl19O1xuICBjb29yZHMuJHthbGxHbENoYW5uZWxzW291dFJhbmsgLSAyXX0gPSBsYXN0RGltO2A7XG5cbiAgY29uc3QgZ2V0QmNhc3RTYW1wbGVyTWF0bXVsU291cmNlID0gYFxudmVjNCBnZXRBQXRPdXRDb29yZHNNYXRtdWwoaW50IGkpIHtcbiAgJHtjb29yZHNEYXRhVHlwZX0gY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICR7c3dhcERpbVNuaXBwZXR9XG4gICR7Y29vcmRzQVNuaXBwZXR9XG4gIHZlYzQgb3V0cHV0VmFsdWUgPSBnZXRBKCR7dW5wYWNrZWRBQ29vcmRzU25pcHBldH0pO1xuICByZXR1cm4gb3V0cHV0VmFsdWU7XG59XG5cbnZlYzQgZ2V0QkF0T3V0Q29vcmRzTWF0bXVsKGludCBpKSB7XG4gICR7Y29vcmRzRGF0YVR5cGV9IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAke3N3YXBEaW1TbmlwcGV0fVxuICAke2Nvb3Jkc0JTbmlwcGV0fVxuICB2ZWM0IG91dHB1dFZhbHVlID0gZ2V0Qigke3VucGFja2VkQkNvb3Jkc1NuaXBwZXR9KTtcbiAgcmV0dXJuIG91dHB1dFZhbHVlO1xufWA7XG5cbiAgcmV0dXJuIGdldEJjYXN0U2FtcGxlck1hdG11bFNvdXJjZTtcbn1cblxuZnVuY3Rpb24gZ2V0QShhbGxHbENoYW5uZWxzOiBzdHJpbmdbXSwgcmFuazogbnVtYmVyKTogc3RyaW5nIHtcbiAgbGV0IHJlcyA9ICcnO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmsgLSAyOyBpKyspIHtcbiAgICByZXMgKz0gYHJjLiR7YWxsR2xDaGFubmVsc1tpXX0sIGA7XG4gIH1cbiAgcmVzICs9IGByYy4ke2FsbEdsQ2hhbm5lbHNbcmFuayAtIDJdfSwgYCArICdpKjInO1xuICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBnZXRCKGFsbEdsQ2hhbm5lbHM6IHN0cmluZ1tdLCByYW5rOiBudW1iZXIpOiBzdHJpbmcge1xuICBsZXQgcmVzID0gJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuayAtIDI7IGkrKykge1xuICAgIHJlcyArPSBgcmMuJHthbGxHbENoYW5uZWxzW2ldfSwgYDtcbiAgfVxuICByZXMgKz0gJ2kqMiwgJyArIGByYy4ke2FsbEdsQ2hhbm5lbHNbcmFuayAtIDFdfWA7XG4gIHJldHVybiByZXM7XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQgeyBXZWJHTEluZmVyZW5jZUhhbmRsZXIgfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5cbmltcG9ydCB7IGNhbGN1bGF0ZU91dHB1dFNoYXBlLCBDb252QXR0cmlidXRlcyB9IGZyb20gJy4vY29udic7XG5pbXBvcnQgeyBjcmVhdGVQYWNrZWRJbTJDb2xQcm9ncmFtSW5mb0xvYWRlciB9IGZyb20gJy4vaW0yY29sLXBhY2snO1xuaW1wb3J0IHsgY3JlYXRlUGFja2VkTWF0bXVsUHJvZ3JhbUluZm9Mb2FkZXIgfSBmcm9tICcuL21hdG11bC1wYWNrJztcblxuZXhwb3J0IGNvbnN0IGNvbnYyRFBhY2tlZFBvaW50d2lzZSA9IChcbiAgaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvcltdLFxuICBhdHRyaWJ1dGVzOiBDb252QXR0cmlidXRlcyxcbik6IFRlbnNvciA9PiB7XG4gIGNvbnN0IHhzaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICBjb25zdCBrc2hhcGUgPSBpbnB1dHNbMV0uZGltcztcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBjYWxjdWxhdGVPdXRwdXRTaGFwZSh4c2hhcGUsIGtzaGFwZSwgYXR0cmlidXRlcy5kaWxhdGlvbnMsIGF0dHJpYnV0ZXMucGFkcywgYXR0cmlidXRlcy5zdHJpZGVzKTtcbiAgY29uc3QgcmVzaGFwZWRYID0gaW5mZXJlbmNlSGFuZGxlci5yZXNoYXBlUGFja2VkKGlucHV0c1swXSwgW3hzaGFwZVsxXSwgeHNoYXBlWzJdICogeHNoYXBlWzNdXSk7XG4gIGNvbnN0IHJlc2hhcGVkSyA9IGluZmVyZW5jZUhhbmRsZXIucmVzaGFwZVBhY2tlZChpbnB1dHNbMV0sIFtrc2hhcGVbMF0sIGtzaGFwZVsxXV0pO1xuXG4gIGNvbnN0IG1hdG11bElucHV0cyA9IGlucHV0cy5sZW5ndGggPiAyID8gW3Jlc2hhcGVkSywgcmVzaGFwZWRYLCBpbnB1dHNbMl1dIDogW3Jlc2hhcGVkSywgcmVzaGFwZWRYXTtcbiAgY29uc3QgbWF0bXVsT3V0cHV0ID0gaW5mZXJlbmNlSGFuZGxlci5ydW4oXG4gICAgY3JlYXRlUGFja2VkTWF0bXVsUHJvZ3JhbUluZm9Mb2FkZXIoaW5mZXJlbmNlSGFuZGxlciwgbWF0bXVsSW5wdXRzLCBhdHRyaWJ1dGVzKSxcbiAgICBtYXRtdWxJbnB1dHMsXG4gICk7XG4gIHJldHVybiBpbmZlcmVuY2VIYW5kbGVyLnJlc2hhcGVQYWNrZWQobWF0bXVsT3V0cHV0LCBvdXRwdXRTaGFwZSk7XG59O1xuXG5leHBvcnQgY29uc3QgY29udjJEUGFja2VkID0gKFxuICBpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yW10sXG4gIGF0dHJpYnV0ZXM6IENvbnZBdHRyaWJ1dGVzLFxuKTogVGVuc29yID0+IHtcbiAgY29uc3QgeHNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gIGNvbnN0IGtzaGFwZSA9IGlucHV0c1sxXS5kaW1zO1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IGNhbGN1bGF0ZU91dHB1dFNoYXBlKHhzaGFwZSwga3NoYXBlLCBhdHRyaWJ1dGVzLmRpbGF0aW9ucywgYXR0cmlidXRlcy5wYWRzLCBhdHRyaWJ1dGVzLnN0cmlkZXMpO1xuXG4gIC8vIHJ1biBpbTJjb2xcbiAgY29uc3QgaW0yY29sT3V0cHV0ID0gaW5mZXJlbmNlSGFuZGxlci5ydW4oXG4gICAgY3JlYXRlUGFja2VkSW0yQ29sUHJvZ3JhbUluZm9Mb2FkZXIoaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzWzBdLCBpbnB1dHNbMV0sIG91dHB1dFNoYXBlLCBhdHRyaWJ1dGVzKSxcbiAgICBbaW5wdXRzWzBdXSxcbiAgKTtcblxuICAvLyByZXNoYXBlIGtlcm5lbFxuICBjb25zdCBrZXJuZWxSZXNoYXBlZCA9IGluZmVyZW5jZUhhbmRsZXIucmVzaGFwZVBhY2tlZChpbnB1dHNbMV0sIFtrc2hhcGVbMF0sIGtzaGFwZVsxXSAqIGtzaGFwZVsyXSAqIGtzaGFwZVszXV0pO1xuXG4gIC8vIHJ1biBtYXRtdWxcbiAgY29uc3QgbWF0bXVsSW5wdXRzID0gaW5wdXRzLmxlbmd0aCA9PT0gMyA/IFtrZXJuZWxSZXNoYXBlZCwgaW0yY29sT3V0cHV0LCBpbnB1dHNbMl1dIDogW2tlcm5lbFJlc2hhcGVkLCBpbTJjb2xPdXRwdXRdO1xuICBjb25zdCBtYXRtdWxPdXRwdXQgPSBpbmZlcmVuY2VIYW5kbGVyLnJ1bihcbiAgICBjcmVhdGVQYWNrZWRNYXRtdWxQcm9ncmFtSW5mb0xvYWRlcihpbmZlcmVuY2VIYW5kbGVyLCBtYXRtdWxJbnB1dHMsIGF0dHJpYnV0ZXMpLFxuICAgIG1hdG11bElucHV0cyxcbiAgKTtcblxuICAvLyByZXNoYXBlIG91dHB1dFxuICBjb25zdCBvdXRwdXRSZXNoYXBlZCA9IGluZmVyZW5jZUhhbmRsZXIucmVzaGFwZVBhY2tlZChtYXRtdWxPdXRwdXQsIG91dHB1dFNoYXBlKTtcbiAgcmV0dXJuIG91dHB1dFJlc2hhcGVkO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgVGVuc29yIH0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7IFdlYkdMSW5mZXJlbmNlSGFuZGxlciB9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7IFByb2dyYW1JbmZvLCBQcm9ncmFtSW5mb0xvYWRlciwgUHJvZ3JhbU1ldGFkYXRhLCBUZXh0dXJlVHlwZSB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHsgQ29udkF0dHJpYnV0ZXMgfSBmcm9tICcuL2NvbnYnO1xuXG5jb25zdCBjcmVhdGVJbTJDb2xQcm9ncmFtTWV0YWRhdGEgPSAoY2FjaGVIaW50OiBzdHJpbmcpID0+ICh7XG4gIG5hbWU6ICdJbTJDb2wnLFxuICBpbnB1dE5hbWVzOiBbJ1gnXSxcbiAgaW5wdXRUeXBlczogW1RleHR1cmVUeXBlLnVucGFja2VkXSxcbiAgY2FjaGVIaW50LFxufSk7XG5cbmNvbnN0IGNyZWF0ZUltMkNvbFByb2dyYW1JbmZvID0gKFxuICBfaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBtZXRhZGF0YTogUHJvZ3JhbU1ldGFkYXRhLFxuICB4OiBUZW5zb3IsXG4gIHc6IFRlbnNvcixcbiAgb3V0cHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICBhdHRyaWJ1dGVzOiBDb252QXR0cmlidXRlcyxcbik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgeHNoYXBlID0geC5kaW1zO1xuICBjb25zdCB3c2hhcGUgPSB3LmRpbXM7XG5cbiAgY29uc3QgcmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aDtcbiAgY29uc3QgaW0yY29sRGltcyA9IGNhbGN1bGF0ZUltMkNvbERpbXMoeHNoYXBlLCB3c2hhcGUsIG91dHB1dFNoYXBlLCA0KTtcblxuICBjb25zdCBzaGFkZXJTb3VyY2UgPSBgXG4gICAgICAgIGNvbnN0IGludCBYQyA9ICR7eHNoYXBlWzFdfTtcbiAgICAgICAgY29uc3QgaW50IFhIID0gJHt4c2hhcGVbMl19O1xuICAgICAgICBjb25zdCBpbnQgWFcgPSAke3hzaGFwZVszXX07XG4gICAgICAgIGNvbnN0IGludCBLSCA9ICR7YXR0cmlidXRlcy5rZXJuZWxTaGFwZVswXX07XG4gICAgICAgIGNvbnN0IGludCBLVyA9ICR7YXR0cmlidXRlcy5rZXJuZWxTaGFwZVsxXX07XG4gICAgICAgIGNvbnN0IGludCBkaWxhdGlvbkggPSAke2F0dHJpYnV0ZXMuZGlsYXRpb25zWzBdfTtcbiAgICAgICAgY29uc3QgaW50IGRpbGF0aW9uVyA9ICR7YXR0cmlidXRlcy5kaWxhdGlvbnNbMV19O1xuICAgICAgICBjb25zdCBpbnQgc3RyaWRlSCA9ICR7YXR0cmlidXRlcy5zdHJpZGVzWzBdfTtcbiAgICAgICAgY29uc3QgaW50IHN0cmlkZVcgPSAke2F0dHJpYnV0ZXMuc3RyaWRlc1sxXX07XG4gICAgICAgIGNvbnN0IGludCBwYWRIID0gJHthdHRyaWJ1dGVzLnBhZHNbMF19O1xuICAgICAgICBjb25zdCBpbnQgcGFkVyA9ICR7YXR0cmlidXRlcy5wYWRzWzFdfTtcbiAgICAgICAgY29uc3QgaW50IEtIS1cgPSBLSCpLVztcbiAgICAgICAgY29uc3QgaW50IFhDS0hLVyA9IFhDICogS0hLVztcbiAgICAgICAgY29uc3QgaW50IG91dHB1dENoYW5uZWxzID0gNDtcbiAgICAgICAgdmVjNCBwcm9jZXNzKGludCBpbmRpY2VzWyR7cmFua31dKSB7XG4gICAgICAgICAgaW50IGIgID0gaW5kaWNlc1swXTsgLy8gYmF0Y2ggc2l6ZVxuICAgICAgICAgIGludCBvaCA9IGluZGljZXNbMV0gKiBzdHJpZGVIIC0gcGFkSDsgLy9vdXRwdXQgaGVpZ2h0XG4gICAgICAgICAgaW50IG93ID0gaW5kaWNlc1syXSAqIHN0cmlkZVcgLSBwYWRXOyAvL291dHB1dCB3aWR0aFxuICAgICAgICAgIGludCBwID0gaW5kaWNlc1szXSAqIG91dHB1dENoYW5uZWxzOyAvL3BhdGNoXG4gICAgICAgICAgdmVjNCB2YWx1ZSA9IHZlYzQoMC4wKTtcbiAgICAgICAgICBmb3IoaW50IGk9MDsgaSA8IG91dHB1dENoYW5uZWxzOyArK2kpIHtcbiAgICAgICAgICAgIGlmKHAgPCBYQ0tIS1cpIHtcbiAgICAgICAgICAgICAgaW50IHBhdGNoQyA9IHAgLyBLSEtXO1xuICAgICAgICAgICAgICBpbnQgcGF0Y2hIID0gKHAgLSBwYXRjaEMqS0hLVykgLyBLVztcbiAgICAgICAgICAgICAgaW50IHBhdGNoVyA9IChwIC0gcGF0Y2hDKktIS1cpIC0gcGF0Y2hIICogS1c7XG4gICAgICAgICAgICAgIGludCB4aDIgPSBvaCArIHBhdGNoSCAqIGRpbGF0aW9uSDtcbiAgICAgICAgICAgICAgaW50IHh3MiA9IG93ICsgcGF0Y2hXICogZGlsYXRpb25XO1xuICAgICAgICAgICAgICBpbnQgeFske3hzaGFwZS5sZW5ndGh9XTtcbiAgICAgICAgICAgICAgeFswXSA9IGI7XG4gICAgICAgICAgICAgIHhbMV0gPSBwYXRjaEM7XG4gICAgICAgICAgICAgIHhbMl0gPSB4aDI7XG4gICAgICAgICAgICAgIHhbM10gPSB4dzI7XG4gICAgICAgICAgICAgIGlmKHhoMiA+PSAwICYmXG4gICAgICAgICAgICAgICAgICB4aDIgPCBYSCAmJlxuICAgICAgICAgICAgICAgICAgeHcyID49IDAgJiZcbiAgICAgICAgICAgICAgICAgIHh3MiA8IFhXKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVbaV0gPSBfWCh4KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKytwO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgYDtcbiAgcmV0dXJuIHtcbiAgICAuLi5tZXRhZGF0YSxcbiAgICBvdXRwdXQ6IHsgZGltczogaW0yY29sRGltcywgdHlwZTogeC50eXBlLCB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGUucGFja2VkTGFzdERpbWVuc2lvbiB9LFxuICAgIHNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVJbTJDb2xQcm9ncmFtSW5mb0xvYWRlciA9IChcbiAgaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICB4OiBUZW5zb3IsXG4gIHc6IFRlbnNvcixcbiAgb3V0cHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICBhdHRyaWJ1dGVzOiBDb252QXR0cmlidXRlcyxcbik6IFByb2dyYW1JbmZvTG9hZGVyID0+IHtcbiAgY29uc3QgbWV0YWRhdGEgPSBjcmVhdGVJbTJDb2xQcm9ncmFtTWV0YWRhdGEoYXR0cmlidXRlcy5jYWNoZUtleSk7XG4gIHJldHVybiB7XG4gICAgLi4ubWV0YWRhdGEsXG4gICAgZ2V0OiAoKSA9PiBjcmVhdGVJbTJDb2xQcm9ncmFtSW5mbyhpbmZlcmVuY2VIYW5kbGVyLCBtZXRhZGF0YSwgeCwgdywgb3V0cHV0U2hhcGUsIGF0dHJpYnV0ZXMpLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGNhbGN1bGF0ZUltMkNvbERpbXMgPSAoXG4gIGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICBrZXJuZWxTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gIG91dHB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgY2hhbm5lbHMgPSA0LFxuKTogbnVtYmVyW10gPT4gW1xuICBvdXRwdXRTaGFwZVswXSxcbiAgb3V0cHV0U2hhcGVbMl0sXG4gIG91dHB1dFNoYXBlWzNdLFxuICBNYXRoLmNlaWwoKGlucHV0U2hhcGVbMV0gKiBrZXJuZWxTaGFwZVsyXSAqIGtlcm5lbFNoYXBlWzNdKSAvIGNoYW5uZWxzKSxcbl07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi8uLi91dGlsJztcbmltcG9ydCB7IGdldEdsc2wgfSBmcm9tICcuLi9nbHNsLXNvdXJjZSc7XG5pbXBvcnQgeyBXZWJHTEluZmVyZW5jZUhhbmRsZXIgfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQgeyBQcm9ncmFtSW5mbywgUHJvZ3JhbUluZm9Mb2FkZXIsIFByb2dyYW1NZXRhZGF0YSwgVGV4dHVyZVR5cGUgfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IGdldEFjdGl2YXRpb25TbmlwcGV0LCBJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzIH0gZnJvbSAnLi9mdXNlLXV0aWxzJztcbmltcG9ydCB7IGNhbGN1bGF0ZUltMkNvbERpbXMgfSBmcm9tICcuL2ltMmNvbCc7XG5cbmNvbnN0IGNyZWF0ZURvdFByb2R1Y3RQcm9ncmFtTWV0YWRhdGEgPSAoaGFzQmlhczogYm9vbGVhbiwgYXR0cmlidXRlczogSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcykgPT4gKHtcbiAgbmFtZTogJ0NvbnZEb3RQcm9kdWN0JyxcbiAgaW5wdXROYW1lczogaGFzQmlhcyA/IFsnSW0yQ29sJywgJ0snLCAnQiddIDogWydJbTJDb2wnLCAnSyddLFxuICBpbnB1dFR5cGVzOiBoYXNCaWFzXG4gICAgPyBbVGV4dHVyZVR5cGUudW5wYWNrZWQsIFRleHR1cmVUeXBlLnBhY2tlZExhc3REaW1lbnNpb24sIFRleHR1cmVUeXBlLnVucGFja2VkXVxuICAgIDogW1RleHR1cmVUeXBlLnVucGFja2VkLCBUZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9uXSxcbiAgY2FjaGVLZXk6IGF0dHJpYnV0ZXMuYWN0aXZhdGlvbkNhY2hlS2V5LFxufSk7XG5cbmNvbnN0IGNyZWF0ZURvdFByb2R1Y3RQcm9ncmFtSW5mbyA9IChcbiAgaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBtZXRhZGF0YTogUHJvZ3JhbU1ldGFkYXRhLFxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvcltdLFxuICBvdXRwdXRTaGFwZTogbnVtYmVyW10sXG4gIGF0dHJpYnV0ZXM6IEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMsXG4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IHhzaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICBjb25zdCBrc2hhcGUgPSBpbnB1dHNbMV0uZGltcztcbiAgY29uc3QgYWRqdXN0ZWRLZXJuZWxTaGFwZSA9IFtrc2hhcGVbMF0sIE1hdGguY2VpbCgoeHNoYXBlWzFdICoga3NoYXBlWzJdICoga3NoYXBlWzNdKSAvIDQpXTtcbiAgY29uc3QgaW0yY29sU2hhcGUgPSBjYWxjdWxhdGVJbTJDb2xEaW1zKHhzaGFwZSwga3NoYXBlLCBvdXRwdXRTaGFwZSk7XG4gIGNvbnN0IFtrV2lkdGgsIGtIZWlnaHRdID0gaW5mZXJlbmNlSGFuZGxlci5jYWxjdWxhdGVUZXh0dXJlV2lkdGhBbmRIZWlnaHQoXG4gICAgYWRqdXN0ZWRLZXJuZWxTaGFwZSxcbiAgICBUZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9uLFxuICApO1xuXG4gIGNvbnN0IGltMmNvbFN0cmlkZXMgPSBTaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXMoaW0yY29sU2hhcGUpO1xuICBjb25zdCBbaW0yY29sV2lkdGgsIGltMmNvbEhlaWdodF0gPSBpbmZlcmVuY2VIYW5kbGVyLmNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodChcbiAgICBpbTJjb2xTaGFwZSxcbiAgICBUZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9uLFxuICApO1xuICBjb25zdCByYW5rID0gb3V0cHV0U2hhcGUubGVuZ3RoO1xuXG4gIGNvbnN0IGluaXRWYWx1ZSA9IGlucHV0cy5sZW5ndGggPCAzID8gJzAuMCcgOiAnX0IoYiknO1xuICBjb25zdCBzaGFyZWREaW0gPSBNYXRoLmNlaWwoKHhzaGFwZVsxXSAqIGtzaGFwZVsyXSAqIGtzaGFwZVszXSkgLyA0KTtcbiAgY29uc3QgeyBhY3RpdmF0aW9uRnVuY3Rpb24sIGFwcGx5QWN0aXZhdGlvbiB9ID0gZ2V0QWN0aXZhdGlvblNuaXBwZXQoYXR0cmlidXRlcyk7XG4gIGNvbnN0IGdsc2wgPSBnZXRHbHNsKGluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuJHthY3RpdmF0aW9uRnVuY3Rpb259XG5mbG9hdCBwcm9jZXNzKGludCBpbmRpY2VzWyR7cmFua31dKSB7XG4gIGludCBiWzFdO1xuICBiWzBdID0gaW5kaWNlc1sxXTtcbiAgaW50IGltMmNvbFs0XTtcbiAgaW0yY29sWzBdID0gaW5kaWNlc1swXTtcbiAgaW0yY29sWzFdID0gaW5kaWNlc1syXTtcbiAgaW0yY29sWzJdID0gaW5kaWNlc1szXTtcbiAgaW50IGltMmNvbE9mZnNldCA9IGltMmNvbFswXSAqICR7aW0yY29sU3RyaWRlc1swXX0gKyBpbTJjb2xbMV0gKiAke2ltMmNvbFN0cmlkZXNbMV19ICsgaW0yY29sWzJdICogJHtcbiAgICBpbTJjb2xTdHJpZGVzWzJdXG4gIH07XG4gIGludCBrZXJuZWxPZmZzZXQgPSBpbmRpY2VzWzFdICogJHthZGp1c3RlZEtlcm5lbFNoYXBlWzFdfTtcbiAgZmxvYXQgdmFsdWUgPSAke2luaXRWYWx1ZX07XG4gIGZvciAoaW50IGkgPSAwOyBpIDwgJHtzaGFyZWREaW19OyArK2kpIHtcbiAgICB2ZWMyIGltMmNvbENvb3JkcyA9IG9mZnNldFRvQ29vcmRzKGltMmNvbE9mZnNldCwgJHtpbTJjb2xXaWR0aH0sICR7aW0yY29sSGVpZ2h0fSk7XG4gICAgdmVjMiBrZXJuZWxDb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhrZXJuZWxPZmZzZXQsICR7a1dpZHRofSwgJHtrSGVpZ2h0fSk7XG4gICAgdmFsdWUgKz0gZG90KCR7Z2xzbC50ZXh0dXJlMkR9KEltMkNvbCwgaW0yY29sQ29vcmRzKSwgJHtnbHNsLnRleHR1cmUyRH0oSywga2VybmVsQ29vcmRzKSk7XG4gICAgKytpbTJjb2xPZmZzZXQ7XG4gICAgKytrZXJuZWxPZmZzZXQ7XG4gIH1cbiAgJHthcHBseUFjdGl2YXRpb259XG4gIHJldHVybiB2YWx1ZTtcbn1gO1xuICByZXR1cm4ge1xuICAgIC4uLm1ldGFkYXRhLFxuICAgIG91dHB1dDogeyBkaW1zOiBvdXRwdXRTaGFwZSwgdHlwZTogaW5wdXRzWzBdLnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS51bnBhY2tlZCB9LFxuICAgIHNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVEb3RQcm9kdWN0UHJvZ3JhbUluZm9Mb2FkZXIgPSAoXG4gIGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JbXSxcbiAgb3V0cHV0U2hhcGU6IG51bWJlcltdLFxuICBhdHRyaWJ1dGVzOiBJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzLFxuKTogUHJvZ3JhbUluZm9Mb2FkZXIgPT4ge1xuICBjb25zdCBtZXRhZGF0YSA9IGNyZWF0ZURvdFByb2R1Y3RQcm9ncmFtTWV0YWRhdGEoaW5wdXRzLmxlbmd0aCA+IDIsIGF0dHJpYnV0ZXMpO1xuICByZXR1cm4ge1xuICAgIC4uLm1ldGFkYXRhLFxuICAgIGdldDogKCkgPT4gY3JlYXRlRG90UHJvZHVjdFByb2dyYW1JbmZvKGluZmVyZW5jZUhhbmRsZXIsIG1ldGFkYXRhLCBpbnB1dHMsIG91dHB1dFNoYXBlLCBhdHRyaWJ1dGVzKSxcbiAgfTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vLi4vLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7IEluZmVyZW5jZUhhbmRsZXIgfSBmcm9tICcuLi8uLi8uLi9iYWNrZW5kJztcbmltcG9ydCB7IEdyYXBoIH0gZnJvbSAnLi4vLi4vLi4vZ3JhcGgnO1xuaW1wb3J0IHsgT3BlcmF0b3JJbXBsZW1lbnRhdGlvbiwgT3BlcmF0b3JJbml0aWFsaXphdGlvbiB9IGZyb20gJy4uLy4uLy4uL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBUZW5zb3IgfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHsgUG9vbENvbnZVdGlsIH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBXZWJHTEluZmVyZW5jZUhhbmRsZXIgfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5cbmltcG9ydCB7IGNyZWF0ZVVucGFja2VkR3JvdXBlZENvbnZQcm9ncmFtSW5mb0xvYWRlciB9IGZyb20gJy4vY29udi1ncm91cGVkJztcbmltcG9ydCB7IGNvbnYyRFBhY2tlZCB9IGZyb20gJy4vY29udi1wYWNrJztcbmltcG9ydCB7IGNyZWF0ZURvdFByb2R1Y3RQcm9ncmFtSW5mb0xvYWRlciB9IGZyb20gJy4vZG90LXByb2R1Y3QnO1xuaW1wb3J0IHsgSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcywgcGFyc2VJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzIH0gZnJvbSAnLi9mdXNlLXV0aWxzJztcbmltcG9ydCB7IGNyZWF0ZUltMkNvbFByb2dyYW1JbmZvTG9hZGVyIH0gZnJvbSAnLi9pbTJjb2wnO1xuaW1wb3J0IHsgY3JlYXRlTWF0bXVsUHJvZ3JhbUluZm9Mb2FkZXIgfSBmcm9tICcuL21hdG11bCc7XG5cbmV4cG9ydCBjb25zdCBjYWxjdWxhdGVPdXRwdXRTaGFwZSA9IChcbiAgaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gIGtlcm5lbFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgZGlsYXRpb25zOiByZWFkb25seSBudW1iZXJbXSxcbiAgYWRqdXN0UGFkczogcmVhZG9ubHkgbnVtYmVyW10sXG4gIHN0cmlkZXM6IHJlYWRvbmx5IG51bWJlcltdLFxuKTogbnVtYmVyW10gPT4ge1xuICBjb25zdCBiYXRjaFNpemUgPSBpbnB1dFNoYXBlWzBdO1xuICBjb25zdCBpbnB1dFNwYXRpYWxTaGFwZSA9IGlucHV0U2hhcGUuc2xpY2UoMik7XG4gIGNvbnN0IHNwYXRpYWxSYW5rID0gaW5wdXRTcGF0aWFsU2hhcGUubGVuZ3RoO1xuICBjb25zdCBvdXRDaGFubmVscyA9IGtlcm5lbFNoYXBlWzBdO1xuICBjb25zdCBrZXJuZWxTcGF0aWFsU2hhcGUgPSBrZXJuZWxTaGFwZS5zbGljZSgyKTtcbiAgY29uc3QgZGlsYXRlZEtlcm5lbFNoYXBlID0ga2VybmVsU3BhdGlhbFNoYXBlLm1hcCgodiwgaSkgPT4gdiArICh2IC0gMSkgKiAoZGlsYXRpb25zW2ldIC0gMSkpO1xuICBjb25zdCBpbnB1dFNwYXRpYWxTaGFwZVdpdGhQYWQgPSBpbnB1dFNwYXRpYWxTaGFwZS5tYXAoKHYsIGkpID0+IHYgKyBhZGp1c3RQYWRzW2ldICsgYWRqdXN0UGFkc1tpICsgc3BhdGlhbFJhbmtdKTtcbiAgY29uc3Qgb3V0cHV0U3BhdGlhbFNoYXBlID0gaW5wdXRTcGF0aWFsU2hhcGVXaXRoUGFkLm1hcCgodiwgaSkgPT5cbiAgICBNYXRoLmZsb29yKCh2IC0gZGlsYXRlZEtlcm5lbFNoYXBlW2ldICsgc3RyaWRlc1tpXSkgLyBzdHJpZGVzW2ldKSxcbiAgKTtcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBbYmF0Y2hTaXplLCBvdXRDaGFubmVsc10uY29uY2F0KC4uLm91dHB1dFNwYXRpYWxTaGFwZSk7XG4gIHJldHVybiBvdXRwdXRTaGFwZTtcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29udkF0dHJpYnV0ZXMgZXh0ZW5kcyBJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzLCBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBhdXRvUGFkOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGRpbGF0aW9uczogcmVhZG9ubHkgbnVtYmVyW107XG4gIHJlYWRvbmx5IGdyb3VwOiBudW1iZXI7XG4gIHJlYWRvbmx5IGtlcm5lbFNoYXBlOiByZWFkb25seSBudW1iZXJbXTtcbiAgcmVhZG9ubHkgcGFkczogcmVhZG9ubHkgbnVtYmVyW107XG4gIHJlYWRvbmx5IHN0cmlkZXM6IHJlYWRvbmx5IG51bWJlcltdO1xufVxuXG5leHBvcnQgY29uc3QgY29udjogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxDb252QXR0cmlidXRlcz4gPSAoXG4gIGluZmVyZW5jZUhhbmRsZXI6IEluZmVyZW5jZUhhbmRsZXIsXG4gIGlucHV0czogVGVuc29yW10sXG4gIGF0dHJpYnV0ZXM6IENvbnZBdHRyaWJ1dGVzLFxuKTogVGVuc29yW10gPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMsIGF0dHJpYnV0ZXMpOyAvLyBjdXJyZW50bHkgd2lsbCBmYWlsIGlmIG5vdCBjb252MkRcbiAgcmV0dXJuIGNvbnYyZChpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMsIGF0dHJpYnV0ZXMpO1xufTtcblxuY29uc3QgY29udjJkOiBPcGVyYXRvckltcGxlbWVudGF0aW9uPENvbnZBdHRyaWJ1dGVzPiA9IChcbiAgaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBpbnB1dHM6IFRlbnNvcltdLFxuICBhdHRyaWJ1dGVzOiBDb252QXR0cmlidXRlcyxcbik6IFRlbnNvcltdID0+IHtcbiAgY29uc3QgYWRqdXN0ZWRBdHRyaWJ1dGVzID0gZ2V0QWRqdXN0ZWRDb252QXR0cmlidXRlcyhhdHRyaWJ1dGVzLCBpbnB1dHMpO1xuICBjb25zdCBwYWNrTW9kZSA9IGluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5wYWNrO1xuICBjb25zdCBpc1BvaW50d2lzZSA9IGFkanVzdGVkQXR0cmlidXRlcy5rZXJuZWxTaGFwZVswXSA9PT0gMSAmJiBhZGp1c3RlZEF0dHJpYnV0ZXMua2VybmVsU2hhcGVbMV0gPT09IDE7XG4gIGlmIChhZGp1c3RlZEF0dHJpYnV0ZXMuZ3JvdXAgPiAxKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gaW5mZXJlbmNlSGFuZGxlci5ydW4oXG4gICAgICBjcmVhdGVVbnBhY2tlZEdyb3VwZWRDb252UHJvZ3JhbUluZm9Mb2FkZXIoaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzLCBhZGp1c3RlZEF0dHJpYnV0ZXMpLFxuICAgICAgaW5wdXRzLFxuICAgICk7XG4gICAgcmV0dXJuIFtyZXN1bHRdO1xuICB9IGVsc2UgaWYgKGlzUG9pbnR3aXNlICYmIHBhY2tNb2RlKSB7XG4gICAgcmV0dXJuIFtjb252MkRVbnBhY2tlZFBvaW50d2lzZShpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMsIGFkanVzdGVkQXR0cmlidXRlcyldO1xuICB9IGVsc2UgaWYgKHBhY2tNb2RlICYmIGlucHV0c1swXS5kaW1zLmxlbmd0aCA9PT0gNCAmJiBpbnB1dHNbMF0uZGltc1swXSA9PT0gMSAmJiAhaXNQb2ludHdpc2UpIHtcbiAgICByZXR1cm4gW2NvbnYyRFBhY2tlZChpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMsIGFkanVzdGVkQXR0cmlidXRlcyldO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbY29udjJEVW5wYWNrZWQoaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzLCBhZGp1c3RlZEF0dHJpYnV0ZXMpXTtcbiAgfVxufTtcblxuY29uc3QgY29udjJEVW5wYWNrZWRQb2ludHdpc2UgPSAoXG4gIGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JbXSxcbiAgYXR0cmlidXRlczogQ29udkF0dHJpYnV0ZXMsXG4pOiBUZW5zb3IgPT4ge1xuICBjb25zdCB4c2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgY29uc3Qga3NoYXBlID0gaW5wdXRzWzFdLmRpbXM7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gY2FsY3VsYXRlT3V0cHV0U2hhcGUoeHNoYXBlLCBrc2hhcGUsIGF0dHJpYnV0ZXMuZGlsYXRpb25zLCBhdHRyaWJ1dGVzLnBhZHMsIGF0dHJpYnV0ZXMuc3RyaWRlcyk7XG4gIGNvbnN0IHJlc2hhcGVkWCA9IGluZmVyZW5jZUhhbmRsZXIucmVzaGFwZVVucGFja2VkKGlucHV0c1swXSwgW3hzaGFwZVsxXSwgeHNoYXBlWzJdICogeHNoYXBlWzNdXSk7XG4gIGNvbnN0IHJlc2hhcGVkSyA9IGluZmVyZW5jZUhhbmRsZXIucmVzaGFwZVVucGFja2VkKGlucHV0c1sxXSwgW2tzaGFwZVswXSwga3NoYXBlWzFdXSk7XG5cbiAgY29uc3QgbWF0bXVsSW5wdXRzID0gaW5wdXRzLmxlbmd0aCA+IDIgPyBbcmVzaGFwZWRLLCByZXNoYXBlZFgsIGlucHV0c1syXV0gOiBbcmVzaGFwZWRLLCByZXNoYXBlZFhdO1xuICBjb25zdCBtYXRtdWxPdXRwdXQgPSBpbmZlcmVuY2VIYW5kbGVyLnJ1bihjcmVhdGVNYXRtdWxQcm9ncmFtSW5mb0xvYWRlcihtYXRtdWxJbnB1dHMsIGF0dHJpYnV0ZXMpLCBtYXRtdWxJbnB1dHMpO1xuICByZXR1cm4gaW5mZXJlbmNlSGFuZGxlci5yZXNoYXBlVW5wYWNrZWQobWF0bXVsT3V0cHV0LCBvdXRwdXRTaGFwZSk7XG59O1xuXG5jb25zdCBjb252MkRVbnBhY2tlZCA9IChcbiAgaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvcltdLFxuICBhdHRyaWJ1dGVzOiBDb252QXR0cmlidXRlcyxcbik6IFRlbnNvciA9PiB7XG4gIGNvbnN0IHhzaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICBjb25zdCBrc2hhcGUgPSBpbnB1dHNbMV0uZGltcztcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBjYWxjdWxhdGVPdXRwdXRTaGFwZSh4c2hhcGUsIGtzaGFwZSwgYXR0cmlidXRlcy5kaWxhdGlvbnMsIGF0dHJpYnV0ZXMucGFkcywgYXR0cmlidXRlcy5zdHJpZGVzKTtcbiAgY29uc3QgeEltMkNvbCA9IGluZmVyZW5jZUhhbmRsZXIucnVuKFxuICAgIGNyZWF0ZUltMkNvbFByb2dyYW1JbmZvTG9hZGVyKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0c1swXSwgaW5wdXRzWzFdLCBvdXRwdXRTaGFwZSwgYXR0cmlidXRlcyksXG4gICAgW2lucHV0c1swXV0sXG4gICk7XG5cbiAgY29uc3QgZG90UHJvZHVjdElucHV0cyA9IGlucHV0cy5sZW5ndGggPT09IDMgPyBbeEltMkNvbCwgaW5wdXRzWzFdLCBpbnB1dHNbMl1dIDogW3hJbTJDb2wsIGlucHV0c1sxXV07XG4gIGNvbnN0IG91dHB1dCA9IGluZmVyZW5jZUhhbmRsZXIucnVuKFxuICAgIGNyZWF0ZURvdFByb2R1Y3RQcm9ncmFtSW5mb0xvYWRlcihpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMsIG91dHB1dFNoYXBlLCBhdHRyaWJ1dGVzKSxcbiAgICBkb3RQcm9kdWN0SW5wdXRzLFxuICApO1xuICByZXR1cm4gb3V0cHV0O1xufTtcblxuY29uc3QgZ2V0QWRqdXN0ZWRDb252QXR0cmlidXRlcyA9IDxUIGV4dGVuZHMgQ29udkF0dHJpYnV0ZXM+KGF0dHJpYnV0ZXM6IFQsIGlucHV0czogVGVuc29yW10pOiBUID0+IHtcbiAgY29uc3Qga2VybmVsU2hhcGUgPSBhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLnNsaWNlKCk7XG4gIC8vIGlmIGtlcm5lbFNoYXBlIGlzIG5vdCBzcGVjaWZpZWQgaW4gdGhlIGF0dHJpYnV0ZXMgb2YgdGhpcyBvcCwgaW5mZXIgaXQgZnJvbSB0aGUgd2VpZ2h0IHRlbnNvciBkaW1zXG4gIGlmIChhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAobGV0IGkgPSAyOyBpIDwgaW5wdXRzWzFdLmRpbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGtlcm5lbFNoYXBlLnB1c2goaW5wdXRzWzFdLmRpbXNbaV0pO1xuICAgIH1cbiAgfVxuICBjb25zdCBwYWRzID0gYXR0cmlidXRlcy5wYWRzLnNsaWNlKCk7XG4gIFBvb2xDb252VXRpbC5hZGp1c3RQYWRzQmFzZWRPbkF1dG9QYWQoXG4gICAgaW5wdXRzWzBdLmRpbXMsXG4gICAgYXR0cmlidXRlcy5zdHJpZGVzLFxuICAgIGF0dHJpYnV0ZXMuZGlsYXRpb25zLFxuICAgIGtlcm5lbFNoYXBlLFxuICAgIHBhZHMsXG4gICAgYXR0cmlidXRlcy5hdXRvUGFkLFxuICApO1xuXG4gIC8vIGFsd2F5cyByZXR1cm4gYSBuZXcgb2JqZWN0IHNvIGRvZXMgbm90IG1vZGlmeSB0aGUgb3JpZ2luYWwgYXR0cmlidXRlc1xuICBjb25zdCBuZXdBdHRyaWJ1dGVzOiBUID0gT2JqZWN0LmFzc2lnbih7fSwgYXR0cmlidXRlcyk7XG4gIE9iamVjdC5hc3NpZ24obmV3QXR0cmlidXRlcywgeyBrZXJuZWxTaGFwZSwgcGFkcywgY2FjaGVLZXk6IGF0dHJpYnV0ZXMuY2FjaGVLZXkgfSk7XG4gIHJldHVybiBuZXdBdHRyaWJ1dGVzO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlQ29udkF0dHJpYnV0ZXM6IE9wZXJhdG9ySW5pdGlhbGl6YXRpb248Q29udkF0dHJpYnV0ZXM+ID0gKG5vZGU6IEdyYXBoLk5vZGUpOiBDb252QXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IGF0dHJpYnV0ZXMgPSBub2RlLmF0dHJpYnV0ZXM7XG4gIGNvbnN0IGFjdGl2YXRpb25BdHRyaWJ1dGVzID0gcGFyc2VJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpO1xuICAvLyBUT0RPIDogTWFrZSB0aGlzIGdlbmVyaWMgZW5vdWdoIHRvIGNvbXB1dGUgZGVmYXVsdCBhdHRyaWJ1dGVzIGZvciBtdWx0aS1kaW1lbnNpb25hbCBjb252XG4gIGNvbnN0IGF1dG9QYWQgPSBhdHRyaWJ1dGVzLmdldFN0cmluZygnYXV0b19wYWQnLCAnTk9UU0VUJyk7XG4gIGNvbnN0IGRpbGF0aW9ucyA9IGF0dHJpYnV0ZXMuZ2V0SW50cygnZGlsYXRpb25zJywgWzEsIDFdKTtcbiAgY29uc3QgZ3JvdXAgPSBhdHRyaWJ1dGVzLmdldEludCgnZ3JvdXAnLCAxKTtcbiAgY29uc3Qga2VybmVsU2hhcGUgPSBhdHRyaWJ1dGVzLmdldEludHMoJ2tlcm5lbF9zaGFwZScsIFtdKTtcbiAgY29uc3QgcGFkcyA9IGF0dHJpYnV0ZXMuZ2V0SW50cygncGFkcycsIFswLCAwLCAwLCAwXSk7XG4gIGNvbnN0IHN0cmlkZXMgPSBhdHRyaWJ1dGVzLmdldEludHMoJ3N0cmlkZXMnLCBbMSwgMV0pO1xuXG4gIHJldHVybiBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe1xuICAgIGF1dG9QYWQsXG4gICAgZGlsYXRpb25zLFxuICAgIGdyb3VwLFxuICAgIGtlcm5lbFNoYXBlLFxuICAgIHBhZHMsXG4gICAgc3RyaWRlcyxcbiAgICAuLi5hY3RpdmF0aW9uQXR0cmlidXRlcyxcbiAgfSk7XG59O1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IFRlbnNvcltdLCBhdHRyaWJ1dGVzOiBDb252QXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICAvLyBSZWZlciB0byB0aGUgYmVsb3cgbGluayBmb3IgYWxsIGlucHV0IGNoZWNrc1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vb25ueC9vbm54L2Jsb2IvbWFpbi9kb2NzL09wZXJhdG9ycy5tZCNDb252XG4gIGlmICghaW5wdXRzIHx8IChpbnB1dHMubGVuZ3RoICE9PSAyICYmIGlucHV0cy5sZW5ndGggIT09IDMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb252IHJlcXVpcmVzIDIgb3IgMyBpbnB1dHMnKTtcbiAgfVxuXG4gIC8vIFRPRE8gOiBOZWVkIHRvIGFkZCBzdXBwb3J0IGZvciBtdWx0aS1kaW1lbnNpb25hbCBjb252XG4gIGlmIChpbnB1dHNbMF0uZGltcy5sZW5ndGggIT09IDQgfHwgaW5wdXRzWzFdLmRpbXMubGVuZ3RoICE9PSA0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjdXJyZW50bHkgb25seSBzdXBwb3J0IDItZGltZW5zaW9uYWwgY29udicpO1xuICB9XG5cbiAgLy8gRklMVEVSX0lOX0NIQU5ORUwgc2hvdWxkIGJlIGVxdWFsIHRvIERBVEFfQ0hBTk5FTFxuICBjb25zdCBkYXRhQ2hhbm5lbCA9IGlucHV0c1swXS5kaW1zWzFdO1xuICBjb25zdCBmaWx0ZXJJbkNoYW5uZWwgPSBpbnB1dHNbMV0uZGltc1sxXSAqIGF0dHJpYnV0ZXMuZ3JvdXA7XG4gIGlmIChkYXRhQ2hhbm5lbCAhPT0gZmlsdGVySW5DaGFubmVsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGSUxURVJfSU5fQ0hBTk5FTCBzaG91bGQgYmUgZXF1YWwgdG8gREFUQV9DSEFOTkVMJyk7XG4gIH1cblxuICAvLyBpZiBiaWFzIGlzIHByb3ZpZGVkIGl0IHNob3VsZCBiZSAxRCBhbmQgdGhlIG51bWJlciBvZiBlbGVtZW50cyBzaG91bGQgYmUgZXF1YWwgdG8gdGhlIG51bWJlciBvZiBmZWF0dXJlIG1hcHNcbiAgaWYgKGlucHV0cy5sZW5ndGggPT09IDMgJiYgKGlucHV0c1syXS5kaW1zLmxlbmd0aCAhPT0gMSB8fCBpbnB1dHNbMV0uZGltc1swXSAhPT0gaW5wdXRzWzJdLmRpbXNbMF0pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGJpYXMnKTtcbiAgfVxuXG4gIGNvbnN0IHNwYXRpYWxSYW5rID0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoIC0gMjtcbiAgLy8gd3JvbmcgZGlsYXRpb25zIGRpbWVuc2lvblxuICBpZiAoYXR0cmlidXRlcy5kaWxhdGlvbnMubGVuZ3RoICE9PSBzcGF0aWFsUmFuaykge1xuICAgIHRocm93IG5ldyBFcnJvcihgZGlsYXRpb25zIHNob3VsZCBiZSAke3NwYXRpYWxSYW5rfURgKTtcbiAgfVxuXG4gIC8vIFdyb25nIHN0cmlkZXMgZGltZW5zaW9uXG4gIGlmIChhdHRyaWJ1dGVzLnN0cmlkZXMubGVuZ3RoICE9PSBzcGF0aWFsUmFuaykge1xuICAgIHRocm93IG5ldyBFcnJvcihgc3RyaWRlcyBzaG91bGQgYmUgJHtzcGF0aWFsUmFua31EYCk7XG4gIH1cblxuICAvLyBXcm9uZyBwYWRzIGRpbWVuc2lvblxuICBpZiAoYXR0cmlidXRlcy5wYWRzLmxlbmd0aCAhPT0gc3BhdGlhbFJhbmsgKiAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBwYWRzIHNob3VsZCBiZSAke3NwYXRpYWxSYW5rICogMn1EYCk7XG4gIH1cblxuICAvLyBpZiBrZXJuZWxTaGFwZSBpcyBzcGVjaWZpZWQsIGl0J3MgZGF0YSBsZW5ndGggbXVzdCBiZSAyIGxlc3MgdGhhbiBkaW1zIGxlbmd0aCBvZiB0aGUgd2VpZ2h0cyB0ZW5zb3JcbiAgLy8gKHRoZSBmaXJzdCAyIGRpbXMgYXJlIGJhdGNoX3NpemUgYW5kIGNoYW5uZWxzKVxuICBpZiAoYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5sZW5ndGggIT09IDAgJiYgYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5sZW5ndGggIT09IGlucHV0c1sxXS5kaW1zLmxlbmd0aCAtIDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQga2VybmVsIHNoYXBlJyk7XG4gIH1cblxuICAvLyBUT0RPIDogTmVlZCB0byBhZGQgc3VwcG9ydCBmb3IgZmxvYXQ2NFxuICBpZiAoaW5wdXRzWzBdLnR5cGUgIT09ICdmbG9hdDMyJyB8fCBpbnB1dHNbMV0udHlwZSAhPT0gJ2Zsb2F0MzInKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb252IGlucHV0KFgsVykgc2hvdWxkIGJlIGZsb2F0IHRlbnNvcicpO1xuICB9XG5cbiAgaWYgKGlucHV0cy5sZW5ndGggPT09IDMgJiYgaW5wdXRzWzJdLnR5cGUgIT09ICdmbG9hdDMyJykge1xuICAgIHRocm93IG5ldyBFcnJvcignQ29udiBpbnB1dChiaWFzKSBzaG91bGQgYmUgZmxvYXQgdGVuc29yJyk7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uLy4uLy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQgeyBJbmZlcmVuY2VIYW5kbGVyIH0gZnJvbSAnLi4vLi4vLi4vYmFja2VuZCc7XG5pbXBvcnQgeyBHcmFwaCB9IGZyb20gJy4uLy4uLy4uL2dyYXBoJztcbmltcG9ydCB7IE9wZXJhdG9ySW1wbGVtZW50YXRpb24sIE9wZXJhdG9ySW5pdGlhbGl6YXRpb24gfSBmcm9tICcuLi8uLi8uLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgVGVuc29yIH0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7IGdldEdsc2wgfSBmcm9tICcuLi9nbHNsLXNvdXJjZSc7XG5pbXBvcnQgeyBXZWJHTEluZmVyZW5jZUhhbmRsZXIgfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQgeyBQcm9ncmFtSW5mbywgUHJvZ3JhbUluZm9Mb2FkZXIsIFByb2dyYW1NZXRhZGF0YSwgVGV4dHVyZVR5cGUgfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IENvbnZBdHRyaWJ1dGVzIH0gZnJvbSAnLi9jb252JztcbmltcG9ydCB7IGdldEFjdGl2YXRpb25TbmlwcGV0LCBwYXJzZUludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMgfSBmcm9tICcuL2Z1c2UtdXRpbHMnO1xuXG5jb25zdCBjb21wdXRlVG90YWxQYWQgPSAoXG4gIGluRGltOiBudW1iZXIsXG4gIHN0cmlkZTogbnVtYmVyLFxuICBhZGo6IG51bWJlcixcbiAga2VybmVsOiBudW1iZXIsXG4gIGRpbGF0aW9uOiBudW1iZXIsXG4gIG91dFNpemU6IG51bWJlcixcbikgPT4gKGluRGltIC0gMSkgKiBzdHJpZGUgKyBhZGogKyAoa2VybmVsIC0gMSkgKiBkaWxhdGlvbiArIDEgLSBvdXRTaXplO1xuXG5jb25zdCBkaXN0cmlidXRlUGFkZGluZyA9ICh0b3RhbFBhZDogbnVtYmVyLCBhdXRvUGFkOiBzdHJpbmcsIHBhZHM6IG51bWJlcltdLCBoZWFkOiBudW1iZXIsIHRhaWw6IG51bWJlcikgPT4ge1xuICBjb25zdCBzbWFsbFBhZCA9IE1hdGguZmxvb3IodG90YWxQYWQgLyAyKTtcbiAgaWYgKGF1dG9QYWQgPT09ICdTQU1FX1VQUEVSJykge1xuICAgIHBhZHNbaGVhZF0gPSBzbWFsbFBhZDtcbiAgICBwYWRzW3RhaWxdID0gdG90YWxQYWQgLSBzbWFsbFBhZDtcbiAgfSBlbHNlIGlmIChhdXRvUGFkID09PSAnU0FNRV9MT1dFUicpIHtcbiAgICBwYWRzW2hlYWRdID0gdG90YWxQYWQgLSBzbWFsbFBhZDtcbiAgICBwYWRzW3RhaWxdID0gc21hbGxQYWQ7XG4gIH1cbn07XG5cbmNvbnN0IGNhbGN1bGF0ZU91dHB1dFNoYXBlQW5kUGFkcyA9IChcbiAgaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gIGtlcm5lbFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgZGlsYXRpb25zOiByZWFkb25seSBudW1iZXJbXSxcbiAgYXV0b1BhZDogc3RyaW5nLFxuICBwYWRzOiBudW1iZXJbXSxcbiAgc3RyaWRlczogcmVhZG9ubHkgbnVtYmVyW10sXG4gIG91dHB1dFBhZGRpbmc6IHJlYWRvbmx5IG51bWJlcltdLFxuICBvdXRwdXRTaGFwZTogbnVtYmVyW10sXG4pID0+IHtcbiAgY29uc3Qgc3BhdGlhbFJhbmsgPSBpbnB1dFNoYXBlLmxlbmd0aCAtIDI7XG4gIGNvbnN0IHVwZGF0ZVNoYXBlID0gb3V0cHV0U2hhcGUubGVuZ3RoID09PSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNwYXRpYWxSYW5rOyArK2kpIHtcbiAgICBjb25zdCBvdXRTaXplID0gdXBkYXRlU2hhcGUgPyBpbnB1dFNoYXBlW2kgKyAyXSAqIHN0cmlkZXNbaV0gOiBvdXRwdXRTaGFwZVtpXTtcbiAgICBjb25zdCB0b3RhbFBhZCA9IGNvbXB1dGVUb3RhbFBhZChpbnB1dFNoYXBlW2kgKyAyXSwgc3RyaWRlc1tpXSwgcGFkc1tpXSwga2VybmVsU2hhcGVbaV0sIGRpbGF0aW9uc1tpXSwgb3V0U2l6ZSk7XG4gICAgZGlzdHJpYnV0ZVBhZGRpbmcodG90YWxQYWQsIGF1dG9QYWQsIHBhZHMsIGksIGkgKyBzcGF0aWFsUmFuayk7XG4gICAgaWYgKHVwZGF0ZVNoYXBlKSB7XG4gICAgICBvdXRwdXRTaGFwZS5wdXNoKFxuICAgICAgICBzdHJpZGVzW2ldICogKGlucHV0U2hhcGVbaSArIDJdIC0gMSkgK1xuICAgICAgICAgIG91dHB1dFBhZGRpbmdbaV0gK1xuICAgICAgICAgIChrZXJuZWxTaGFwZVtpXSAtIDEpICogZGlsYXRpb25zW2ldICtcbiAgICAgICAgICAxIC1cbiAgICAgICAgICBwYWRzW2ldIC1cbiAgICAgICAgICBwYWRzW2kgKyBzcGF0aWFsUmFua10sXG4gICAgICApO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IGludGVyZmFjZSBDb252VHJhbnNwb3NlQXR0cmlidXRlcyBleHRlbmRzIENvbnZBdHRyaWJ1dGVzIHtcbiAgcmVhZG9ubHkgb3V0cHV0UGFkZGluZzogcmVhZG9ubHkgbnVtYmVyW107XG4gIHJlYWRvbmx5IG91dHB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXTtcbn1cblxuZXhwb3J0IGNvbnN0IGNvbnZUcmFuc3Bvc2U6IE9wZXJhdG9ySW1wbGVtZW50YXRpb248Q29udlRyYW5zcG9zZUF0dHJpYnV0ZXM+ID0gKFxuICBpbmZlcmVuY2VIYW5kbGVyOiBJbmZlcmVuY2VIYW5kbGVyLFxuICBpbnB1dHM6IFRlbnNvcltdLFxuICBhdHRyaWJ1dGVzOiBDb252VHJhbnNwb3NlQXR0cmlidXRlcyxcbik6IFRlbnNvcltdID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoaW5wdXRzLCBhdHRyaWJ1dGVzKTsgLy8gY3VycmVudGx5IHdpbGwgZmFpbCBpZiBub3QgY29udlRyYW5zcG9zZTJEXG4gIHJldHVybiBjb252VHJhbnNwb3NlMmQoaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzLCBhdHRyaWJ1dGVzKTtcbn07XG5cbmNvbnN0IGNvbnZUcmFuc3Bvc2UyZDogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxDb252VHJhbnNwb3NlQXR0cmlidXRlcz4gPSAoXG4gIGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXRzOiBUZW5zb3JbXSxcbiAgYXR0cmlidXRlczogQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMsXG4pOiBUZW5zb3JbXSA9PiB7XG4gIGNvbnN0IGFkanVzdGVkQXR0cmlidXRlcyA9IGdldEFkanVzdGVkQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMoYXR0cmlidXRlcywgaW5wdXRzKTtcbiAgcmV0dXJuIFtjb252VHJhbnNwb3NlMkRVbnBhY2tlZChpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMsIGFkanVzdGVkQXR0cmlidXRlcyldO1xufTtcblxuY29uc3QgY3JlYXRlQ29udlRyYW5zcG9zZVByb2dyYW1NZXRhZGF0YSA9IChoYXNCaWFzOiBib29sZWFuLCBjYWNoZUhpbnQ6IHN0cmluZykgPT4gKHtcbiAgbmFtZTogJ0NvbnZUcmFuc3Bvc2UnLFxuICBpbnB1dE5hbWVzOiBoYXNCaWFzID8gWydYJywgJ1cnLCAnQiddIDogWydYJywgJ1cnXSxcbiAgaW5wdXRUeXBlczogaGFzQmlhc1xuICAgID8gW1RleHR1cmVUeXBlLnVucGFja2VkLCBUZXh0dXJlVHlwZS51bnBhY2tlZCwgVGV4dHVyZVR5cGUudW5wYWNrZWRdXG4gICAgOiBbVGV4dHVyZVR5cGUudW5wYWNrZWQsIFRleHR1cmVUeXBlLnVucGFja2VkXSxcbiAgY2FjaGVIaW50LFxufSk7XG5cbmNvbnN0IGNyZWF0ZVVucGFja2VkQ29udlRyYW5zcG9zZVByb2dyYW1JbmZvID0gKFxuICBpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yW10sXG4gIG1ldGFkYXRhOiBQcm9ncmFtTWV0YWRhdGEsXG4gIGF0dHJpYnV0ZXM6IENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzLFxuKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBoYXNCaWFzID0gaW5wdXRzLmxlbmd0aCA+IDI7XG4gIGNvbnN0IHZhbHVlSW5pdCA9IGhhc0JpYXMgPyAnZ2V0QihvdXRwdXRfY2hhbm5lbCknIDogJzAuMCc7XG4gIGNvbnN0IHhTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICBjb25zdCB3U2hhcGUgPSBpbnB1dHNbMV0uZGltcztcbiAgY29uc3Qgb3V0cHV0Q2hhbm5lbHNQZXJHcm91cCA9IHdTaGFwZVsxXTtcbiAgY29uc3QgaW5wdXRDaGFubmVsc1Blckdyb3VwID0gd1NoYXBlWzBdIC8gYXR0cmlidXRlcy5ncm91cDtcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBbaW5wdXRzWzBdLmRpbXNbMF0sIGlucHV0c1sxXS5kaW1zWzFdICogYXR0cmlidXRlcy5ncm91cCwgLi4uYXR0cmlidXRlcy5vdXRwdXRTaGFwZV07XG4gIGNvbnN0IGdsc2wgPSBnZXRHbHNsKGluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgY29uc3QgeyBhY3RpdmF0aW9uRnVuY3Rpb24sIGFwcGx5QWN0aXZhdGlvbiB9ID0gZ2V0QWN0aXZhdGlvblNuaXBwZXQoYXR0cmlidXRlcyk7XG5cbiAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICBjb25zdCBpdmVjMiBzdHJpZGVzID0gaXZlYzIoJHthdHRyaWJ1dGVzLnN0cmlkZXNbMF19LCAke2F0dHJpYnV0ZXMuc3RyaWRlc1sxXX0pO1xuICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoJHthdHRyaWJ1dGVzLnBhZHNbMF19LCAke2F0dHJpYnV0ZXMucGFkc1sxXX0pO1xuICAke2FjdGl2YXRpb25GdW5jdGlvbn1cbiAgdm9pZCBtYWluKCkge1xuICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgIGludCBiYXRjaCA9IGNvb3Jkcy54O1xuICAgIGludCBvdXRwdXRfY2hhbm5lbCA9IGNvb3Jkcy55O1xuXG4gICAgaXZlYzIgbG9jID0gY29vcmRzLnp3ICsgcGFkcztcblxuICAgIGludCBncm91cF9pZCA9IG91dHB1dF9jaGFubmVsIC8gJHtvdXRwdXRDaGFubmVsc1Blckdyb3VwfTtcbiAgICBpbnQgd091dENoYW5uZWwgPSBvdXRwdXRfY2hhbm5lbCAtIGdyb3VwX2lkICogJHtvdXRwdXRDaGFubmVsc1Blckdyb3VwfTtcblxuICAgIGZsb2F0IHZhbHVlID0gJHt2YWx1ZUluaXR9O1xuICAgIGZvciAoaW50IGluQ2hhbm5lbE9mZnNldCA9IDA7IGluQ2hhbm5lbE9mZnNldCA8ICR7aW5wdXRDaGFubmVsc1Blckdyb3VwfTsgaW5DaGFubmVsT2Zmc2V0KyspIHtcbiAgICAgIGludCBpbnB1dF9jaGFubmVsID0gZ3JvdXBfaWQgKiAke2lucHV0Q2hhbm5lbHNQZXJHcm91cH0gKyBpbkNoYW5uZWxPZmZzZXQ7XG4gICAgICBmb3IgKGludCB3V09mZiA9IDA7IHdXT2ZmIDwgJHt3U2hhcGVbMl19OyB3V09mZisrKSB7XG4gICAgICAgIGZvciAoaW50IHdIT2ZmID0gMDsgd0hPZmYgPCAke3dTaGFwZVszXX07IHdIT2ZmKyspIHtcbiAgICAgICAgICBpdmVjMiB3T2ZmID0gaXZlYzIod1dPZmYgKiAke2F0dHJpYnV0ZXMuZGlsYXRpb25zWzBdfSwgd0hPZmYgKiAke2F0dHJpYnV0ZXMuZGlsYXRpb25zWzFdfSk7XG4gICAgICAgICAgaXZlYzIgd0xvYyA9IGxvYyAtIHdPZmY7XG4gICAgICAgICAgaXZlYzIgd0xvY0luID0gd0xvYyAvIHN0cmlkZXM7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgd0xvY0luICogc3RyaWRlcyA9PSB3TG9jICYmXG4gICAgICAgICAgICB3TG9jSW4ueCA+PSAwICYmIHdMb2NJbi54IDwgJHt4U2hhcGVbMl19ICYmXG4gICAgICAgICAgICB3TG9jSW4ueSA+PSAwICYmIHdMb2NJbi55IDwgJHt4U2hhcGVbM119XG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBmbG9hdCB4VmFsID0gZ2V0WChiYXRjaCwgaW5wdXRfY2hhbm5lbCwgd0xvY0luLnksIHdMb2NJbi54KTtcbiAgICAgICAgICAgIGZsb2F0IHdWYWwgPSBnZXRXKGlucHV0X2NoYW5uZWwsIHdPdXRDaGFubmVsLCB3SE9mZiwgd1dPZmYpO1xuICAgICAgICAgICAgdmFsdWUgKz0geFZhbCAqIHdWYWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgICR7YXBwbHlBY3RpdmF0aW9ufVxuICAgICR7Z2xzbC5vdXRwdXR9ID0gdmVjNCh2YWx1ZSwgLjAsIC4wLCAuMCk7XG4gIH1cbmA7XG4gIHJldHVybiB7XG4gICAgLi4ubWV0YWRhdGEsXG4gICAgb3V0cHV0OiB7IGRpbXM6IG91dHB1dFNoYXBlLCB0eXBlOiBpbnB1dHNbMF0udHlwZSwgdGV4dHVyZVR5cGU6IFRleHR1cmVUeXBlLnVucGFja2VkIH0sXG4gICAgc2hhZGVyU291cmNlLFxuICAgIGhhc01haW46IHRydWUsXG4gIH07XG59O1xuXG5jb25zdCBjcmVhdGVVbnBhY2tlZENvbnZUcmFuc3Bvc2VQcm9ncmFtSW5mb0xvYWRlciA9IChcbiAgaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvcltdLFxuICBhdHRyaWJ1dGVzOiBDb252VHJhbnNwb3NlQXR0cmlidXRlcyxcbik6IFByb2dyYW1JbmZvTG9hZGVyID0+IHtcbiAgY29uc3QgbWV0YWRhdGEgPSBjcmVhdGVDb252VHJhbnNwb3NlUHJvZ3JhbU1ldGFkYXRhKGlucHV0cy5sZW5ndGggPiAyLCBhdHRyaWJ1dGVzLmNhY2hlS2V5KTtcbiAgcmV0dXJuIHtcbiAgICAuLi5tZXRhZGF0YSxcbiAgICBnZXQ6ICgpID0+IGNyZWF0ZVVucGFja2VkQ29udlRyYW5zcG9zZVByb2dyYW1JbmZvKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0cywgbWV0YWRhdGEsIGF0dHJpYnV0ZXMpLFxuICB9O1xufTtcblxuY29uc3QgY29udlRyYW5zcG9zZTJEVW5wYWNrZWQgPSAoXG4gIGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JbXSxcbiAgYXR0cmlidXRlczogQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMsXG4pOiBUZW5zb3IgPT4ge1xuICBjb25zdCByZXN1bHQgPSBpbmZlcmVuY2VIYW5kbGVyLnJ1bihcbiAgICBjcmVhdGVVbnBhY2tlZENvbnZUcmFuc3Bvc2VQcm9ncmFtSW5mb0xvYWRlcihpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMsIGF0dHJpYnV0ZXMpLFxuICAgIGlucHV0cyxcbiAgKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmNvbnN0IGdldEFkanVzdGVkQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMgPSA8VCBleHRlbmRzIENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzPihhdHRyaWJ1dGVzOiBULCBpbnB1dHM6IFRlbnNvcltdKTogVCA9PiB7XG4gIGNvbnN0IGtlcm5lbFNoYXBlID0gYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5zbGljZSgpO1xuICAvLyBpZiBrZXJuZWxTaGFwZSBpcyBub3Qgc3BlY2lmaWVkIGluIHRoZSBhdHRyaWJ1dGVzIG9mIHRoaXMgb3AsIGluZmVyIGl0IGZyb20gdGhlIHdlaWdodCB0ZW5zb3IgZGltc1xuICBpZiAoYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGxldCBpID0gMjsgaSA8IGlucHV0c1sxXS5kaW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICBrZXJuZWxTaGFwZS5wdXNoKGlucHV0c1sxXS5kaW1zW2ldKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBwYWRzID0gYXR0cmlidXRlcy5wYWRzLnNsaWNlKCk7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gYXR0cmlidXRlcy5vdXRwdXRTaGFwZS5zbGljZSgpO1xuICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gIC8vIElmIG91dHB1dFNoYXBlIGlzIG5vdCBzcGVjaWZpZWQgaW4gdGhlIGF0dHJpYnV0ZXMgb2YgdGhpcyBvcCwgaW5mZXIgaXQgZnJvbSB0aGUgcGFyYW1ldGVyc1xuICAvLyBTaW1pbGFybHksIGF1dG9tYXRpY2FsbHkgaW5mZXIgcGFkcyBpZiBub3Qgc3BlY2lmaWVkXG4gIGNhbGN1bGF0ZU91dHB1dFNoYXBlQW5kUGFkcyhcbiAgICBpbnB1dFNoYXBlLFxuICAgIGtlcm5lbFNoYXBlLFxuICAgIGF0dHJpYnV0ZXMuZGlsYXRpb25zLFxuICAgIGF0dHJpYnV0ZXMuYXV0b1BhZCxcbiAgICBwYWRzLFxuICAgIGF0dHJpYnV0ZXMuc3RyaWRlcyxcbiAgICBhdHRyaWJ1dGVzLm91dHB1dFBhZGRpbmcsXG4gICAgb3V0cHV0U2hhcGUsXG4gICk7XG5cbiAgLy8gYWx3YXlzIHJldHVybiBhIG5ldyBvYmplY3Qgc28gZG9lcyBub3QgbW9kaWZ5IHRoZSBvcmlnaW5hbCBhdHRyaWJ1dGVzXG4gIGNvbnN0IG5ld0F0dHJpYnV0ZXM6IFQgPSBPYmplY3QuYXNzaWduKHt9LCBhdHRyaWJ1dGVzKTtcbiAgT2JqZWN0LmFzc2lnbihuZXdBdHRyaWJ1dGVzLCB7IGtlcm5lbFNoYXBlLCBwYWRzLCBvdXRwdXRTaGFwZSwgY2FjaGVLZXk6IGF0dHJpYnV0ZXMuY2FjaGVLZXkgfSk7XG4gIHJldHVybiBuZXdBdHRyaWJ1dGVzO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXM6IE9wZXJhdG9ySW5pdGlhbGl6YXRpb248Q29udlRyYW5zcG9zZUF0dHJpYnV0ZXM+ID0gKFxuICBub2RlOiBHcmFwaC5Ob2RlLFxuKTogQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMgPT4ge1xuICBjb25zdCBhdHRyaWJ1dGVzID0gbm9kZS5hdHRyaWJ1dGVzO1xuICBjb25zdCBhY3RpdmF0aW9uQXR0cmlidXRlcyA9IHBhcnNlSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcyhhdHRyaWJ1dGVzKTtcbiAgLy8gVE9ETyA6IE1ha2UgdGhpcyBnZW5lcmljIGVub3VnaCB0byBjb21wdXRlIGRlZmF1bHQgYXR0cmlidXRlcyBmb3IgbXVsdGktZGltZW5zaW9uYWwgY29udlxuICBjb25zdCBhdXRvUGFkID0gYXR0cmlidXRlcy5nZXRTdHJpbmcoJ2F1dG9fcGFkJywgJ05PVFNFVCcpO1xuICBjb25zdCBkaWxhdGlvbnMgPSBhdHRyaWJ1dGVzLmdldEludHMoJ2RpbGF0aW9ucycsIFsxLCAxXSk7XG4gIGNvbnN0IGdyb3VwID0gYXR0cmlidXRlcy5nZXRJbnQoJ2dyb3VwJywgMSk7XG4gIGNvbnN0IGtlcm5lbFNoYXBlID0gYXR0cmlidXRlcy5nZXRJbnRzKCdrZXJuZWxfc2hhcGUnLCBbXSk7XG4gIGNvbnN0IG91dHB1dFBhZGRpbmcgPSBhdHRyaWJ1dGVzLmdldEludHMoJ291dHB1dF9wYWRkaW5nJywgWzAsIDBdKTtcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBhdHRyaWJ1dGVzLmdldEludHMoJ291dHB1dF9zaGFwZScsIFtdKTtcbiAgY29uc3QgcGFkcyA9IGF0dHJpYnV0ZXMuZ2V0SW50cygncGFkcycsIFswLCAwLCAwLCAwXSk7XG4gIGNvbnN0IHN0cmlkZXMgPSBhdHRyaWJ1dGVzLmdldEludHMoJ3N0cmlkZXMnLCBbMSwgMV0pO1xuXG4gIHJldHVybiBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe1xuICAgIGF1dG9QYWQsXG4gICAgZGlsYXRpb25zLFxuICAgIGdyb3VwLFxuICAgIGtlcm5lbFNoYXBlLFxuICAgIG91dHB1dFBhZGRpbmcsXG4gICAgb3V0cHV0U2hhcGUsXG4gICAgcGFkcyxcbiAgICBzdHJpZGVzLFxuICAgIC4uLmFjdGl2YXRpb25BdHRyaWJ1dGVzLFxuICB9KTtcbn07XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogVGVuc29yW10sIGF0dHJpYnV0ZXM6IENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIC8vIFJlZmVyIHRvIHRoZSBiZWxvdyBsaW5rIGZvciBhbGwgaW5wdXQgY2hlY2tzXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9vbm54L29ubngvYmxvYi9tYWluL2RvY3MvT3BlcmF0b3JzLm1kI0NvbnZcbiAgaWYgKCFpbnB1dHMgfHwgKGlucHV0cy5sZW5ndGggIT09IDIgJiYgaW5wdXRzLmxlbmd0aCAhPT0gMykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnYgcmVxdWlyZXMgMiBvciAzIGlucHV0cycpO1xuICB9XG5cbiAgLy8gVE9ETyA6IE5lZWQgdG8gYWRkIHN1cHBvcnQgZm9yIG11bHRpLWRpbWVuc2lvbmFsIGNvbnZcbiAgaWYgKGlucHV0c1swXS5kaW1zLmxlbmd0aCAhPT0gNCB8fCBpbnB1dHNbMV0uZGltcy5sZW5ndGggIT09IDQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2N1cnJlbnRseSBvbmx5IHN1cHBvcnQgMi1kaW1lbnNpb25hbCBjb252Jyk7XG4gIH1cblxuICAvLyBGSUxURVJfSU5fQ0hBTk5FTCBzaG91bGQgYmUgZXF1YWwgdG8gREFUQV9DSEFOTkVMXG4gIGNvbnN0IGRhdGFDaGFubmVsID0gaW5wdXRzWzBdLmRpbXNbMV07XG4gIGNvbnN0IGZpbHRlckluQ2hhbm5lbCA9IGlucHV0c1sxXS5kaW1zWzBdO1xuICBpZiAoZGF0YUNoYW5uZWwgIT09IGZpbHRlckluQ2hhbm5lbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRklMVEVSX0lOX0NIQU5ORUwgc2hvdWxkIGJlIGVxdWFsIHRvIERBVEFfQ0hBTk5FTCcpO1xuICB9XG5cbiAgY29uc3QgZmVhdHVyZU1hcHMgPSBpbnB1dHNbMV0uZGltc1sxXSAqIGF0dHJpYnV0ZXMuZ3JvdXA7XG5cbiAgLy8gaWYgYmlhcyBpcyBwcm92aWRlZCBpdCBzaG91bGQgYmUgMUQgYW5kIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgc2hvdWxkIGJlIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgZmVhdHVyZSBtYXBzXG4gIGlmIChpbnB1dHMubGVuZ3RoID09PSAzICYmIChpbnB1dHNbMl0uZGltcy5sZW5ndGggIT09IDEgfHwgaW5wdXRzWzJdLmRpbXNbMF0gIT09IGZlYXR1cmVNYXBzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBiaWFzJyk7XG4gIH1cblxuICBjb25zdCBzcGF0aWFsUmFuayA9IGlucHV0c1swXS5kaW1zLmxlbmd0aCAtIDI7XG4gIC8vIHdyb25nIGRpbGF0aW9ucyBkaW1lbnNpb25cbiAgaWYgKGF0dHJpYnV0ZXMuZGlsYXRpb25zLmxlbmd0aCAhPT0gc3BhdGlhbFJhbmspIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGRpbGF0aW9ucyBzaG91bGQgYmUgJHtzcGF0aWFsUmFua31EYCk7XG4gIH1cblxuICAvLyBXcm9uZyBzdHJpZGVzIGRpbWVuc2lvblxuICBpZiAoYXR0cmlidXRlcy5zdHJpZGVzLmxlbmd0aCAhPT0gc3BhdGlhbFJhbmspIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHN0cmlkZXMgc2hvdWxkIGJlICR7c3BhdGlhbFJhbmt9RGApO1xuICB9XG5cbiAgLy8gV3JvbmcgcGFkcyBkaW1lbnNpb25cbiAgaWYgKGF0dHJpYnV0ZXMucGFkcy5sZW5ndGggIT09IHNwYXRpYWxSYW5rICogMikge1xuICAgIHRocm93IG5ldyBFcnJvcihgcGFkcyBzaG91bGQgYmUgJHtzcGF0aWFsUmFuayAqIDJ9RGApO1xuICB9XG5cbiAgLy8gV3Jvbmcgb3V0cHV0IHBhZGRpbmcgZGltZW5zaW9uXG4gIGlmIChhdHRyaWJ1dGVzLm91dHB1dFBhZGRpbmcubGVuZ3RoICE9PSBzcGF0aWFsUmFuaykge1xuICAgIHRocm93IG5ldyBFcnJvcihgb3V0cHV0X3BhZGRpbmcgc2hvdWxkIGJlICR7c3BhdGlhbFJhbmt9RGApO1xuICB9XG5cbiAgLy8gaWYga2VybmVsU2hhcGUgaXMgc3BlY2lmaWVkLCBpdCdzIGRhdGEgbGVuZ3RoIG11c3QgYmUgMiBsZXNzIHRoYW4gZGltcyBsZW5ndGggb2YgdGhlIHdlaWdodHMgdGVuc29yXG4gIC8vICh0aGUgZmlyc3QgMiBkaW1zIGFyZSBiYXRjaF9zaXplIGFuZCBjaGFubmVscylcbiAgaWYgKGF0dHJpYnV0ZXMua2VybmVsU2hhcGUubGVuZ3RoICE9PSAwICYmIGF0dHJpYnV0ZXMua2VybmVsU2hhcGUubGVuZ3RoICE9PSBpbnB1dHNbMV0uZGltcy5sZW5ndGggLSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGtlcm5lbCBzaGFwZScpO1xuICB9XG5cbiAgLy8gYXMgd2l0aCBrZXJuZWxTaGFwZSwgbXVzdCBoYXZlIHNhbWUgbnVtYmVyIG9mIHNwYXRpYWwgZGltcyBhcyBpbnB1dFxuICBpZiAoYXR0cmlidXRlcy5vdXRwdXRTaGFwZS5sZW5ndGggIT09IDAgJiYgYXR0cmlidXRlcy5vdXRwdXRTaGFwZS5sZW5ndGggIT09IGlucHV0c1swXS5kaW1zLmxlbmd0aCAtIDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgb3V0cHV0IHNoYXBlJyk7XG4gIH1cblxuICAvLyBUT0RPIDogTmVlZCB0byBhZGQgc3VwcG9ydCBmb3IgZmxvYXQ2NFxuICBpZiAoaW5wdXRzWzBdLnR5cGUgIT09ICdmbG9hdDMyJyB8fCBpbnB1dHNbMV0udHlwZSAhPT0gJ2Zsb2F0MzInKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb252VHJhbnNwb3NlIGlucHV0KFgsVykgc2hvdWxkIGJlIGZsb2F0IHRlbnNvcicpO1xuICB9XG5cbiAgaWYgKGlucHV0cy5sZW5ndGggPT09IDMgJiYgaW5wdXRzWzJdLnR5cGUgIT09ICdmbG9hdDMyJykge1xuICAgIHRocm93IG5ldyBFcnJvcignQ29udlRyYW5zcG9zZSBpbnB1dChiaWFzKSBzaG91bGQgYmUgZmxvYXQgdGVuc29yJyk7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vLi4vLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7IEdyYXBoIH0gZnJvbSAnLi4vLi4vLi4vZ3JhcGgnO1xuaW1wb3J0IHsgT3BlcmF0b3JJbXBsZW1lbnRhdGlvbiwgT3BlcmF0b3JJbml0aWFsaXphdGlvbiB9IGZyb20gJy4uLy4uLy4uL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBUZW5zb3IgfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBXZWJHTEluZmVyZW5jZUhhbmRsZXIgfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQgeyBQcm9ncmFtSW5mbywgVGV4dHVyZVR5cGUgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNwb3NlQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IHBlcm06IG51bWJlcltdO1xufVxuXG5jb25zdCB0cmFuc3Bvc2VQcm9ncmFtTWV0YWRhdGEgPSB7XG4gIG5hbWU6ICdUcmFuc3Bvc2UnLFxuICBpbnB1dE5hbWVzOiBbJ0EnXSxcbiAgaW5wdXRUeXBlczogW1RleHR1cmVUeXBlLnVucGFja2VkXSxcbn07XG5cbmV4cG9ydCBjb25zdCB0cmFuc3Bvc2U6IE9wZXJhdG9ySW1wbGVtZW50YXRpb248VHJhbnNwb3NlQXR0cmlidXRlcz4gPSAoXG4gIGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXRzOiBUZW5zb3JbXSxcbiAgYXR0cmlidXRlczogVHJhbnNwb3NlQXR0cmlidXRlcyxcbik6IFRlbnNvcltdID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoaW5wdXRzKTtcbiAgY29uc3Qgb3V0cHV0ID0gaW5mZXJlbmNlSGFuZGxlci5ydW4oXG4gICAge1xuICAgICAgLi4udHJhbnNwb3NlUHJvZ3JhbU1ldGFkYXRhLFxuICAgICAgY2FjaGVIaW50OiBhdHRyaWJ1dGVzLmNhY2hlS2V5LFxuICAgICAgZ2V0OiAoKSA9PiBjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbyhpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHNbMF0sIGF0dHJpYnV0ZXMucGVybSksXG4gICAgfSxcbiAgICBpbnB1dHMsXG4gICk7XG4gIHJldHVybiBbb3V0cHV0XTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZVRyYW5zcG9zZUF0dHJpYnV0ZXM6IE9wZXJhdG9ySW5pdGlhbGl6YXRpb248VHJhbnNwb3NlQXR0cmlidXRlcz4gPSAoXG4gIG5vZGU6IEdyYXBoLk5vZGUsXG4pOiBUcmFuc3Bvc2VBdHRyaWJ1dGVzID0+IGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7IHBlcm06IG5vZGUuYXR0cmlidXRlcy5nZXRJbnRzKCdwZXJtJywgW10pIH0pO1xuXG5jb25zdCBjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbyA9IChcbiAgX2luZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXQ6IFRlbnNvcixcbiAgcGVybTogbnVtYmVyW10sXG4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dC5kaW1zO1xuICBwZXJtID0gZ2V0QWRqdXN0ZWRQZXJtKGlucHV0U2hhcGUsIHBlcm0pO1xuICBjb25zdCB1bnBhY2tlZE91dHB1dFNoYXBlID0gZ2V0T3V0cHV0U2hhcGUoaW5wdXRTaGFwZSwgcGVybSk7XG4gIGNvbnN0IHJhbmsgPSBpbnB1dFNoYXBlLmxlbmd0aDtcbiAgLy8gQSBkaW1zPVske2lucHV0c1swXS5kaW1zLnRvU3RyaW5nKCl9XVxuICAvLyBvdXQgRGltcz1bJHt1bnBhY2tlZE91dHB1dFNoYXBlLnRvU3RyaW5nKCl9XVxuICAvLyBiYXNlZCBvbiBwZXJtPVske3Blcm0udG9TdHJpbmcoKX1dXG4gIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgICR7Z2V0UGVybUZ1bmN0aW9uQm9keSgncGVybScsIHBlcm0sIHJhbmspfVxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske3Jhbmt9XSkge1xuICAgICAgICBpbnQgYVske3Jhbmt9XTtcbiAgICAgICAgcGVybShhLCBpbmRpY2VzKTtcbiAgICAgICAgcmV0dXJuIF9BKGEpO1xuICAgICAgfWA7XG4gIHJldHVybiB7XG4gICAgLi4udHJhbnNwb3NlUHJvZ3JhbU1ldGFkYXRhLFxuICAgIG91dHB1dDogeyBkaW1zOiB1bnBhY2tlZE91dHB1dFNoYXBlLCB0eXBlOiBpbnB1dC50eXBlLCB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGUudW5wYWNrZWQgfSxcbiAgICBzaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG5jb25zdCBnZXRBZGp1c3RlZFBlcm0gPSAoaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIHBlcm06IG51bWJlcltdKTogbnVtYmVyW10gPT4ge1xuICBpZiAocGVybSAmJiBwZXJtLmxlbmd0aCAhPT0gaW5wdXRTaGFwZS5sZW5ndGgpIHtcbiAgICBwZXJtID0gWy4uLmlucHV0U2hhcGUua2V5cygpXS5yZXZlcnNlKCk7XG4gIH1cbiAgcmV0dXJuIHBlcm07XG59O1xuXG5jb25zdCBnZXRPdXRwdXRTaGFwZSA9IChpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgcGVybTogbnVtYmVyW10pOiByZWFkb25seSBudW1iZXJbXSA9PiB7XG4gIHBlcm0gPSBnZXRBZGp1c3RlZFBlcm0oaW5wdXRTaGFwZSwgcGVybSk7XG4gIHJldHVybiBTaGFwZVV0aWwuc29ydEJhc2VkT25QZXJtKGlucHV0U2hhcGUsIHBlcm0pO1xufTtcblxuY29uc3QgZ2V0UGVybUZ1bmN0aW9uQm9keSA9IChuYW1lOiBzdHJpbmcsIHBlcm06IG51bWJlcltdLCByYW5rOiBudW1iZXIpOiBzdHJpbmcgPT4ge1xuICBjb25zdCByZXZlcnNlRnVuYyA9IFtdO1xuICByZXZlcnNlRnVuYy5wdXNoKGB2b2lkICR7bmFtZX0ob3V0IGludCBhWyR7cmFua31dLCBpbnQgc3JjWyR7cmFua31dKSB7YCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuazsgKytpKSB7XG4gICAgcmV2ZXJzZUZ1bmMucHVzaChgXFx0YVske3Blcm1baV19XT1zcmNbJHtpfV07YCk7XG4gIH1cbiAgcmV2ZXJzZUZ1bmMucHVzaCgnXFx0fScpO1xuICByZXR1cm4gcmV2ZXJzZUZ1bmMuam9pbignXFxuJyk7XG59O1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IFRlbnNvcltdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9zZSByZXF1aXJlcyAxIGlucHV0LicpO1xuICB9XG5cbiAgaWYgKGlucHV0c1swXS50eXBlICE9PSAnZmxvYXQzMicgJiYgaW5wdXRzWzBdLnR5cGUgIT09ICdmbG9hdDY0Jykge1xuICAgIHRocm93IG5ldyBFcnJvcignaW5wdXQgc2hvdWxkIGJlIGZsb2F0IHRlbnNvcicpO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBHcmFwaCB9IGZyb20gJy4uLy4uLy4uL2dyYXBoJztcbmltcG9ydCB7IE9wZXJhdG9ySW1wbGVtZW50YXRpb24sIE9wZXJhdG9ySW5pdGlhbGl6YXRpb24gfSBmcm9tICcuLi8uLi8uLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgVGVuc29yIH0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7IFdlYkdMSW5mZXJlbmNlSGFuZGxlciB9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcblxuaW1wb3J0IHsgdHJhbnNwb3NlLCBUcmFuc3Bvc2VBdHRyaWJ1dGVzIH0gZnJvbSAnLi90cmFuc3Bvc2UnO1xuXG5leHBvcnQgaW50ZXJmYWNlIERlcHRoVG9TcGFjZUF0dHJpYnV0ZXMge1xuICBtb2RlOiAnRENSJyB8ICdDUkQnO1xuICBibG9ja3NpemU6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNvbnN0IGRlcHRoVG9TcGFjZTogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxEZXB0aFRvU3BhY2VBdHRyaWJ1dGVzPiA9IChcbiAgaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBpbnB1dHM6IFRlbnNvcltdLFxuICBhdHRyaWJ1dGVzOiBEZXB0aFRvU3BhY2VBdHRyaWJ1dGVzLFxuKTogVGVuc29yW10gPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuICBjb25zdCBibG9ja3NpemUgPSBhdHRyaWJ1dGVzLmJsb2Nrc2l6ZTtcbiAgY29uc3QgYmxvY2tzaXplU3FyID0gYmxvY2tzaXplICogYmxvY2tzaXplO1xuICBjb25zdCB0cmFuc3Bvc2VQZXJtID0gYXR0cmlidXRlcy5tb2RlID09PSAnRENSJyA/IFswLCAzLCA0LCAxLCA1LCAyXSA6IFswLCAxLCA0LCAyLCA1LCAzXTtcbiAgY29uc3QgZmlyc3RSZXNoYXBlU2hhcGUgPVxuICAgIGF0dHJpYnV0ZXMubW9kZSA9PT0gJ0RDUidcbiAgICAgID8gW1xuICAgICAgICAgIGlucHV0c1swXS5kaW1zWzBdLFxuICAgICAgICAgIGJsb2Nrc2l6ZSxcbiAgICAgICAgICBibG9ja3NpemUsXG4gICAgICAgICAgaW5wdXRzWzBdLmRpbXNbMV0gLyBibG9ja3NpemVTcXIsXG4gICAgICAgICAgaW5wdXRzWzBdLmRpbXNbMl0sXG4gICAgICAgICAgaW5wdXRzWzBdLmRpbXNbM10sXG4gICAgICAgIF1cbiAgICAgIDogW1xuICAgICAgICAgIGlucHV0c1swXS5kaW1zWzBdLFxuICAgICAgICAgIGlucHV0c1swXS5kaW1zWzFdIC8gYmxvY2tzaXplU3FyLFxuICAgICAgICAgIGJsb2Nrc2l6ZSxcbiAgICAgICAgICBibG9ja3NpemUsXG4gICAgICAgICAgaW5wdXRzWzBdLmRpbXNbMl0sXG4gICAgICAgICAgaW5wdXRzWzBdLmRpbXNbM10sXG4gICAgICAgIF07XG5cbiAgLy8gY29uc3QgdHJhbnNwb3NlID0gbmV3IFdlYkdMVHJhbnNwb3NlKCk7XG4gIC8vIGNvbnN0IGF0dHJpYnV0ZXMgPSBuZXcgQXR0cmlidXRlKHVuZGVmaW5lZCk7XG4gIC8vIGF0dHJpYnV0ZXMuc2V0KCdwZXJtJywgJ2ludHMnLCB0cmFuc3Bvc2VQZXJtKTtcbiAgLy8gdHJhbnNwb3NlLmluaXRpYWxpemUoYXR0cmlidXRlcyk7XG5cbiAgLy8gRmlyc3QgcmVzaGFwZVxuICBjb25zdCBmaXJzdFJlc2hhcGVkVGVuc29yID0gaW5mZXJlbmNlSGFuZGxlci5yZXNoYXBlVW5wYWNrZWQoaW5wdXRzWzBdLCBmaXJzdFJlc2hhcGVTaGFwZSk7XG5cbiAgLy8gdHJhbnNwb3NlXG4gIGNvbnN0IHRyYW5zcG9zZUF0dHJpYnV0ZXM6IFRyYW5zcG9zZUF0dHJpYnV0ZXMgPSB7IHBlcm06IHRyYW5zcG9zZVBlcm0sIGNhY2hlS2V5OiBgJHt0cmFuc3Bvc2VQZXJtfWAgfTtcbiAgY29uc3QgW3RyYW5zcG9zZU91dHB1dF0gPSB0cmFuc3Bvc2UoaW5mZXJlbmNlSGFuZGxlciwgW2ZpcnN0UmVzaGFwZWRUZW5zb3JdLCB0cmFuc3Bvc2VBdHRyaWJ1dGVzKTtcblxuICAvLyBTZWNvbmQgcmVzaGFwZVxuICBjb25zdCBzZWNvbmRSZXNoYXBlU2hhcGUgPSBbXG4gICAgaW5wdXRzWzBdLmRpbXNbMF0sXG4gICAgaW5wdXRzWzBdLmRpbXNbMV0gLyBibG9ja3NpemVTcXIsXG4gICAgaW5wdXRzWzBdLmRpbXNbMl0gKiBibG9ja3NpemUsXG4gICAgaW5wdXRzWzBdLmRpbXNbM10gKiBibG9ja3NpemUsXG4gIF07XG4gIGNvbnN0IHJlc3VsdCA9IGluZmVyZW5jZUhhbmRsZXIucmVzaGFwZVVucGFja2VkKHRyYW5zcG9zZU91dHB1dCwgc2Vjb25kUmVzaGFwZVNoYXBlKTtcbiAgcmV0dXJuIFtyZXN1bHRdO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlRGVwdGhUb1NwYWNlQXR0cmlidXRlczogT3BlcmF0b3JJbml0aWFsaXphdGlvbjxEZXB0aFRvU3BhY2VBdHRyaWJ1dGVzPiA9IChcbiAgbm9kZTogR3JhcGguTm9kZSxcbik6IERlcHRoVG9TcGFjZUF0dHJpYnV0ZXMgPT4ge1xuICAvLyBwcm9jZXNzaW5nIG5vZGUgYXR0cmlidXRlc1xuICBjb25zdCBibG9ja3NpemUgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0SW50KCdibG9ja3NpemUnKTtcbiAgaWYgKGJsb2Nrc2l6ZSA8IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGJsb2Nrc2l6ZSBtdXN0IGJlID49IDEsIGJ1dCBnb3QgOiAke2Jsb2Nrc2l6ZX0gZm9yIERlcHRoVG9TcGFjZWApO1xuICB9XG4gIGNvbnN0IG1vZGUgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0U3RyaW5nKCdtb2RlJywgJ0RDUicpO1xuICBpZiAobW9kZSAhPT0gJ0RDUicgJiYgbW9kZSAhPT0gJ0NSRCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHVucmVjb2duaXplZCBtb2RlOiAke21vZGV9IGZvciBEZXB0aFRvU3BhY2VgKTtcbiAgfVxuICByZXR1cm4geyBtb2RlLCBibG9ja3NpemUgfTtcbn07XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogVGVuc29yW10pOiB2b2lkID0+IHtcbiAgaWYgKGlucHV0cy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYERlcHRoVG9TcGFjZSBleHBlY3QgMSBpbnB1dHMsIGJ1dCBnb3QgJHtpbnB1dHMubGVuZ3RofWApO1xuICB9XG5cbiAgLy8gSW5wdXQgaGFzIHRvIGJlIGEgNC1EIHRlbnNvclxuICAvLyBUT0RPOiBTdXBwb3J0IHN0cmluZyBkZXB0aC10by1zcGFjZS5cbiAgaWYgKGlucHV0c1swXS50eXBlID09PSAnc3RyaW5nJyB8fCBpbnB1dHNbMF0uZGltcy5sZW5ndGggIT09IDQpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdEZXB0aFRvU3BhY2UgaW5wdXQgc2hvdWxkIGJlIGEgNC1EIG51bWVyaWMgdGVuc29yJyk7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEdyYXBoIH0gZnJvbSAnLi4vLi4vLi4vZ3JhcGgnO1xuaW1wb3J0IHsgT3BlcmF0b3JJbXBsZW1lbnRhdGlvbiwgT3BlcmF0b3JJbml0aWFsaXphdGlvbiB9IGZyb20gJy4uLy4uLy4uL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBUZW5zb3IgfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBXZWJHTEluZmVyZW5jZUhhbmRsZXIgfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5cbmV4cG9ydCBjb25zdCBmbGF0dGVuOiBPcGVyYXRvckltcGxlbWVudGF0aW9uPG51bWJlcj4gPSAoXG4gIGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXRzOiBUZW5zb3JbXSxcbiAgYXhpczogbnVtYmVyLFxuKTogVGVuc29yW10gPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMsIGF4aXMpO1xuXG4gIGNvbnN0IG91dHB1dERpbXMgPSBTaGFwZVV0aWwuZmxhdHRlblNoYXBlKGlucHV0c1swXS5kaW1zLCBheGlzKTtcbiAgcmV0dXJuIFtpbmZlcmVuY2VIYW5kbGVyLnJlc2hhcGVVbnBhY2tlZChpbnB1dHNbMF0sIG91dHB1dERpbXMpXTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUZsYXR0ZW5BdHRyaWJ1dGVzOiBPcGVyYXRvckluaXRpYWxpemF0aW9uPG51bWJlcj4gPSAobm9kZTogR3JhcGguTm9kZSk6IG51bWJlciA9PlxuICBub2RlLmF0dHJpYnV0ZXMuZ2V0SW50KCdheGlzJywgMSk7IC8vIGRlZmF1bHQgYXhpcyBpcyAxXG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogVGVuc29yW10sIGF4aXM6IG51bWJlcik6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGbGF0dGVuIHJlcXVpcmVzIDEgaW5wdXQuJyk7XG4gIH1cblxuICBjb25zdCByID0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoO1xuICBpZiAociA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2NhbGFyIHRlbnNvciBpcyBub3Qgc3VwcG9ydGVkLicpO1xuICB9XG5cbiAgaWYgKGF4aXMgPCAtciB8fCBheGlzID4gcikge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBheGlzJyk7XG4gIH1cblxuICAvLyBUT0RPOiBTdXBwb3J0IHN0cmluZyB0eXBlXG4gIGlmIChpbnB1dHNbMF0udHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0cmluZyB0ZW5zb3IgaXMgbm90IHN1cHBvcnRlZC4nKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgSW5mZXJlbmNlSGFuZGxlciB9IGZyb20gJy4vYmFja2VuZCc7XG5pbXBvcnQgeyBHcmFwaCB9IGZyb20gJy4vZ3JhcGgnO1xuaW1wb3J0IHsgVGVuc29yIH0gZnJvbSAnLi90ZW5zb3InO1xuXG5leHBvcnQgdHlwZSBPcGVyYXRvckltcGxlbWVudGF0aW9uPFQ+ID0gKGluZmVyZW5jZUhhbmRsZXI6IEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10sIGNvbnRleHQ6IFQpID0+IFRlbnNvcltdO1xuZXhwb3J0IHR5cGUgT3BlcmF0b3JJbml0aWFsaXphdGlvbjxUPiA9IChub2RlOiBHcmFwaC5Ob2RlLCBncmFwaDogR3JhcGgpID0+IFQ7XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3BlcmF0b3Ige1xuICByZWFkb25seSBpbXBsOiBPcGVyYXRvckltcGxlbWVudGF0aW9uPHVua25vd24+O1xuICByZWFkb25seSBjb250ZXh0OiBHcmFwaC5Ob2RlIHwgdW5rbm93bjtcbn1cblxuZXhwb3J0IGNvbnN0IE5VTUJFUl9UWVBFUzogcmVhZG9ubHkgVGVuc29yLkRhdGFUeXBlW10gPSBbXG4gICdmbG9hdDMyJyxcbiAgJ2Zsb2F0NjQnLFxuICAnaW50MzInLFxuICAnaW50MTYnLFxuICAnaW50OCcsXG4gICd1aW50MTYnLFxuICAndWludDMyJyxcbiAgJ3VpbnQ4Jyxcbl07XG5leHBvcnQgY29uc3QgSU5UX1RZUEVTOiByZWFkb25seSBUZW5zb3IuRGF0YVR5cGVbXSA9IFsnaW50MzInLCAnaW50MTYnLCAnaW50OCcsICd1aW50MTYnLCAndWludDMyJywgJ3VpbnQ4J107XG5leHBvcnQgY29uc3QgRkxPQVRfVFlQRVM6IHJlYWRvbmx5IFRlbnNvci5EYXRhVHlwZVtdID0gWydmbG9hdDMyJywgJ2Zsb2F0NjQnXTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgQXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi8uLi8uLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHsgR3JhcGggfSBmcm9tICcuLi8uLi8uLi9ncmFwaCc7XG5pbXBvcnQgeyBOVU1CRVJfVFlQRVMsIE9wZXJhdG9ySW1wbGVtZW50YXRpb24sIE9wZXJhdG9ySW5pdGlhbGl6YXRpb24gfSBmcm9tICcuLi8uLi8uLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgVGVuc29yIH0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgV2ViR0xJbmZlcmVuY2VIYW5kbGVyIH0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHsgUHJvZ3JhbUluZm8sIFByb2dyYW1JbmZvTG9hZGVyLCBQcm9ncmFtTWV0YWRhdGEsIFRleHR1cmVUeXBlIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbnRlcmZhY2UgR2F0aGVyQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IGF4aXM6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNvbnN0IGdhdGhlcjogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxHYXRoZXJBdHRyaWJ1dGVzPiA9IChcbiAgaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBpbnB1dHM6IFRlbnNvcltdLFxuICBhdHRyaWJ1dGVzOiBHYXRoZXJBdHRyaWJ1dGVzLFxuKTogVGVuc29yW10gPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMsIGF0dHJpYnV0ZXMuYXhpcyk7XG4gIGNvbnN0IG91dHB1dCA9IGluZmVyZW5jZUhhbmRsZXIucnVuKGNyZWF0ZUdhdGhlclByb2dyYW1JbmZvTG9hZGVyKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0cywgYXR0cmlidXRlcyksIGlucHV0cyk7XG4gIHJldHVybiBbb3V0cHV0XTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUdhdGhlckF0dHJpYnV0ZXM6IE9wZXJhdG9ySW5pdGlhbGl6YXRpb248R2F0aGVyQXR0cmlidXRlcz4gPSAobm9kZTogR3JhcGguTm9kZSk6IEdhdGhlckF0dHJpYnV0ZXMgPT5cbiAgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHsgYXhpczogbm9kZS5hdHRyaWJ1dGVzLmdldEludCgnYXhpcycsIDApIH0pO1xuXG5jb25zdCBnYXRoZXJQcm9ncmFtTWV0YWRhdGEgPSB7XG4gIG5hbWU6ICdHYXRoZXInLFxuICBpbnB1dE5hbWVzOiBbJ0EnLCAnQiddLFxuICBpbnB1dFR5cGVzOiBbVGV4dHVyZVR5cGUudW5wYWNrZWQsIFRleHR1cmVUeXBlLnVucGFja2VkXSxcbn07XG5cbmNvbnN0IGNyZWF0ZUdhdGhlclByb2dyYW1JbmZvID0gKFxuICBfaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBtZXRhZGF0YTogUHJvZ3JhbU1ldGFkYXRhLFxuICBpbnB1dHM6IFRlbnNvcltdLFxuICBheGlzOiBudW1iZXIsXG4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcy5zbGljZSgpO1xuICBjb25zdCBpbmRleERhdGFTaGFwZSA9IGlucHV0c1sxXS5kaW1zLnNsaWNlKCk7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gbmV3IEFycmF5KGlucHV0U2hhcGUubGVuZ3RoICsgaW5kZXhEYXRhU2hhcGUubGVuZ3RoIC0gMSk7XG5cbiAgYXhpcyA9IFNoYXBlVXRpbC5ub3JtYWxpemVBeGlzKGF4aXMsIGlucHV0U2hhcGUubGVuZ3RoKTtcbiAgY29uc3QgaW5kZXhDb3B5T3BzOiBzdHJpbmdbXSA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dFNoYXBlLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gb3V0cHV0U2hhcGUgaXMgZGl2aWRlZCBpbnRvIHRocmVlIHBhcnRzOiBBLCBCLCBDXG4gICAgLy8gfDAgICAgICAgIGF4aXN8ICBheGlzICsgaW5kZXhEYXRhU2hhcGUubGVuZ3RoIHwgICAgICAgICAgZW5kfFxuICAgIC8vIHwgICAgIEEgICAgICAgfCAgICAgICAgICAgICBCICAgICAgICAgICAgICAgICB8ICAgICAgQyAgICAgIHxcbiAgICAvL1xuICAgIC8vIGlucHV0SWR4OiBbQSwgaW5wdXRzWzFdW0JdLCBDXVxuICAgIGlmIChpIDwgYXhpcykge1xuICAgICAgLy8gQVxuICAgICAgb3V0cHV0U2hhcGVbaV0gPSBpbnB1dFNoYXBlW2ldO1xuICAgICAgaW5kZXhDb3B5T3BzLnB1c2goYGlucHV0SWR4WyR7aX1dID0gb3V0cHV0SWR4WyR7aX1dO2ApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaSA8IGF4aXMgKyBpbmRleERhdGFTaGFwZS5sZW5ndGgpIHtcbiAgICAgICAgLy8gQlxuICAgICAgICBvdXRwdXRTaGFwZVtpXSA9IGluZGV4RGF0YVNoYXBlW2kgLSBheGlzXTtcbiAgICAgICAgaW5kZXhDb3B5T3BzLnB1c2goYGluZGV4RGF0YUlkeFske2kgLSBheGlzfV0gPSBvdXRwdXRJZHhbJHtpfV07YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDXG4gICAgICAgIG91dHB1dFNoYXBlW2ldID0gaW5wdXRTaGFwZVtpIC0gaW5kZXhEYXRhU2hhcGUubGVuZ3RoICsgMV07IC8vIHNraXAgMSBmb3IgYXhpc1xuICAgICAgICBpbmRleENvcHlPcHMucHVzaChgaW5wdXRJZHhbJHtpIC0gaW5kZXhEYXRhU2hhcGUubGVuZ3RoICsgMX1dID0gb3V0cHV0SWR4WyR7aX1dO2ApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG9yYW5rID0gb3V0cHV0U2hhcGUubGVuZ3RoIHx8IDE7XG4gIGNvbnN0IGlyYW5rID0gaW5wdXRTaGFwZS5sZW5ndGg7XG4gIGNvbnN0IGlEcmFuayA9IGluZGV4RGF0YVNoYXBlLmxlbmd0aCB8fCAxO1xuICBjb25zdCBzaGFkZXJTb3VyY2UgPSBgXG4gICAgICBmbG9hdCBwcm9jZXNzKGludCBvdXRwdXRJZHhbJHtvcmFua31dKSB7XG4gICAgICAgIGludCBpbnB1dElkeFske2lyYW5rfV07XG4gICAgICAgIGludCBpbmRleERhdGFJZHhbJHtpRHJhbmt9XTtcbiAgICAgICAgaW5kZXhEYXRhSWR4WzBdID0gMDtcbiAgICAgICAgJHtpbmRleENvcHlPcHMuam9pbignXFxuICAgICAgICAnKX1cbiAgICAgICAgaW50IGlkeCA9IGludChfQihpbmRleERhdGFJZHgpKTtcbiAgICAgICAgaW5wdXRJZHhbJHtheGlzfV0gPSBpZHggPCAwID8gaWR4ICsgJHtpbnB1dFNoYXBlW2F4aXNdfSA6IGlkeDtcbiAgICAgICAgcmV0dXJuIF9BKGlucHV0SWR4KTtcbiAgICAgIH1gO1xuICByZXR1cm4ge1xuICAgIC4uLm1ldGFkYXRhLFxuICAgIG91dHB1dDogeyBkaW1zOiBvdXRwdXRTaGFwZSwgdHlwZTogaW5wdXRzWzBdLnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS51bnBhY2tlZCB9LFxuICAgIHNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG5cbmNvbnN0IGNyZWF0ZUdhdGhlclByb2dyYW1JbmZvTG9hZGVyID0gKFxuICBoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsXG4gIGlucHV0czogVGVuc29yW10sXG4gIGF0dHJpYnV0ZXM6IEdhdGhlckF0dHJpYnV0ZXMsXG4pOiBQcm9ncmFtSW5mb0xvYWRlciA9PiB7XG4gIGNvbnN0IG1ldGFkYXRhID0geyAuLi5nYXRoZXJQcm9ncmFtTWV0YWRhdGEsIGNhY2hlSGludDogYXR0cmlidXRlcy5jYWNoZUtleSB9O1xuICByZXR1cm4geyAuLi5tZXRhZGF0YSwgZ2V0OiAoKSA9PiBjcmVhdGVHYXRoZXJQcm9ncmFtSW5mbyhoYW5kbGVyLCBtZXRhZGF0YSwgaW5wdXRzLCBhdHRyaWJ1dGVzLmF4aXMpIH07XG59O1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IFRlbnNvcltdLCBheGlzOiBudW1iZXIpOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcignR2F0aGVyIHJlcXVpcmVzIDIgaW5wdXRzLicpO1xuICB9XG4gIGNvbnN0IHRlbnNvclJhbmsgPSBpbnB1dHNbMF0uZGltcy5sZW5ndGg7XG4gIGlmICh0ZW5zb3JSYW5rIDwgMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCBzaGFwZS4nKTtcbiAgfVxuICBpZiAoYXhpcyA8IC10ZW5zb3JSYW5rIHx8IGF4aXMgPiB0ZW5zb3JSYW5rIC0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBheGlzLicpO1xuICB9XG4gIGlmIChOVU1CRVJfVFlQRVMuaW5kZXhPZihpbnB1dHNbMF0udHlwZSkgPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhaWQgaW5wdXQgdHlwZS4nKTtcbiAgfVxuICBpZiAoaW5wdXRzWzFdLnR5cGUgIT09ICdpbnQzMicgJiYgaW5wdXRzWzFdLnR5cGUgIT09ICdpbnQxNicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFpZCBpbnB1dCB0eXBlLicpO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uLy4uLy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQgeyBHcmFwaCB9IGZyb20gJy4uLy4uLy4uL2dyYXBoJztcbmltcG9ydCB7IE9wZXJhdG9ySW1wbGVtZW50YXRpb24sIE9wZXJhdG9ySW5pdGlhbGl6YXRpb24gfSBmcm9tICcuLi8uLi8uLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgVGVuc29yIH0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7IEdlbW1VdGlsIH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBXZWJHTEluZmVyZW5jZUhhbmRsZXIgfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQgeyBQcm9ncmFtSW5mbywgUHJvZ3JhbUluZm9Mb2FkZXIsIFByb2dyYW1NZXRhZGF0YSwgVGV4dHVyZVR5cGUgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2VtbUF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICB0cmFuc0E6IGJvb2xlYW47XG4gIHRyYW5zQjogYm9vbGVhbjtcbiAgYWxwaGE6IG51bWJlcjtcbiAgYmV0YTogbnVtYmVyO1xuICBpc09wdGlvbmFsQzogYm9vbGVhbjsgLy8gaW4gb3BzZXQgMTEsIEMgYmVjb21lcyBvcHRpb25hbFxufVxuXG5leHBvcnQgY29uc3QgZ2VtbTogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxHZW1tQXR0cmlidXRlcz4gPSAoXG4gIGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXRzOiBUZW5zb3JbXSxcbiAgYXR0cmlidXRlczogR2VtbUF0dHJpYnV0ZXMsXG4pOiBUZW5zb3JbXSA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGlucHV0cywgYXR0cmlidXRlcyk7XG4gIGNvbnN0IG91dHB1dCA9IGluZmVyZW5jZUhhbmRsZXIucnVuKGNyZWF0ZUdlbW1Qcm9ncmFtSW5mb0xvYWRlcihpbnB1dHMsIGF0dHJpYnV0ZXMpLCBpbnB1dHMpO1xuICByZXR1cm4gW291dHB1dF07XG59O1xuXG5jb25zdCBwYXJzZUdlbW1BdHRyaWJ1dGVzID0gKG5vZGU6IEdyYXBoLk5vZGUsIGlzT3B0aW9uYWxDOiBib29sZWFuKTogR2VtbUF0dHJpYnV0ZXMgPT4ge1xuICBjb25zdCB0cmFuc0EgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0SW50KCd0cmFuc0EnLCAwKSAhPT0gMDtcbiAgY29uc3QgdHJhbnNCID0gbm9kZS5hdHRyaWJ1dGVzLmdldEludCgndHJhbnNCJywgMCkgIT09IDA7XG4gIGNvbnN0IGFscGhhID0gbm9kZS5hdHRyaWJ1dGVzLmdldEZsb2F0KCdhbHBoYScsIDEuMCk7XG4gIGNvbnN0IGJldGEgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0RmxvYXQoJ2JldGEnLCAxLjApO1xuICByZXR1cm4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHsgdHJhbnNBLCB0cmFuc0IsIGFscGhhLCBiZXRhLCBpc09wdGlvbmFsQyB9KTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUdlbW1BdHRyaWJ1dGVzVjc6IE9wZXJhdG9ySW5pdGlhbGl6YXRpb248R2VtbUF0dHJpYnV0ZXM+ID0gKG5vZGU6IEdyYXBoLk5vZGUpOiBHZW1tQXR0cmlidXRlcyA9PlxuICBwYXJzZUdlbW1BdHRyaWJ1dGVzKG5vZGUsIGZhbHNlKTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlR2VtbUF0dHJpYnV0ZXNWMTE6IE9wZXJhdG9ySW5pdGlhbGl6YXRpb248R2VtbUF0dHJpYnV0ZXM+ID0gKG5vZGU6IEdyYXBoLk5vZGUpOiBHZW1tQXR0cmlidXRlcyA9PlxuICBwYXJzZUdlbW1BdHRyaWJ1dGVzKG5vZGUsIHRydWUpO1xuXG5jb25zdCBjcmVhdGVHZW1tUHJvZ3JhbUluZm9Mb2FkZXIgPSAoaW5wdXRzOiBUZW5zb3JbXSwgYXR0cmlidXRlczogR2VtbUF0dHJpYnV0ZXMpOiBQcm9ncmFtSW5mb0xvYWRlciA9PiB7XG4gIGNvbnN0IG1ldGFkYXRhID0ge1xuICAgIG5hbWU6ICdHZW1tJyxcbiAgICBpbnB1dE5hbWVzOiBpbnB1dHMubGVuZ3RoID09PSAzID8gWydBJywgJ0InLCAnQyddIDogWydBJywgJ0InXSxcbiAgICBpbnB1dFR5cGVzOlxuICAgICAgaW5wdXRzLmxlbmd0aCA9PT0gM1xuICAgICAgICA/IFtUZXh0dXJlVHlwZS51bnBhY2tlZCwgVGV4dHVyZVR5cGUudW5wYWNrZWQsIFRleHR1cmVUeXBlLnVucGFja2VkXVxuICAgICAgICA6IFtUZXh0dXJlVHlwZS51bnBhY2tlZCwgVGV4dHVyZVR5cGUudW5wYWNrZWRdLFxuICAgIGtleTogYXR0cmlidXRlcy5jYWNoZUtleSxcbiAgfTtcblxuICByZXR1cm4geyAuLi5tZXRhZGF0YSwgZ2V0OiAoKSA9PiBjcmVhdGVHZW1tUHJvZ3JhbUluZm8obWV0YWRhdGEsIGlucHV0cywgYXR0cmlidXRlcykgfTtcbn07XG5cbmNvbnN0IGNyZWF0ZUdlbW1Qcm9ncmFtSW5mbyA9IChcbiAgbWV0YWRhdGE6IFByb2dyYW1NZXRhZGF0YSxcbiAgaW5wdXRzOiBUZW5zb3JbXSxcbiAgYXR0cmlidXRlczogR2VtbUF0dHJpYnV0ZXMsXG4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGFTaGFwZSA9IGlucHV0c1swXS5kaW1zLnNsaWNlKCk7XG4gIGNvbnN0IGJTaGFwZSA9IGlucHV0c1sxXS5kaW1zLnNsaWNlKCk7XG4gIGNvbnN0IFtNLCBOXSA9IEdlbW1VdGlsLmdldFNoYXBlT2ZHZW1tUmVzdWx0KFxuICAgIGFTaGFwZSxcbiAgICBhdHRyaWJ1dGVzLnRyYW5zQSxcbiAgICBiU2hhcGUsXG4gICAgYXR0cmlidXRlcy50cmFuc0IsXG4gICAgaW5wdXRzLmxlbmd0aCA9PT0gMyA/IGlucHV0c1syXS5kaW1zIDogdW5kZWZpbmVkLFxuICApO1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IFtNLCBOXTtcbiAgaWYgKCFvdXRwdXRTaGFwZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHVzZSBnZW1tIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO1xuICB9XG4gIGxldCBzaGFyZWREaW0gPSBhU2hhcGVbYVNoYXBlLmxlbmd0aCAtIDFdO1xuICBsZXQgbGluZSA9ICcnO1xuICBpZiAoYXR0cmlidXRlcy50cmFuc0EpIHtcbiAgICBzaGFyZWREaW0gPSBhU2hhcGVbMF07XG4gIH1cbiAgaWYgKGF0dHJpYnV0ZXMudHJhbnNBICYmIGF0dHJpYnV0ZXMudHJhbnNCKSB7XG4gICAgbGluZSA9ICd2YWx1ZSArPSBfQV9UKGEpICogX0JfVChiKTsnO1xuICB9IGVsc2UgaWYgKGF0dHJpYnV0ZXMudHJhbnNBICYmICFhdHRyaWJ1dGVzLnRyYW5zQikge1xuICAgIGxpbmUgPSAndmFsdWUgKz0gX0FfVChhKSAqIF9CKGIpOyc7XG4gIH0gZWxzZSBpZiAoIWF0dHJpYnV0ZXMudHJhbnNBICYmIGF0dHJpYnV0ZXMudHJhbnNCKSB7XG4gICAgbGluZSA9ICd2YWx1ZSArPSBfQShhKSAqIF9CX1QoYik7JztcbiAgfSBlbHNlIGlmICghYXR0cmlidXRlcy50cmFuc0EgJiYgIWF0dHJpYnV0ZXMudHJhbnNCKSB7XG4gICAgbGluZSA9ICd2YWx1ZSArPSBfQShhKSAqIF9CKGIpOyc7XG4gIH1cbiAgY29uc3QgcmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aDtcbiAgY29uc3QgZGVjbGFyZUMgPSBpbnB1dHMubGVuZ3RoID09PSAzID8gYGludCBjWyR7aW5wdXRzWzJdLmRpbXMubGVuZ3RofV07YCA6ICcnO1xuICBjb25zdCBicm9hZGNhc3RDID0gaW5wdXRzLmxlbmd0aCA9PT0gMyA/ICdiY2FzdEluZGljZXNfQyhpbmRpY2VzLCBjKTsnIDogJyc7XG4gIGNvbnN0IGNhbGN1bGF0ZUMgPSBpbnB1dHMubGVuZ3RoID09PSAzID8gJ3ZhbHVlICs9IGJldGEgKiBfQyhjKTsnIDogJyc7XG4gIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbJHtyYW5rfV0pIHtcbiAgICAgICAgICBpbnQgYVske3Jhbmt9XTtcbiAgICAgICAgICBpbnQgYlske3Jhbmt9XTtcbiAgICAgICAgICAke2RlY2xhcmVDfVxuXG4gICAgICAgICAgY29weVZlYyhpbmRpY2VzLCBhKTtcbiAgICAgICAgICBjb3B5VmVjKGluZGljZXMsIGIpO1xuICAgICAgICAgICR7YnJvYWRjYXN0Q31cblxuICAgICAgICAgIGZsb2F0IHZhbHVlID0gMC4wO1xuICAgICAgICAgIGZvciAoaW50IGs9MDsgazwke3NoYXJlZERpbX07ICsraykge1xuICAgICAgICAgICAgICBhWyR7cmFuayAtIDF9XSA9IGs7XG4gICAgICAgICAgICAgIGJbJHtyYW5rIC0gMn1dID0gaztcbiAgICAgICAgICAgICAgJHtsaW5lfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhbHVlID0gdmFsdWUgKiBhbHBoYTtcbiAgICAgICAgICAke2NhbGN1bGF0ZUN9XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfWA7XG4gIHJldHVybiB7XG4gICAgLi4ubWV0YWRhdGEsXG4gICAgb3V0cHV0OiB7IGRpbXM6IG91dHB1dFNoYXBlLCB0eXBlOiBpbnB1dHNbMF0udHlwZSwgdGV4dHVyZVR5cGU6IFRleHR1cmVUeXBlLnVucGFja2VkIH0sXG4gICAgdmFyaWFibGVzOiBbXG4gICAgICB7IG5hbWU6ICdhbHBoYScsIHR5cGU6ICdmbG9hdCcsIGRhdGE6IGF0dHJpYnV0ZXMuYWxwaGEgfSxcbiAgICAgIHsgbmFtZTogJ2JldGEnLCB0eXBlOiAnZmxvYXQnLCBkYXRhOiBhdHRyaWJ1dGVzLmJldGEgfSxcbiAgICBdLFxuICAgIHNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogVGVuc29yW10sIGF0dHJpYnV0ZXM6IEdlbW1BdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBpcyBtaXNzaW5nJyk7XG4gIH1cbiAgaWYgKGF0dHJpYnV0ZXMuaXNPcHRpb25hbEMgJiYgKGlucHV0cy5sZW5ndGggPCAyIHx8IGlucHV0cy5sZW5ndGggPiAzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWlkIGlucHV0IHNoYXBlLicpO1xuICB9XG4gIGlmICghYXR0cmlidXRlcy5pc09wdGlvbmFsQyAmJiBpbnB1dHMubGVuZ3RoICE9PSAzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdHZW1tIHJlcXVpcmVzIDMgaW5wdXRzJyk7XG4gIH1cblxuICAvLyAnQycgY2FuIGJlIG9mIGRpbWVuc2lvbmFsaXR5IDEgb3IgMiBvbmx5XG4gIGlmIChpbnB1dHMubGVuZ3RoID09PSAzICYmIGlucHV0c1syXS5kaW1zLmxlbmd0aCAhPT0gMSAmJiBpbnB1dHNbMl0uZGltcy5sZW5ndGggIT09IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgc2hhcGUgb2YgQycpO1xuICB9XG5cbiAgaWYgKFxuICAgIChpbnB1dHNbMF0udHlwZSAhPT0gJ2Zsb2F0MzInICYmIGlucHV0c1swXS50eXBlICE9PSAnZmxvYXQ2NCcpIHx8XG4gICAgKGlucHV0c1sxXS50eXBlICE9PSAnZmxvYXQzMicgJiYgaW5wdXRzWzFdLnR5cGUgIT09ICdmbG9hdDY0JykgfHxcbiAgICAoaW5wdXRzLmxlbmd0aCA9PT0gMyAmJiBpbnB1dHNbMl0udHlwZSAhPT0gJ2Zsb2F0MzInICYmIGlucHV0c1syXS50eXBlICE9PSAnZmxvYXQ2NCcpXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCB0eXBlLicpO1xuICB9XG5cbiAgaWYgKGlucHV0c1swXS50eXBlICE9PSBpbnB1dHNbMV0udHlwZSB8fCAoaW5wdXRzLmxlbmd0aCA9PT0gMyAmJiBpbnB1dHNbMF0udHlwZSAhPT0gaW5wdXRzWzJdLnR5cGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCB0eXBlcyBhcmUgbWlzbWF0Y2hlZCcpO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uLy4uLy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQgeyBHcmFwaCB9IGZyb20gJy4uLy4uLy4uL2dyYXBoJztcbmltcG9ydCB7IE9wZXJhdG9ySW1wbGVtZW50YXRpb24sIE9wZXJhdG9ySW5pdGlhbGl6YXRpb24gfSBmcm9tICcuLi8uLi8uLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgVGVuc29yIH0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7IFdlYkdMSW5mZXJlbmNlSGFuZGxlciB9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7IFByb2dyYW1JbmZvLCBQcm9ncmFtSW5mb0xvYWRlciwgUHJvZ3JhbU1ldGFkYXRhLCBUZXh0dXJlVHlwZSB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBJbWFnZVNjYWxlckF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICBzY2FsZTogbnVtYmVyO1xuICBiaWFzOiBudW1iZXJbXTtcbn1cblxuZXhwb3J0IGNvbnN0IGltYWdlU2NhbGVyOiBPcGVyYXRvckltcGxlbWVudGF0aW9uPEltYWdlU2NhbGVyQXR0cmlidXRlcz4gPSAoXG4gIGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXRzOiBUZW5zb3JbXSxcbiAgYXR0cmlidXRlczogSW1hZ2VTY2FsZXJBdHRyaWJ1dGVzLFxuKTogVGVuc29yW10gPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuICBjb25zdCBvdXRwdXQgPSBpbmZlcmVuY2VIYW5kbGVyLnJ1bihjcmVhdGVJbWFnZVNjYWxlclByb2dyYW1JbmZvTG9hZGVyKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0cywgYXR0cmlidXRlcyksIGlucHV0cyk7XG4gIHJldHVybiBbb3V0cHV0XTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUltYWdlU2NhbGVyQXR0cmlidXRlczogT3BlcmF0b3JJbml0aWFsaXphdGlvbjxJbWFnZVNjYWxlckF0dHJpYnV0ZXM+ID0gKFxuICBub2RlOiBHcmFwaC5Ob2RlLFxuKTogSW1hZ2VTY2FsZXJBdHRyaWJ1dGVzID0+IHtcbiAgY29uc3Qgc2NhbGUgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0RmxvYXQoJ3NjYWxlJyk7XG4gIGNvbnN0IGJpYXMgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0RmxvYXRzKCdiaWFzJyk7XG4gIHJldHVybiBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoeyBzY2FsZSwgYmlhcyB9KTtcbn07XG5cbmNvbnN0IGltYWdlU2NhbGVyUHJvZ3JhbU1ldGFkYXRhID0ge1xuICBuYW1lOiAnSW1hZ2VTY2FsZXInLFxuICBpbnB1dE5hbWVzOiBbJ1gnXSxcbiAgaW5wdXRUeXBlczogW1RleHR1cmVUeXBlLnVucGFja2VkXSxcbn07XG5cbmNvbnN0IGNyZWF0ZUltYWdlU2NhbGVyUHJvZ3JhbUluZm8gPSAoXG4gIF9oYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsXG4gIG1ldGFkYXRhOiBQcm9ncmFtTWV0YWRhdGEsXG4gIGlucHV0czogVGVuc29yW10sXG4gIGF0dHJpYnV0ZXM6IEltYWdlU2NhbGVyQXR0cmlidXRlcyxcbik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcy5zbGljZSgpO1xuICBjb25zdCByYW5rID0gb3V0cHV0U2hhcGUubGVuZ3RoO1xuICBjb25zdCBnZXRCaWFzTWV0aG9kID0gY3JlYXRlR2V0Qmlhc01ldGhvZChhdHRyaWJ1dGVzLmJpYXMubGVuZ3RoKTtcbiAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICAgJHtnZXRCaWFzTWV0aG9kfVxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske3Jhbmt9XSkge1xuICAgICAgICByZXR1cm4gX1goaW5kaWNlcykgKiBzY2FsZSArIGdldEJpYXMoYmlhcywgaW5kaWNlc1sxXSk7XG4gICAgICB9YDtcbiAgcmV0dXJuIHtcbiAgICAuLi5tZXRhZGF0YSxcbiAgICBvdXRwdXQ6IHsgZGltczogb3V0cHV0U2hhcGUsIHR5cGU6IGlucHV0c1swXS50eXBlLCB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGUudW5wYWNrZWQgfSxcbiAgICB2YXJpYWJsZXM6IFtcbiAgICAgIHsgbmFtZTogJ2JpYXMnLCB0eXBlOiAnZmxvYXQnLCBhcnJheUxlbmd0aDogYXR0cmlidXRlcy5iaWFzLmxlbmd0aCwgZGF0YTogYXR0cmlidXRlcy5iaWFzIH0sXG4gICAgICB7IG5hbWU6ICdzY2FsZScsIHR5cGU6ICdmbG9hdCcsIGRhdGE6IGF0dHJpYnV0ZXMuc2NhbGUgfSxcbiAgICBdLFxuICAgIHNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG5cbmNvbnN0IGNyZWF0ZUltYWdlU2NhbGVyUHJvZ3JhbUluZm9Mb2FkZXIgPSAoXG4gIGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXRzOiBUZW5zb3JbXSxcbiAgYXR0cmlidXRlczogSW1hZ2VTY2FsZXJBdHRyaWJ1dGVzLFxuKTogUHJvZ3JhbUluZm9Mb2FkZXIgPT4ge1xuICBjb25zdCBtZXRhZGF0YSA9IHsgLi4uaW1hZ2VTY2FsZXJQcm9ncmFtTWV0YWRhdGEsIGNhY2hlSGludDogYXR0cmlidXRlcy5jYWNoZUtleSB9O1xuICByZXR1cm4geyAuLi5tZXRhZGF0YSwgZ2V0OiAoKSA9PiBjcmVhdGVJbWFnZVNjYWxlclByb2dyYW1JbmZvKGhhbmRsZXIsIG1ldGFkYXRhLCBpbnB1dHMsIGF0dHJpYnV0ZXMpIH07XG59O1xuXG5jb25zdCBjcmVhdGVHZXRCaWFzTWV0aG9kID0gKG51bUNoYW5uZWxzOiBudW1iZXIpOiBzdHJpbmcgPT4ge1xuICBjb25zdCBjb2RlTGluZXM6IHN0cmluZ1tdID0gW2BmbG9hdCBnZXRCaWFzKGZsb2F0IGJpYXNbJHtudW1DaGFubmVsc31dLCBpbnQgY2hhbm5lbCkge2BdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNoYW5uZWxzOyArK2kpIHtcbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgY29kZUxpbmVzLnB1c2goJ1xcdCcgKyBgaWYgKGNoYW5uZWwgPT0gJHtpfSkgeyByZXR1cm4gYmlhc1ske2l9XTsgfWApO1xuICAgIH0gZWxzZSBpZiAoaSA9PT0gbnVtQ2hhbm5lbHMgLSAxKSB7XG4gICAgICBjb2RlTGluZXMucHVzaCgnXFx0JyArIGBlbHNlIHsgcmV0dXJuIGJpYXNbJHtpfV07IH1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29kZUxpbmVzLnB1c2goJ1xcdCcgKyBgZWxzZSBpZiAoY2hhbm5lbCA9PSAke2l9KSB7IHJldHVybiBiaWFzWyR7aX1dOyB9YCk7XG4gICAgfVxuICB9XG4gIGNvZGVMaW5lcy5wdXNoKCdcXHQnICsgJ30nKTtcbiAgcmV0dXJuIGNvZGVMaW5lcy5qb2luKCdcXG4nKTtcbn07XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogVGVuc29yW10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2VTY2FsZXIgcmVxdWlyZXMgMSBpbnB1dC4nKTtcbiAgfVxuICBpZiAoaW5wdXRzWzBdLmRpbXMubGVuZ3RoICE9PSA0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0IHNoYXBlLicpO1xuICB9XG4gIGlmIChpbnB1dHNbMF0udHlwZSAhPT0gJ2Zsb2F0MzInICYmIGlucHV0c1swXS50eXBlICE9PSAnZmxvYXQ2NCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgdHlwZS4nKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgR3JhcGggfSBmcm9tICcuLi8uLi8uLi9ncmFwaCc7XG5pbXBvcnQgeyBPcGVyYXRvckltcGxlbWVudGF0aW9uLCBPcGVyYXRvckluaXRpYWxpemF0aW9uIH0gZnJvbSAnLi4vLi4vLi4vb3BlcmF0b3JzJztcbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQgeyBnZXRHbHNsIH0gZnJvbSAnLi4vZ2xzbC1zb3VyY2UnO1xuaW1wb3J0IHsgV2ViR0xJbmZlcmVuY2VIYW5kbGVyIH0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHsgUHJvZ3JhbUluZm8sIFByb2dyYW1JbmZvTG9hZGVyLCBQcm9ncmFtTWV0YWRhdGEsIFRleHR1cmVUeXBlIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgY29uc3QgaW5zdGFuY2VOb3JtYWxpemF0aW9uOiBPcGVyYXRvckltcGxlbWVudGF0aW9uPG51bWJlcj4gPSAoXG4gIGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXRzOiBUZW5zb3JbXSxcbiAgZXBzaWxvbjogbnVtYmVyLFxuKTogVGVuc29yW10gPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuXG4gIGNvbnN0IG1lYW5BbmRWYXJpYW5jZSA9IGluZmVyZW5jZUhhbmRsZXIucnVuKGNyZWF0ZU1lYW5BbmRWYXJpYW5jZVByb2dyYW1JbmZvTG9hZGVyKGlucHV0c1swXSksIGlucHV0cyk7XG4gIGNvbnN0IG91dHB1dCA9IGluZmVyZW5jZUhhbmRsZXIucnVuKFxuICAgIGNyZWF0ZUNvbXB1dGVPdXRwdXRQcm9ncmFtSW5mb0xvYWRlcihpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHNbMF0sIGVwc2lsb24sIG1lYW5BbmRWYXJpYW5jZS5kaW1zKSxcbiAgICBbaW5wdXRzWzBdLCBtZWFuQW5kVmFyaWFuY2UsIGlucHV0c1sxXSwgaW5wdXRzWzJdXSxcbiAgKTtcbiAgcmV0dXJuIFtvdXRwdXRdO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlSW5zdGFuY2VOb3JtYWxpemF0aW9uQXR0cmlidXRlczogT3BlcmF0b3JJbml0aWFsaXphdGlvbjxudW1iZXI+ID0gKG5vZGU6IEdyYXBoLk5vZGUpOiBudW1iZXIgPT5cbiAgbm9kZS5hdHRyaWJ1dGVzLmdldEZsb2F0KCdlcHNpbG9uJywgMWUtNSk7XG5cbmNvbnN0IG1lYW5BbmRWYXJpYW5jZVByb2dyYW1NZXRhZGF0YSA9IHtcbiAgbmFtZTogJ0luc3RhbmNlTm9ybWFsaXphdGlvbl9NZWFuQW5kVmFyaWFuY2UnLFxuICBpbnB1dE5hbWVzOiBbJ1gnXSxcbiAgaW5wdXRUeXBlczogW1RleHR1cmVUeXBlLnVucGFja2VkXSxcbn07XG5cbmNvbnN0IGNyZWF0ZU1lYW5BbmRWYXJpYW5jZVByb2dyYW1JbmZvID0gKG1ldGFkYXRhOiBQcm9ncmFtTWV0YWRhdGEsIGlucHV0OiBUZW5zb3IpOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IHhEaW1zID0gaW5wdXQuZGltcy5zbGljZSgpO1xuICBjb25zdCBjaGFubmVsID0geERpbXNbMV07XG4gIGNvbnN0IGNoYW5uZWxTaXplID0geERpbXNbMl0gKiB4RGltc1szXTtcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBbeERpbXNbMF0sIGNoYW5uZWxdO1xuXG4gIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgIHZlYzQgcHJvY2VzcyhpbnRbMl0gaW5kaWNlcykge1xuICAgICAgICB2ZWM0IHYgPSB2ZWM0KDAuMCk7XG4gICAgICAgIGludCBhWzRdO1xuICAgICAgICBhWzBdID0gaW5kaWNlc1swXTtcbiAgICAgICAgYVsxXSA9IGluZGljZXNbMV07XG4gICAgICAgIGZsb2F0IHRlbXAgPSAwLjA7XG4gICAgICAgIGZvcihpbnQgYTI9MDsgYTI8JHt4RGltc1syXX07IGEyKyspIHtcbiAgICAgICAgICBhWzJdID0gYTI7XG4gICAgICAgICAgZm9yKGludCBhMz0wOyBhMzwke3hEaW1zWzNdfTsgYTMrKykge1xuICAgICAgICAgICAgYVszXSA9IGEzO1xuICAgICAgICAgICAgZmxvYXQgeCA9IF9YKGEpO1xuICAgICAgICAgICAgdGVtcCArPSB4O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmbG9hdCBtZWFuID0gdGVtcCAvIGZsb2F0KCR7Y2hhbm5lbFNpemV9KTtcbiAgICAgICAgdGVtcCA9IDAuMDtcbiAgICAgICAgZm9yKGludCBhMj0wOyBhMjwke3hEaW1zWzJdfTsgYTIrKykge1xuICAgICAgICAgIGFbMl0gPSBhMjtcbiAgICAgICAgICBmb3IoaW50IGEzPTA7IGEzPCR7eERpbXNbM119OyBhMysrKSB7XG4gICAgICAgICAgICBhWzNdID0gYTM7XG4gICAgICAgICAgICBmbG9hdCB4ID0gX1goYSk7XG4gICAgICAgICAgICB0ZW1wICs9ICh4IC0gbWVhbikgKiAoeCAtIG1lYW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2LnIgPSBtZWFuO1xuICAgICAgICB2LmcgPSB0ZW1wIC8gZmxvYXQoJHtjaGFubmVsU2l6ZX0pO1xuXG4gICAgICAgIHJldHVybiB2O1xuICAgICAgfWA7XG4gIHJldHVybiB7XG4gICAgLi4ubWV0YWRhdGEsXG4gICAgb3V0cHV0OiB7IGRpbXM6IG91dHB1dFNoYXBlLCB0eXBlOiBpbnB1dC50eXBlLCB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGUucGFja2VkTGFzdERpbWVuc2lvbiB9LFxuICAgIHNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG5cbmNvbnN0IGNyZWF0ZU1lYW5BbmRWYXJpYW5jZVByb2dyYW1JbmZvTG9hZGVyID0gKGlucHV0OiBUZW5zb3IpOiBQcm9ncmFtSW5mb0xvYWRlciA9PiAoe1xuICAuLi5tZWFuQW5kVmFyaWFuY2VQcm9ncmFtTWV0YWRhdGEsXG4gIGdldDogKCkgPT4gY3JlYXRlTWVhbkFuZFZhcmlhbmNlUHJvZ3JhbUluZm8obWVhbkFuZFZhcmlhbmNlUHJvZ3JhbU1ldGFkYXRhLCBpbnB1dCksXG59KTtcblxuY29uc3QgY29tcHV0ZU91dHB1dFByb2dyYW1NZXRhZGF0YSA9IHtcbiAgbmFtZTogJ0luc3RhbmNlTm9ybWFsaXphdGlvbl9Db21wdXRlT3V0cHV0JyxcbiAgaW5wdXROYW1lczogWydYJywgJ01lYW5BbmRWYXJpYW5jZScsICdTY2FsZScsICdCJ10sXG4gIGlucHV0VHlwZXM6IFtUZXh0dXJlVHlwZS51bnBhY2tlZCwgVGV4dHVyZVR5cGUucGFja2VkTGFzdERpbWVuc2lvbiwgVGV4dHVyZVR5cGUudW5wYWNrZWQsIFRleHR1cmVUeXBlLnVucGFja2VkXSxcbn07XG5cbmNvbnN0IGNyZWF0ZUNvbXB1dGVPdXRwdXRQcm9ncmFtSW5mbyA9IChcbiAgaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBtZXRhZGF0YTogUHJvZ3JhbU1ldGFkYXRhLFxuICBpbnB1dDogVGVuc29yLFxuICBlcHNpbG9uOiBudW1iZXIsXG4gIG1lYW5BbmRWYXJpYW5jZVNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgZ2xzbCA9IGdldEdsc2woaW5mZXJlbmNlSGFuZGxlci5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pO1xuICBjb25zdCBbdGV4dHVyZVdpZHRoLCB0ZXh0dXJlSGVpZ2h0XSA9IGluZmVyZW5jZUhhbmRsZXIuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0KFxuICAgIG1lYW5BbmRWYXJpYW5jZVNoYXBlLFxuICAgIFRleHR1cmVUeXBlLnBhY2tlZExhc3REaW1lbnNpb24sXG4gICk7XG4gIGNvbnN0IFttZWFuQW5kVmFyaWFuY2VXaWR0aCwgbWVhbkFuZFZhcmlhbmNlSGVpZ2h0XSA9IFt0ZXh0dXJlV2lkdGggLyA0LCB0ZXh0dXJlSGVpZ2h0XTtcbiAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICAgdmVjNCBnZXRfTWVhbkFuZFZhcmlhbmNlKGludFsyXSBtdikge1xuICAgICAgICBpbnQgb2Zmc2V0ID0gaW5kaWNlc1RvT2Zmc2V0X01lYW5BbmRWYXJpYW5jZShtdik7XG4gICAgICAgIHZlYzIgY29vcmRzID0gb2Zmc2V0VG9Db29yZHMob2Zmc2V0LCAke21lYW5BbmRWYXJpYW5jZVdpZHRofSwgJHttZWFuQW5kVmFyaWFuY2VIZWlnaHR9KTtcbiAgICAgICAgcmV0dXJuICR7Z2xzbC50ZXh0dXJlMkR9KE1lYW5BbmRWYXJpYW5jZSwgY29vcmRzKTtcbiAgICAgIH1cblxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnRbNF0gaW5kaWNlcykge1xuICAgICAgICBpbnQgbXZbMl07XG4gICAgICAgIG12WzBdID0gaW5kaWNlc1swXTtcbiAgICAgICAgbXZbMV0gPSBpbmRpY2VzWzFdO1xuICAgICAgICB2ZWM0IG1lYW5fYW5kX3ZhcmlhbmNlID0gZ2V0X01lYW5BbmRWYXJpYW5jZShtdik7XG4gICAgICAgIGZsb2F0IG1lYW4gPSBtZWFuX2FuZF92YXJpYW5jZS5yO1xuICAgICAgICBmbG9hdCB2YXJpYW5jZSA9IG1lYW5fYW5kX3ZhcmlhbmNlLmc7XG5cbiAgICAgICAgaW50IHNiWzFdO1xuICAgICAgICBzYlswXSA9IGluZGljZXNbMV07XG4gICAgICAgIGZsb2F0IHNjYWxlID0gX1NjYWxlKHNiKTtcbiAgICAgICAgZmxvYXQgYiA9IF9CKHNiKTtcblxuICAgICAgICByZXR1cm4gc2NhbGUgKiAoX1goaW5kaWNlcykgLSBtZWFuKSAvIHNxcnQodmFyaWFuY2UgKyBlcHNpbG9uKSArIGI7XG4gICAgICB9YDtcbiAgcmV0dXJuIHtcbiAgICAuLi5tZXRhZGF0YSxcbiAgICBvdXRwdXQ6IHsgZGltczogaW5wdXQuZGltcywgdHlwZTogaW5wdXQudHlwZSwgdGV4dHVyZVR5cGU6IFRleHR1cmVUeXBlLnVucGFja2VkIH0sXG4gICAgdmFyaWFibGVzOiBbeyBuYW1lOiAnZXBzaWxvbicsIHR5cGU6ICdmbG9hdCcsIGRhdGE6IGVwc2lsb24gfV0sXG4gICAgc2hhZGVyU291cmNlLFxuICB9O1xufTtcblxuY29uc3QgY3JlYXRlQ29tcHV0ZU91dHB1dFByb2dyYW1JbmZvTG9hZGVyID0gKFxuICBpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsXG4gIGlucHV0OiBUZW5zb3IsXG4gIGVwc2lsb246IG51bWJlcixcbiAgbWVhbkFuZFZhcmlhbmNlU2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuKTogUHJvZ3JhbUluZm9Mb2FkZXIgPT4ge1xuICBjb25zdCBtZXRhZGF0YSA9IHsgLi4uY29tcHV0ZU91dHB1dFByb2dyYW1NZXRhZGF0YSwgY2FjaGVIaW50OiBgJHtlcHNpbG9ufWAgfTtcbiAgcmV0dXJuIHtcbiAgICAuLi5tZXRhZGF0YSxcbiAgICBnZXQ6ICgpID0+IGNyZWF0ZUNvbXB1dGVPdXRwdXRQcm9ncmFtSW5mbyhpbmZlcmVuY2VIYW5kbGVyLCBtZXRhZGF0YSwgaW5wdXQsIGVwc2lsb24sIG1lYW5BbmRWYXJpYW5jZVNoYXBlKSxcbiAgfTtcbn07XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogVGVuc29yW10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5zdGFuY2VOb3JtYWxpemF0aW9uIHJlcXVpcmVzIDMgaW5wdXRzLicpO1xuICB9XG5cbiAgY29uc3QgWCA9IGlucHV0c1swXTtcbiAgY29uc3Qgc2NhbGUgPSBpbnB1dHNbMV07XG4gIGNvbnN0IEIgPSBpbnB1dHNbMl07XG5cbiAgLy8gaW5wdXQgc2hvdWxkIGF0IGxlYXN0IGhhdmUgdGhyZWUgZGltZW5zaW9ucyAtIE4sQyxkaW0xLC4uLixkaW1uXG4gIC8vIG90aGVyIGlucHV0cyBjYW4gaGF2ZSBvbmx5IG9uZSBkaW1lbnNpb25zXG4gIGlmIChYLmRpbXMubGVuZ3RoIDwgMyB8fCBzY2FsZS5kaW1zLmxlbmd0aCAhPT0gMSB8fCBCLmRpbXMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0IHNoYXBlLicpO1xuICB9XG4gIGlmIChzY2FsZS5kaW1zWzBdICE9PSBYLmRpbXNbMV0gfHwgQi5kaW1zWzBdICE9PSBYLmRpbXNbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IHNoYXBlcyBhcmUgbWlzbWF0Y2hlZC4nKTtcbiAgfVxuICBpZiAoXG4gICAgKFgudHlwZSAhPT0gJ2Zsb2F0MzInICYmIFgudHlwZSAhPT0gJ2Zsb2F0NjQnKSB8fFxuICAgIChzY2FsZS50eXBlICE9PSAnZmxvYXQzMicgJiYgc2NhbGUudHlwZSAhPT0gJ2Zsb2F0NjQnKSB8fFxuICAgIChCLnR5cGUgIT09ICdmbG9hdDMyJyAmJiBCLnR5cGUgIT09ICdmbG9hdDY0JylcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0IHR5cGUuJyk7XG4gIH1cbiAgaWYgKGlucHV0c1swXS5kaW1zLmxlbmd0aCAhPT0gNCkge1xuICAgIHRocm93IG5ldyBFcnJvcignT25seSBzdXBwb3J0IDQtRCBpbnB1dCBzaGFwZS4nKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgQXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi8uLi8uLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHsgR3JhcGggfSBmcm9tICcuLi8uLi8uLi9ncmFwaCc7XG5pbXBvcnQgeyBPcGVyYXRvckltcGxlbWVudGF0aW9uLCBPcGVyYXRvckluaXRpYWxpemF0aW9uIH0gZnJvbSAnLi4vLi4vLi4vb3BlcmF0b3JzJztcbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQgeyBXZWJHTEluZmVyZW5jZUhhbmRsZXIgfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQgeyBQcm9ncmFtSW5mbywgUHJvZ3JhbUluZm9Mb2FkZXIsIFRleHR1cmVUeXBlIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIExybkF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICBhbHBoYTogbnVtYmVyO1xuICBiZXRhOiBudW1iZXI7XG4gIGJpYXM6IG51bWJlcjtcbiAgc2l6ZTogbnVtYmVyO1xufVxuXG5leHBvcnQgY29uc3QgbHJuOiBPcGVyYXRvckltcGxlbWVudGF0aW9uPExybkF0dHJpYnV0ZXM+ID0gKFxuICBpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsXG4gIGlucHV0czogVGVuc29yW10sXG4gIGF0dHJpYnV0ZXM6IExybkF0dHJpYnV0ZXMsXG4pOiBUZW5zb3JbXSA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGlucHV0cyk7XG5cbiAgLy8gaWYgKGluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5wYWNrKSB7XG4gIC8vICAgcmV0dXJuIFtpbmZlcmVuY2VIYW5kbGVyLnJ1bihjcmVhdGVQYWNrZWRMcm5Qcm9ncmFtSW5mb0xvYWRlcihpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMsIGF0dHJpYnV0ZXMpLFxuICAvLyAgIGlucHV0cyldO1xuICAvLyB9IGVsc2Uge1xuICByZXR1cm4gW2luZmVyZW5jZUhhbmRsZXIucnVuKGNyZWF0ZUxyblByb2dyYW1JbmZvTG9hZGVyKGlucHV0cywgYXR0cmlidXRlcyksIGlucHV0cyldO1xuICAvL31cbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUxybkF0dHJpYnV0ZXM6IE9wZXJhdG9ySW5pdGlhbGl6YXRpb248THJuQXR0cmlidXRlcz4gPSAobm9kZTogR3JhcGguTm9kZSk6IExybkF0dHJpYnV0ZXMgPT4ge1xuICBjb25zdCBhbHBoYSA9IG5vZGUuYXR0cmlidXRlcy5nZXRGbG9hdCgnYWxwaGEnLCAwLjAwMDEpO1xuICBjb25zdCBiZXRhID0gbm9kZS5hdHRyaWJ1dGVzLmdldEZsb2F0KCdiZXRhJywgMC43NSk7XG4gIGNvbnN0IGJpYXMgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0RmxvYXQoJ2JpYXMnLCAxLjApO1xuICBjb25zdCBzaXplID0gbm9kZS5hdHRyaWJ1dGVzLmdldEludCgnc2l6ZScpO1xuXG4gIHJldHVybiBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoeyBhbHBoYSwgYmV0YSwgYmlhcywgc2l6ZSB9KTtcbn07XG5cbmNvbnN0IGxyblByb2dyYW1NZXRhZGF0YSA9IHtcbiAgbmFtZTogJ0xSTicsXG4gIGlucHV0TmFtZXM6IFsnWCddLFxuICBpbnB1dFR5cGVzOiBbVGV4dHVyZVR5cGUudW5wYWNrZWRdLFxufTtcblxuZnVuY3Rpb24gY3JlYXRlTHJuUHJvZ3JhbUluZm8oaW5wdXRzOiBUZW5zb3JbXSwgYXR0cmlidXRlczogTHJuQXR0cmlidXRlcyk6IFByb2dyYW1JbmZvIHtcbiAgY29uc3QgQyA9IGlucHV0c1swXS5kaW1zWzFdO1xuICBjb25zdCByYW5rID0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoO1xuICBjb25zdCBmcm9tID0gLU1hdGguZmxvb3IoKGF0dHJpYnV0ZXMuc2l6ZSAtIDEpIC8gMik7XG4gIGNvbnN0IHRvID0gTWF0aC5jZWlsKChhdHRyaWJ1dGVzLnNpemUgLSAxKSAvIDIpO1xuICBjb25zdCBhbHBoYSA9IGBmbG9hdCgke2F0dHJpYnV0ZXMuYWxwaGF9KSAvIGZsb2F0KCR7YXR0cmlidXRlcy5zaXplfSlgO1xuICBjb25zdCBiaWFzID0gYGZsb2F0KCR7YXR0cmlidXRlcy5iaWFzfSlgO1xuICBjb25zdCBiZXRhID0gYGZsb2F0KCR7YXR0cmlidXRlcy5iZXRhfSlgO1xuXG4gIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICBmbG9hdCBwcm9jZXNzKGludCBpbmRpY2VzWyR7cmFua31dKSB7XG4gICAgICAgIGludCBjID0gaW5kaWNlc1sxXTtcbiAgICAgICAgZmxvYXQgeCA9IF9YKGluZGljZXMpO1xuICAgICAgICBmbG9hdCBzcXVhcmVfc3VtID0gMC4wO1xuXG4gICAgICAgIGZvciAoaW50IGkgPSAke2Zyb219OyBpIDw9ICR7dG99OyBpKyspIHtcbiAgICAgICAgICBpbnQgaWR4ID0gYyArIGk7XG4gICAgICAgICAgaWYgKGMgPj0gMCAmJiBjIDwgJHtDfSkge1xuICAgICAgICAgICAgaW5kaWNlc1sxXSA9IGlkeDtcbiAgICAgICAgICAgIGZsb2F0IGogPSBfWChpbmRpY2VzKTtcbiAgICAgICAgICAgIHNxdWFyZV9zdW0gKz0gaiAqIGo7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4IC8gcG93KCR7Ymlhc30gKyAke2FscGhhfSAqIHNxdWFyZV9zdW0sICR7YmV0YX0pO1xuICAgIH1gO1xuICByZXR1cm4ge1xuICAgIC4uLmxyblByb2dyYW1NZXRhZGF0YSxcbiAgICBjYWNoZUhpbnQ6IGF0dHJpYnV0ZXMuY2FjaGVLZXksXG4gICAgb3V0cHV0OiB7IGRpbXM6IGlucHV0c1swXS5kaW1zLCB0eXBlOiBpbnB1dHNbMF0udHlwZSwgdGV4dHVyZVR5cGU6IFRleHR1cmVUeXBlLnVucGFja2VkIH0sXG4gICAgc2hhZGVyU291cmNlLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTHJuUHJvZ3JhbUluZm9Mb2FkZXIoaW5wdXRzOiBUZW5zb3JbXSwgYXR0cmlidXRlczogTHJuQXR0cmlidXRlcyk6IFByb2dyYW1JbmZvTG9hZGVyIHtcbiAgcmV0dXJuIHsgLi4ubHJuUHJvZ3JhbU1ldGFkYXRhLCBjYWNoZUhpbnQ6IGF0dHJpYnV0ZXMuY2FjaGVLZXksIGdldDogKCkgPT4gY3JlYXRlTHJuUHJvZ3JhbUluZm8oaW5wdXRzLCBhdHRyaWJ1dGVzKSB9O1xufVxuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IFRlbnNvcltdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0xSTiByZXF1aXJlcyAxIGlucHV0LicpO1xuICB9XG4gIGlmIChpbnB1dHNbMF0uZGltcy5sZW5ndGggIT09IDQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2N1cnJlbnRseSBvbmx5IHN1cHBvcnQgTFJOIGZvciBpbnB1dCB3aXRoIFwiTkNIV1wiIGZvcm1hdCcpO1xuICB9XG4gIGlmIChpbnB1dHNbMF0udHlwZSAhPT0gJ2Zsb2F0MzInKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnB1dCBzaG91bGQgYmUgZmxvYXQgdHlwZScpO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uLy4uLy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQgeyBHcmFwaCB9IGZyb20gJy4uLy4uLy4uL2dyYXBoJztcbmltcG9ydCB7IE9wZXJhdG9ySW1wbGVtZW50YXRpb24sIE9wZXJhdG9ySW5pdGlhbGl6YXRpb24gfSBmcm9tICcuLi8uLi8uLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgVGVuc29yIH0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgZ2V0R2xzbCwgR2xzbCB9IGZyb20gJy4uL2dsc2wtc291cmNlJztcbmltcG9ydCB7IFdlYkdMSW5mZXJlbmNlSGFuZGxlciB9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7IFByb2dyYW1JbmZvLCBUZXh0dXJlVHlwZSB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBQYWRBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgcmVhZG9ubHkgbW9kZTogc3RyaW5nO1xuICByZWFkb25seSBwYWRzOiBudW1iZXJbXTtcbiAgcmVhZG9ubHkgdmFsdWU6IG51bWJlcjtcbn1cblxuY29uc3QgcGFkUHJvZ3JhbU1ldGFkYXRhID0ge1xuICBuYW1lOiAnUGFkJyxcbiAgaW5wdXROYW1lczogWydBJ10sXG4gIGlucHV0VHlwZXM6IFtUZXh0dXJlVHlwZS51bnBhY2tlZF0sXG59O1xuXG5leHBvcnQgY29uc3QgcGFkVjI6IE9wZXJhdG9ySW1wbGVtZW50YXRpb248UGFkQXR0cmlidXRlcz4gPSAoXG4gIGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXRzOiBUZW5zb3JbXSxcbiAgYXR0cmlidXRlczogUGFkQXR0cmlidXRlcyxcbik6IFRlbnNvcltdID0+IHtcbiAgdmFsaWRhdGVJbnB1dHNWMihpbnB1dHMpO1xuICBjb25zdCBvdXRwdXQgPSBpbmZlcmVuY2VIYW5kbGVyLnJ1bihcbiAgICB7XG4gICAgICAuLi5wYWRQcm9ncmFtTWV0YWRhdGEsXG4gICAgICBjYWNoZUhpbnQ6IGF0dHJpYnV0ZXMuY2FjaGVLZXksXG4gICAgICBnZXQ6ICgpID0+IGNyZWF0ZVBhZFByb2dyYW1JbmZvKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0c1swXSwgYXR0cmlidXRlcyksXG4gICAgfSxcbiAgICBpbnB1dHMsXG4gICk7XG4gIHJldHVybiBbb3V0cHV0XTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZVBhZEF0dHJpYnV0ZXNWMjogT3BlcmF0b3JJbml0aWFsaXphdGlvbjxQYWRBdHRyaWJ1dGVzPiA9IChub2RlOiBHcmFwaC5Ob2RlKTogUGFkQXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IG1vZGUgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0U3RyaW5nKCdtb2RlJywgJ2NvbnN0YW50Jyk7XG4gIGNvbnN0IHZhbHVlID0gbm9kZS5hdHRyaWJ1dGVzLmdldEZsb2F0KCd2YWx1ZScsIDAuMCk7XG4gIGNvbnN0IHBhZHMgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0SW50cygncGFkcycpO1xuICByZXR1cm4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHsgbW9kZSwgdmFsdWUsIHBhZHMgfSk7XG59O1xuXG5leHBvcnQgY29uc3QgcGFkVjExOiBPcGVyYXRvckltcGxlbWVudGF0aW9uPHN0cmluZz4gPSAoXG4gIGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXRzOiBUZW5zb3JbXSxcbiAgbW9kZTogc3RyaW5nLFxuKTogVGVuc29yW10gPT4ge1xuICB2YWxpZGF0ZUlucHV0c1YxMShpbnB1dHMpO1xuICBjb25zdCBhdHRydWJ1dGVzID0gZ2VuZXJhdGVQYWRBdHRyaWJ1dGVzRnJvbUlucHV0cyhpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMsIG1vZGUpO1xuICByZXR1cm4gcGFkVjIoaW5mZXJlbmNlSGFuZGxlciwgW2lucHV0c1swXV0sIGF0dHJ1YnV0ZXMpO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlUGFkQXR0cmlidXRlc1YxMTogT3BlcmF0b3JJbml0aWFsaXphdGlvbjxzdHJpbmc+ID0gKG5vZGU6IEdyYXBoLk5vZGUpOiBzdHJpbmcgPT5cbiAgbm9kZS5hdHRyaWJ1dGVzLmdldFN0cmluZygnbW9kZScsICdjb25zdGFudCcpO1xuXG5jb25zdCBnZW5lcmF0ZVBhZEF0dHJpYnV0ZXNGcm9tSW5wdXRzID0gKFxuICBpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsXG4gIGlucHV0czogVGVuc29yW10sXG4gIG1vZGU6IHN0cmluZyxcbik6IFBhZEF0dHJpYnV0ZXMgPT4ge1xuICBpZiAoXG4gICAgIWluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5pc0luaXRpYWxpemVyKGlucHV0c1sxXS5kYXRhSWQpIHx8XG4gICAgKGlucHV0cy5sZW5ndGggPj0gMyAmJiAhaW5mZXJlbmNlSGFuZGxlci5zZXNzaW9uLmlzSW5pdGlhbGl6ZXIoaW5wdXRzWzJdLmRhdGFJZCkpXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcignZHluYW1pYyBwYWQgYXR0cmlidXRlcyBhcmUgbm90IGFsbG93ZWQnKTtcbiAgfVxuXG4gIGNvbnN0IHBhZHMgPSBBcnJheS5mcm9tKGlucHV0c1sxXS5pbnRlZ2VyRGF0YSk7XG4gIGNvbnN0IHZhbHVlID0gaW5wdXRzLmxlbmd0aCA+PSAzID8gaW5wdXRzWzJdLmZsb2F0RGF0YVswXSA6IDAuMDtcblxuICByZXR1cm4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHsgbW9kZSwgcGFkcywgdmFsdWUgfSk7XG59O1xuXG5jb25zdCBjcmVhdGVQYWRQcm9ncmFtSW5mbyA9IChcbiAgaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBpbnB1dDogVGVuc29yLFxuICBhdHRyaWJ1dGVzOiBQYWRBdHRyaWJ1dGVzLFxuKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IFNoYXBlVXRpbC5wYWRTaGFwZShpbnB1dC5kaW1zLnNsaWNlKCksIGF0dHJpYnV0ZXMucGFkcyk7XG4gIGNvbnN0IHJhbmsgPSBvdXRwdXRTaGFwZS5sZW5ndGg7XG4gIGNvbnN0IHBhZEZ1bmN0aW9uID0gZ2V0UGFkRnVuY3Rpb24oaW5mZXJlbmNlSGFuZGxlciwgaW5wdXQsIGF0dHJpYnV0ZXMpO1xuICBjb25zdCBzaGFkZXJTb3VyY2UgPSBgXG4gICAgICAke3BhZEZ1bmN0aW9ufVxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnRbJHtyYW5rfV0gaW5kaWNlcykge1xuICAgICAgICAgIHJldHVybiBwYWRBKGluZGljZXMpO1xuICAgICAgfWA7XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ1BhZCcsXG4gICAgaW5wdXROYW1lczogWydBJ10sXG4gICAgaW5wdXRUeXBlczogW1RleHR1cmVUeXBlLnVucGFja2VkXSxcbiAgICBvdXRwdXQ6IHsgZGltczogb3V0cHV0U2hhcGUsIHR5cGU6IGlucHV0LnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS51bnBhY2tlZCB9LFxuICAgIHNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzVjIgPSAoaW5wdXRzOiBUZW5zb3JbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQYWQgcmVxdWlyZXMgMSBpbnB1dCcpO1xuICB9XG4gIGlmIChpbnB1dHNbMF0udHlwZSAhPT0gJ2Zsb2F0MzInICYmIGlucHV0c1swXS50eXBlICE9PSAnZmxvYXQ2NCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgdHlwZS4nKTtcbiAgfVxufTtcblxuY29uc3QgdmFsaWRhdGVJbnB1dHNWMTEgPSAoaW5wdXRzOiBUZW5zb3JbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCAoaW5wdXRzLmxlbmd0aCAhPT0gMiAmJiBpbnB1dHMubGVuZ3RoICE9PSAzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUGFkIHJlcXVpcmVzIDIgb3IgMyBpbnB1dHMnKTtcbiAgfVxuICBpZiAoaW5wdXRzWzFdLnR5cGUgIT09ICdpbnQzMicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgdHlwZS4nKTtcbiAgfVxuICBpZiAoaW5wdXRzLmxlbmd0aCA+PSAzICYmIGlucHV0c1syXS50eXBlID09PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCB0eXBlLicpO1xuICB9XG59O1xuXG5jb25zdCBnZXRQYWRGdW5jdGlvbiA9IChpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0OiBUZW5zb3IsIGF0dHJpYnV0ZXM6IFBhZEF0dHJpYnV0ZXMpOiBzdHJpbmcgPT4ge1xuICBjb25zdCBnbHNsID0gZ2V0R2xzbChpbmZlcmVuY2VIYW5kbGVyLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbik7XG4gIGNvbnN0IFt3aWR0aCwgaGVpZ2h0XSA9IGluZmVyZW5jZUhhbmRsZXIuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0KGlucHV0LmRpbXMsIFRleHR1cmVUeXBlLnVucGFja2VkKTtcbiAgY29uc3Qgc3RyaWRlcyA9IFNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyhpbnB1dC5kaW1zKTtcblxuICBzd2l0Y2ggKGF0dHJpYnV0ZXMubW9kZSkge1xuICAgIGNhc2UgJ2NvbnN0YW50JzpcbiAgICAgIHJldHVybiBnZXRQYWRDb25zdGFudChnbHNsLCBpbnB1dC5kaW1zLCBzdHJpZGVzLCB3aWR0aCwgaGVpZ2h0LCBhdHRyaWJ1dGVzLnBhZHMsIGF0dHJpYnV0ZXMudmFsdWUpO1xuICAgIGNhc2UgJ3JlZmxlY3QnOlxuICAgICAgcmV0dXJuIGdldFBhZFJlZmxlY3QoZ2xzbCwgaW5wdXQuZGltcywgc3RyaWRlcywgd2lkdGgsIGhlaWdodCwgYXR0cmlidXRlcy5wYWRzKTtcbiAgICBjYXNlICdlZGdlJzpcbiAgICAgIHJldHVybiBnZXRQYWRFZGdlKGdsc2wsIGlucHV0LmRpbXMsIHN0cmlkZXMsIHdpZHRoLCBoZWlnaHQsIGF0dHJpYnV0ZXMucGFkcyk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtb2RlJyk7XG4gIH1cbn07XG5cbmNvbnN0IGdldFBhZENvbnN0YW50ID0gKFxuICBnbHNsOiBHbHNsLFxuICBzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gIHN0cmlkZXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICB3aWR0aDogbnVtYmVyLFxuICBoZWlnaHQ6IG51bWJlcixcbiAgcGFkczogbnVtYmVyW10sXG4gIHZhbHVlOiBudW1iZXIsXG4pOiBzdHJpbmcgPT4ge1xuICBjb25zdCByYW5rID0gc2hhcGUubGVuZ3RoO1xuICBsZXQgYmxvY2sgPSAnJztcbiAgZm9yIChsZXQgaSA9IHJhbmsgLSAxOyBpID49IDA7IC0taSkge1xuICAgIGJsb2NrICs9IGBcbiAgICAgICAgayA9IG1bJHtpfV0gLSAke3BhZHNbaV19O1xuICAgICAgICBpZiAoayA8IDApICByZXR1cm4gY29uc3RhbnQ7XG4gICAgICAgIGlmIChrID49ICR7c2hhcGVbaV19KSByZXR1cm4gY29uc3RhbnQ7XG4gICAgICAgIG9mZnNldCArPSBrICogJHtzdHJpZGVzW2ldfTtcbiAgICAgICAgYDtcbiAgfVxuICByZXR1cm4gYFxuICAgICAgZmxvYXQgcGFkQShpbnQgbVske3Jhbmt9XSkge1xuICAgICAgICBjb25zdCBmbG9hdCBjb25zdGFudCA9IGZsb2F0KCR7dmFsdWV9KTtcbiAgICAgICAgaW50IG9mZnNldCA9IDA7XG4gICAgICAgIGludCBrID0gMDtcbiAgICAgICAgJHtibG9ja31cbiAgICAgICAgdmVjMiBjb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhvZmZzZXQsICR7d2lkdGh9LCAke2hlaWdodH0pO1xuICAgICAgICBmbG9hdCB2YWx1ZSA9IGdldENvbG9yQXNGbG9hdCgke2dsc2wudGV4dHVyZTJEfShBLCBjb29yZHMpKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgYDtcbn07XG5cbmNvbnN0IGdldFBhZFJlZmxlY3QgPSAoXG4gIGdsc2w6IEdsc2wsXG4gIHNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgc3RyaWRlczogcmVhZG9ubHkgbnVtYmVyW10sXG4gIHdpZHRoOiBudW1iZXIsXG4gIGhlaWdodDogbnVtYmVyLFxuICBwYWRzOiBudW1iZXJbXSxcbik6IHN0cmluZyA9PiB7XG4gIGNvbnN0IHJhbmsgPSBzaGFwZS5sZW5ndGg7XG5cbiAgbGV0IGJsb2NrID0gJyc7XG4gIGZvciAobGV0IGkgPSByYW5rIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICBibG9jayArPSBgXG4gICAgICAgIGsgPSBtWyR7aX1dIC0gJHtwYWRzW2ldfTtcbiAgICAgICAgaWYgKGsgPCAwKSB7IGsgPSAtazsgfVxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgaW50IF8ybl8xID0gJHsyICogKHNoYXBlW2ldIC0gMSl9O1xuICAgICAgICAgIGsgPSBpbnQoIG1vZCggZmxvYXQoayksIGZsb2F0KF8ybl8xKSApICkgO1xuICAgICAgICAgIGlmKGsgPj0gJHtzaGFwZVtpXX0pIHsgayA9IF8ybl8xIC0gazsgfVxuICAgICAgICB9XG4gICAgICAgIG9mZnNldCArPSBrICogJHtzdHJpZGVzW2ldfTtcbiAgICAgICAgYDtcbiAgfVxuICByZXR1cm4gYFxuICAgICAgZmxvYXQgcGFkQShpbnQgbVske3Jhbmt9XSkge1xuICAgICAgICBpbnQgb2Zmc2V0ID0gMDtcbiAgICAgICAgaW50IGsgPSAwO1xuICAgICAgICAke2Jsb2NrfVxuICAgICAgICB2ZWMyIGNvb3JkcyA9IG9mZnNldFRvQ29vcmRzKG9mZnNldCwgJHt3aWR0aH0sICR7aGVpZ2h0fSk7XG4gICAgICAgIGZsb2F0IHZhbHVlID0gZ2V0Q29sb3JBc0Zsb2F0KCR7Z2xzbC50ZXh0dXJlMkR9KEEsIGNvb3JkcykpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBgO1xufTtcblxuY29uc3QgZ2V0UGFkRWRnZSA9IChcbiAgZ2xzbDogR2xzbCxcbiAgc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICBzdHJpZGVzOiByZWFkb25seSBudW1iZXJbXSxcbiAgd2lkdGg6IG51bWJlcixcbiAgaGVpZ2h0OiBudW1iZXIsXG4gIHBhZHM6IG51bWJlcltdLFxuKTogc3RyaW5nID0+IHtcbiAgY29uc3QgcmFuayA9IHNoYXBlLmxlbmd0aDtcblxuICBsZXQgYmxvY2sgPSAnJztcbiAgZm9yIChsZXQgaSA9IHJhbmsgLSAxOyBpID49IDA7IC0taSkge1xuICAgIGJsb2NrICs9IGBcbiAgICAgICAgayA9IG1bJHtpfV0gLSAke3BhZHNbaV19O1xuICAgICAgICBpZiAoayA8IDApICBrID0gMDtcbiAgICAgICAgaWYgKGsgPj0gJHtzaGFwZVtpXX0pIGsgPSAke3NoYXBlW2ldIC0gMX07XG4gICAgICAgIG9mZnNldCArPSBrICogJHtzdHJpZGVzW2ldfTtcbiAgICAgIGA7XG4gIH1cbiAgcmV0dXJuIGBcbiAgICAgIGZsb2F0IHBhZEEoaW50IG1bJHtyYW5rfV0pIHtcbiAgICAgICAgaW50IG9mZnNldCA9IDA7XG4gICAgICAgIGludCBrID0gMDtcbiAgICAgICAgJHtibG9ja31cbiAgICAgICAgdmVjMiBjb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhvZmZzZXQsICR7d2lkdGh9LCAke2hlaWdodH0pO1xuICAgICAgICBmbG9hdCB2YWx1ZSA9IGdldENvbG9yQXNGbG9hdCgke2dsc2wudGV4dHVyZTJEfShBLCBjb29yZHMpKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgYDtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vLi4vLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7IEdyYXBoIH0gZnJvbSAnLi4vLi4vLi4vZ3JhcGgnO1xuaW1wb3J0IHsgT3BlcmF0b3JJbXBsZW1lbnRhdGlvbiwgT3BlcmF0b3JJbml0aWFsaXphdGlvbiB9IGZyb20gJy4uLy4uLy4uL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBUZW5zb3IgfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHsgUG9vbENvbnZVdGlsLCBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi8uLi91dGlsJztcbmltcG9ydCB7IFdlYkdMSW5mZXJlbmNlSGFuZGxlciB9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7IFByb2dyYW1JbmZvLCBQcm9ncmFtTWV0YWRhdGEsIFRleHR1cmVUeXBlIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIEF2ZXJhZ2VQb29sQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IGF1dG9QYWQ6IHN0cmluZztcbiAgcmVhZG9ubHkgY2VpbE1vZGU6IG51bWJlcjtcbiAgcmVhZG9ubHkgY291bnRJbmNsdWRlUGFkOiBib29sZWFuO1xuICByZWFkb25seSBrZXJuZWxTaGFwZTogcmVhZG9ubHkgbnVtYmVyW107XG4gIHJlYWRvbmx5IHN0cmlkZXM6IHJlYWRvbmx5IG51bWJlcltdO1xuICByZWFkb25seSBwYWRzOiByZWFkb25seSBudW1iZXJbXTtcbn1cblxuZXhwb3J0IGNvbnN0IGF2ZXJhZ2VQb29sOiBPcGVyYXRvckltcGxlbWVudGF0aW9uPEF2ZXJhZ2VQb29sQXR0cmlidXRlcz4gPSAoXG4gIGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXRzOiBUZW5zb3JbXSxcbiAgYXR0cmlidXRlczogQXZlcmFnZVBvb2xBdHRyaWJ1dGVzLFxuKTogVGVuc29yW10gPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuICBjb25zdCBtZXRhZGF0YSA9IHtcbiAgICBuYW1lOiAnQXZlcmFnZVBvb2wnLFxuICAgIGlucHV0TmFtZXM6IFsnWCddLFxuICAgIGlucHV0VHlwZXM6IFtUZXh0dXJlVHlwZS51bnBhY2tlZF0sXG4gICAgY2FjaGVIaW50OiBhdHRyaWJ1dGVzLmNhY2hlS2V5LFxuICB9O1xuICBjb25zdCBvdXRwdXQgPSBpbmZlcmVuY2VIYW5kbGVyLnJ1bihcbiAgICB7IC4uLm1ldGFkYXRhLCBnZXQ6ICgpID0+IGNyZWF0ZUF2ZXJhZ2VQb29sUHJvZ3JhbUluZm8oaW5wdXRzLCBtZXRhZGF0YSwgZmFsc2UsIGF0dHJpYnV0ZXMpIH0sXG4gICAgaW5wdXRzLFxuICApO1xuICByZXR1cm4gW291dHB1dF07XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VBdmVyYWdlUG9vbEF0dHJpYnV0ZXM6IE9wZXJhdG9ySW5pdGlhbGl6YXRpb248QXZlcmFnZVBvb2xBdHRyaWJ1dGVzPiA9IChcbiAgbm9kZTogR3JhcGguTm9kZSxcbik6IEF2ZXJhZ2VQb29sQXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IGF1dG9QYWQgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0U3RyaW5nKCdhdXRvX3BhZCcsICdOT1RTRVQnKTtcbiAgY29uc3QgY2VpbE1vZGUgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0SW50KCdjZWlsX21vZGUnLCAwKTtcbiAgY29uc3QgY291bnRJbmNsdWRlUGFkID0gbm9kZS5hdHRyaWJ1dGVzLmdldEludCgnY291bnRfaW5jbHVkZV9wYWQnLCAwKSA9PT0gMCA/IGZhbHNlIDogdHJ1ZTtcbiAgY29uc3Qga2VybmVsU2hhcGUgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0SW50cygna2VybmVsX3NoYXBlJyk7XG4gIGNvbnN0IHN0cmlkZXMgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0SW50cygnc3RyaWRlcycsIFtdKTtcbiAgY29uc3QgcGFkcyA9IG5vZGUuYXR0cmlidXRlcy5nZXRJbnRzKCdwYWRzJywgW10pO1xuXG4gIC8vIFRPRE86IHN1cHBvcnQgYXR0cmlidXRlICdjZWlsX21vZGUnXG4gIGlmIChjZWlsTW9kZSAhPT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndXNpbmcgY2VpbCgpIGluIHNoYXBlIGNvbXB1dGF0aW9uIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGZvciBBdmVyYWdlUG9vbCcpO1xuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7IGF1dG9QYWQsIGNlaWxNb2RlLCBjb3VudEluY2x1ZGVQYWQsIGtlcm5lbFNoYXBlLCBzdHJpZGVzLCBwYWRzIH0pO1xufTtcblxuY29uc3QgY3JlYXRlQXZlcmFnZVBvb2xQcm9ncmFtSW5mbyA9IChcbiAgaW5wdXRzOiBUZW5zb3JbXSxcbiAgbWV0YWRhdGE6IFByb2dyYW1NZXRhZGF0YSxcbiAgaXNHbG9iYWxPcGVyYXRvcjogYm9vbGVhbixcbiAgYXR0cmlidXRlczogQXZlcmFnZVBvb2xBdHRyaWJ1dGVzLFxuKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBbYWRqdXN0ZWRBdHRyaWJ1dGVzLCBvdXRwdXRTaGFwZV0gPSBnZXRBZGp1c3RlZFBvb2xBdHRyaWJ1dGVzQW5kT3V0cHV0U2hhcGUoXG4gICAgaW5wdXRzLFxuICAgIGF0dHJpYnV0ZXMsXG4gICAgaXNHbG9iYWxPcGVyYXRvcixcbiAgKTtcbiAgY29uc3Qga2VybmVsU2l6ZSA9IFNoYXBlVXRpbC5zaXplKGFkanVzdGVkQXR0cmlidXRlcy5rZXJuZWxTaGFwZSk7XG4gIGNvbnN0IG9wMSA9ICd2YWx1ZSArPSBfWCh4KTsnO1xuICBsZXQgb3AyID0gJyc7XG4gIGlmIChhZGp1c3RlZEF0dHJpYnV0ZXMuY291bnRJbmNsdWRlUGFkKSB7XG4gICAgb3AyICs9IGB2YWx1ZSAvPSBmbG9hdCgke2tlcm5lbFNpemV9KTtgO1xuICB9IGVsc2Uge1xuICAgIG9wMiArPSBgdmFsdWUgLz0gZmxvYXQoJHtrZXJuZWxTaXplfSAtIHBhZCk7YDtcbiAgfVxuICBjb25zdCBwb29saW5nQ29kZSA9IGdlbmVyYXRlUG9vbGluZ0NvZGUoaW5wdXRzWzBdLmRpbXMsIGFkanVzdGVkQXR0cmlidXRlcywgb3AxLCBvcDIsICcwLjAnKTtcbiAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICAgICAke3Bvb2xpbmdDb2RlfVxuICAgICAgYDtcbiAgcmV0dXJuIHtcbiAgICAuLi5tZXRhZGF0YSxcbiAgICBvdXRwdXQ6IHsgZGltczogb3V0cHV0U2hhcGUsIHR5cGU6IGlucHV0c1swXS50eXBlLCB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGUudW5wYWNrZWQgfSxcbiAgICBzaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgZ2xvYmFsQXZlcmFnZVBvb2w6IE9wZXJhdG9ySW1wbGVtZW50YXRpb248QXZlcmFnZVBvb2xBdHRyaWJ1dGVzPiA9IChcbiAgaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBpbnB1dHM6IFRlbnNvcltdLFxuICBhdHRyaWJ1dGVzOiBBdmVyYWdlUG9vbEF0dHJpYnV0ZXMsXG4pOiBUZW5zb3JbXSA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGlucHV0cyk7XG4gIGNvbnN0IG1ldGFkYXRhID0ge1xuICAgIG5hbWU6ICdHbG9iYWxBdmVyYWdlUG9vbCcsXG4gICAgaW5wdXROYW1lczogWydYJ10sXG4gICAgaW5wdXRUeXBlczogW1RleHR1cmVUeXBlLnVucGFja2VkXSxcbiAgICBjYWNoZUhpbnQ6IGAke2F0dHJpYnV0ZXMuY291bnRJbmNsdWRlUGFkfWAsXG4gIH07XG4gIGNvbnN0IG91dHB1dCA9IGluZmVyZW5jZUhhbmRsZXIucnVuKFxuICAgIHsgLi4ubWV0YWRhdGEsIGdldDogKCkgPT4gY3JlYXRlQXZlcmFnZVBvb2xQcm9ncmFtSW5mbyhpbnB1dHMsIG1ldGFkYXRhLCB0cnVlLCBhdHRyaWJ1dGVzKSB9LFxuICAgIGlucHV0cyxcbiAgKTtcbiAgcmV0dXJuIFtvdXRwdXRdO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlR2xvYmFsQXZlcmFnZVBvb2xBdHRyaWJ1dGVzOiBPcGVyYXRvckluaXRpYWxpemF0aW9uPEF2ZXJhZ2VQb29sQXR0cmlidXRlcz4gPSAoXG4gIG5vZGU6IEdyYXBoLk5vZGUsXG4pOiBBdmVyYWdlUG9vbEF0dHJpYnV0ZXMgPT4ge1xuICBjb25zdCBjb3VudEluY2x1ZGVQYWQgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0SW50KCdjb3VudF9pbmNsdWRlX3BhZCcsIDApID09PSAwID8gZmFsc2UgOiB0cnVlO1xuICByZXR1cm4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHtcbiAgICBhdXRvUGFkOiAnJyxcbiAgICBjZWlsTW9kZTogMCxcbiAgICBjb3VudEluY2x1ZGVQYWQsXG4gICAga2VybmVsU2hhcGU6IFtdLFxuICAgIHN0cmlkZXM6IFtdLFxuICAgIHBhZHM6IFtdLFxuICB9KTtcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWF4UG9vbEF0dHJpYnV0ZXMgZXh0ZW5kcyBBdmVyYWdlUG9vbEF0dHJpYnV0ZXMge1xuICByZWFkb25seSBzdG9yYWdlT3JkZXI6IG51bWJlcjtcbiAgcmVhZG9ubHkgZGlsYXRpb25zOiBudW1iZXJbXTtcbn1cblxuZXhwb3J0IGNvbnN0IG1heFBvb2w6IE9wZXJhdG9ySW1wbGVtZW50YXRpb248TWF4UG9vbEF0dHJpYnV0ZXM+ID0gKFxuICBpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsXG4gIGlucHV0czogVGVuc29yW10sXG4gIGF0dHJpYnV0ZXM6IE1heFBvb2xBdHRyaWJ1dGVzLFxuKTogVGVuc29yW10gPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuICBjb25zdCBtZXRhZGF0YSA9IHtcbiAgICBuYW1lOiAnTWF4UG9vbCcsXG4gICAgaW5wdXROYW1lczogWydYJ10sXG4gICAgaW5wdXRUeXBlczogW1RleHR1cmVUeXBlLnVucGFja2VkXSxcbiAgICBjYWNoZUhpbnQ6IGF0dHJpYnV0ZXMuY2FjaGVLZXksXG4gIH07XG4gIGNvbnN0IG91dHB1dCA9IGluZmVyZW5jZUhhbmRsZXIucnVuKFxuICAgIHsgLi4ubWV0YWRhdGEsIGdldDogKCkgPT4gY3JlYXRlTWF4UG9vbFByb2dyYW1JbmZvKGlucHV0cywgbWV0YWRhdGEsIGZhbHNlLCBhdHRyaWJ1dGVzKSB9LFxuICAgIGlucHV0cyxcbiAgKTtcbiAgcmV0dXJuIFtvdXRwdXRdO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlTWF4UG9vbEF0dHJpYnV0ZXM6IE9wZXJhdG9ySW5pdGlhbGl6YXRpb248TWF4UG9vbEF0dHJpYnV0ZXM+ID0gKFxuICBub2RlOiBHcmFwaC5Ob2RlLFxuKTogTWF4UG9vbEF0dHJpYnV0ZXMgPT4ge1xuICBjb25zdCBhdXRvUGFkID0gbm9kZS5hdHRyaWJ1dGVzLmdldFN0cmluZygnYXV0b19wYWQnLCAnTk9UU0VUJyk7XG4gIGNvbnN0IGNlaWxNb2RlID0gbm9kZS5hdHRyaWJ1dGVzLmdldEludCgnY2VpbF9tb2RlJywgMCk7XG4gIGNvbnN0IGtlcm5lbFNoYXBlID0gbm9kZS5hdHRyaWJ1dGVzLmdldEludHMoJ2tlcm5lbF9zaGFwZScpO1xuICBjb25zdCBzdHJpZGVzID0gbm9kZS5hdHRyaWJ1dGVzLmdldEludHMoJ3N0cmlkZXMnLCBbXSk7XG4gIGNvbnN0IHBhZHMgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0SW50cygncGFkcycsIFtdKTtcbiAgY29uc3Qgc3RvcmFnZU9yZGVyID0gbm9kZS5hdHRyaWJ1dGVzLmdldEludCgnc3RvcmFnZV9vcmRlcicsIDApO1xuICBjb25zdCBkaWxhdGlvbnMgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0SW50cygnZGlsYXRpb25zJywgW10pO1xuXG4gIC8vIFRPRE86IHN1cHBvcnQgYXR0cmlidXRlICdjZWlsX21vZGUnIGFuZCAnc3RvcmFnZV9vcmRlcidcbiAgaWYgKHN0b3JhZ2VPcmRlciAhPT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY29sdW1uIG1ham9yIHN0b3JhZ2Ugb3JkZXIgaXMgbm90IHlldCBzdXBwb3J0ZWQgZm9yIE1heFBvb2wnKTtcbiAgfVxuICBpZiAoY2VpbE1vZGUgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzaW5nIGNlaWwoKSBpbiBzaGFwZSBjb21wdXRhdGlvbiBpcyBub3QgeWV0IHN1cHBvcnRlZCBmb3IgTWF4UG9vbCcpO1xuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7XG4gICAgYXV0b1BhZCxcbiAgICBjZWlsTW9kZSxcbiAgICBjb3VudEluY2x1ZGVQYWQ6IGZhbHNlLFxuICAgIGtlcm5lbFNoYXBlLFxuICAgIHN0cmlkZXMsXG4gICAgcGFkcyxcbiAgICBzdG9yYWdlT3JkZXIsXG4gICAgZGlsYXRpb25zLFxuICB9KTtcbn07XG5cbmNvbnN0IGNyZWF0ZU1heFBvb2xQcm9ncmFtSW5mbyA9IChcbiAgaW5wdXRzOiBUZW5zb3JbXSxcbiAgbWV0YWRhdGE6IFByb2dyYW1NZXRhZGF0YSxcbiAgaXNHbG9iYWxPcGVyYXRvcjogYm9vbGVhbixcbiAgYXR0cmlidXRlczogTWF4UG9vbEF0dHJpYnV0ZXMsXG4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IFthZGp1c3RlZEF0dHJpYnV0ZXMsIG91dHB1dFNoYXBlXSA9IGdldEFkanVzdGVkUG9vbEF0dHJpYnV0ZXNBbmRPdXRwdXRTaGFwZShcbiAgICBpbnB1dHMsXG4gICAgYXR0cmlidXRlcyxcbiAgICBpc0dsb2JhbE9wZXJhdG9yLFxuICApO1xuICBjb25zdCBvcDEgPSBgXG4gICAgICB2YWx1ZSA9IG1heChfWCh4KSwgdmFsdWUpO1xuICAgIGA7XG4gIGNvbnN0IG9wMiA9ICcnO1xuICBjb25zdCBwb29saW5nQ29kZSA9IGdlbmVyYXRlUG9vbGluZ0NvZGUoaW5wdXRzWzBdLmRpbXMsIGFkanVzdGVkQXR0cmlidXRlcywgb3AxLCBvcDIsICctMWU1Jyk7XG4gIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgICR7cG9vbGluZ0NvZGV9XG4gICAgYDtcbiAgcmV0dXJuIHtcbiAgICAuLi5tZXRhZGF0YSxcbiAgICBvdXRwdXQ6IHsgZGltczogb3V0cHV0U2hhcGUsIHR5cGU6IGlucHV0c1swXS50eXBlLCB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGUudW5wYWNrZWQgfSxcbiAgICBzaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG5jb25zdCBnZXRBZGp1c3RlZFBvb2xBdHRyaWJ1dGVzQW5kT3V0cHV0U2hhcGUgPSAoXG4gIGlucHV0czogVGVuc29yW10sXG4gIGF0dHJpYnV0ZXM6IEF2ZXJhZ2VQb29sQXR0cmlidXRlcyB8IE1heFBvb2xBdHRyaWJ1dGVzLFxuICBpc0dsb2JhbE9wZXJhdG9yOiBib29sZWFuLFxuKTogW0F2ZXJhZ2VQb29sQXR0cmlidXRlcyB8IE1heFBvb2xBdHRyaWJ1dGVzLCBudW1iZXJbXV0gPT4ge1xuICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXMuc2xpY2UoKTtcbiAgY29uc3QgaGFzRGlsYXRpb25zID0gT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoYXR0cmlidXRlcywgJ2RpbGF0aW9ucycpO1xuICBjb25zdCBrZXJuZWxTaGFwZSA9IGF0dHJpYnV0ZXMua2VybmVsU2hhcGUuc2xpY2UoKTtcbiAgY29uc3Qgc3RyaWRlcyA9IGF0dHJpYnV0ZXMuc3RyaWRlcy5zbGljZSgpO1xuICBjb25zdCBkaWxhdGlvbnM6IG51bWJlcltdID0gaGFzRGlsYXRpb25zID8gKGF0dHJpYnV0ZXMgYXMgTWF4UG9vbEF0dHJpYnV0ZXMpLmRpbGF0aW9ucy5zbGljZSgpIDogW107XG4gIGNvbnN0IHBhZHMgPSBhdHRyaWJ1dGVzLnBhZHMuc2xpY2UoKTtcbiAgUG9vbENvbnZVdGlsLmFkanVzdFBvb2xBdHRyaWJ1dGVzKGlzR2xvYmFsT3BlcmF0b3IsIGlucHV0U2hhcGUsIGtlcm5lbFNoYXBlLCBzdHJpZGVzLCBkaWxhdGlvbnMsIHBhZHMpO1xuXG4gIGNvbnN0IG91dHB1dFNoYXBlID0gUG9vbENvbnZVdGlsLmNvbXB1dGVQb29sT3V0cHV0U2hhcGUoXG4gICAgaXNHbG9iYWxPcGVyYXRvcixcbiAgICBpbnB1dFNoYXBlLFxuICAgIHN0cmlkZXMsXG4gICAgZGlsYXRpb25zLFxuICAgIGtlcm5lbFNoYXBlLFxuICAgIHBhZHMsXG4gICAgYXR0cmlidXRlcy5hdXRvUGFkLFxuICApO1xuXG4gIGNvbnN0IG5ld0F0dHJpYnV0ZXMgPSBPYmplY3QuYXNzaWduKHt9LCBhdHRyaWJ1dGVzKTtcbiAgaWYgKGhhc0RpbGF0aW9ucykge1xuICAgIE9iamVjdC5hc3NpZ24obmV3QXR0cmlidXRlcywgeyBrZXJuZWxTaGFwZSwgc3RyaWRlcywgcGFkcywgZGlsYXRpb25zLCBjYWNoZUtleTogYXR0cmlidXRlcy5jYWNoZUtleSB9KTtcbiAgfSBlbHNlIHtcbiAgICBPYmplY3QuYXNzaWduKG5ld0F0dHJpYnV0ZXMsIHsga2VybmVsU2hhcGUsIHN0cmlkZXMsIHBhZHMsIGNhY2hlS2V5OiBhdHRyaWJ1dGVzLmNhY2hlS2V5IH0pO1xuICB9XG4gIHJldHVybiBbbmV3QXR0cmlidXRlcywgb3V0cHV0U2hhcGVdO1xufTtcblxuY29uc3QgZ2xvYmFsTWF4UG9vbEF0dHJpYnV0ZXMgPSB7XG4gIGF1dG9QYWQ6ICcnLFxuICBjZWlsTW9kZTogMCxcbiAgY291bnRJbmNsdWRlUGFkOiBmYWxzZSxcbiAga2VybmVsU2hhcGU6IFtdLFxuICBzdHJpZGVzOiBbXSxcbiAgcGFkczogW10sXG4gIHN0b3JhZ2VPcmRlcjogMCxcbiAgZGlsYXRpb25zOiBbXSxcbiAgY2FjaGVLZXk6ICcnLFxufTtcblxuY29uc3QgZ2xvYmFsTWF4UG9vbE1ldGFkYXRhID0ge1xuICBuYW1lOiAnR2xvYmFsTWF4UG9vbCcsXG4gIGlucHV0TmFtZXM6IFsnWCddLFxuICBpbnB1dFR5cGVzOiBbVGV4dHVyZVR5cGUudW5wYWNrZWRdLFxufTtcblxuZXhwb3J0IGNvbnN0IGdsb2JhbE1heFBvb2wgPSAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10gPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuICBjb25zdCBvdXRwdXQgPSBpbmZlcmVuY2VIYW5kbGVyLnJ1bihcbiAgICB7XG4gICAgICAuLi5nbG9iYWxNYXhQb29sTWV0YWRhdGEsXG4gICAgICBnZXQ6ICgpID0+IGNyZWF0ZU1heFBvb2xQcm9ncmFtSW5mbyhpbnB1dHMsIGdsb2JhbE1heFBvb2xNZXRhZGF0YSwgdHJ1ZSwgZ2xvYmFsTWF4UG9vbEF0dHJpYnV0ZXMpLFxuICAgIH0sXG4gICAgaW5wdXRzLFxuICApO1xuICByZXR1cm4gW291dHB1dF07XG59O1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IFRlbnNvcltdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Bvb2wgb3BzIHJlcXVpcmVzIDEgaW5wdXQuJyk7XG4gIH1cbiAgaWYgKGlucHV0c1swXS50eXBlICE9PSAnZmxvYXQzMicgJiYgaW5wdXRzWzBdLnR5cGUgIT09ICdmbG9hdDY0Jykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCB0eXBlLicpO1xuICB9XG59O1xuXG5jb25zdCBnZW5lcmF0ZVBvb2xpbmdDb2RlID0gKFxuICBpbnB1dERpbXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICBhdHRyaWJ1dGVzOiBBdmVyYWdlUG9vbEF0dHJpYnV0ZXMsXG4gIG9wMTogc3RyaW5nLFxuICBvcDI6IHN0cmluZyxcbiAgc3RhcnQ6IHN0cmluZyxcbik6IHN0cmluZyA9PiB7XG4gIGNvbnN0IHJhbmsgPSBpbnB1dERpbXMubGVuZ3RoO1xuICBpZiAoYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5sZW5ndGggPD0gMikge1xuICAgIGNvbnN0IGt3ID0gYXR0cmlidXRlcy5rZXJuZWxTaGFwZVthdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IHN3ID0gYXR0cmlidXRlcy5zdHJpZGVzW2F0dHJpYnV0ZXMuc3RyaWRlcy5sZW5ndGggLSAxXTtcbiAgICBjb25zdCBwd1N0YXJ0ID0gYXR0cmlidXRlcy5wYWRzW2F0dHJpYnV0ZXMucGFkcy5sZW5ndGggLyAyIC0gMV07XG4gICAgY29uc3QgcHdFbmQgPSBhdHRyaWJ1dGVzLnBhZHNbYXR0cmlidXRlcy5wYWRzLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IGRpbVcgPSBpbnB1dERpbXNbcmFuayAtIDFdO1xuICAgIGxldCBjb2RlVyA9ICcnO1xuICAgIGxldCBjb2RlSCA9ICcnO1xuICAgIGxldCBjb2RlSEVuZCA9ICcnO1xuICAgIGlmIChwd1N0YXJ0ICsgcHdFbmQgIT09IDApIHtcbiAgICAgIGNvZGVXID0gYFxuICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgJHtrd307IGkrKykge1xuICAgICAgICAgICAgeFske3Jhbmt9IC0gMV0gPSBpbmRpY2VzWyR7cmFua30gLSAxXSAqICR7c3d9IC0gJHtwd1N0YXJ0fSArIGk7XG4gICAgICAgICAgICBpZiAoeFske3Jhbmt9IC0gMV0gPCAwIHx8IHhbJHtyYW5rfSAtIDFdID49ICR7ZGltV30pIHtcbiAgICAgICAgICAgICAgcGFkKys7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJHtvcDF9XG4gICAgICAgICAgfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGVXID0gYFxuICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgJHtrd307IGkrKykge1xuICAgICAgICAgICAgeFske3Jhbmt9IC0gMV0gPSBpbmRpY2VzWyR7cmFua30gLSAxXSAqICR7c3d9IC0gJHtwd1N0YXJ0fSArIGk7XG4gICAgICAgICAgICAke29wMX1cbiAgICAgICAgICB9YDtcbiAgICB9XG5cbiAgICBpZiAoYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5sZW5ndGggPT09IDIpIHtcbiAgICAgIGNvbnN0IGtoID0gYXR0cmlidXRlcy5rZXJuZWxTaGFwZVthdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aCAtIDJdO1xuICAgICAgY29uc3Qgc2ggPSBhdHRyaWJ1dGVzLnN0cmlkZXNbYXR0cmlidXRlcy5zdHJpZGVzLmxlbmd0aCAtIDJdO1xuICAgICAgY29uc3QgcGhTdGFydCA9IGF0dHJpYnV0ZXMucGFkc1thdHRyaWJ1dGVzLnBhZHMubGVuZ3RoIC8gMiAtIDJdO1xuICAgICAgY29uc3QgcGhFbmQgPSBhdHRyaWJ1dGVzLnBhZHNbYXR0cmlidXRlcy5wYWRzLmxlbmd0aCAtIDJdO1xuICAgICAgY29uc3QgZGltSCA9IGlucHV0RGltc1tyYW5rIC0gMl07XG4gICAgICBpZiAocGhTdGFydCArIHBoRW5kICE9PSAwKSB7XG4gICAgICAgIGNvZGVIID0gYFxuICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCAke2tofTsgaisrKSB7XG4gICAgICAgICAgICAgIHhbJHtyYW5rfSAtIDJdID0gaW5kaWNlc1ske3Jhbmt9IC0gMl0gKiAke3NofSAtICR7cGhTdGFydH0gKyBqO1xuICAgICAgICAgICAgICBpZiAoeFske3Jhbmt9IC0gMl0gPCAwIHx8IHhbJHtyYW5rfSAtIDJdID49ICR7ZGltSH0pIHtcbiAgICAgICAgICAgICAgICBwYWQrPSAke2t3fTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIGA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb2RlSCA9IGBcbiAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgJHtraH07IGorKykge1xuICAgICAgICAgICAgICB4WyR7cmFua30gLSAyXSA9IGluZGljZXNbJHtyYW5rfSAtIDJdICogJHtzaH0gLSAke3BoU3RhcnR9ICsgajtcbiAgICAgICAgICAgIGA7XG4gICAgICB9XG4gICAgICBjb2RlSEVuZCA9IGBcbiAgICAgICAgICB9XG4gICAgICAgIGA7XG4gICAgfVxuXG4gICAgY29uc3QgcG9vbGluZ0NvZGUgPSBgXG4gICAgICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbJHtyYW5rfV0pIHtcbiAgICAgICAgICBpbnQgeFske3Jhbmt9XTtcbiAgICAgICAgICBjb3B5VmVjKGluZGljZXMsIHgpO1xuXG4gICAgICAgICAgZmxvYXQgdmFsdWUgPSAke3N0YXJ0fTtcbiAgICAgICAgICBpbnQgcGFkID0gMDtcbiAgICAgICAgICAke2NvZGVIfVxuICAgICAgICAgICR7Y29kZVd9XG4gICAgICAgICAgJHtjb2RlSEVuZH1cbiAgICAgICAgICAke29wMn1cbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIGA7XG4gICAgcmV0dXJuIHBvb2xpbmdDb2RlO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGtlcm5lbFNpemUgPSBTaGFwZVV0aWwuc2l6ZShhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlKTtcbiAgICBjb25zdCBrZXJuZWxTdHJpZGVzID0gU2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKGF0dHJpYnV0ZXMua2VybmVsU2hhcGUpO1xuICAgIGNvbnN0IHN0cmlkZXNSYW5rID0ga2VybmVsU3RyaWRlcy5sZW5ndGg7XG4gICAgY29uc3QgcGFkc1JhbmsgPSBhdHRyaWJ1dGVzLnBhZHMubGVuZ3RoO1xuICAgIGNvbnN0IG9mZnNldFRvSW5kaWNlc0Z1bmN0aW9uID0gb2Zmc2V0VG9JbmRpY2VzKHN0cmlkZXNSYW5rKTtcbiAgICBjb25zdCBjb3B5SW5wdXREaW1zID0gY29weUFycmF5KGlucHV0RGltcywgJ2lucHV0RGltcycpO1xuICAgIGNvbnN0IGNvcHlQYWRzID0gY29weUFycmF5KGF0dHJpYnV0ZXMucGFkcywgJ3BhZHMnKTtcbiAgICBjb25zdCBjb3B5S2VybmVsU3RyaWRlcyA9IGNvcHlBcnJheShrZXJuZWxTdHJpZGVzLCAna2VybmVsU3RyaWRlcycpO1xuICAgIGNvbnN0IGNvcHlTdHJpZGVzID0gY29weUFycmF5KGF0dHJpYnV0ZXMuc3RyaWRlcywgJ3N0cmlkZXMnKTtcbiAgICBjb25zdCBoYXNQYWRzID0gYXR0cmlidXRlcy5wYWRzLnJlZHVjZSgoc3VtLCBjdXIpID0+IHN1bSArIGN1cik7XG4gICAgbGV0IHBhZENvZGUgPSAnJztcbiAgICBpZiAoaGFzUGFkcykge1xuICAgICAgcGFkQ29kZSA9IGBcbiAgICAgICAgICAgIGlmICh4W2pdID49IGlucHV0RGltc1tqXSB8fCB4W2pdIDwgMCkge1xuICAgICAgICAgICAgICBwYWQrKztcbiAgICAgICAgICAgICAgaXNQYWQgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFpc1BhZCkge1xuICAgICAgICAgICAgJHtvcDF9XG4gICAgICAgICAgfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhZENvZGUgPSBgXG4gICAgICAgICAgfVxuICAgICAgICAgICR7b3AxfVxuICAgICAgICBgO1xuICAgIH1cbiAgICBjb25zdCBwb29saW5nQ29kZSA9IGBcbiAgICAgICAgJHtvZmZzZXRUb0luZGljZXNGdW5jdGlvbn1cbiAgICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske3Jhbmt9XSkge1xuICAgICAgICAgIGludCB4WyR7cmFua31dO1xuICAgICAgICAgIGNvcHlWZWMoaW5kaWNlcywgeCk7XG4gICAgICAgICAgaW50IG9mZnNldFske3N0cmlkZXNSYW5rfV07XG4gICAgICAgICAgaW50IHBhZHNbJHtwYWRzUmFua31dO1xuICAgICAgICAgIGludCBpbnB1dERpbXNbJHtyYW5rfV07XG4gICAgICAgICAgaW50IGtlcm5lbFN0cmlkZXNbJHtzdHJpZGVzUmFua31dO1xuICAgICAgICAgIGludCBzdHJpZGVzWyR7c3RyaWRlc1Jhbmt9XTtcbiAgICAgICAgICAke2NvcHlQYWRzfVxuICAgICAgICAgICR7Y29weUlucHV0RGltc31cbiAgICAgICAgICAke2NvcHlTdHJpZGVzfVxuICAgICAgICAgICR7Y29weUtlcm5lbFN0cmlkZXN9XG5cbiAgICAgICAgICBmbG9hdCB2YWx1ZSA9ICR7c3RhcnR9O1xuICAgICAgICAgIGludCBwYWQgPSAwO1xuICAgICAgICAgIGJvb2wgaXNQYWQgPSBmYWxzZTtcbiAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8ICR7a2VybmVsU2l6ZX07IGkrKykge1xuICAgICAgICAgICAgb2Zmc2V0VG9JbmRpY2VzKGksIGtlcm5lbFN0cmlkZXMsIG9mZnNldCk7XG4gICAgICAgICAgICBpc1BhZCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChpbnQgaiA9ICR7cmFua30gLSAke3N0cmlkZXNSYW5rfTsgaiA8ICR7cmFua307IGorKykge1xuICAgICAgICAgICAgICB4W2pdID0gaW5kaWNlc1tqXSAqIHN0cmlkZXNbaiAtICR7cmFua30gKyAke3N0cmlkZXNSYW5rfV1cbiAgICAgICAgICAgICAgICArIG9mZnNldFtqIC0gJHtyYW5rfSArICR7c3RyaWRlc1Jhbmt9XSAtIHBhZHNbaiAtIDJdO1xuICAgICAgICAgICAgICAke3BhZENvZGV9XG4gICAgICAgICAgfVxuICAgICAgICAgICR7b3AyfVxuXG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICBgO1xuICAgIHJldHVybiBwb29saW5nQ29kZTtcbiAgfVxufTtcblxuY29uc3QgY29weUFycmF5ID0gKGFycmF5OiByZWFkb25seSBudW1iZXJbXSwgYXJyYXlOYW1lOiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICBsZXQgYmxvY2sgPSAnJztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgIGJsb2NrICs9IGBcbiAgICAgICR7YXJyYXlOYW1lfVske2l9XSA9ICR7YXJyYXlbaV19O1xuICAgIGA7XG4gIH1cbiAgcmV0dXJuIGJsb2NrO1xufTtcblxuY29uc3Qgb2Zmc2V0VG9JbmRpY2VzID0gKHJhbms6IG51bWJlcik6IHN0cmluZyA9PiBgXG4gIHZvaWQgb2Zmc2V0VG9JbmRpY2VzKGludCBvZmZzZXQsIGludFske3Jhbmt9XSBzdHJpZGVzLCBvdXQgaW50WyR7cmFua31dIGluZGljZXMpIHtcbiAgICBpZiAoJHtyYW5rfSA9PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoaW50IGkgPSAwOyBpIDwgJHtyYW5rfSAtIDE7ICsraSkge1xuICAgICAgaW5kaWNlc1tpXSA9IG9mZnNldCAvIHN0cmlkZXNbaV07XG4gICAgICBvZmZzZXQgLT0gaW5kaWNlc1tpXSAqIHN0cmlkZXNbaV07XG4gICAgfVxuICAgIGluZGljZXNbJHtyYW5rfSAtIDFdID0gb2Zmc2V0O1xuICB9YDtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgQXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi8uLi8uLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHsgR3JhcGggfSBmcm9tICcuLi8uLi8uLi9ncmFwaCc7XG5pbXBvcnQgeyBOVU1CRVJfVFlQRVMsIE9wZXJhdG9ySW1wbGVtZW50YXRpb24sIE9wZXJhdG9ySW5pdGlhbGl6YXRpb24gfSBmcm9tICcuLi8uLi8uLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgVGVuc29yIH0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgV2ViR0xJbmZlcmVuY2VIYW5kbGVyIH0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHsgUHJvZ3JhbUluZm8sIFByb2dyYW1NZXRhZGF0YSwgVGV4dHVyZVR5cGUgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVkdWNlQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IGF4ZXM6IG51bWJlcltdO1xuICByZWFkb25seSBrZWVwRGltczogYm9vbGVhbjtcbn1cblxuLy8gcmV0dXJuIFtpbml0IG9wcywgcmVkdWNlIG9wcywgZmluYWwgb3BzXVxudHlwZSBSZWR1Y2VPcCA9IChpbnB1dHM6IFRlbnNvcltdLCBheGVzOiBudW1iZXJbXSkgPT4gc3RyaW5nW107XG5cbmNvbnN0IHJlZHVjZSA9IChcbiAgaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBpbnB1dHM6IFRlbnNvcltdLFxuICBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzLFxuICBuYW1lOiBzdHJpbmcsXG4gIHJlZHVjZU9wOiBSZWR1Y2VPcCxcbik6IFRlbnNvcltdID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoaW5wdXRzKTtcblxuICBjb25zdCByZWR1Y2VQcm9ncmFtTWV0YWRhdGEgPSB7XG4gICAgbmFtZSxcbiAgICBpbnB1dE5hbWVzOiBbJ0EnXSxcbiAgICBpbnB1dFR5cGVzOiBbVGV4dHVyZVR5cGUudW5wYWNrZWRdLFxuICB9O1xuXG4gIGNvbnN0IG91dHB1dCA9IGluZmVyZW5jZUhhbmRsZXIucnVuKFxuICAgIHtcbiAgICAgIC4uLnJlZHVjZVByb2dyYW1NZXRhZGF0YSxcbiAgICAgIGNhY2hlSGludDogYXR0cmlidXRlcy5jYWNoZUtleSxcbiAgICAgIGdldDogKCkgPT4gY3JlYXRlUmVkdWNlUHJvZ3JhbUluZm8oaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzLCBhdHRyaWJ1dGVzLCBuYW1lLCByZWR1Y2VPcCwgcmVkdWNlUHJvZ3JhbU1ldGFkYXRhKSxcbiAgICB9LFxuICAgIGlucHV0cyxcbiAgKTtcbiAgcmV0dXJuIFtvdXRwdXRdO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlUmVkdWNlQXR0cmlidXRlczogT3BlcmF0b3JJbml0aWFsaXphdGlvbjxSZWR1Y2VBdHRyaWJ1dGVzPiA9IChub2RlOiBHcmFwaC5Ob2RlKTogUmVkdWNlQXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IGF4ZXMgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0SW50cygnYXhlcycsIFtdKTtcbiAgY29uc3Qga2VlcERpbXMgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0SW50KCdrZWVwZGltcycsIDEpID09PSAxO1xuICByZXR1cm4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHsgYXhlcywga2VlcERpbXMgfSk7XG59O1xuXG5jb25zdCBjcmVhdGVSZWR1Y2VQcm9ncmFtSW5mbyA9IChcbiAgX2hhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXRzOiBUZW5zb3JbXSxcbiAgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyxcbiAgX25hbWU6IHN0cmluZyxcbiAgcmVkdWNlT3A6IFJlZHVjZU9wLFxuICByZWR1Y2VQcm9ncmFtTWV0YWRhdGE6IFByb2dyYW1NZXRhZGF0YSxcbik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3Qgb3V0cHV0U2hhcGU6IG51bWJlcltdID0gW107XG4gIGNvbnN0IGlSYW5rID0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoIHx8IDE7XG5cbiAgY29uc3QgaWR4Q29weSA9IFtdOyAvLyBjb3B5IG91dHB1dCBpbmRleGVzIHRvIGlucHV0IGluZGV4ZXNcblxuICBjb25zdCBheGVzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4ZXMoYXR0cmlidXRlcy5heGVzLCBpbnB1dHNbMF0uZGltcy5sZW5ndGgpO1xuICBjb25zdCBvcHMgPSByZWR1Y2VPcChpbnB1dHMsIGF4ZXMpO1xuICBsZXQgcmVkdWNlT3BzID0gb3BzWzFdO1xuXG4gIGZvciAobGV0IGsgPSAwOyBrIDwgaW5wdXRzWzBdLmRpbXMubGVuZ3RoOyBrKyspIHtcbiAgICAvLyBpZiB0aGlzIGF4aXMgaXMgcmVkdWNlZFxuICAgIGlmIChheGVzLmluZGV4T2YoaykgPj0gMCB8fCBheGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKGF0dHJpYnV0ZXMua2VlcERpbXMpIHtcbiAgICAgICAgb3V0cHV0U2hhcGUucHVzaCgxKTtcbiAgICAgIH0gLy8gZWxzZSB7IHJlbW92ZSB0aGUgYXhpcyBmcm9tIG91dHB1dFNoYXBlOyB9XG5cbiAgICAgIC8vIGxvb3Agb3ZlciB0aGUgZC10aCBheGlzXG4gICAgICByZWR1Y2VPcHMgPSBgXG4gICAgICAgICAgZm9yKGludCBqJHtrfSA9IDA7IGoke2t9IDwgJHtpbnB1dHNbMF0uZGltc1trXX07IGoke2t9KyspIHtcbiAgICAgICAgICAgIGlucHV0SWR4WyR7a31dID0gaiR7a307XG4gICAgICAgICAgICAke3JlZHVjZU9wc31cbiAgICAgICAgICB9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWR4Q29weS5wdXNoKGBpbnB1dElkeFske2t9XSA9IG91dHB1dElkeFske291dHB1dFNoYXBlLmxlbmd0aH1dO2ApO1xuXG4gICAgICBvdXRwdXRTaGFwZS5wdXNoKGlucHV0c1swXS5kaW1zW2tdKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBvUmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aCB8fCAxO1xuXG4gIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50IG91dHB1dElkeFske29SYW5rfV0pIHtcbiAgICAgICAgZmxvYXQgdmFsdWU7ICAgICAgICAgICAgICAgICAvLyBmaW5hbCByZXN1bHRcbiAgICAgICAgaW50IGlucHV0SWR4WyR7aVJhbmt9XTsgICAgICAvLyBhZGRyZXNzaW5nIGlucHV0IGRhdGFcbiAgICAgICAgJHtpZHhDb3B5LmpvaW4oJ1xcbicpfVxuICAgICAgICAke29wc1swXX0gICAgICAgLy8gaW5pdCBvcHMgZm9yIHJlZHVjZSBtYXgvbWluXG4gICAgICAgICR7cmVkdWNlT3BzfVxuICAgICAgICAke29wc1syXX0gICAgICAgLy8gZmluYWwgY29tcHV0YXRpb24gZm9yIHJlZHVjZSBtZWFuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1gO1xuXG4gIHJldHVybiB7XG4gICAgLi4ucmVkdWNlUHJvZ3JhbU1ldGFkYXRhLFxuICAgIG91dHB1dDogeyBkaW1zOiBvdXRwdXRTaGFwZSwgdHlwZTogaW5wdXRzWzBdLnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS51bnBhY2tlZCB9LFxuICAgIHNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogVGVuc29yW10pOiB2b2lkID0+IHtcbiAgLy8gVE9ETzogc3VwcG9ydCBSZWR1Y2UqIG9wZXJhdG9ycyB3aXRoIDIgaW5wdXRzLlxuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZWR1Y2Ugb3AgcmVxdWlyZXMgMSBpbnB1dC4nKTtcbiAgfVxuXG4gIGlmIChOVU1CRVJfVFlQRVMuaW5kZXhPZihpbnB1dHNbMF0udHlwZSkgPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0IHR5cGUuJyk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VTdW06IE9wZXJhdG9ySW1wbGVtZW50YXRpb248UmVkdWNlQXR0cmlidXRlcz4gPSAoXG4gIGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXRzOiBUZW5zb3JbXSxcbiAgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyxcbik6IFRlbnNvcltdID0+IHtcbiAgY29uc3QgcmVkdWNlT3A6IFJlZHVjZU9wID0gKCk6IHN0cmluZ1tdID0+IFsndmFsdWUgPSAwLjA7JywgJ3ZhbHVlICs9IF9BKGlucHV0SWR4KTsnLCAnJ107XG4gIHJldHVybiByZWR1Y2UoaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzLCBhdHRyaWJ1dGVzLCAnUmVkdWNlU3VtJywgcmVkdWNlT3ApO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZU1lYW46IE9wZXJhdG9ySW1wbGVtZW50YXRpb248UmVkdWNlQXR0cmlidXRlcz4gPSAoXG4gIGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXRzOiBUZW5zb3JbXSxcbiAgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyxcbik6IFRlbnNvcltdID0+IHtcbiAgY29uc3QgcmVkdWNlT3A6IFJlZHVjZU9wID0gKGlucHV0czogVGVuc29yW10sIGF4ZXM6IG51bWJlcltdKTogc3RyaW5nW10gPT4ge1xuICAgIGxldCBzaXplID0gMS4wO1xuICAgIGZvciAobGV0IGsgPSAwOyBrIDwgaW5wdXRzWzBdLmRpbXMubGVuZ3RoOyBrKyspIHtcbiAgICAgIGlmIChheGVzLmluZGV4T2YoaykgPj0gMCB8fCBheGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzaXplICo9IGlucHV0c1swXS5kaW1zW2tdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbJ3ZhbHVlID0gMC4wOycsICd2YWx1ZSArPSBfQShpbnB1dElkeCk7JywgYHZhbHVlIC89ICR7c2l6ZX0uO2BdOyAvLyBlbnN1cmUgcmVhbCBudW1iZXIgd2l0aCBgLmBcbiAgfTtcbiAgcmV0dXJuIHJlZHVjZShpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMsIGF0dHJpYnV0ZXMsICdSZWR1Y2VNZWFuJywgcmVkdWNlT3ApO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZU1heDogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxSZWR1Y2VBdHRyaWJ1dGVzPiA9IChcbiAgaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBpbnB1dHM6IFRlbnNvcltdLFxuICBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzLFxuKTogVGVuc29yW10gPT4ge1xuICBjb25zdCByZWR1Y2VPcDogUmVkdWNlT3AgPSAoaW5wdXRzOiBUZW5zb3JbXSwgYXhlczogbnVtYmVyW10pOiBzdHJpbmdbXSA9PiB7XG4gICAgY29uc3QgaWR4WmVybyA9IFtdO1xuICAgIGZvciAobGV0IGsgPSAwOyBrIDwgaW5wdXRzWzBdLmRpbXMubGVuZ3RoOyBrKyspIHtcbiAgICAgIGlmIChheGVzLmluZGV4T2YoaykgPj0gMCB8fCBheGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpZHhaZXJvLnB1c2goYGlucHV0SWR4WyR7a31dID0gMDtgKTsgLy8gZmlyc3QgZWxlbWVudFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbYCR7aWR4WmVyby5qb2luKCdcXG4nKX1cXG52YWx1ZSA9IF9BKGlucHV0SWR4KTtgLCAndmFsdWUgPSBtYXgodmFsdWUsIF9BKGlucHV0SWR4KSk7JywgJyddO1xuICB9O1xuICByZXR1cm4gcmVkdWNlKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0cywgYXR0cmlidXRlcywgJ1JlZHVjZU1heCcsIHJlZHVjZU9wKTtcbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VNaW46IE9wZXJhdG9ySW1wbGVtZW50YXRpb248UmVkdWNlQXR0cmlidXRlcz4gPSAoXG4gIGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXRzOiBUZW5zb3JbXSxcbiAgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyxcbik6IFRlbnNvcltdID0+IHtcbiAgY29uc3QgcmVkdWNlT3A6IFJlZHVjZU9wID0gKGlucHV0czogVGVuc29yW10sIGF4ZXM6IG51bWJlcltdKTogc3RyaW5nW10gPT4ge1xuICAgIGNvbnN0IGlkeFplcm8gPSBbXTtcbiAgICBmb3IgKGxldCBrID0gMDsgayA8IGlucHV0c1swXS5kaW1zLmxlbmd0aDsgaysrKSB7XG4gICAgICBpZiAoYXhlcy5pbmRleE9mKGspID49IDAgfHwgYXhlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaWR4WmVyby5wdXNoKGBpbnB1dElkeFske2t9XSA9IDA7YCk7IC8vIGZpcnN0IGVsZW1lbnRcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gW2Ake2lkeFplcm8uam9pbignXFxuJyl9XFxudmFsdWUgPSBfQShpbnB1dElkeCk7YCwgJ3ZhbHVlID0gbWluKHZhbHVlLCBfQShpbnB1dElkeCkpOycsICcnXTtcbiAgfTtcbiAgcmV0dXJuIHJlZHVjZShpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMsIGF0dHJpYnV0ZXMsICdSZWR1Y2VNaW4nLCByZWR1Y2VPcCk7XG59O1xuXG5leHBvcnQgY29uc3QgcmVkdWNlUHJvZDogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxSZWR1Y2VBdHRyaWJ1dGVzPiA9IChcbiAgaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBpbnB1dHM6IFRlbnNvcltdLFxuICBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzLFxuKTogVGVuc29yW10gPT4ge1xuICBjb25zdCByZWR1Y2VPcDogUmVkdWNlT3AgPSAoKTogc3RyaW5nW10gPT4gWyd2YWx1ZSA9IDEuMDsnLCAndmFsdWUgKj0gX0EoaW5wdXRJZHgpOycsICcnXTtcbiAgcmV0dXJuIHJlZHVjZShpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMsIGF0dHJpYnV0ZXMsICdSZWR1Y2VQcm9kJywgcmVkdWNlT3ApO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZUxvZ1N1bTogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxSZWR1Y2VBdHRyaWJ1dGVzPiA9IChcbiAgaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBpbnB1dHM6IFRlbnNvcltdLFxuICBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzLFxuKTogVGVuc29yW10gPT4ge1xuICBjb25zdCByZWR1Y2VPcDogUmVkdWNlT3AgPSAoKTogc3RyaW5nW10gPT4gWyd2YWx1ZSA9IDAuMDsnLCAndmFsdWUgKz0gX0EoaW5wdXRJZHgpOycsICd2YWx1ZSA9IGxvZyh2YWx1ZSk7J107XG4gIHJldHVybiByZWR1Y2UoaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzLCBhdHRyaWJ1dGVzLCAnUmVkdWNlTG9nU3VtJywgcmVkdWNlT3ApO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZUxvZ1N1bVNxdWFyZTogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxSZWR1Y2VBdHRyaWJ1dGVzPiA9IChcbiAgaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBpbnB1dHM6IFRlbnNvcltdLFxuICBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzLFxuKTogVGVuc29yW10gPT4ge1xuICBjb25zdCByZWR1Y2VPcDogUmVkdWNlT3AgPSAoKTogc3RyaW5nW10gPT4gWydmbG9hdCB0OyB2YWx1ZSA9IDAuMDsnLCAndCA9IF9BKGlucHV0SWR4KTsgdmFsdWUgKz0gdCAqIHQ7JywgJyddO1xuICByZXR1cm4gcmVkdWNlKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0cywgYXR0cmlidXRlcywgJ1JlZHVjZUxvZ1N1bVNxdWFyZScsIHJlZHVjZU9wKTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi8uLi91dGlsJztcbmltcG9ydCB7IFdlYkdMSW5mZXJlbmNlSGFuZGxlciB9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcblxuZXhwb3J0IGNvbnN0IHJlc2hhcGUgPSAoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10gPT4ge1xuICBjb25zdCByZXNoYXBlZERpbXMgPSBTaGFwZVV0aWwuY2FsY3VsYXRlUmVzaGFwZWREaW1zKGlucHV0c1swXS5kaW1zLCBpbnB1dHNbMV0uaW50ZWdlckRhdGEpO1xuICBpZiAoaGFuZGxlci5zZXNzaW9uLnBhY2spIHtcbiAgICByZXR1cm4gW2hhbmRsZXIucmVzaGFwZVBhY2tlZChpbnB1dHNbMF0sIHJlc2hhcGVkRGltcyldO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbaGFuZGxlci5yZXNoYXBlVW5wYWNrZWQoaW5wdXRzWzBdLCByZXNoYXBlZERpbXMpXTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgQXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi8uLi8uLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHsgR3JhcGggfSBmcm9tICcuLi8uLi8uLi9ncmFwaCc7XG5pbXBvcnQgeyBPcGVyYXRvckltcGxlbWVudGF0aW9uLCBPcGVyYXRvckluaXRpYWxpemF0aW9uIH0gZnJvbSAnLi4vLi4vLi4vb3BlcmF0b3JzJztcbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQgeyBnZXRHbHNsIH0gZnJvbSAnLi4vZ2xzbC1zb3VyY2UnO1xuaW1wb3J0IHsgV2ViR0xJbmZlcmVuY2VIYW5kbGVyIH0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHsgUHJvZ3JhbUluZm8sIFRleHR1cmVUeXBlIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVwc2FtcGxlQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IG9wc2V0OiBudW1iZXI7XG4gIHJlYWRvbmx5IGlzUmVzaXplOiBib29sZWFuO1xuICByZWFkb25seSBtb2RlOiBzdHJpbmc7XG4gIHJlYWRvbmx5IHNjYWxlczogbnVtYmVyW107XG4gIHJlYWRvbmx5IGV4dHJhcG9sYXRpb25WYWx1ZTogbnVtYmVyO1xuICByZWFkb25seSBjb29yZGluYXRlVHJhbnNmb3JtTW9kZTogc3RyaW5nO1xuICByZWFkb25seSB1c2VFeHRyYXBvbGF0aW9uOiBib29sZWFuO1xuICByZWFkb25seSBuZWVkUm9pSW5wdXQ6IGJvb2xlYW47XG4gIHJlYWRvbmx5IG5lYXJlc3RNb2RlOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGN1YmljQ29lZmZpY2llbnRBOiBudW1iZXI7XG4gIHJlYWRvbmx5IGV4Y2x1ZGVPdXRzaWRlOiBib29sZWFuO1xuICByZWFkb25seSB1c2VOZWFyZXN0MnhPcHRpbWl6YXRpb246IGJvb2xlYW47XG4gIHJlYWRvbmx5IHJvaUlucHV0SWR4OiBudW1iZXI7XG4gIHJlYWRvbmx5IHNjYWxlc0lucHV0SWR4OiBudW1iZXI7XG4gIHJlYWRvbmx5IHNpemVzSW5wdXRJZHg6IG51bWJlcjtcbn1cblxuY29uc3QgdXBzYW1wbGVQcm9ncmFtTWV0YWRhdGEgPSB7XG4gIG5hbWU6ICdVcHNhbXBsZScsXG4gIGlucHV0TmFtZXM6IFsnWCddLFxuICBpbnB1dFR5cGVzOiBbVGV4dHVyZVR5cGUudW5wYWNrZWRdLFxufTtcblxuZXhwb3J0IGNvbnN0IHVwc2FtcGxlOiBPcGVyYXRvckltcGxlbWVudGF0aW9uPFVwc2FtcGxlQXR0cmlidXRlcz4gPSAoXG4gIGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXRzOiBUZW5zb3JbXSxcbiAgYXR0cmlidXRlczogVXBzYW1wbGVBdHRyaWJ1dGVzLFxuKTogVGVuc29yW10gPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMsIGF0dHJpYnV0ZXMpO1xuICBjb25zdCBvdXRwdXQgPSBpbmZlcmVuY2VIYW5kbGVyLnJ1bihcbiAgICB7XG4gICAgICAuLi51cHNhbXBsZVByb2dyYW1NZXRhZGF0YSxcbiAgICAgIGNhY2hlSGludDogYXR0cmlidXRlcy5jYWNoZUtleSxcbiAgICAgIGdldDogKCkgPT4gY3JlYXRlVXBzYW1wbGVQcm9ncmFtSW5mbyhpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMsIGF0dHJpYnV0ZXMpLFxuICAgIH0sXG4gICAgaW5wdXRzLFxuICApO1xuICByZXR1cm4gW291dHB1dF07XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXNWNzogT3BlcmF0b3JJbml0aWFsaXphdGlvbjxVcHNhbXBsZUF0dHJpYnV0ZXM+ID0gKFxuICBub2RlOiBHcmFwaC5Ob2RlLFxuKTogVXBzYW1wbGVBdHRyaWJ1dGVzID0+IHBhcnNlVXBzYW1wbGVBdHRyaWJ1dGVzKG5vZGUsIDcpO1xuXG5leHBvcnQgY29uc3QgcGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXNWOTogT3BlcmF0b3JJbml0aWFsaXphdGlvbjxVcHNhbXBsZUF0dHJpYnV0ZXM+ID0gKFxuICBub2RlOiBHcmFwaC5Ob2RlLFxuKTogVXBzYW1wbGVBdHRyaWJ1dGVzID0+IHBhcnNlVXBzYW1wbGVBdHRyaWJ1dGVzKG5vZGUsIDkpO1xuXG5leHBvcnQgY29uc3QgcGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXMgPSAobm9kZTogR3JhcGguTm9kZSwgb3BzZXQ6IG51bWJlcik6IFVwc2FtcGxlQXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IGlzUmVzaXplID0gb3BzZXQgPj0gMTA7XG5cbiAgLy8gcHJvY2Vzc2luZyBub2RlIGF0dHJpYnV0ZXNcbiAgY29uc3QgbW9kZSA9IG5vZGUuYXR0cmlidXRlcy5nZXRTdHJpbmcoJ21vZGUnLCAnbmVhcmVzdCcpO1xuICBpZiAobW9kZSAhPT0gJ25lYXJlc3QnICYmIG1vZGUgIT09ICdsaW5lYXInICYmIChvcHNldCA8IDExIHx8IG1vZGUgIT09ICdjdWJpYycpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGB1bnJlY29nbml6ZWQgbW9kZTogJHttb2RlfWApO1xuICB9XG5cbiAgbGV0IHNjYWxlczogbnVtYmVyW10gPSBbXTtcbiAgaWYgKG9wc2V0IDwgOSkge1xuICAgIHNjYWxlcyA9IG5vZGUuYXR0cmlidXRlcy5nZXRGbG9hdHMoJ3NjYWxlcycpO1xuICAgIHNjYWxlc1ZhbGlkYXRpb24oc2NhbGVzLCBtb2RlLCBpc1Jlc2l6ZSk7XG4gIH1cblxuICBjb25zdCBleHRyYXBvbGF0aW9uVmFsdWUgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0RmxvYXQoJ2V4dHJhcG9sYXRpb25fdmFsdWUnLCAwLjApO1xuXG4gIGNvbnN0IGNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlID1cbiAgICBvcHNldCA+IDEwID8gbm9kZS5hdHRyaWJ1dGVzLmdldFN0cmluZygnY29vcmRpbmF0ZV90cmFuc2Zvcm1hdGlvbl9tb2RlJywgJ2hhbGZfcGl4ZWwnKSA6ICdhc3ltbWV0cmljJztcbiAgaWYgKFxuICAgIFtcbiAgICAgICdhc3ltbWV0cmljJyxcbiAgICAgICdweXRvcmNoX2hhbGZfcGl4ZWwnLFxuICAgICAgJ3RmX2hhbGZfcGl4ZWxfZm9yX25uJyxcbiAgICAgICdhbGlnbl9jb3JuZXJzJyxcbiAgICAgICd0Zl9jcm9wX2FuZF9yZXNpemUnLFxuICAgICAgJ2hhbGZfcGl4ZWwnLFxuICAgIF0uaW5kZXhPZihjb29yZGluYXRlVHJhbnNmb3JtTW9kZSkgPT09IC0xXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcihgY29vcmRpbmF0ZV90cmFuc2Zvcm1fbW9kZSAnJHtjb29yZGluYXRlVHJhbnNmb3JtTW9kZX0nIGlzIG5vdCBzdXBwb3J0ZWRgKTtcbiAgfVxuICBjb25zdCBuZWVkUm9pSW5wdXQgPSBjb29yZGluYXRlVHJhbnNmb3JtTW9kZSA9PT0gJ3RmX2Nyb3BfYW5kX3Jlc2l6ZSc7XG4gIGNvbnN0IHVzZUV4dHJhcG9sYXRpb24gPSBuZWVkUm9pSW5wdXQ7XG5cbiAgY29uc3QgbmVhcmVzdE1vZGUgPVxuICAgIG1vZGUgPT09ICduZWFyZXN0JyAmJiBvcHNldCA+PSAxMSA/IG5vZGUuYXR0cmlidXRlcy5nZXRTdHJpbmcoJ25lYXJlc3RfbW9kZScsICdyb3VuZF9wcmVmZXJfZmxvb3InKSA6ICcnO1xuICBpZiAoWydyb3VuZF9wcmVmZXJfZmxvb3InLCAncm91bmRfcHJlZmVyX2NlaWwnLCAnZmxvb3InLCAnY2VpbCcsICcnXS5pbmRleE9mKG5lYXJlc3RNb2RlKSA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYG5lYXJlc3RfbW9kZSAnJHtuZWFyZXN0TW9kZX0nIGlzIG5vdCBzdXBwb3J0ZWRgKTtcbiAgfVxuXG4gIGNvbnN0IGN1YmljQ29lZmZpY2llbnRBID0gbm9kZS5hdHRyaWJ1dGVzLmdldEZsb2F0KCdjdWJpY19jb2VmZl9hJywgLTAuNzUpO1xuICBjb25zdCBleGNsdWRlT3V0c2lkZSA9IG5vZGUuYXR0cmlidXRlcy5nZXRJbnQoJ2V4Y2x1ZGVfb3V0c2lkZScsIDApICE9PSAwO1xuICBpZiAoZXhjbHVkZU91dHNpZGUgJiYgbW9kZSAhPT0gJ2N1YmljJykge1xuICAgIHRocm93IG5ldyBFcnJvcignZXhjbHVkZV9vdXRzaWRlIGNhbiBiZSBzZXQgdG8gMSBvbmx5IHdoZW4gbW9kZSBpcyBDVUJJQy4nKTtcbiAgfVxuXG4gIGNvbnN0IHVzZU5lYXJlc3QyeE9wdGltaXphdGlvbiA9XG4gICAgb3BzZXQgPCAxMSA/IHRydWUgOiBtb2RlID09PSAnbmVhcmVzdCcgJiYgY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUgPT09ICdhc3ltbWV0cmljJyAmJiBuZWFyZXN0TW9kZSA9PT0gJ2Zsb29yJztcblxuICBsZXQgcm9pSW5wdXRJZHggPSAwO1xuICBsZXQgc2NhbGVzSW5wdXRJZHggPSAwO1xuICBsZXQgc2l6ZXNJbnB1dElkeCA9IDA7XG5cbiAgaWYgKG9wc2V0ID4gMTApIHtcbiAgICAvLyBoYW5kbGUgd2hlbiByb2lJbnB1dCBpcyBub3QgZ2l2ZW5cbiAgICBpZiAobm9kZS5pbnB1dHMubGVuZ3RoID4gMikge1xuICAgICAgcm9pSW5wdXRJZHggPSAxO1xuICAgICAgc2NhbGVzSW5wdXRJZHggPSAyO1xuICAgICAgc2l6ZXNJbnB1dElkeCA9IDM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjYWxlc0lucHV0SWR4ID0gMTtcbiAgICAgIHNpemVzSW5wdXRJZHggPSAyO1xuICAgIH1cbiAgfSBlbHNlIGlmIChvcHNldCA9PT0gOSkge1xuICAgIHNjYWxlc0lucHV0SWR4ID0gMTtcbiAgfVxuXG4gIHJldHVybiBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe1xuICAgIG9wc2V0LFxuICAgIGlzUmVzaXplLFxuICAgIG1vZGUsXG4gICAgc2NhbGVzLFxuICAgIGV4dHJhcG9sYXRpb25WYWx1ZSxcbiAgICBjb29yZGluYXRlVHJhbnNmb3JtTW9kZSxcbiAgICB1c2VFeHRyYXBvbGF0aW9uLFxuICAgIG5lZWRSb2lJbnB1dCxcbiAgICBuZWFyZXN0TW9kZSxcbiAgICBjdWJpY0NvZWZmaWNpZW50QSxcbiAgICBleGNsdWRlT3V0c2lkZSxcbiAgICB1c2VOZWFyZXN0MnhPcHRpbWl6YXRpb24sXG4gICAgcm9pSW5wdXRJZHgsXG4gICAgc2NhbGVzSW5wdXRJZHgsXG4gICAgc2l6ZXNJbnB1dElkeCxcbiAgfSk7XG59O1xuXG5jb25zdCBjcmVhdGVVcHNhbXBsZVByb2dyYW1JbmZvID0gKFxuICBpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsXG4gIGlucHV0czogVGVuc29yW10sXG4gIGF0dHJpYnV0ZXM6IFVwc2FtcGxlQXR0cmlidXRlcyxcbik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgZ2xzbCA9IGdldEdsc2woaW5mZXJlbmNlSGFuZGxlci5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pO1xuICBjb25zdCBbaW5wdXRXaWR0aCwgaW5wdXRIZWlnaHRdID0gaW5mZXJlbmNlSGFuZGxlci5jYWxjdWxhdGVUZXh0dXJlV2lkdGhBbmRIZWlnaHQoXG4gICAgaW5wdXRzWzBdLmRpbXMsXG4gICAgVGV4dHVyZVR5cGUudW5wYWNrZWQsXG4gICk7XG5cbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcy5tYXAoKGRpbSwgaSkgPT4gTWF0aC5mbG9vcihkaW0gKiBhdHRyaWJ1dGVzLnNjYWxlc1tpXSkpO1xuICBjb25zdCBbb3V0cHV0V2lkdGgsIG91dHB1dEhlaWdodF0gPSBpbmZlcmVuY2VIYW5kbGVyLmNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodChcbiAgICBvdXRwdXRTaGFwZSxcbiAgICBUZXh0dXJlVHlwZS51bnBhY2tlZCxcbiAgKTtcbiAgY29uc3QgZGltID0gb3V0cHV0U2hhcGUubGVuZ3RoO1xuXG4gIGNvbnN0IG91dHB1dFBpdGNoZXMgPSBuZXcgQXJyYXk8bnVtYmVyPihkaW0pO1xuICBjb25zdCBpbnB1dFBpdGNoZXMgPSBuZXcgQXJyYXk8bnVtYmVyPihkaW0pO1xuICBsZXQgcHJlY2FsY3VsYXRlZFBpdGNoZXMgPSBgXG4gICAgICBpbnQgb3V0cHV0X3BpdGNoZXNbJHtkaW19XTtcbiAgICAgIGludCBpbnB1dF9waXRjaGVzWyR7ZGltfV07XG4gICAgICBgO1xuICBmb3IgKGxldCBkID0gZGltIC0gMTsgZCA+PSAwOyBkLS0pIHtcbiAgICBvdXRwdXRQaXRjaGVzW2RdID0gZCA9PT0gZGltIC0gMSA/IDEgOiBvdXRwdXRQaXRjaGVzW2QgKyAxXSAqIG91dHB1dFNoYXBlW2QgKyAxXTtcbiAgICBpbnB1dFBpdGNoZXNbZF0gPSBkID09PSBkaW0gLSAxID8gMSA6IGlucHV0UGl0Y2hlc1tkICsgMV0gKiBpbnB1dHNbMF0uZGltc1tkICsgMV07XG5cbiAgICBwcmVjYWxjdWxhdGVkUGl0Y2hlcyArPSBgXG4gICAgICAgIG91dHB1dF9waXRjaGVzWyR7ZH1dID0gJHtvdXRwdXRQaXRjaGVzW2RdfTtcbiAgICAgICAgaW5wdXRfcGl0Y2hlc1ske2R9XSA9ICR7aW5wdXRQaXRjaGVzW2RdfTtcbiAgICAgICAgYDtcbiAgfVxuICBjb25zdCBnZXRJbnB1dEZsb2F0RnVuY3Rpb24gPSBgXG4gICAgICBmbG9hdCBnZXRJbnB1dEZsb2F0KGludCBpbmRleCkge1xuICAgICAgICB2ZWMyIGNvb3JkcyA9IG9mZnNldFRvQ29vcmRzKGluZGV4LCAke2lucHV0V2lkdGh9LCAke2lucHV0SGVpZ2h0fSk7XG4gICAgICAgIGZsb2F0IHZhbHVlID0gZ2V0Q29sb3JBc0Zsb2F0KCR7Z2xzbC50ZXh0dXJlMkR9KFgsIGNvb3JkcykpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBgO1xuXG4gIGNvbnN0IHNoYWRlclNvdXJjZSA9XG4gICAgYXR0cmlidXRlcy5tb2RlID09PSAnbmVhcmVzdCdcbiAgICAgID8gLy8gbmVhcmVzdFxuICAgICAgICBgXG4gICAgJHtnZXRJbnB1dEZsb2F0RnVuY3Rpb259XG4gICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske2RpbX1dKSB7XG4gICAgICBpbnQgaW5wdXRfaW5kZXggPSAwO1xuICAgICAgaW50IG91dHB1dF9pbmRleCA9IGNvb3Jkc1RvT2Zmc2V0KFRleENvb3JkcywgJHtvdXRwdXRXaWR0aH0sICR7b3V0cHV0SGVpZ2h0fSk7XG5cbiAgICAgICR7cHJlY2FsY3VsYXRlZFBpdGNoZXN9XG5cbiAgICAgIGludCBkLCBtO1xuICAgICAgZm9yIChpbnQgZGltID0gMDsgZGltIDwgJHtkaW19OyArK2RpbSkge1xuICAgICAgICBkID0gb3V0cHV0X2luZGV4IC8gb3V0cHV0X3BpdGNoZXNbZGltXTtcbiAgICAgICAgbSA9IG91dHB1dF9pbmRleCAtIGQgKiBvdXRwdXRfcGl0Y2hlc1tkaW1dO1xuICAgICAgICBvdXRwdXRfaW5kZXggPSBtO1xuXG4gICAgICAgIGlmIChzY2FsZXNbZGltXSAhPSAxICYmIGQgPiAwKSB7XG4gICAgICAgICAgaW50IGQyID0gZCAvIHNjYWxlc1tkaW1dO1xuICAgICAgICAgIG0gPSBkIC0gZDIgKiBzY2FsZXNbZGltXTtcbiAgICAgICAgICBkID0gZDI7XG4gICAgICAgIH1cbiAgICAgICAgaW5wdXRfaW5kZXggKz0gaW5wdXRfcGl0Y2hlc1tkaW1dICogZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdldElucHV0RmxvYXQoaW5wdXRfaW5kZXgpO1xuICAgIH1gXG4gICAgICA6IGRpbSA9PT0gNFxuICAgICAgICA/IC8vIGJpbGluZWFyIDREXG4gICAgICAgICAgYFxuICAgICR7Z2V0SW5wdXRGbG9hdEZ1bmN0aW9ufVxuICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbNF0pIHtcbiAgICAgIGludCBpbnB1dF9pbmRleCA9IDA7XG4gICAgICBpbnQgb3V0cHV0X2luZGV4ID0gY29vcmRzVG9PZmZzZXQoVGV4Q29vcmRzLCAke291dHB1dFdpZHRofSwgJHtvdXRwdXRIZWlnaHR9KTtcblxuICAgICAgJHtwcmVjYWxjdWxhdGVkUGl0Y2hlc31cblxuICAgICAgaW50IG07XG4gICAgICBpbnQgaW5kZXhfb2ZfZGltMCwgaW5kZXhfb2ZfZGltMSwgaW5kZXhfb2ZfZGltMiwgaW5kZXhfb2ZfZGltMztcbiAgICAgIGluZGV4X29mX2RpbTAgPSBvdXRwdXRfaW5kZXggLyBvdXRwdXRfcGl0Y2hlc1swXTtcbiAgICAgIG0gPSBvdXRwdXRfaW5kZXggLSBpbmRleF9vZl9kaW0wICogb3V0cHV0X3BpdGNoZXNbMF07XG4gICAgICBpbmRleF9vZl9kaW0xID0gbSAvIG91dHB1dF9waXRjaGVzWzFdO1xuICAgICAgbSA9IG0gLSBpbmRleF9vZl9kaW0xICogb3V0cHV0X3BpdGNoZXNbMV07XG4gICAgICBpbmRleF9vZl9kaW0yID0gbSAvIG91dHB1dF9waXRjaGVzWzJdO1xuICAgICAgbSA9IG0gLSBpbmRleF9vZl9kaW0yICogb3V0cHV0X3BpdGNoZXNbMl07XG4gICAgICBpbmRleF9vZl9kaW0zID0gbTtcblxuICAgICAgaW50IGluZGV4X29mX2lucHV0X2RpbTIsIGluZGV4X29mX2lucHV0X2RpbTMsIHhfb2Zmc2V0LCB5X29mZnNldDtcbiAgICAgIGluZGV4X29mX2lucHV0X2RpbTIgPSBpbmRleF9vZl9kaW0yIC8gc2NhbGVzWzJdO1xuICAgICAgeV9vZmZzZXQgPSBpbmRleF9vZl9kaW0yIC0gaW5kZXhfb2ZfaW5wdXRfZGltMiAqIHNjYWxlc1syXTtcbiAgICAgIGluZGV4X29mX2lucHV0X2RpbTMgPSBpbmRleF9vZl9kaW0zIC8gc2NhbGVzWzNdO1xuICAgICAgeF9vZmZzZXQgPSBpbmRleF9vZl9kaW0zIC0gaW5kZXhfb2ZfaW5wdXRfZGltMyAqIHNjYWxlc1szXTtcblxuICAgICAgaW5wdXRfaW5kZXggPSBpbmRleF9vZl9kaW0wICogaW5wdXRfcGl0Y2hlc1swXSArXG4gICAgICAgICAgICBpbmRleF9vZl9kaW0xICogaW5wdXRfcGl0Y2hlc1sxXSArXG4gICAgICAgICAgICBpbmRleF9vZl9pbnB1dF9kaW0yICogaW5wdXRfcGl0Y2hlc1syXSArXG4gICAgICAgICAgICBpbmRleF9vZl9pbnB1dF9kaW0zO1xuXG4gICAgICBmbG9hdCB4MDAgPSBnZXRJbnB1dEZsb2F0KGlucHV0X2luZGV4KTtcbiAgICAgIGZsb2F0IHgxMCwgeDAxLCB4MTE7XG5cbiAgICAgIGJvb2wgZW5kX29mX2RpbTIgPSBmYWxzZTtcbiAgICAgIGlmIChpbmRleF9vZl9pbnB1dF9kaW0yID09ICgke2lucHV0c1swXS5kaW1zWzJdfSAtIDEpKSB7XG4gICAgICAgIC8vIEl0J3MgdGhlIGVuZCBpbiBkaW1lbnNpb24gMlxuICAgICAgICB4MDEgPSB4MDA7XG4gICAgICAgIGVuZF9vZl9kaW0yID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHgwMSA9IGdldElucHV0RmxvYXQoaW5wdXRfaW5kZXggKyBpbnB1dF9waXRjaGVzWzJdKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGluZGV4X29mX2lucHV0X2RpbTMgPT0gKGlucHV0X3BpdGNoZXNbMl0gLSAxKSkge1xuICAgICAgICAvLyBJdCdzIHRoZSBlbmQgaW4gZGltZW5zaW9uIDNcbiAgICAgICAgeDEwID0geDAwO1xuICAgICAgICB4MTEgPSB4MDE7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgeDEwID0gZ2V0SW5wdXRGbG9hdChpbnB1dF9pbmRleCArIDEpO1xuICAgICAgICB4MTEgPSBlbmRfb2ZfZGltMiA/IHgxMCA6IGdldElucHV0RmxvYXQoaW5wdXRfaW5kZXggKyBpbnB1dF9waXRjaGVzWzJdICsgMSk7XG4gICAgICB9XG5cbiAgICAgIGZsb2F0IHkwID0geDAwICsgZmxvYXQoeV9vZmZzZXQpICogKHgwMSAtIHgwMCkgLyBmbG9hdChzY2FsZXNbMl0pO1xuICAgICAgZmxvYXQgeTEgPSB4MTAgKyBmbG9hdCh5X29mZnNldCkgKiAoeDExIC0geDEwKSAvIGZsb2F0KHNjYWxlc1syXSk7XG4gICAgICByZXR1cm4geTAgKyBmbG9hdCh4X29mZnNldCkgKiAoeTEgLSB5MCkgLyBmbG9hdChzY2FsZXNbM10pO1xuICAgIH1gXG4gICAgICAgIDogLy8gYmlsaW5lYXIgMkRcbiAgICAgICAgICBgXG4gICAgJHtnZXRJbnB1dEZsb2F0RnVuY3Rpb259XG4gICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1syXSkge1xuICAgICAgaW50IGlucHV0X2luZGV4ID0gMDtcbiAgICAgIGludCBvdXRwdXRfaW5kZXggPSBjb29yZHNUb09mZnNldChUZXhDb29yZHMsICR7b3V0cHV0V2lkdGh9LCAke291dHB1dEhlaWdodH0pO1xuXG4gICAgICAke3ByZWNhbGN1bGF0ZWRQaXRjaGVzfVxuXG4gICAgICBpbnQgbTtcbiAgICAgIGludCBpbmRleF9vZl9kaW0wLCBpbmRleF9vZl9kaW0xO1xuICAgICAgaW5kZXhfb2ZfZGltMCA9IG91dHB1dF9pbmRleCAvIG91dHB1dF9waXRjaGVzWzBdO1xuICAgICAgbSA9IG91dHB1dF9pbmRleCAtIGluZGV4X29mX2RpbTAgKiBvdXRwdXRfcGl0Y2hlc1swXTtcbiAgICAgIGluZGV4X29mX2RpbTEgPSBtO1xuXG4gICAgICBpbnQgaW5kZXhfb2ZfaW5wdXRfZGltMCwgaW5kZXhfb2ZfaW5wdXRfZGltMSwgeF9vZmZzZXQsIHlfb2Zmc2V0O1xuICAgICAgaW5kZXhfb2ZfaW5wdXRfZGltMCA9IGluZGV4X29mX2RpbTAgLyBzY2FsZXNbMF07XG4gICAgICB5X29mZnNldCA9IGluZGV4X29mX2RpbTAgLSBpbmRleF9vZl9pbnB1dF9kaW0wICogc2NhbGVzWzBdO1xuICAgICAgaW5kZXhfb2ZfaW5wdXRfZGltMSA9IGluZGV4X29mX2RpbTEgLyBzY2FsZXNbMV07XG4gICAgICB4X29mZnNldCA9IGluZGV4X29mX2RpbTEgLSBpbmRleF9vZl9pbnB1dF9kaW0xICogc2NhbGVzWzFdO1xuXG4gICAgICBpbnB1dF9pbmRleCA9IGluZGV4X29mX2lucHV0X2RpbTAgKiBpbnB1dF9waXRjaGVzWzBdICsgaW5kZXhfb2ZfaW5wdXRfZGltMTtcblxuICAgICAgZmxvYXQgeDAwID0gZ2V0SW5wdXRGbG9hdChpbnB1dF9pbmRleCk7XG4gICAgICBmbG9hdCB4MTAsIHgwMSwgeDExO1xuXG4gICAgICBib29sIGVuZF9vZl9kaW0wID0gZmFsc2U7XG4gICAgICBpZiAoaW5kZXhfb2ZfaW5wdXRfZGltMCA9PSAoJHtpbnB1dHNbMF0uZGltc1swXX0gLSAxKSkge1xuICAgICAgICAvLyBJdCdzIHRoZSBlbmQgaW4gZGltZW5zaW9uIDBcbiAgICAgICAgeDAxID0geDAwO1xuICAgICAgICBlbmRfb2ZfZGltMCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4MDEgPSBnZXRJbnB1dEZsb2F0KGlucHV0X2luZGV4ICsgaW5wdXRfcGl0Y2hlc1swXSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleF9vZl9pbnB1dF9kaW0xID09IChpbnB1dF9waXRjaGVzWzBdIC0gMSkpIHtcbiAgICAgICAgLy8gSXQncyB0aGUgZW5kIGluIGRpbWVuc2lvbiAxXG4gICAgICAgIHgxMCA9IHgwMDtcbiAgICAgICAgeDExID0geDAxO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHgxMCA9IGdldElucHV0RmxvYXQoaW5wdXRfaW5kZXggKyAxKTtcbiAgICAgICAgeDExID0gZW5kX29mX2RpbTAgPyB4MTAgOiBnZXRJbnB1dEZsb2F0KGlucHV0X2luZGV4ICsgaW5wdXRfcGl0Y2hlc1swXSArIDEpO1xuICAgICAgfVxuXG4gICAgICBmbG9hdCB5MCA9IHgwMCArIGZsb2F0KHlfb2Zmc2V0KSAqICh4MDEgLSB4MDApIC8gZmxvYXQoc2NhbGVzWzBdKTtcbiAgICAgIGZsb2F0IHkxID0geDEwICsgZmxvYXQoeV9vZmZzZXQpICogKHgxMSAtIHgxMCkgLyBmbG9hdChzY2FsZXNbMF0pO1xuICAgICAgcmV0dXJuIHkwICsgZmxvYXQoeF9vZmZzZXQpICogKHkxIC0geTApIC8gZmxvYXQoc2NhbGVzWzFdKTtcbiAgICB9YDtcbiAgcmV0dXJuIHtcbiAgICAuLi51cHNhbXBsZVByb2dyYW1NZXRhZGF0YSxcbiAgICBvdXRwdXQ6IHsgZGltczogb3V0cHV0U2hhcGUsIHR5cGU6IGlucHV0c1swXS50eXBlLCB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGUudW5wYWNrZWQgfSxcbiAgICBzaGFkZXJTb3VyY2UsXG4gICAgdmFyaWFibGVzOiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdzY2FsZXMnLFxuICAgICAgICB0eXBlOiAnaW50JyxcbiAgICAgICAgYXJyYXlMZW5ndGg6IGF0dHJpYnV0ZXMuc2NhbGVzLmxlbmd0aCxcbiAgICAgICAgZGF0YTogYXR0cmlidXRlcy5zY2FsZXMubWFwKCh4KSA9PiBNYXRoLmNlaWwoeCkpLFxuICAgICAgfSxcbiAgICBdLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogVGVuc29yW10sIGF0dHJpYnV0ZTogVXBzYW1wbGVBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGlmIChcbiAgICAhaW5wdXRzIHx8XG4gICAgKGF0dHJpYnV0ZS5vcHNldCA8IDkgJiYgaW5wdXRzLmxlbmd0aCAhPT0gMSkgfHxcbiAgICAoYXR0cmlidXRlLm9wc2V0ID49IDkgJiYgYXR0cmlidXRlLm9wc2V0IDwgMTEgJiYgaW5wdXRzLmxlbmd0aCAhPT0gMikgfHxcbiAgICAoYXR0cmlidXRlLm9wc2V0ID49IDExICYmIGlucHV0cy5sZW5ndGggPCAyKVxuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5wdXRzLicpO1xuICB9XG5cbiAgaWYgKGF0dHJpYnV0ZS5zY2FsZXMubGVuZ3RoID4gMCAmJiBpbnB1dHNbMF0uZGltcy5sZW5ndGggIT09IGF0dHJpYnV0ZS5zY2FsZXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0IHNoYXBlLicpO1xuICB9XG5cbiAgaWYgKGlucHV0c1swXS50eXBlID09PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCB0ZW5zb3IgdHlwZXMuJyk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBzY2FsZXNWYWxpZGF0aW9uID0gKHNjYWxlczogbnVtYmVyW10sIG1vZGU6IHN0cmluZywgaXNSZXNpemU6IGJvb2xlYW4pOiB2b2lkID0+IHtcbiAgaWYgKCFpc1Jlc2l6ZSkge1xuICAgIGZvciAoY29uc3Qgc2NhbGUgb2Ygc2NhbGVzKSB7XG4gICAgICBpZiAoc2NhbGUgPCAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2NhbGUgdmFsdWUgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxLicpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGNvbnN0IHNjYWxlIG9mIHNjYWxlcykge1xuICAgICAgaWYgKHNjYWxlIDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTY2FsZSB2YWx1ZSBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIDAuJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChtb2RlID09PSAnbGluZWFyJyB8fCBtb2RlID09PSAnY3ViaWMnKSB7XG4gICAgaWYgKHNjYWxlcy5sZW5ndGggIT09IDIgJiYgKHNjYWxlcy5sZW5ndGggIT09IDQgfHwgc2NhbGVzWzBdICE9PSAxIHx8IHNjYWxlc1sxXSAhPT0gMSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJ0xpbmVhcicgbW9kZSBhbmQgJ0N1YmljJyBtb2RlIG9ubHkgc3VwcG9ydCAyLUQgaW5wdXRzICgnQmlsaW5lYXInLCAnQmljdWJpYycpIFxcXG4gICAgICAgIG9yIDQtRCBpbnB1dHMgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBvdXRlcm1vc3QgMiBzY2FsZSB2YWx1ZXMgYmVpbmcgMSBcXFxuICAgICAgICBpbiB0aGUgJHtpc1Jlc2l6ZSA/ICdSZXNpemUnIDogJ1Vwc2FtcGxlJ30gb3BlYXJ0b3IuYCk7XG4gICAgfVxuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBHcmFwaCB9IGZyb20gJy4uLy4uLy4uL2dyYXBoJztcbmltcG9ydCB7IE9wZXJhdG9ySW1wbGVtZW50YXRpb24sIE9wZXJhdG9ySW5pdGlhbGl6YXRpb24gfSBmcm9tICcuLi8uLi8uLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgVGVuc29yIH0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7IGdldEdsc2wgfSBmcm9tICcuLi9nbHNsLXNvdXJjZSc7XG5pbXBvcnQgeyBXZWJHTEluZmVyZW5jZUhhbmRsZXIgfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQgeyBQcm9ncmFtSW5mbywgVGV4dHVyZVR5cGUgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBnZXRDb29yZHNEYXRhVHlwZSB9IGZyb20gJy4uL3V0aWxzJztcblxuaW1wb3J0IHsgdW5wYWNrRnJvbUNoYW5uZWwgfSBmcm9tICcuL3BhY2tpbmctdXRpbHMnO1xuaW1wb3J0IHsgcGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXMsIHNjYWxlc1ZhbGlkYXRpb24sIFVwc2FtcGxlQXR0cmlidXRlcywgdmFsaWRhdGVJbnB1dHMgfSBmcm9tICcuL3Vwc2FtcGxlJztcblxuY29uc3QgcmVzaXplUHJvZ3JhbU1ldGFkYXRhID0ge1xuICBuYW1lOiAnUmVzaXplJyxcbiAgaW5wdXROYW1lczogWydBJ10sXG4gIGlucHV0VHlwZXM6IFtUZXh0dXJlVHlwZS5wYWNrZWRdLFxufTtcblxuZXhwb3J0IGNvbnN0IHJlc2l6ZTogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxVcHNhbXBsZUF0dHJpYnV0ZXM+ID0gKFxuICBpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsXG4gIGlucHV0czogVGVuc29yW10sXG4gIGF0dHJpYnV0ZXM6IFVwc2FtcGxlQXR0cmlidXRlcyxcbik6IFRlbnNvcltdID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoaW5wdXRzLCBhdHRyaWJ1dGVzKTtcbiAgY29uc3Qgb3V0cHV0ID0gaW5mZXJlbmNlSGFuZGxlci5ydW4oXG4gICAge1xuICAgICAgLi4ucmVzaXplUHJvZ3JhbU1ldGFkYXRhLFxuICAgICAgY2FjaGVIaW50OiBhdHRyaWJ1dGVzLmNhY2hlS2V5LFxuICAgICAgZ2V0OiAoKSA9PiBjcmVhdGVQYWNrZWRSZXNpemVQcm9ncmFtSW5mbyhpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMsIGF0dHJpYnV0ZXMpLFxuICAgIH0sXG4gICAgaW5wdXRzLFxuICApO1xuICByZXR1cm4gW291dHB1dF07XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VSZXNpemVBdHRyaWJ1dGVzVjEwOiBPcGVyYXRvckluaXRpYWxpemF0aW9uPFVwc2FtcGxlQXR0cmlidXRlcz4gPSAoXG4gIG5vZGU6IEdyYXBoLk5vZGUsXG4pOiBVcHNhbXBsZUF0dHJpYnV0ZXMgPT4gcGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXMobm9kZSwgMTApO1xuXG5leHBvcnQgY29uc3QgcGFyc2VSZXNpemVBdHRyaWJ1dGVzVjExOiBPcGVyYXRvckluaXRpYWxpemF0aW9uPFVwc2FtcGxlQXR0cmlidXRlcz4gPSAoXG4gIG5vZGU6IEdyYXBoLk5vZGUsXG4pOiBVcHNhbXBsZUF0dHJpYnV0ZXMgPT4gcGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXMobm9kZSwgMTEpO1xuXG5jb25zdCBjcmVhdGVQYWNrZWRSZXNpemVQcm9ncmFtSW5mbyA9IChcbiAgaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBpbnB1dHM6IFRlbnNvcltdLFxuICBhdHRyaWJ1dGVzOiBVcHNhbXBsZUF0dHJpYnV0ZXMsXG4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGdsc2wgPSBnZXRHbHNsKGluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgY29uc3QgW3NjYWxlcywgb3V0cHV0U2hhcGVdID0gcHJlcGFyZUlucHV0cyhpbnB1dHMsIGF0dHJpYnV0ZXMpO1xuXG4gIGNvbnN0IGlzU2FtZSA9IHNjYWxlcy5ldmVyeSgoczogbnVtYmVyKSA9PiBzID09PSAxKSAmJiBhdHRyaWJ1dGVzLmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlICE9PSAndGZfY3JvcF9hbmRfcmVzaXplJztcbiAgaWYgKGlzU2FtZSkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5yZXNpemVQcm9ncmFtTWV0YWRhdGEsXG4gICAgICBvdXRwdXQ6IHsgZGltczogb3V0cHV0U2hhcGUsIHR5cGU6IGlucHV0c1swXS50eXBlLCB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGUucGFja2VkIH0sXG4gICAgICBoYXNNYWluOiB0cnVlLFxuICAgICAgc2hhZGVyU291cmNlOiBgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgICAgICAgICB2ZWM0IHYgPSAke2dsc2wudGV4dHVyZTJEfShYLCBUZXhDb29yZHMpO1xuICAgICAgICAgICAgICAgICAgICAke2dsc2wub3V0cHV0fSA9IHY7XG4gICAgICAgICAgICAgICAgfWAsXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IGRpbSA9IG91dHB1dFNoYXBlLmxlbmd0aDtcbiAgaWYgKGRpbSA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYG91dHB1dCBkaW1lbnNpb24gc2hvdWxkIGJlIGF0IGxlYXN0IDIsIGJ1dCBnb3QgJHtkaW19YCk7XG4gIH1cblxuICBjb25zdCBvdXRwdXRIZWlnaHQgPSBvdXRwdXRTaGFwZVtkaW0gLSAyXTtcbiAgY29uc3Qgb3V0cHV0V2lkdGggPSBvdXRwdXRTaGFwZVtkaW0gLSAxXTtcblxuICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gIGlmIChkaW0gIT09IGlucHV0U2hhcGUubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBvdXRwdXQgZGltZW5zaW9uIHNob3VsZCBtYXRjaCBpbnB1dCAke2lucHV0U2hhcGUubGVuZ3RofSwgYnV0IGdvdCAke2RpbX1gKTtcbiAgfVxuICBjb25zdCBpbnB1dEhlaWdodCA9IGlucHV0U2hhcGVbZGltIC0gMl07XG4gIGNvbnN0IGlucHV0V2lkdGggPSBpbnB1dFNoYXBlW2RpbSAtIDFdO1xuXG4gIGNvbnN0IHNjYWxlc0hlaWdodCA9IHNjYWxlc1tkaW0gLSAyXTtcbiAgY29uc3Qgc2NhbGVzV2lkdGggPSBzY2FsZXNbZGltIC0gMV07XG5cbiAgbGV0IGdldFNvdXJjZUZyYWNJbmRleCA9ICcnO1xuXG4gIGlmIChhdHRyaWJ1dGVzLm1vZGUgIT09ICdsaW5lYXInKSB7XG4gICAgLy8gVE9ETzogc3VwcG9ydCBvdGhlciBtb2Rlc1xuICAgIHRocm93IG5ldyBFcnJvcihgcmVzaXplIChwYWNrZWQpIGRvZXMgbm90IHN1cHBvcnQgbW9kZTogJyR7YXR0cmlidXRlcy5tb2RlfSdgKTtcbiAgfVxuICBzd2l0Y2ggKGF0dHJpYnV0ZXMuY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUpIHtcbiAgICBjYXNlICdhc3ltbWV0cmljJzpcbiAgICAgIGdldFNvdXJjZUZyYWNJbmRleCA9IGBcbiAgICAgICAgICAgICAgICAgICAgdmVjNCBnZXRTb3VyY2VGcmFjSW5kZXgoaXZlYzQgY29vcmRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmVjNChjb29yZHMpIC8gc2NhbGVXSFdIO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2hhbGZfcGl4ZWwnOlxuICAgICAgZ2V0U291cmNlRnJhY0luZGV4ID0gYFxuICAgICAgICAgICAgICAgICAgICB2ZWM0IGdldFNvdXJjZUZyYWNJbmRleChpdmVjNCBjb29yZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAodmVjNChjb29yZHMpICsgMC41KSAvIHNjYWxlV0hXSCAtIDAuNTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGA7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdweXRvcmNoX2hhbGZfcGl4ZWwnOlxuICAgICAgZ2V0U291cmNlRnJhY0luZGV4ID0gYFxuICAgICAgICAgICAgICAgICAgICB2ZWM0IGdldFNvdXJjZUZyYWNJbmRleChpdmVjNCBjb29yZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzQgZmNvb3JkcyA9IHZlYzQoY29vcmRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2ZWM0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR7b3V0cHV0V2lkdGh9LjAgPiAxLjAgPyAoZmNvb3Jkcy54ICsgMC41KSAvIHNjYWxlV0hXSC54IC0gMC41IDogMC4wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR7b3V0cHV0SGVpZ2h0fS4wID4gMS4wID8gKGZjb29yZHMueSArIDAuNSkgLyBzY2FsZVdIV0gueSAtIDAuNSA6IDAuMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAke291dHB1dFdpZHRofS4wID4gMS4wID8gKGZjb29yZHMueiArIDAuNSkgLyBzY2FsZVdIV0gueiAtIDAuNSA6IDAuMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAke291dHB1dEhlaWdodH0uMCA+IDEuMCA/IChmY29vcmRzLncgKyAwLjUpIC8gc2NhbGVXSFdILncgLSAwLjUgOiAwLjBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGA7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdhbGlnbl9jb3JuZXJzJzpcbiAgICAgIGdldFNvdXJjZUZyYWNJbmRleCA9IGBcbiAgICAgICAgICAgICAgICAgICAgdmVjNCBnZXRTb3VyY2VGcmFjSW5kZXgoaXZlYzQgY29vcmRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWM0IHJlc2l6ZWQgPSB2ZWM0KCR7b3V0cHV0V2lkdGh9LjAgLSAxLjAsICR7b3V0cHV0SGVpZ2h0fS4wIC0gMS4wLCAke291dHB1dFdpZHRofS4wIC0gMS4wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR7b3V0cHV0SGVpZ2h0fS4wIC0gMS4wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzQgb3JpZ2luYWwgPSB2ZWM0KCR7aW5wdXRXaWR0aH0uMCAtIDEuMCwgJHtpbnB1dEhlaWdodH0uMCAtIDEuMCwgJHtpbnB1dFdpZHRofS4wIC0gMS4wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR7aW5wdXRIZWlnaHR9LjAgLSAxLjApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmVjNCBuZXdfc2NhbGUgPSBvcmlnaW5hbCAvIHJlc2l6ZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmVjNChjb29yZHMpICogbmV3X3NjYWxlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYDtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBUT0RPOnN1cHBvcnRpbmcgb3RoZXIgY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGVzXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHJlc2l6ZSAocGFja2VkKSBkb2VzIG5vdCBzdXBwb3J0IGNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlOiBcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJHthdHRyaWJ1dGVzLmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlfSdgKTtcbiAgfVxuXG4gIGNvbnN0IGNvb3Jkc0RhdGFUeXBlID0gZ2V0Q29vcmRzRGF0YVR5cGUoZGltKTtcbiAgY29uc3QgdW5wYWNrQ2hhbm5lbCA9IHVucGFja0Zyb21DaGFubmVsKCk7XG4gIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgICAgICAgIGNvbnN0IHZlYzIgaW5wdXRXSCA9IHZlYzIoJHtpbnB1dEhlaWdodH0uMCwgJHtpbnB1dFdpZHRofS4wKTtcbiAgICAgICAgICAgIGNvbnN0IHZlYzQgc2NhbGVXSFdIID0gdmVjNChmbG9hdCgke3NjYWxlc0hlaWdodH0pLCBmbG9hdCgke3NjYWxlc1dpZHRofSksIGZsb2F0KCR7c2NhbGVzSGVpZ2h0fSksIGZsb2F0KCR7XG4gICAgICAgICAgICAgIHNjYWxlc1dpZHRoXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAke3VucGFja0NoYW5uZWx9XG4gICAgICAgICAgICAke2dldFNvdXJjZUZyYWNJbmRleH1cbiAgICAgICAgICAgIGZsb2F0IGdldEFWYWx1ZShpbnQgeDEwLCBpbnQgciwgaW50IGMsIGludCBkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldENoYW5uZWwoZ2V0QSh4MTAsIHIsIGMsIGQpLCB2ZWMyKGMsIGQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICAgICAgICAke2Nvb3Jkc0RhdGFUeXBlfSByYyA9IGdldE91dHB1dENvb3JkcygpO1xuXG4gICAgICAgICAgICAgICAgaW50IGJhdGNoID0gcmNbMF07XG4gICAgICAgICAgICAgICAgaW50IGRlcHRoID0gcmNbMV07XG5cbiAgICAgICAgICAgICAgICAvLyByZXRyaWV2ZSB0aGUgNCBjb29yZGluYXRlcyB0aGF0IGlzIHVzZWQgaW4gdGhlIDQgcGFja2VkIG91dHB1dCB2YWx1ZXMuXG4gICAgICAgICAgICAgICAgaXZlYzQgY29vcmRzID0gaXZlYzQocmMud3osIHJjLncgKyAxLCByYy56ICsgMSk7XG5cbiAgICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIHNvdXJjZSBpbmRleCBpbiBmcmFjdGlvblxuICAgICAgICAgICAgICAgIHZlYzQgc291cmNlRnJhYyA9IGdldFNvdXJjZUZyYWNJbmRleChjb29yZHMpO1xuXG4gICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBsb3dlciBhbmQgdXBwZXIgYm91bmQgb2YgdGhlIDQgdmFsdWVzIHRoYXQgd2lsbCBiZSBwYWNrZWQgaW50byBvbmUgdGV4ZWwuXG4gICAgICAgICAgICAgICAgaXZlYzQgeDAwID0gaXZlYzQobWF4KHNvdXJjZUZyYWMueHksIHZlYzIoMC4wKSksIG1pbihpbnB1dFdIIC0gMS4wLCBjZWlsKHNvdXJjZUZyYWMueHkpKSk7XG4gICAgICAgICAgICAgICAgaXZlYzQgeDAxID0gaXZlYzQobWF4KHNvdXJjZUZyYWMueHcsIHZlYzIoMC4wKSksIG1pbihpbnB1dFdIIC0gMS4wLCBjZWlsKHNvdXJjZUZyYWMueHcpKSk7XG4gICAgICAgICAgICAgICAgaXZlYzQgeDEwID0gaXZlYzQobWF4KHNvdXJjZUZyYWMuenksIHZlYzIoMC4wKSksIG1pbihpbnB1dFdIIC0gMS4wLCBjZWlsKHNvdXJjZUZyYWMuenkpKSk7XG4gICAgICAgICAgICAgICAgaXZlYzQgeDExID0gaXZlYzQobWF4KHNvdXJjZUZyYWMuencsIHZlYzIoMC4wKSksIG1pbihpbnB1dFdIIC0gMS4wLCBjZWlsKHNvdXJjZUZyYWMuencpKSk7XG5cbiAgICAgICAgICAgICAgICBib29sIGhhc05leHRSb3cgPSByYy53IDwgJHtvdXRwdXRIZWlnaHQgLSAxfTtcbiAgICAgICAgICAgICAgICBib29sIGhhc05leHRDb2wgPSByYy56IDwgJHtvdXRwdXRXaWR0aCAtIDF9O1xuXG4gICAgICAgICAgICAgICAgLy8gcGFjayB4MDAsIHgwMSwgeDEwLCB4MTEncyB0b3AtbGVmdCBjb3JuZXIgaW50byBvbmUgdmVjNCBzdHJ1Y3R1cmVcbiAgICAgICAgICAgICAgICB2ZWM0IHRvcExlZnQgPSB2ZWM0KFxuICAgICAgICAgICAgICAgICAgICBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MDAueCwgeDAwLnkpLFxuICAgICAgICAgICAgICAgICAgICBoYXNOZXh0Q29sID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDAxLngsIHgwMS55KSA6IDAuMCxcbiAgICAgICAgICAgICAgICAgICAgaGFzTmV4dFJvdyA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgxMC54LCB4MTAueSkgOiAwLjAsXG4gICAgICAgICAgICAgICAgICAgIChoYXNOZXh0Um93ICYmIGhhc05leHRDb2wpID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDExLngsIHgxMS55KSA6IDAuMCk7XG5cbiAgICAgICAgICAgICAgICAvLyBwYWNrIHgwMCwgeDAxLCB4MTAsIHgxMSdzIHRvcC1yaWdodCBjb3JuZXIgaW50byBvbmUgdmVjNCBzdHJ1Y3R1cmVcbiAgICAgICAgICAgICAgICB2ZWM0IHRvcFJpZ2h0ID0gdmVjNChcbiAgICAgICAgICAgICAgICAgICAgZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDAwLngsIHgwMC53KSxcbiAgICAgICAgICAgICAgICAgICAgaGFzTmV4dENvbCA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgwMS54LCB4MDEudykgOiAwLjAsXG4gICAgICAgICAgICAgICAgICAgIGhhc05leHRSb3cgPyBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MTAueCwgeDEwLncpIDogMC4wLFxuICAgICAgICAgICAgICAgICAgICAoaGFzTmV4dFJvdyAmJiBoYXNOZXh0Q29sKSA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgxMS54LCB4MTEudykgOiAwLjApO1xuXG4gICAgICAgICAgICAgICAgLy8gcGFjayB4MDAsIHgwMSwgeDEwLCB4MTEncyBib3R0b20tbGVmdCBjb3JuZXIgaW50byBvbmUgdmVjNCBzdHJ1Y3R1cmVcbiAgICAgICAgICAgICAgICB2ZWM0IGJvdHRvbUxlZnQgPSB2ZWM0KFxuICAgICAgICAgICAgICAgICAgICBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MDAueiwgeDAwLnkpLFxuICAgICAgICAgICAgICAgICAgICBoYXNOZXh0Q29sID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDAxLnosIHgwMS55KSA6IDAuMCxcbiAgICAgICAgICAgICAgICAgICAgaGFzTmV4dFJvdyA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgxMC56LCB4MTAueSkgOiAwLjAsXG4gICAgICAgICAgICAgICAgICAgIChoYXNOZXh0Um93ICYmIGhhc05leHRDb2wpID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDExLnosIHgxMS55KSA6IDAuMCk7XG5cbiAgICAgICAgICAgICAgICAvLyBwYWNrIHgwMCwgeDAxLCB4MTAsIHgxMSdzIGJvdHRvbS1yaWdodCBjb3JuZXIgaW50byBvbmUgdmVjNCBzdHJ1Y3R1cmVcbiAgICAgICAgICAgICAgICB2ZWM0IGJvdHRvbVJpZ2h0ID0gdmVjNChcbiAgICAgICAgICAgICAgICAgICAgZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDAwLnosIHgwMC53KSxcbiAgICAgICAgICAgICAgICAgICAgaGFzTmV4dENvbCA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgwMS56LCB4MDEudykgOiAwLjAsXG4gICAgICAgICAgICAgICAgICAgIGhhc05leHRSb3cgPyBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MTAueiwgeDEwLncpIDogMC4wLFxuICAgICAgICAgICAgICAgICAgICAoaGFzTmV4dFJvdyAmJiBoYXNOZXh0Q29sKSA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgxMS56LCB4MTEudykgOiAwLjApO1xuXG4gICAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBpbnRlcnBvbGF0aW9uIGZyYWN0aW9uIG9uIHUgYW5kIHYgZGlyZWN0aW9uXG4gICAgICAgICAgICAgICAgdmVjNCBmcmFjID0gdmVjNChzb3VyY2VGcmFjKSAtIGZsb29yKHNvdXJjZUZyYWMpO1xuICAgICAgICAgICAgICAgIHZlYzQgY2xhbXBGcmFjID0gY2xhbXAoZnJhYywgdmVjNCgwLjApLCB2ZWM0KDEuMCkpO1xuXG4gICAgICAgICAgICAgICAgdmVjNCB0b3AgPSBtaXgodG9wTGVmdCwgdG9wUmlnaHQsIGNsYW1wRnJhYy55d3l3KTtcbiAgICAgICAgICAgICAgICB2ZWM0IGJvdHRvbSA9IG1peChib3R0b21MZWZ0LCBib3R0b21SaWdodCwgY2xhbXBGcmFjLnl3eXcpO1xuICAgICAgICAgICAgICAgIHZlYzQgbmV3VmFsdWUgPSBtaXgodG9wLCBib3R0b20sIGNsYW1wRnJhYy54eHp6KTtcblxuICAgICAgICAgICAgICAgICR7Z2xzbC5vdXRwdXR9ID0gdmVjNChuZXdWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGA7XG4gIHJldHVybiB7XG4gICAgLi4ucmVzaXplUHJvZ3JhbU1ldGFkYXRhLFxuICAgIG91dHB1dDogeyBkaW1zOiBvdXRwdXRTaGFwZSwgdHlwZTogaW5wdXRzWzBdLnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS5wYWNrZWQgfSxcbiAgICBoYXNNYWluOiB0cnVlLFxuICAgIHNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG5cbmNvbnN0IHByZXBhcmVJbnB1dHMgPSAoaW5wdXRzOiBUZW5zb3JbXSwgYXR0cmlidXRlczogVXBzYW1wbGVBdHRyaWJ1dGVzKTogW3JlYWRvbmx5IG51bWJlcltdLCByZWFkb25seSBudW1iZXJbXV0gPT4ge1xuICBjb25zdCB4ID0gaW5wdXRzWzBdO1xuICBjb25zdCB4RGltcyA9IHguZGltcztcblxuICBsZXQgc2NhbGVzID0gYXR0cmlidXRlcy5zY2FsZXM7XG4gIGxldCBvdXRwdXRTaXplczogbnVtYmVyW10gfCB1bmRlZmluZWQ7XG4gIGlmIChzY2FsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgY29uc3Qgc2NhbGVzVGVuc29yID0gaW5wdXRzW2F0dHJpYnV0ZXMuc2NhbGVzSW5wdXRJZHhdO1xuICAgIGlmIChzY2FsZXNUZW5zb3IgJiYgc2NhbGVzVGVuc29yLnNpemUgIT09IDApIHtcbiAgICAgIGlmIChpbnB1dHNbYXR0cmlidXRlcy5zaXplc0lucHV0SWR4XSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgb25lIG9mIHNjYWxlcyBvciBzaXplcyBtdXN0IGJlIHByb3ZpZGVkIGFzIGlucHV0LicpO1xuICAgICAgfVxuICAgICAgc2NhbGVzID0gcGFyc2VTY2FsZXNEYXRhKHNjYWxlc1RlbnNvciwgYXR0cmlidXRlcy5tb2RlLCBhdHRyaWJ1dGVzLmlzUmVzaXplKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc2l6ZXNUZW5zb3IgPSBpbnB1dHNbYXR0cmlidXRlcy5zaXplc0lucHV0SWR4XTtcbiAgICAgIGlmICghc2l6ZXNUZW5zb3IgfHwgc2l6ZXNUZW5zb3Iuc2l6ZSA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VpdGhlciBzY2FsZXMgb3Igc2l6ZXMgTVVTVCBiZSBwcm92aWRlZCBhcyBpbnB1dC4nKTtcbiAgICAgIH1cblxuICAgICAgb3V0cHV0U2l6ZXMgPSBBcnJheS5mcm9tKHNpemVzVGVuc29yLmludGVnZXJEYXRhKTtcbiAgICAgIHNjYWxlcyA9IHBhcnNlU2NhbGVzRGF0YUZyb21PdXRwdXRTaXplKG91dHB1dFNpemVzLCB4RGltcywgYXR0cmlidXRlcy5tb2RlLCBhdHRyaWJ1dGVzLmlzUmVzaXplKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlucHV0c1thdHRyaWJ1dGVzLnNpemVzSW5wdXRJZHhdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgb25lIG9mIHNjYWxlcyBvciBzaXplcyBtdXN0IGJlIHByb3ZpZGVkIGFzIGlucHV0LicpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHlEaW1zID0gb3V0cHV0U2l6ZXMgfHwgeERpbXMubWFwKChkaW0sIGkpID0+IE1hdGguZmxvb3IoZGltICogc2NhbGVzW2ldKSk7XG5cbiAgcmV0dXJuIFtzY2FsZXMsIHlEaW1zXTtcbn07XG5cbmNvbnN0IHBhcnNlU2NhbGVzRGF0YSA9IChzY2FsZTogVGVuc29yLCBtb2RlOiBzdHJpbmcsIGlzUmVzaXplOiBib29sZWFuKTogbnVtYmVyW10gPT4ge1xuICBjb25zdCBzY2FsZXMgPSBBcnJheS5mcm9tKHNjYWxlLmZsb2F0RGF0YSk7XG4gIHNjYWxlc1ZhbGlkYXRpb24oc2NhbGVzLCBtb2RlLCBpc1Jlc2l6ZSk7XG4gIHJldHVybiBzY2FsZXM7XG59O1xuXG5jb25zdCBwYXJzZVNjYWxlc0RhdGFGcm9tT3V0cHV0U2l6ZSA9IChcbiAgeURpbXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICB4RGltczogcmVhZG9ubHkgbnVtYmVyW10sXG4gIG1vZGU6IHN0cmluZyxcbiAgaXNSZXNpemU6IGJvb2xlYW4sXG4pOiBudW1iZXJbXSA9PiB7XG4gIGNvbnN0IGxlbmd0aCA9IHhEaW1zLmxlbmd0aDtcbiAgY29uc3Qgc2NhbGVzID0gbmV3IEFycmF5PG51bWJlcj4obGVuZ3RoKTtcblxuICBmb3IgKGxldCBpID0gMCwgZW5kID0gbGVuZ3RoOyBpIDwgZW5kOyBpKyspIHtcbiAgICBpZiAoeERpbXNbaV0gPT09IDApIHtcbiAgICAgIGlmICh5RGltc1tpXSAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IGRpbSBpcyB6ZXJvIGJ1dCByZXF1aXJlZCBvdXRwdXQgZGltIGlzIG5vbi16ZXJvLicpO1xuICAgICAgfVxuICAgICAgc2NhbGVzW2ldID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NhbGVzW2ldID0geURpbXNbaV0gLyB4RGltc1tpXTtcbiAgICB9XG4gIH1cbiAgc2NhbGVzVmFsaWRhdGlvbihzY2FsZXMsIG1vZGUsIGlzUmVzaXplKTtcbiAgcmV0dXJuIHNjYWxlcztcbn07XG5cbi8vIHJvaSBkYXRhIGlzIG5vdCB1c2VkIHlldC4gYnV0IGxlYXZlIGhlcmUgZm9yIGZ1dHVyZSB1c2FnZS5cbi8vIGNvbnN0IGdldFJvaSA9IChpbnB1dHM6IFRlbnNvcltdLCBhdHRyaWJ1dGVzOiBVcHNhbXBsZUF0dHJpYnV0ZXMpIDogbnVtYmVyW10gPT4ge1xuLy8gICAgIGxldCByb2k6IG51bWJlcltdID0gW107XG4vLyAgICAgaWYgKGF0dHJpYnV0ZXMubmVlZFJvaUlucHV0KSB7XG4vLyAgICAgICAgIGlmIChhdHRyaWJ1dGVzLnJvaUlucHV0SWR4IDw9IDApIHtcbi8vICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByb2kgaW5wdXQgaW5kZXguJyk7XG4vLyAgICAgICAgIH1cbi8vICAgICAgICAgY29uc3Qgcm9pVGVuc29yID0gaW5wdXRzW2F0dHJpYnV0ZXMucm9pSW5wdXRJZHhdO1xuLy8gICAgICAgICByb2kgPSByb2lUZW5zb3Iuc2l6ZSA+IDAgPyBBcnJheS5mcm9tKHJvaVRlbnNvci5mbG9hdERhdGEpIDogW107XG4vLyAgICAgfSBlbHNlIHtcbi8vICAgICAgICAgcm9pID0gbmV3IEFycmF5KGlucHV0c1swXS5kaW1zLmxlbmd0aCAqIDIpLmZpbGwoMCk7XG4vLyAgICAgfVxuLy8gICAgIHJldHVybiByb2k7XG4vLyB9O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBUZW5zb3IgfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHsgV2ViR0xJbmZlcmVuY2VIYW5kbGVyIH0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuXG5leHBvcnQgY29uc3Qgc2hhcGUgPSAoX2luZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoaW5wdXRzKTtcbiAgcmV0dXJuIFtuZXcgVGVuc29yKFtpbnB1dHNbMF0uZGltcy5sZW5ndGhdLCAnaW50MzInLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgbmV3IEludDMyQXJyYXkoaW5wdXRzWzBdLmRpbXMpKV07XG59O1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IFRlbnNvcltdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYXBlIHJlcXVpcmVzIDEgaW5wdXQuJyk7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vLi4vLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7IEdyYXBoIH0gZnJvbSAnLi4vLi4vLi4vZ3JhcGgnO1xuaW1wb3J0IHsgTlVNQkVSX1RZUEVTLCBPcGVyYXRvckltcGxlbWVudGF0aW9uLCBPcGVyYXRvckluaXRpYWxpemF0aW9uIH0gZnJvbSAnLi4vLi4vLi4vb3BlcmF0b3JzJztcbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi8uLi91dGlsJztcbmltcG9ydCB7IFdlYkdMSW5mZXJlbmNlSGFuZGxlciB9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7IFByb2dyYW1JbmZvLCBUZXh0dXJlVHlwZSB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBTbGljZUF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBheGVzOiBudW1iZXJbXTtcbiAgcmVhZG9ubHkgZW5kczogbnVtYmVyW107XG4gIHJlYWRvbmx5IHN0YXJ0czogbnVtYmVyW107XG59XG5cbmNvbnN0IHNsaWNlUHJvZ3JhbU1ldGFkYXRhID0ge1xuICBuYW1lOiAnU2xpY2UnLFxuICBpbnB1dE5hbWVzOiBbJ0EnXSxcbiAgaW5wdXRUeXBlczogW1RleHR1cmVUeXBlLnVucGFja2VkXSxcbn07XG5cbmV4cG9ydCBjb25zdCBzbGljZTogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxTbGljZUF0dHJpYnV0ZXM+ID0gKFxuICBpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsXG4gIGlucHV0czogVGVuc29yW10sXG4gIGF0dHJpYnV0ZXM6IFNsaWNlQXR0cmlidXRlcyxcbik6IFRlbnNvcltdID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoaW5wdXRzKTtcbiAgY29uc3Qgb3V0cHV0ID0gaW5mZXJlbmNlSGFuZGxlci5ydW4oXG4gICAge1xuICAgICAgLi4uc2xpY2VQcm9ncmFtTWV0YWRhdGEsXG4gICAgICBjYWNoZUhpbnQ6IGF0dHJpYnV0ZXMuY2FjaGVLZXksXG4gICAgICBnZXQ6ICgpID0+IGNyZWF0ZVNsaWNlUHJvZ3JhbUluZm8oaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzWzBdLCBhdHRyaWJ1dGVzKSxcbiAgICB9LFxuICAgIGlucHV0cyxcbiAgKTtcbiAgcmV0dXJuIFtvdXRwdXRdO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlU2xpY2VBdHRyaWJ1dGVzOiBPcGVyYXRvckluaXRpYWxpemF0aW9uPFNsaWNlQXR0cmlidXRlcz4gPSAobm9kZTogR3JhcGguTm9kZSk6IFNsaWNlQXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IHN0YXJ0cyA9IG5vZGUuYXR0cmlidXRlcy5nZXRJbnRzKCdzdGFydHMnKTtcbiAgY29uc3QgZW5kcyA9IG5vZGUuYXR0cmlidXRlcy5nZXRJbnRzKCdlbmRzJyk7XG4gIGNvbnN0IGF4ZXMgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0SW50cygnYXhlcycsIFtdKTtcbiAgcmV0dXJuIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7IHN0YXJ0cywgZW5kcywgYXhlcyB9KTtcbn07XG5cbmNvbnN0IGNyZWF0ZVNsaWNlUHJvZ3JhbUluZm8gPSAoXG4gIF9pbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsXG4gIGlucHV0OiBUZW5zb3IsXG4gIGF0dHJpYnV0ZXM6IFNsaWNlQXR0cmlidXRlcyxcbik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgYXhlcyA9IGF0dHJpYnV0ZXMuYXhlcy5sZW5ndGggPT09IDAgPyBpbnB1dC5kaW1zLnNsaWNlKDApLm1hcCgoX3ZhbCwgaSkgPT4gaSkgOiBhdHRyaWJ1dGVzLmF4ZXM7XG4gIGNvbnN0IG5vcm1hbGl6ZWRBeGVzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4ZXMoYXhlcywgaW5wdXQuZGltcy5sZW5ndGgpO1xuICBjb25zdCBzdGFydHMgPSBhdHRyaWJ1dGVzLnN0YXJ0cy5tYXAoKHN0YXJ0LCBpKSA9PiB7XG4gICAgaWYgKHN0YXJ0ID4gaW5wdXQuZGltc1tub3JtYWxpemVkQXhlc1tpXV0gLSAxKSB7XG4gICAgICByZXR1cm4gaW5wdXQuZGltc1tub3JtYWxpemVkQXhlc1tpXV07XG4gICAgfVxuICAgIHJldHVybiBTaGFwZVV0aWwubm9ybWFsaXplQXhpcyhzdGFydCwgaW5wdXQuZGltc1tub3JtYWxpemVkQXhlc1tpXV0pO1xuICB9KTtcbiAgY29uc3QgZW5kcyA9IGF0dHJpYnV0ZXMuZW5kcy5tYXAoKGVuZCwgaSkgPT4ge1xuICAgIGlmIChlbmQgPiBpbnB1dC5kaW1zW25vcm1hbGl6ZWRBeGVzW2ldXSAtIDEpIHtcbiAgICAgIHJldHVybiBpbnB1dC5kaW1zW25vcm1hbGl6ZWRBeGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIFNoYXBlVXRpbC5ub3JtYWxpemVBeGlzKGVuZCwgaW5wdXQuZGltc1tub3JtYWxpemVkQXhlc1tpXV0pO1xuICB9KTtcblxuICBjb25zdCBvdXRwdXRTaGFwZSA9IGlucHV0LmRpbXMuc2xpY2UoKTtcblxuICBjb25zdCBzbGljZU9wczogc3RyaW5nW10gPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub3JtYWxpemVkQXhlcy5sZW5ndGg7IGkrKykge1xuICAgIG91dHB1dFNoYXBlW25vcm1hbGl6ZWRBeGVzW2ldXSA9IGVuZHNbaV0gLSBzdGFydHNbaV07XG4gICAgaWYgKHN0YXJ0c1tpXSA+IDApIHtcbiAgICAgIHNsaWNlT3BzLnB1c2goYG91dHB1dElkeFske25vcm1hbGl6ZWRBeGVzW2ldfV0gKz0gJHtzdGFydHNbaV19O2ApO1xuICAgIH0gLy8gZWxzZSB7IHNsaWNlT3BzLnB1c2goYG91dHB1dElkeFske25vcm1hbGl6ZWRBeGVzW2ldfV0gKz0gMDtgKTsgfVxuICB9XG5cbiAgY29uc3QgcmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aDtcbiAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgb3V0cHV0SWR4WyR7cmFua31dKSB7XG4gICAgICAgICR7c2xpY2VPcHMuam9pbignXFxuICAgICAgJyl9XG4gICAgICAgIHJldHVybiBfQShvdXRwdXRJZHgpO1xuICAgICAgfWA7XG4gIHJldHVybiB7XG4gICAgLi4uc2xpY2VQcm9ncmFtTWV0YWRhdGEsXG4gICAgb3V0cHV0OiB7IGRpbXM6IG91dHB1dFNoYXBlLCB0eXBlOiBpbnB1dC50eXBlLCB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGUudW5wYWNrZWQgfSxcbiAgICBzaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IFRlbnNvcltdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NsaWNlIHJlcXVpcmVzIDEgaW5wdXQuJyk7XG4gIH1cbiAgaWYgKE5VTUJFUl9UWVBFUy5pbmRleE9mKGlucHV0c1swXS50eXBlKSA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgdHlwZS4nKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHNsaWNlVjEwID0gKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdID0+IHtcbiAgdmFsaWRhdGVJbnB1dHNWMTAoaW5wdXRzKTtcbiAgY29uc3QgYXR0cmlidXRlcyA9IGdlbmVyYXRlU2xpY2VBdHRyaWJ1dGVzRnJvbUlucHV0cyhpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMpO1xuICBjb25zdCBvdXRwdXQgPSBpbmZlcmVuY2VIYW5kbGVyLnJ1bihcbiAgICB7XG4gICAgICAuLi5zbGljZVByb2dyYW1NZXRhZGF0YSxcbiAgICAgIGNhY2hlSGludDogYXR0cmlidXRlcy5jYWNoZUtleSxcbiAgICAgIGdldDogKCkgPT4gY3JlYXRlU2xpY2VQcm9ncmFtSW5mbyhpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHNbMF0sIGF0dHJpYnV0ZXMpLFxuICAgIH0sXG4gICAgW2lucHV0c1swXV0sXG4gICk7XG4gIHJldHVybiBbb3V0cHV0XTtcbn07XG5cbmNvbnN0IGdlbmVyYXRlU2xpY2VBdHRyaWJ1dGVzRnJvbUlucHV0cyA9IChcbiAgaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBpbnB1dHM6IFRlbnNvcltdLFxuKTogU2xpY2VBdHRyaWJ1dGVzID0+IHtcbiAgaWYgKFxuICAgICFpbmZlcmVuY2VIYW5kbGVyLnNlc3Npb24uaXNJbml0aWFsaXplcihpbnB1dHNbMV0uZGF0YUlkKSB8fFxuICAgICFpbmZlcmVuY2VIYW5kbGVyLnNlc3Npb24uaXNJbml0aWFsaXplcihpbnB1dHNbMl0uZGF0YUlkKSB8fFxuICAgIChpbnB1dHMubGVuZ3RoID49IDQgJiYgIWluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5pc0luaXRpYWxpemVyKGlucHV0c1szXS5kYXRhSWQpKSB8fFxuICAgIChpbnB1dHMubGVuZ3RoID49IDUgJiYgIWluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5pc0luaXRpYWxpemVyKGlucHV0c1s0XS5kYXRhSWQpKVxuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2R5bmFtaWMgc2xpY2UgYXR0cmlidXRlcyBhcmUgbm90IGFsbG93ZWQnKTtcbiAgfVxuXG4gIGlmIChpbnB1dHMubGVuZ3RoID49IDUgJiYgaW5wdXRzWzRdLmludGVnZXJEYXRhLnNvbWUoKGk6IG51bWJlcikgPT4gaSAhPT0gMSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2N1cnJlbnRseSBub24tMSBzdGVwcyBpcyBub3Qgc3VwcG9ydGVkIGZvciBTbGljZScpO1xuICB9XG5cbiAgY29uc3Qgc3RhcnRzID0gQXJyYXkuZnJvbShpbnB1dHNbMV0uaW50ZWdlckRhdGEpO1xuICBjb25zdCBlbmRzID0gQXJyYXkuZnJvbShpbnB1dHNbMl0uaW50ZWdlckRhdGEpO1xuICBjb25zdCBheGVzID0gaW5wdXRzLmxlbmd0aCA+PSA0ID8gQXJyYXkuZnJvbShpbnB1dHNbM10uaW50ZWdlckRhdGEpIDogW107XG4gIGNvbnN0IGNhY2hlS2V5ID0gYCR7YXhlc307JHtzdGFydHN9OyR7ZW5kc31gO1xuICByZXR1cm4geyBzdGFydHMsIGVuZHMsIGF4ZXMsIGNhY2hlS2V5IH07XG59O1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0c1YxMCA9IChpbnB1dHM6IFRlbnNvcltdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggPCAzIHx8IGlucHV0cy5sZW5ndGggPiA1KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0IG51bWJlci4nKTtcbiAgfVxuICBpZiAoaW5wdXRzWzFdLnR5cGUgIT09ICdpbnQzMicgfHwgaW5wdXRzWzFdLmRpbXMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0IHR5cGUuJyk7XG4gIH1cbiAgaWYgKGlucHV0c1syXS50eXBlICE9PSAnaW50MzInIHx8IGlucHV0c1syXS5kaW1zLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCB0eXBlLicpO1xuICB9XG4gIGlmIChpbnB1dHMubGVuZ3RoID49IDQgJiYgKGlucHV0c1szXS50eXBlICE9PSAnaW50MzInIHx8IGlucHV0c1szXS5kaW1zLmxlbmd0aCAhPT0gMSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgdHlwZS4nKTtcbiAgfVxuICBpZiAoaW5wdXRzLmxlbmd0aCA+PSA1ICYmIChpbnB1dHNbNF0udHlwZSAhPT0gJ2ludDMyJyB8fCBpbnB1dHNbNF0uZGltcy5sZW5ndGggIT09IDEpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0IHR5cGUuJyk7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vLi4vLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7IEdyYXBoIH0gZnJvbSAnLi4vLi4vLi4vZ3JhcGgnO1xuaW1wb3J0IHsgT3BlcmF0b3JJbXBsZW1lbnRhdGlvbiwgT3BlcmF0b3JJbml0aWFsaXphdGlvbiB9IGZyb20gJy4uLy4uLy4uL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBUZW5zb3IgfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBnZXRHbHNsIH0gZnJvbSAnLi4vZ2xzbC1zb3VyY2UnO1xuaW1wb3J0IHsgV2ViR0xJbmZlcmVuY2VIYW5kbGVyIH0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHsgUHJvZ3JhbUluZm8sIFRleHR1cmVUeXBlIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyB0cmFuc3Bvc2UsIFRyYW5zcG9zZUF0dHJpYnV0ZXMgfSBmcm9tICcuL3RyYW5zcG9zZSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU29mdG1heEF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBheGlzOiBudW1iZXI7XG59XG5cbmNvbnN0IHNvZnRtYXhDb21wdXRlTWF4UHJvZ3JhbU1ldGFkYXRhID0ge1xuICBuYW1lOiAnU29mdG1heENvbXB1dGVNYXgnLFxuICBpbnB1dE5hbWVzOiBbJ0EnXSxcbiAgaW5wdXRUeXBlczogW1RleHR1cmVUeXBlLnVucGFja2VkXSxcbn07XG5cbmNvbnN0IHNvZnRtYXhDb21wdXRlU2NhbGVQcm9ncmFtTWV0YWRhdGEgPSB7XG4gIG5hbWU6ICdTb2Z0bWF4Q29tcHV0ZVNjYWxlJyxcbiAgaW5wdXROYW1lczogWydBJywgJ01heCddLFxuICBpbnB1dFR5cGVzOiBbVGV4dHVyZVR5cGUudW5wYWNrZWQsIFRleHR1cmVUeXBlLnVucGFja2VkXSxcbn07XG5cbmNvbnN0IHNvZnRtYXhQcm9ncmFtTWV0YWRhdGEgPSB7XG4gIG5hbWU6ICdTb2Z0TWF4JyxcbiAgaW5wdXROYW1lczogWydBJywgJ01heCcsICdOb3JtJ10sXG4gIGlucHV0VHlwZXM6IFtUZXh0dXJlVHlwZS51bnBhY2tlZCwgVGV4dHVyZVR5cGUudW5wYWNrZWQsIFRleHR1cmVUeXBlLnVucGFja2VkXSxcbn07XG5cbmV4cG9ydCBjb25zdCBzb2Z0bWF4OiBPcGVyYXRvckltcGxlbWVudGF0aW9uPFNvZnRtYXhBdHRyaWJ1dGVzPiA9IChcbiAgaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBpbnB1dHM6IFRlbnNvcltdLFxuICBhdHRyaWJ1dGVzOiBTb2Z0bWF4QXR0cmlidXRlcyxcbik6IFRlbnNvcltdID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoaW5wdXRzKTtcblxuICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXMuc2xpY2UoKTtcbiAgY29uc3QgYXhpcyA9IFNoYXBlVXRpbC5ub3JtYWxpemVBeGlzKGF0dHJpYnV0ZXMuYXhpcywgaW5wdXRTaGFwZS5sZW5ndGgpO1xuICBjb25zdCBsb2dpY2FsUm93Q291bnQgPSBTaGFwZVV0aWwuc2l6ZVRvRGltZW5zaW9uKGlucHV0U2hhcGUsIGF4aXMpO1xuICBjb25zdCBmZWF0dXJlQ291bnQgPSBTaGFwZVV0aWwuc2l6ZUZyb21EaW1lbnNpb24oaW5wdXRTaGFwZSwgYXhpcyk7XG5cbiAgY29uc3Qgb3V0cHV0ID0gY29tcHV0ZVNvZnRtYXgoaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzLCBhdHRyaWJ1dGVzLCBsb2dpY2FsUm93Q291bnQsIGZlYXR1cmVDb3VudCk7XG4gIHJldHVybiBvdXRwdXQ7XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VTb2Z0bWF4QXR0cmlidXRlczogT3BlcmF0b3JJbml0aWFsaXphdGlvbjxTb2Z0bWF4QXR0cmlidXRlcz4gPSAoXG4gIG5vZGU6IEdyYXBoLk5vZGUsXG4pOiBTb2Z0bWF4QXR0cmlidXRlcyA9PiBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoeyBheGlzOiBub2RlLmF0dHJpYnV0ZXMuZ2V0SW50KCdheGlzJywgMSkgfSk7XG5cbmV4cG9ydCBjb25zdCBwYXJzZVNvZnRtYXhBdHRyaWJ1dGVzVjEzOiBPcGVyYXRvckluaXRpYWxpemF0aW9uPFNvZnRtYXhBdHRyaWJ1dGVzPiA9IChcbiAgbm9kZTogR3JhcGguTm9kZSxcbik6IFNvZnRtYXhBdHRyaWJ1dGVzID0+IGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7IGF4aXM6IG5vZGUuYXR0cmlidXRlcy5nZXRJbnQoJ2F4aXMnLCAtMSkgfSk7XG5cbi8vIFRoZSBcInNlbWFudGljXCIgbWVhbmluZyBvZiBheGlzIGhhcyBjaGFuZ2VkIGluIG9wc2V0LTEzLlxuLy8gUGxlYXNlIGNvbXBhcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9vbm54L29ubngvYmxvYi9tYWluL2RvY3MvT3BlcmF0b3JzLm1kI1NvZnRtYXhcbi8vIHdpdGggaHR0cHM6Ly9naXRodWIuY29tL29ubngvb25ueC9ibG9iL21haW4vZG9jcy9DaGFuZ2Vsb2cubWQjU29mdG1heC0xMSBmb3IgZGV0YWlsZWQgZXhwbGFuYXRpb25zXG4vLyBUbyBhY2NvdW50IGZvciB0aGUgb3BzZXQtMTMgYmVoYXZpb3IsIG91ciBwbGFuIHdpbGwgYmUgdG8gdHJhbnNwb3NlIHRoZSBcImF4aXNcIiBkaW0gdG8gdGhlIGlubmVybW9zdCBkaW1cbi8vIGFuZCBwZXJmb3JtIHNvZnRtYXggYW5kIHRoZW4gcmV2ZXJzZSB0aGUgdHJhbnNwb3NlLiBXZSBjYW4gc2tpcCB0aGUgdHJhbnNwb3NpbmcgYXNwZWN0IGlmIHRoZSBheGlzIGlzIGFscmVhZHlcbi8vIHRoZSBpbm5lcm1vc3QgZGltXG5leHBvcnQgY29uc3Qgc29mdG1heFYxMzogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxTb2Z0bWF4QXR0cmlidXRlcz4gPSAoXG4gIGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXRzOiBUZW5zb3JbXSxcbiAgYXR0cmlidXRlczogU29mdG1heEF0dHJpYnV0ZXMsXG4pOiBUZW5zb3JbXSA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGlucHV0cyk7XG5cbiAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zLnNsaWNlKCk7XG4gIGNvbnN0IGF4aXMgPSBTaGFwZVV0aWwubm9ybWFsaXplQXhpcyhhdHRyaWJ1dGVzLmF4aXMsIGlucHV0U2hhcGUubGVuZ3RoKTtcbiAgY29uc3QgcmFuayA9IGlucHV0U2hhcGUubGVuZ3RoO1xuXG4gIGNvbnN0IGlzVHJhbnNwb3NlUmVxdWlyZWQgPSBheGlzICE9PSByYW5rIC0gMSA/IHRydWUgOiBmYWxzZTtcbiAgY29uc3QgdHJhbnNwb3NlZElucHV0U2hhcGU6IG51bWJlcltdID0gW107XG4gIGxldCBwZXJtOiBudW1iZXJbXSA9IFtdO1xuICBsZXQgdHJhbnNwb3NlZElucHV0czogVGVuc29yW10gPSBbXTtcbiAgbGV0IHRyYW5zcG9zZUF0dHJpYnV0ZTogVHJhbnNwb3NlQXR0cmlidXRlcztcblxuICBpZiAoaXNUcmFuc3Bvc2VSZXF1aXJlZCkge1xuICAgIHBlcm0gPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiByYW5rIH0pLm1hcCgoXywgaSkgPT4gaSk7XG5cbiAgICAvLyBzd2FwIHRoZSBpbm5lcm1vc3QgZGltIHdpdGggdGhlIGRpbSBjb3JyZXNwb25kaW5nIHRvIGF4aXNcbiAgICBwZXJtW2F4aXNdID0gcmFuayAtIDE7XG4gICAgcGVybVtyYW5rIC0gMV0gPSBheGlzO1xuXG4gICAgcGVybS5tYXAoKHApID0+IHRyYW5zcG9zZWRJbnB1dFNoYXBlLnB1c2goaW5wdXRTaGFwZVtwXSkpO1xuXG4gICAgdHJhbnNwb3NlQXR0cmlidXRlID0gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHsgcGVybSB9KTtcbiAgICB0cmFuc3Bvc2VkSW5wdXRzID0gdHJhbnNwb3NlKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0cywgdHJhbnNwb3NlQXR0cmlidXRlKTtcbiAgfVxuXG4gIGNvbnN0IGxvZ2ljYWxSb3dDb3VudCA9IGlzVHJhbnNwb3NlUmVxdWlyZWRcbiAgICA/IFNoYXBlVXRpbC5zaXplVG9EaW1lbnNpb24odHJhbnNwb3NlZElucHV0U2hhcGUsIHJhbmsgLSAxKVxuICAgIDogU2hhcGVVdGlsLnNpemVUb0RpbWVuc2lvbihpbnB1dFNoYXBlLCByYW5rIC0gMSk7XG4gIGNvbnN0IGZlYXR1cmVDb3VudCA9IGlzVHJhbnNwb3NlUmVxdWlyZWRcbiAgICA/IFNoYXBlVXRpbC5zaXplRnJvbURpbWVuc2lvbih0cmFuc3Bvc2VkSW5wdXRTaGFwZSwgcmFuayAtIDEpXG4gICAgOiBTaGFwZVV0aWwuc2l6ZUZyb21EaW1lbnNpb24oaW5wdXRTaGFwZSwgcmFuayAtIDEpO1xuXG4gIGNvbnN0IG91dHB1dCA9IGNvbXB1dGVTb2Z0bWF4KFxuICAgIGluZmVyZW5jZUhhbmRsZXIsXG4gICAgaXNUcmFuc3Bvc2VSZXF1aXJlZCA/IHRyYW5zcG9zZWRJbnB1dHMgOiBpbnB1dHMsXG4gICAgYXR0cmlidXRlcyxcbiAgICBsb2dpY2FsUm93Q291bnQsXG4gICAgZmVhdHVyZUNvdW50LFxuICApO1xuXG4gIGlmIChpc1RyYW5zcG9zZVJlcXVpcmVkKSB7XG4gICAgY29uc3QgcmV2ZXJzZWRPdXRwdXQgPSB0cmFuc3Bvc2UoaW5mZXJlbmNlSGFuZGxlciwgb3V0cHV0LCB0cmFuc3Bvc2VBdHRyaWJ1dGUhKTtcbiAgICByZXR1cm4gcmV2ZXJzZWRPdXRwdXQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxufTtcblxuY29uc3QgY29tcHV0ZVNvZnRtYXggPSAoXG4gIGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXRzOiBUZW5zb3JbXSxcbiAgYXR0cmlidXRlczogU29mdG1heEF0dHJpYnV0ZXMsXG4gIGxvZ2ljYWxSb3dDb3VudDogbnVtYmVyLFxuICBmZWF0dXJlQ291bnQ6IG51bWJlcixcbik6IFRlbnNvcltdID0+IHtcbiAgY29uc3QgY29tcHV0ZU1heFByb2dyYW1JbmZvID0gY3JlYXRlQ29tcHV0ZU1heFByb2dyYW1JbmZvKFxuICAgIGluZmVyZW5jZUhhbmRsZXIsXG4gICAgaW5wdXRzWzBdLFxuICAgIGxvZ2ljYWxSb3dDb3VudCxcbiAgICBmZWF0dXJlQ291bnQsXG4gICAgW2xvZ2ljYWxSb3dDb3VudF0sXG4gICk7XG4gIGNvbnN0IG1heCA9IGluZmVyZW5jZUhhbmRsZXIucnVuKFxuICAgIHsgLi4uc29mdG1heENvbXB1dGVNYXhQcm9ncmFtTWV0YWRhdGEsIGNhY2hlSGludDogYXR0cmlidXRlcy5jYWNoZUtleSwgZ2V0OiAoKSA9PiBjb21wdXRlTWF4UHJvZ3JhbUluZm8gfSxcbiAgICBpbnB1dHMsXG4gICk7XG5cbiAgY29uc3QgY29tcHV0ZVNjYWxlUHJvZ3JhbUluZm8gPSBjcmVhdGVDb21wdXRTY2FsZVByb2dyYW1JbmZvKFxuICAgIGluZmVyZW5jZUhhbmRsZXIsXG4gICAgaW5wdXRzWzBdLFxuICAgIGxvZ2ljYWxSb3dDb3VudCxcbiAgICBmZWF0dXJlQ291bnQsXG4gICAgY29tcHV0ZU1heFByb2dyYW1JbmZvLm91dHB1dC5kaW1zLFxuICAgIFtsb2dpY2FsUm93Q291bnRdLFxuICApO1xuICBjb25zdCBzY2FsZSA9IGluZmVyZW5jZUhhbmRsZXIucnVuKFxuICAgIHsgLi4uc29mdG1heENvbXB1dGVTY2FsZVByb2dyYW1NZXRhZGF0YSwgY2FjaGVIaW50OiBhdHRyaWJ1dGVzLmNhY2hlS2V5LCBnZXQ6ICgpID0+IGNvbXB1dGVTY2FsZVByb2dyYW1JbmZvIH0sXG4gICAgW2lucHV0c1swXSwgbWF4XSxcbiAgKTtcblxuICBjb25zdCBzb2Z0TWF4UHJvZ3JhbUluZm8gPSBjcmVhdGVTb2Z0TWF4UHJvZ3JhbUluZm8oXG4gICAgaW5mZXJlbmNlSGFuZGxlcixcbiAgICBpbnB1dHNbMF0sXG4gICAgbG9naWNhbFJvd0NvdW50LFxuICAgIGZlYXR1cmVDb3VudCxcbiAgICBjb21wdXRlTWF4UHJvZ3JhbUluZm8ub3V0cHV0LmRpbXMsXG4gICAgY29tcHV0ZVNjYWxlUHJvZ3JhbUluZm8ub3V0cHV0LmRpbXMsXG4gICk7XG4gIGNvbnN0IG91dHB1dCA9IGluZmVyZW5jZUhhbmRsZXIucnVuKFxuICAgIHsgLi4uc29mdG1heFByb2dyYW1NZXRhZGF0YSwgY2FjaGVIaW50OiBhdHRyaWJ1dGVzLmNhY2hlS2V5LCBnZXQ6ICgpID0+IHNvZnRNYXhQcm9ncmFtSW5mbyB9LFxuICAgIFtpbnB1dHNbMF0sIG1heCwgc2NhbGVdLFxuICApO1xuICByZXR1cm4gW291dHB1dF07XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIHRleHR1cmUgdGhhdCBjb250YWlucyB0aGUgbWF4aW11bSB2YWx1ZSBvZiBlYWNoIG9mIHRoZSAnTicgcm93c1xuICovXG5jb25zdCBjcmVhdGVDb21wdXRlTWF4UHJvZ3JhbUluZm8gPSAoXG4gIGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXQ6IFRlbnNvcixcbiAgbG9naWNhbFJvd0NvdW50OiBudW1iZXIsXG4gIGZlYXR1cmVDb3VudDogbnVtYmVyLFxuICBvdXRwdXRTaGFwZTogbnVtYmVyW10sXG4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IFt0ZXh0dXJlV2lkdGgsIHRleHR1cmVIZWlnaHRdID0gaW5mZXJlbmNlSGFuZGxlci5jYWxjdWxhdGVUZXh0dXJlV2lkdGhBbmRIZWlnaHQoXG4gICAgaW5wdXQuZGltcyxcbiAgICBUZXh0dXJlVHlwZS51bnBhY2tlZCxcbiAgKTtcbiAgY29uc3QgcmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aDtcblxuICBpZiAobG9naWNhbFJvd0NvdW50IDwgMSB8fCBmZWF0dXJlQ291bnQgPCAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdMb2dpY2FsIHJvdyBjb3VudCBOIGFuZCBmZWF0dXJlIGNvdW50IEQgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMScpO1xuICB9XG5cbiAgaWYgKG91dHB1dFNoYXBlLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRGltZW5zaW9uYWxpdHkgb2YgdGhlIG91dHB1dCBzaG91bGQgYmUgMScpO1xuICB9XG5cbiAgaWYgKG91dHB1dFNoYXBlWzBdICE9PSBsb2dpY2FsUm93Q291bnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYXBlIG9mIHRoZSBvdXRwdXQgc2hvdWxkIGJlIGVxdWFsIHRvIGxvZ2ljYWwgcm93IGNvdW50Jyk7XG4gIH1cblxuICBjb25zdCBnbHNsID0gZ2V0R2xzbChpbmZlcmVuY2VIYW5kbGVyLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbik7XG4gIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50WyR7cmFua31dIGluZGljZXMpIHtcbiAgICAgICAgaW50IGxvZ2ljYWxfcm93X3N0YXJ0X29mZnNldCA9IGluZGljZXNbMF0gKiAke2ZlYXR1cmVDb3VudH07XG5cbiAgICAgICAgZmxvYXQgbWF4ID0gZ2V0Q29sb3JBc0Zsb2F0KCR7Z2xzbC50ZXh0dXJlMkR9KEEsIG9mZnNldFRvQ29vcmRzKGxvZ2ljYWxfcm93X3N0YXJ0X29mZnNldCwgJHt0ZXh0dXJlV2lkdGh9LFxuICAgICAgICAke3RleHR1cmVIZWlnaHR9ICkpKTtcbiAgICAgICAgZm9yKGludCBpPTE7IGk8JHtmZWF0dXJlQ291bnR9OyArK2kpXG4gICAgICAgIHtcbiAgICAgICAgICBmbG9hdCBjdXJyZW50ID0gZ2V0Q29sb3JBc0Zsb2F0KCR7Z2xzbC50ZXh0dXJlMkR9KEEsIG9mZnNldFRvQ29vcmRzKGxvZ2ljYWxfcm93X3N0YXJ0X29mZnNldCArIGksXG4gICAgICAgICAgICAke3RleHR1cmVXaWR0aH0sICR7dGV4dHVyZUhlaWdodH0pKSk7XG4gICAgICAgICAgaWYoY3VycmVudCA+IG1heClcbiAgICAgICAgICBtYXggPSBjdXJyZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICAgIH1gO1xuICByZXR1cm4ge1xuICAgIC4uLnNvZnRtYXhDb21wdXRlTWF4UHJvZ3JhbU1ldGFkYXRhLFxuICAgIG91dHB1dDogeyBkaW1zOiBvdXRwdXRTaGFwZSwgdHlwZTogaW5wdXQudHlwZSwgdGV4dHVyZVR5cGU6IFRleHR1cmVUeXBlLnVucGFja2VkIH0sXG4gICAgc2hhZGVyU291cmNlLFxuICB9O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSB0ZXh0dXJlIHRoYXQgY29udGFpbnMgdGhlIG5vcm1hbGl6YXRpb24gZmFjdG9yIGZvciBlYWNoIG9mIHRoZSAnTicgcm93c1xuICovXG5jb25zdCBjcmVhdGVDb21wdXRTY2FsZVByb2dyYW1JbmZvID0gKFxuICBpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsXG4gIGlucHV0OiBUZW5zb3IsXG4gIGxvZ2ljYWxSb3dDb3VudDogbnVtYmVyLFxuICBmZWF0dXJlQ291bnQ6IG51bWJlcixcbiAgbWF4RWxlbWVudFBlckxvZ2ljYWxSb3c6IHJlYWRvbmx5IG51bWJlcltdLFxuICBvdXRwdXRTaGFwZTogbnVtYmVyW10sXG4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IFt0ZXh0dXJlV2lkdGgsIHRleHR1cmVIZWlnaHRdID0gaW5mZXJlbmNlSGFuZGxlci5jYWxjdWxhdGVUZXh0dXJlV2lkdGhBbmRIZWlnaHQoXG4gICAgaW5wdXQuZGltcyxcbiAgICBUZXh0dXJlVHlwZS51bnBhY2tlZCxcbiAgKTtcbiAgY29uc3QgcmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aDtcblxuICBpZiAobG9naWNhbFJvd0NvdW50IDwgMSB8fCBmZWF0dXJlQ291bnQgPCAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdMb2dpY2FsIHJvdyBjb3VudCBOIGFuZCBmZWF0dXJlIGNvdW50IEQgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMScpO1xuICB9XG5cbiAgaWYgKG91dHB1dFNoYXBlLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRGltZW5zaW9uYWxpdHkgb2YgdGhlIG91dHB1dCBzaG91bGQgYmUgMScpO1xuICB9XG5cbiAgaWYgKG91dHB1dFNoYXBlWzBdICE9PSBsb2dpY2FsUm93Q291bnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYXBlIG9mIHRoZSBvdXRwdXQgc2hvdWxkIGJlIGVxdWFsIHRvIGxvZ2ljYWwgcm93IGNvdW50Jyk7XG4gIH1cblxuICBpZiAobWF4RWxlbWVudFBlckxvZ2ljYWxSb3cubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdEaW1lbnNpb25hbGl0eSBvZiB0aGUgaW50ZXJtZWRpYXRlIHJlc3VsdHMgc2hvdWxkIGJlIDEnKTtcbiAgfVxuXG4gIGlmIChtYXhFbGVtZW50UGVyTG9naWNhbFJvd1swXSAhPT0gbG9naWNhbFJvd0NvdW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTaGFwZSBvZiB0aGUgaW50ZXJtZWRpYXRlIHJlc3VsdHMgc2hvdWxkIGJlIGVxdWFsIHRvIGxvZ2ljYWwgcm93IGNvdW50Jyk7XG4gIH1cblxuICBjb25zdCBnbHNsID0gZ2V0R2xzbChpbmZlcmVuY2VIYW5kbGVyLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbik7XG4gIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50WyR7cmFua31dIGluZGljZXMpIHtcbiAgICAgICAgaW50IGxvZ2ljYWxfcm93X3N0YXJ0X29mZnNldCA9IGluZGljZXNbMF0gKiAke2ZlYXR1cmVDb3VudH07XG5cbiAgICAgICAgZmxvYXQgbm9ybV9mYWN0b3IgPSAwLjA7XG4gICAgICAgIGZsb2F0IG1heCA9IF9NYXgoaW5kaWNlcyk7XG4gICAgICAgIGZvcihpbnQgaT0wOyBpPCR7ZmVhdHVyZUNvdW50fTsgKytpKVxuICAgICAgICB7XG4gICAgICAgICAgbm9ybV9mYWN0b3IgKz0gZXhwKGdldENvbG9yQXNGbG9hdCgke2dsc2wudGV4dHVyZTJEfShBLCBvZmZzZXRUb0Nvb3Jkcyhsb2dpY2FsX3Jvd19zdGFydF9vZmZzZXQgKyBpLFxuICAgICAgICAgICAgJHt0ZXh0dXJlV2lkdGh9LCAke3RleHR1cmVIZWlnaHR9KSkpIC0gbWF4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub3JtX2ZhY3RvcjtcbiAgICAgIH1gO1xuICByZXR1cm4ge1xuICAgIC4uLnNvZnRtYXhDb21wdXRlU2NhbGVQcm9ncmFtTWV0YWRhdGEsXG4gICAgb3V0cHV0OiB7IGRpbXM6IG91dHB1dFNoYXBlLCB0eXBlOiBpbnB1dC50eXBlLCB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGUudW5wYWNrZWQgfSxcbiAgICBzaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG5jb25zdCBjcmVhdGVTb2Z0TWF4UHJvZ3JhbUluZm8gPSAoXG4gIGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXQ6IFRlbnNvcixcbiAgbG9naWNhbFJvd0NvdW50OiBudW1iZXIsXG4gIGZlYXR1cmVDb3VudDogbnVtYmVyLFxuICBtYXhFbGVtZW50UGVyTG9naWNhbFJvdzogcmVhZG9ubHkgbnVtYmVyW10sXG4gIG5vcm1hbGl6YXRpb25QZXJMb2dpY2FsUm93OiByZWFkb25seSBudW1iZXJbXSxcbik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgW3RleHR1cmVXaWR0aCwgdGV4dHVyZUhlaWdodF0gPSBpbmZlcmVuY2VIYW5kbGVyLmNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodChcbiAgICBpbnB1dC5kaW1zLFxuICAgIFRleHR1cmVUeXBlLnVucGFja2VkLFxuICApO1xuICBjb25zdCByYW5rID0gaW5wdXQuZGltcy5sZW5ndGg7XG5cbiAgaWYgKGxvZ2ljYWxSb3dDb3VudCA8IDEgfHwgZmVhdHVyZUNvdW50IDwgMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTG9naWNhbCByb3cgY291bnQgTiBhbmQgZmVhdHVyZSBjb3VudCBEIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDEnKTtcbiAgfVxuXG4gIGlmIChtYXhFbGVtZW50UGVyTG9naWNhbFJvdy5sZW5ndGggIT09IDEgfHwgbm9ybWFsaXphdGlvblBlckxvZ2ljYWxSb3cubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdEaW1lbnNpb25hbGl0eSBvZiB0aGUgaW50ZXJtZWRpYXRlIHJlc3VsdHMgc2hvdWxkIGJlIDEnKTtcbiAgfVxuXG4gIGlmIChtYXhFbGVtZW50UGVyTG9naWNhbFJvd1swXSAhPT0gbG9naWNhbFJvd0NvdW50IHx8IG5vcm1hbGl6YXRpb25QZXJMb2dpY2FsUm93WzBdICE9PSBsb2dpY2FsUm93Q291bnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYXBlIG9mIHRoZSBpbnRlcm1lZGlhdGUgcmVzdWx0cyBzaG91bGQgYmUgZXF1YWwgdG8gbG9naWNhbCByb3cgY291bnQnKTtcbiAgfVxuXG4gIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50WyR7cmFua31dIGluZGljZXMpIHtcblxuICAgICAgLy8gZ2V0IG9mZnNldCBvZiBjdXJyZW50IGxvZ2ljYWwgdGVuc29yIGluZGV4IGZyb20gdGhlIDItRCB0ZXh0dXJlIGNvb3JkaW5hdGVzIChUZXhDb29yZHMpXG4gICAgICBpbnQgb2Zmc2V0ID0gY29vcmRzVG9PZmZzZXQoVGV4Q29vcmRzLCAke3RleHR1cmVXaWR0aH0sICR7dGV4dHVyZUhlaWdodH0pO1xuXG4gICAgICAvL2RldGVybWluZSB0aGUgbG9naWNhbCByb3cgZm9yIHRoaXMgaW5kZXhcbiAgICAgIGludCBsb2dpY2FsX3Jvd19pbmRleFsxXTtcbiAgICAgIGxvZ2ljYWxfcm93X2luZGV4WzBdID0gb2Zmc2V0IC8gJHtmZWF0dXJlQ291bnR9O1xuXG4gICAgICBmbG9hdCBub3JtX2ZhY3RvciA9IF9Ob3JtKGxvZ2ljYWxfcm93X2luZGV4KTtcblxuICAgICAgLy8gYXZvaWQgcG9zc2libGUgZGl2aXNpb24gYnkgMFxuICAgICAgLy8gaWYgbm9ybV9mYWNvciBpcyAwLCBhbGwgZWxlbWVudHMgYXJlIHplcm9cbiAgICAgIC8vIGlmIHNvLCByZXR1cm4gMFxuICAgICAgaWYobm9ybV9mYWN0b3IgPT0gMC4wKVxuICAgICAgICByZXR1cm4gMC4wO1xuXG4gICAgICByZXR1cm4gZXhwKF9BKGluZGljZXMpIC0gX01heChsb2dpY2FsX3Jvd19pbmRleCkpIC8gbm9ybV9mYWN0b3I7XG4gICAgfWA7XG4gIHJldHVybiB7XG4gICAgLi4uc29mdG1heFByb2dyYW1NZXRhZGF0YSxcbiAgICBvdXRwdXQ6IHsgZGltczogaW5wdXQuZGltcywgdHlwZTogaW5wdXQudHlwZSwgdGV4dHVyZVR5cGU6IFRleHR1cmVUeXBlLnVucGFja2VkIH0sXG4gICAgc2hhZGVyU291cmNlLFxuICB9O1xufTtcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiBUZW5zb3JbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTb2Z0bWF4IHJlcXVpcmVzIDEgaW5wdXQuJyk7XG4gIH1cblxuICBpZiAoaW5wdXRzWzBdLnR5cGUgIT09ICdmbG9hdDMyJyAmJiBpbnB1dHNbMF0udHlwZSAhPT0gJ2Zsb2F0NjQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0IHR5cGUnKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgQXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi8uLi8uLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHsgR3JhcGggfSBmcm9tICcuLi8uLi8uLi9ncmFwaCc7XG5pbXBvcnQgeyBPcGVyYXRvckltcGxlbWVudGF0aW9uLCBPcGVyYXRvckluaXRpYWxpemF0aW9uIH0gZnJvbSAnLi4vLi4vLi4vb3BlcmF0b3JzJztcbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQgeyBTaGFwZVV0aWwsIFNwbGl0VXRpbCB9IGZyb20gJy4uLy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgV2ViR0xJbmZlcmVuY2VIYW5kbGVyIH0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHsgUHJvZ3JhbUluZm8sIFRleHR1cmVUeXBlIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNwbGl0QXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IGF4aXM6IG51bWJlcjtcbiAgcmVhZG9ubHkgc3BsaXQ6IG51bWJlcltdO1xuICByZWFkb25seSBudW1PdXRwdXRzOiBudW1iZXI7XG59XG5cbmNvbnN0IHNwbGl0UHJvZ3JhbU1ldGFkYXRhID0ge1xuICBuYW1lOiAnU3BsaXQnLFxuICBpbnB1dE5hbWVzOiBbJ0EnXSxcbiAgaW5wdXRUeXBlczogW1RleHR1cmVUeXBlLnVucGFja2VkXSxcbn07XG5cbmV4cG9ydCBjb25zdCBzcGxpdDogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxTcGxpdEF0dHJpYnV0ZXM+ID0gKFxuICBpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsXG4gIGlucHV0czogVGVuc29yW10sXG4gIGF0dHJpYnV0ZXM6IFNwbGl0QXR0cmlidXRlcyxcbik6IFRlbnNvcltdID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoaW5wdXRzKTtcblxuICBjb25zdCBheGlzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMoYXR0cmlidXRlcy5heGlzLCBpbnB1dHNbMF0uZGltcy5sZW5ndGgpO1xuICBjb25zdCBjb3VudCA9IGdldFByb2dyYW1Db3VudChpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMsIGF4aXMsIGF0dHJpYnV0ZXMpO1xuICBjb25zdCBvdXRwdXQ6IFRlbnNvcltdID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgIG91dHB1dC5wdXNoKFxuICAgICAgaW5mZXJlbmNlSGFuZGxlci5ydW4oXG4gICAgICAgIHtcbiAgICAgICAgICAuLi5zcGxpdFByb2dyYW1NZXRhZGF0YSxcbiAgICAgICAgICBjYWNoZUhpbnQ6IGAke2F0dHJpYnV0ZXMuY2FjaGVLZXl9OyR7aX1gLFxuICAgICAgICAgIGdldDogKCkgPT4gY3JlYXRlU3BsaXRQcm9ncmFtSW5mbyhpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHNbMF0sIGF0dHJpYnV0ZXMsIGF4aXMsIGkpLFxuICAgICAgICB9LFxuICAgICAgICBpbnB1dHMsXG4gICAgICApLFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlU3BsaXRBdHRyaWJ1dGVzOiBPcGVyYXRvckluaXRpYWxpemF0aW9uPFNwbGl0QXR0cmlidXRlcz4gPSAobm9kZTogR3JhcGguTm9kZSk6IFNwbGl0QXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IGF4aXMgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0SW50KCdheGlzJywgMCk7XG4gIGNvbnN0IHNwbGl0ID0gbm9kZS5hdHRyaWJ1dGVzLmdldEludHMoJ3NwbGl0JywgW10pO1xuICBjb25zdCBudW1PdXRwdXRzID0gbm9kZS5vdXRwdXRzLmxlbmd0aDtcbiAgcmV0dXJuIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7IGF4aXMsIHNwbGl0LCBudW1PdXRwdXRzIH0pO1xufTtcblxuY29uc3QgZ2V0UHJvZ3JhbUNvdW50ID0gKFxuICBfaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLFxuICBpbnB1dHM6IFRlbnNvcltdLFxuICBheGlzOiBudW1iZXIsXG4gIGF0dHJpYnV0ZXM6IFNwbGl0QXR0cmlidXRlcyxcbik6IG51bWJlciA9PiB7XG4gIGNvbnN0IFssIG9mZnNldHNdID0gU3BsaXRVdGlsLnNwbGl0U2hhcGUoaW5wdXRzWzBdLmRpbXMsIGF4aXMsIGF0dHJpYnV0ZXMuc3BsaXQsIGF0dHJpYnV0ZXMubnVtT3V0cHV0cyk7XG4gIHJldHVybiBvZmZzZXRzLmxlbmd0aDtcbn07XG5cbmNvbnN0IGNyZWF0ZVNwbGl0UHJvZ3JhbUluZm8gPSAoXG4gIF9pbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsXG4gIGlucHV0OiBUZW5zb3IsXG4gIGF0dHJpYnV0ZXM6IFNwbGl0QXR0cmlidXRlcyxcbiAgYXhpczogbnVtYmVyLFxuICBpbmRleDogbnVtYmVyLFxuKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBbc2hhcGVzLCBvZmZzZXRzXSA9IFNwbGl0VXRpbC5zcGxpdFNoYXBlKGlucHV0LmRpbXMsIGF4aXMsIGF0dHJpYnV0ZXMuc3BsaXQsIGF0dHJpYnV0ZXMubnVtT3V0cHV0cyk7XG4gIGNvbnN0IG9mZnNldCA9IG9mZnNldHNbaW5kZXhdO1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IHNoYXBlc1tpbmRleF07XG4gIGNvbnN0IHJhbmsgPSBvdXRwdXRTaGFwZS5sZW5ndGg7XG4gIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbJHtyYW5rfV0pIHtcbiAgICAgICAgaW5kaWNlc1ske2F4aXN9XSArPSAke29mZnNldH07XG4gICAgICAgIHJldHVybiBfQShpbmRpY2VzKTtcbiAgICAgIH1cbiAgICBgO1xuICByZXR1cm4ge1xuICAgIC4uLnNwbGl0UHJvZ3JhbU1ldGFkYXRhLFxuICAgIGNhY2hlSGludDogYCR7YXR0cmlidXRlcy5jYWNoZUtleX06JHtpbmRleH1gLFxuICAgIG91dHB1dDogeyBkaW1zOiBvdXRwdXRTaGFwZSwgdHlwZTogaW5wdXQudHlwZSwgdGV4dHVyZVR5cGU6IFRleHR1cmVUeXBlLnVucGFja2VkIH0sXG4gICAgc2hhZGVyU291cmNlLFxuICB9O1xufTtcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiBUZW5zb3JbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTcGxpdCByZXF1aXJlcyBvbmUgaW5wdXQuJyk7XG4gIH1cblxuICBpZiAoXG4gICAgaW5wdXRzWzBdLnR5cGUgIT09ICdpbnQ4JyAmJlxuICAgIGlucHV0c1swXS50eXBlICE9PSAndWludDgnICYmXG4gICAgaW5wdXRzWzBdLnR5cGUgIT09ICdpbnQxNicgJiZcbiAgICBpbnB1dHNbMF0udHlwZSAhPT0gJ3VpbnQxNicgJiZcbiAgICBpbnB1dHNbMF0udHlwZSAhPT0gJ2ludDMyJyAmJlxuICAgIGlucHV0c1swXS50eXBlICE9PSAndWludDMyJyAmJlxuICAgIGlucHV0c1swXS50eXBlICE9PSAnZmxvYXQzMicgJiZcbiAgICBpbnB1dHNbMF0udHlwZSAhPT0gJ2Zsb2F0NjQnICYmXG4gICAgaW5wdXRzWzBdLnR5cGUgIT09ICdib29sJ1xuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgdHlwZS4nKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgR3JhcGggfSBmcm9tICcuLi8uLi8uLi9ncmFwaCc7XG5pbXBvcnQgeyBPcGVyYXRvckltcGxlbWVudGF0aW9uLCBPcGVyYXRvckluaXRpYWxpemF0aW9uIH0gZnJvbSAnLi4vLi4vLi4vb3BlcmF0b3JzJztcbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi8uLi91dGlsJztcbmltcG9ydCB7IFdlYkdMSW5mZXJlbmNlSGFuZGxlciB9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcblxuZXhwb3J0IGNvbnN0IHNxdWVlemU6IE9wZXJhdG9ySW1wbGVtZW50YXRpb248bnVtYmVyW10+ID0gKFxuICBpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsXG4gIGlucHV0czogVGVuc29yW10sXG4gIGF4ZXM6IG51bWJlcltdLFxuKTogVGVuc29yW10gPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IFNoYXBlVXRpbC5zcXVlZXplU2hhcGUoaW5wdXRzWzBdLmRpbXMsIGF4ZXMpO1xuICBjb25zdCBvdXRwdXQgPSBpbmZlcmVuY2VIYW5kbGVyLnJlc2hhcGVVbnBhY2tlZChpbnB1dHNbMF0sIG91dHB1dFNoYXBlKTtcbiAgcmV0dXJuIFtvdXRwdXRdO1xufTtcblxuZXhwb3J0IGNvbnN0IHNxdWVlemVWMTMgPSAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10gPT4ge1xuICB2YWxpZGF0ZUlucHV0c1YxMyhpbnB1dHMpO1xuICByZXR1cm4gc3F1ZWV6ZShpbmZlcmVuY2VIYW5kbGVyLCBbaW5wdXRzWzBdXSwgQXJyYXkuZnJvbShpbnB1dHNbMV0uaW50ZWdlckRhdGEpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZVNxdWVlemVBdHRyaWJ1dGVzOiBPcGVyYXRvckluaXRpYWxpemF0aW9uPG51bWJlcltdPiA9IChub2RlOiBHcmFwaC5Ob2RlKTogbnVtYmVyW10gPT5cbiAgbm9kZS5hdHRyaWJ1dGVzLmdldEludHMoJ2F4ZXMnKTtcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiBUZW5zb3JbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTcXVlZXplIHJlcXVpcmVzIDEgaW5wdXQuJyk7XG4gIH1cblxuICBpZiAoaW5wdXRzWzBdLnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGlucHV0IHRlbnNvciB0eXBlcy4nKTtcbiAgfVxufTtcblxuY29uc3QgdmFsaWRhdGVJbnB1dHNWMTMgPSAoaW5wdXRzOiBUZW5zb3JbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTcXVlZXplIHJlcXVpcmVzIDIgaW5wdXRzLicpO1xuICB9XG5cbiAgaWYgKGlucHV0c1sxXS50eXBlICE9PSAnaW50MzInKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0IHR5cGUuJyk7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQgeyBnZXRHbHNsIH0gZnJvbSAnLi4vZ2xzbC1zb3VyY2UnO1xuaW1wb3J0IHsgV2ViR0xJbmZlcmVuY2VIYW5kbGVyIH0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHsgUHJvZ3JhbUluZm8sIFByb2dyYW1NZXRhZGF0YSwgVGV4dHVyZVR5cGUgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBjb25zdCBzdW0gPSAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10gPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuXG4gIGNvbnN0IHN1bVByb2dyYW1NZXRhZGF0YSA9IHtcbiAgICBuYW1lOiAnU3VtJyxcbiAgICBpbnB1dE5hbWVzOiBpbnB1dHMubWFwKChfdiwgaSkgPT4gYFgke2l9YCksXG4gICAgaW5wdXRUeXBlczogbmV3IEFycmF5KGlucHV0cy5sZW5ndGgpLmZpbGwoVGV4dHVyZVR5cGUudW5wYWNrZWQpLFxuICB9O1xuXG4gIGNvbnN0IG91dHB1dCA9IGluZmVyZW5jZUhhbmRsZXIucnVuKFxuICAgIHsgLi4uc3VtUHJvZ3JhbU1ldGFkYXRhLCBnZXQ6ICgpID0+IGNyZWF0ZVN1bVByb2dyYW1JbmZvKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0cywgc3VtUHJvZ3JhbU1ldGFkYXRhKSB9LFxuICAgIGlucHV0cyxcbiAgKTtcbiAgcmV0dXJuIFtvdXRwdXRdO1xufTtcblxuY29uc3QgY3JlYXRlU3VtUHJvZ3JhbUluZm8gPSAoXG4gIGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlcixcbiAgaW5wdXRzOiBUZW5zb3JbXSxcbiAgc3VtUHJvZ3JhbU1ldGFkYXRhOiBQcm9ncmFtTWV0YWRhdGEsXG4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGdsc2wgPSBnZXRHbHNsKGluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcy5zbGljZSgpO1xuICBjb25zdCBzdW1MaW5lID0gaW5wdXRzLm1hcCgoX3YsIGkpID0+IGAke2dsc2wudGV4dHVyZTJEfShYJHtpfSxUZXhDb29yZHMpYCkuam9pbignICsgJyk7XG4gIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgdmVjNCByZXN1bHQgPSAke3N1bUxpbmV9O1xuICAgICAgICAke2dsc2wub3V0cHV0fSA9IHJlc3VsdDtcbiAgICAgIH1cbiAgICBgO1xuICByZXR1cm4ge1xuICAgIC4uLnN1bVByb2dyYW1NZXRhZGF0YSxcbiAgICBvdXRwdXQ6IHsgZGltczogb3V0cHV0U2hhcGUsIHR5cGU6IGlucHV0c1swXS50eXBlLCB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGUudW5wYWNrZWQgfSxcbiAgICBoYXNNYWluOiB0cnVlLFxuICAgIHNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogVGVuc29yW10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignU3VtIHJlcXVpcmVzIGlucHV0cy4nKTtcbiAgfVxuXG4gIGNvbnN0IGxlbmd0aCA9IGlucHV0c1swXS5kaW1zLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBpbnB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobGVuZ3RoICE9PSBpbnB1dHNbaV0uZGltcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgc2hhcGVzIGFyZSBtaXNtYXRjaGVkLicpO1xuICAgIH1cblxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmIChpbnB1dHNbMF0uZGltc1tqXSAhPT0gaW5wdXRzW2ldLmRpbXNbal0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBzaGFwZXMgYXJlIG5vdCBtYXRjaGVkLicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChpbnB1dHNbMF0udHlwZSAhPT0gJ2Zsb2F0MzInICYmIGlucHV0c1swXS50eXBlICE9PSAnZmxvYXQ2NCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgdHlwZS4nKTtcbiAgfVxuICBmb3IgKGxldCBpID0gMTsgaSA8IGlucHV0cy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChpbnB1dHNbMF0udHlwZSAhPT0gaW5wdXRzW2ldLnR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgdHlwZXMgYXJlIG5vdCBtYXRjaGVkLicpO1xuICAgIH1cbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgTlVNQkVSX1RZUEVTIH0gZnJvbSAnLi4vLi4vLi4vb3BlcmF0b3JzJztcbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQgeyBXZWJHTEluZmVyZW5jZUhhbmRsZXIgfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQgeyBQcm9ncmFtSW5mbywgUHJvZ3JhbU1ldGFkYXRhLCBUZXh0dXJlVHlwZSB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGNvbnN0IHRpbGUgPSAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10gPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuXG4gIGNvbnN0IHRpbGVQcm9ncmFtTWV0YWRhdGEgPSB7XG4gICAgbmFtZTogJ1RpbGUnLFxuICAgIGlucHV0TmFtZXM6IFsnQSddLFxuICAgIGlucHV0VHlwZXM6IFtUZXh0dXJlVHlwZS51bnBhY2tlZF0sXG4gIH07XG5cbiAgY29uc3Qgb3V0cHV0ID0gaW5mZXJlbmNlSGFuZGxlci5ydW4oXG4gICAgeyAuLi50aWxlUHJvZ3JhbU1ldGFkYXRhLCBnZXQ6ICgpID0+IGNyZWF0ZVRpbGVQcm9ncmFtSW5mbyhpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMsIHRpbGVQcm9ncmFtTWV0YWRhdGEpIH0sXG4gICAgaW5wdXRzLFxuICApO1xuICByZXR1cm4gW291dHB1dF07XG59O1xuXG5jb25zdCBjcmVhdGVUaWxlUHJvZ3JhbUluZm8gPSAoXG4gIF9oYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsXG4gIGlucHV0czogVGVuc29yW10sXG4gIHRpbGVQcm9ncmFtTWV0YWRhdGE6IFByb2dyYW1NZXRhZGF0YSxcbik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zLnNsaWNlKCk7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gbmV3IEFycmF5KGlucHV0U2hhcGUubGVuZ3RoKTtcblxuICBjb25zdCB0aWxlT3BzOiBzdHJpbmdbXSA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0U2hhcGUubGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRTaGFwZVtpXSA9IGlucHV0U2hhcGVbaV0gKiBpbnB1dHNbMV0ubnVtYmVyRGF0YVtpXTtcbiAgICB0aWxlT3BzLnB1c2goYGlucHV0SWR4WyR7aX1dID0gaW50KG1vZChmbG9hdChvdXRwdXRJZHhbJHtpfV0pLCAke2lucHV0U2hhcGVbaV19LikpO2ApO1xuICB9XG5cbiAgY29uc3QgcmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aDtcbiAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgb3V0cHV0SWR4WyR7cmFua31dKSB7XG4gICAgICAgIGludCBpbnB1dElkeFske3Jhbmt9XTtcbiAgICAgICAgJHt0aWxlT3BzLmpvaW4oJ1xcbicpfVxuICAgICAgICByZXR1cm4gX0EoaW5wdXRJZHgpO1xuICAgICAgfVxuICAgIGA7XG4gIHJldHVybiB7XG4gICAgLi4udGlsZVByb2dyYW1NZXRhZGF0YSxcbiAgICBvdXRwdXQ6IHsgZGltczogb3V0cHV0U2hhcGUsIHR5cGU6IGlucHV0c1swXS50eXBlLCB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGUudW5wYWNrZWQgfSxcbiAgICBzaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IFRlbnNvcltdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RpbGUgcmVxdWlyZXMgMiBpbnB1dC4nKTtcbiAgfVxuICBpZiAoaW5wdXRzWzFdLmRpbXMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc2Vjb25kIGlucHV0IHNoYXBlIG11c3QgMSBkaW1lbnNpb24uJyk7XG4gIH1cbiAgaWYgKGlucHV0c1sxXS5kaW1zWzBdICE9PSBpbnB1dHNbMF0uZGltcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgc2hhcGUuJyk7XG4gIH1cbiAgaWYgKE5VTUJFUl9UWVBFUy5pbmRleE9mKGlucHV0c1swXS50eXBlKSA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgdHlwZS4nKTtcbiAgfVxuICBpZiAoaW5wdXRzWzFdLnR5cGUgIT09ICdpbnQzMicgJiYgaW5wdXRzWzFdLnR5cGUgIT09ICdpbnQxNicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmVwZWF0IHR5cGUuJyk7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEdyYXBoIH0gZnJvbSAnLi4vLi4vLi4vZ3JhcGgnO1xuaW1wb3J0IHsgT3BlcmF0b3JJbXBsZW1lbnRhdGlvbiwgT3BlcmF0b3JJbml0aWFsaXphdGlvbiB9IGZyb20gJy4uLy4uLy4uL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBUZW5zb3IgfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBXZWJHTEluZmVyZW5jZUhhbmRsZXIgfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5cbmV4cG9ydCBjb25zdCB1bnNxdWVlemU6IE9wZXJhdG9ySW1wbGVtZW50YXRpb248bnVtYmVyW10+ID0gKFxuICBpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsXG4gIGlucHV0czogVGVuc29yW10sXG4gIGF4ZXM6IG51bWJlcltdLFxuKTogVGVuc29yW10gPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IFNoYXBlVXRpbC51bnNxdWVlemVTaGFwZShpbnB1dHNbMF0uZGltcywgYXhlcyk7XG4gIGNvbnN0IG91dHB1dCA9IGluZmVyZW5jZUhhbmRsZXIucmVzaGFwZVVucGFja2VkKGlucHV0c1swXSwgb3V0cHV0U2hhcGUpO1xuICByZXR1cm4gW291dHB1dF07XG59O1xuXG5leHBvcnQgY29uc3QgdW5zcXVlZXplVjEzID0gKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdID0+IHtcbiAgdmFsaWRhdGVJbnB1dHNWMTMoaW5wdXRzKTtcbiAgcmV0dXJuIHVuc3F1ZWV6ZShpbmZlcmVuY2VIYW5kbGVyLCBbaW5wdXRzWzBdXSwgQXJyYXkuZnJvbShpbnB1dHNbMV0uaW50ZWdlckRhdGEpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZVVuc3F1ZWV6ZUF0dHJpYnV0ZXM6IE9wZXJhdG9ySW5pdGlhbGl6YXRpb248bnVtYmVyW10+ID0gKG5vZGU6IEdyYXBoLk5vZGUpOiBudW1iZXJbXSA9PlxuICBub2RlLmF0dHJpYnV0ZXMuZ2V0SW50cygnYXhlcycpO1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IFRlbnNvcltdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3F1ZWV6ZSByZXF1aXJlcyAxIGlucHV0LicpO1xuICB9XG5cbiAgaWYgKGlucHV0c1swXS50eXBlID09PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbnB1dCB0ZW5zb3IgdHlwZXMuJyk7XG4gIH1cbn07XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzVjEzID0gKGlucHV0czogVGVuc29yW10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5zcXVlZXplIHJlcXVpcmVzIDIgaW5wdXRzLicpO1xuICB9XG5cbiAgaWYgKGlucHV0c1sxXS50eXBlICE9PSAnaW50MzInKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0IHR5cGUuJyk7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IE9wU2V0IH0gZnJvbSAnLi4vLi4vb3BzZXQnO1xuXG5pbXBvcnQgeyBiYXRjaE5vcm1hbGl6YXRpb24sIHBhcnNlQmF0Y2hOb3JtYWxpemF0aW9uQXR0cmlidXRlcyB9IGZyb20gJy4vb3BzL2JhdGNoLW5vcm1hbGl6YXRpb24nO1xuaW1wb3J0ICogYXMgYmluYXJ5T3BzIGZyb20gJy4vb3BzL2JpbmFyeS1vcCc7XG5pbXBvcnQgeyBjYXN0LCBwYXJzZUNhc3RBdHRyaWJ1dGVzIH0gZnJvbSAnLi9vcHMvY2FzdCc7XG5pbXBvcnQgeyBjb25jYXQsIHBhcnNlQ29uY2F0QXR0cmlidXRlcyB9IGZyb20gJy4vb3BzL2NvbmNhdCc7XG5pbXBvcnQgeyBjb252LCBwYXJzZUNvbnZBdHRyaWJ1dGVzIH0gZnJvbSAnLi9vcHMvY29udic7XG5pbXBvcnQgeyBjb252VHJhbnNwb3NlLCBwYXJzZUNvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzIH0gZnJvbSAnLi9vcHMvY29udi10cmFuc3Bvc2UnO1xuaW1wb3J0IHsgZGVwdGhUb1NwYWNlLCBwYXJzZURlcHRoVG9TcGFjZUF0dHJpYnV0ZXMgfSBmcm9tICcuL29wcy9kZXB0aC10by1zcGFjZSc7XG5pbXBvcnQgeyBmbGF0dGVuLCBwYXJzZUZsYXR0ZW5BdHRyaWJ1dGVzIH0gZnJvbSAnLi9vcHMvZmxhdHRlbic7XG5pbXBvcnQgeyBnYXRoZXIsIHBhcnNlR2F0aGVyQXR0cmlidXRlcyB9IGZyb20gJy4vb3BzL2dhdGhlcic7XG5pbXBvcnQgeyBnZW1tLCBwYXJzZUdlbW1BdHRyaWJ1dGVzVjExLCBwYXJzZUdlbW1BdHRyaWJ1dGVzVjcgfSBmcm9tICcuL29wcy9nZW1tJztcbmltcG9ydCB7IGltYWdlU2NhbGVyLCBwYXJzZUltYWdlU2NhbGVyQXR0cmlidXRlcyB9IGZyb20gJy4vb3BzL2ltYWdlLXNjYWxlcic7XG5pbXBvcnQgeyBpbnN0YW5jZU5vcm1hbGl6YXRpb24sIHBhcnNlSW5zdGFuY2VOb3JtYWxpemF0aW9uQXR0cmlidXRlcyB9IGZyb20gJy4vb3BzL2luc3RhbmNlLW5vcm1hbGl6YXRpb24nO1xuaW1wb3J0IHsgbHJuLCBwYXJzZUxybkF0dHJpYnV0ZXMgfSBmcm9tICcuL29wcy9scm4nO1xuaW1wb3J0IHsgbWF0TXVsLCBwYXJzZU1hdE11bEF0dHJpYnV0ZXMgfSBmcm9tICcuL29wcy9tYXRtdWwnO1xuaW1wb3J0IHsgcGFkVjExLCBwYWRWMiwgcGFyc2VQYWRBdHRyaWJ1dGVzVjExLCBwYXJzZVBhZEF0dHJpYnV0ZXNWMiB9IGZyb20gJy4vb3BzL3BhZCc7XG5pbXBvcnQge1xuICBhdmVyYWdlUG9vbCxcbiAgZ2xvYmFsQXZlcmFnZVBvb2wsXG4gIGdsb2JhbE1heFBvb2wsXG4gIG1heFBvb2wsXG4gIHBhcnNlQXZlcmFnZVBvb2xBdHRyaWJ1dGVzLFxuICBwYXJzZUdsb2JhbEF2ZXJhZ2VQb29sQXR0cmlidXRlcyxcbiAgcGFyc2VNYXhQb29sQXR0cmlidXRlcyxcbn0gZnJvbSAnLi9vcHMvcG9vbCc7XG5pbXBvcnQge1xuICBwYXJzZVJlZHVjZUF0dHJpYnV0ZXMsXG4gIHJlZHVjZUxvZ1N1bSxcbiAgcmVkdWNlTG9nU3VtU3F1YXJlLFxuICByZWR1Y2VNYXgsXG4gIHJlZHVjZU1lYW4sXG4gIHJlZHVjZU1pbixcbiAgcmVkdWNlUHJvZCxcbiAgcmVkdWNlU3VtLFxufSBmcm9tICcuL29wcy9yZWR1Y2UnO1xuaW1wb3J0IHsgcmVzaGFwZSB9IGZyb20gJy4vb3BzL3Jlc2hhcGUnO1xuaW1wb3J0IHsgcGFyc2VSZXNpemVBdHRyaWJ1dGVzVjEwLCBwYXJzZVJlc2l6ZUF0dHJpYnV0ZXNWMTEsIHJlc2l6ZSB9IGZyb20gJy4vb3BzL3Jlc2l6ZS1wYWNrZWQnO1xuaW1wb3J0IHsgc2hhcGUgfSBmcm9tICcuL29wcy9zaGFwZSc7XG5pbXBvcnQgeyBwYXJzZVNsaWNlQXR0cmlidXRlcywgc2xpY2UsIHNsaWNlVjEwIH0gZnJvbSAnLi9vcHMvc2xpY2UnO1xuaW1wb3J0IHsgcGFyc2VTb2Z0bWF4QXR0cmlidXRlcywgcGFyc2VTb2Z0bWF4QXR0cmlidXRlc1YxMywgc29mdG1heCwgc29mdG1heFYxMyB9IGZyb20gJy4vb3BzL3NvZnRtYXgnO1xuaW1wb3J0IHsgcGFyc2VTcGxpdEF0dHJpYnV0ZXMsIHNwbGl0IH0gZnJvbSAnLi9vcHMvc3BsaXQnO1xuaW1wb3J0IHsgcGFyc2VTcXVlZXplQXR0cmlidXRlcywgc3F1ZWV6ZSwgc3F1ZWV6ZVYxMyB9IGZyb20gJy4vb3BzL3NxdWVlemUnO1xuaW1wb3J0IHsgc3VtIH0gZnJvbSAnLi9vcHMvc3VtJztcbmltcG9ydCB7IHRpbGUgfSBmcm9tICcuL29wcy90aWxlJztcbmltcG9ydCB7IHBhcnNlVHJhbnNwb3NlQXR0cmlidXRlcywgdHJhbnNwb3NlIH0gZnJvbSAnLi9vcHMvdHJhbnNwb3NlJztcbmltcG9ydCAqIGFzIHVuYXJ5T3BzIGZyb20gJy4vb3BzL3VuYXJ5LW9wJztcbmltcG9ydCB7IHBhcnNlVW5zcXVlZXplQXR0cmlidXRlcywgdW5zcXVlZXplLCB1bnNxdWVlemVWMTMgfSBmcm9tICcuL29wcy91bnNxdWVlemUnO1xuaW1wb3J0IHsgcGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXNWNywgcGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXNWOSwgdXBzYW1wbGUgfSBmcm9tICcuL29wcy91cHNhbXBsZSc7XG5cbmV4cG9ydCBjb25zdCBXRUJHTF9PUF9SRVNPTFZFX1JVTEVTOiByZWFkb25seSBPcFNldC5SZXNvbHZlUnVsZVtdID0gW1xuICBbJ0FicycsICcnLCAnNisnLCB1bmFyeU9wcy5hYnNdLFxuICBbJ0Fjb3MnLCAnJywgJzcrJywgdW5hcnlPcHMuYWNvc10sXG4gIFsnQWRkJywgJycsICc3KycsIGJpbmFyeU9wcy5hZGRdLFxuICBbJ0FuZCcsICcnLCAnNysnLCBiaW5hcnlPcHMuYW5kXSxcbiAgWydBc2luJywgJycsICc3KycsIHVuYXJ5T3BzLmFzaW5dLFxuICBbJ0F0YW4nLCAnJywgJzcrJywgdW5hcnlPcHMuYXRhbl0sXG4gIC8vIFRPRE86IHN1cHBvcnQgbmV3IGF0dHJpYnV0ZXMgZm9yIEF2ZXJhZ2VQb29sLTEwXG4gIFsnQXZlcmFnZVBvb2wnLCAnJywgJzcrJywgYXZlcmFnZVBvb2wsIHBhcnNlQXZlcmFnZVBvb2xBdHRyaWJ1dGVzXSxcbiAgWydCYXRjaE5vcm1hbGl6YXRpb24nLCAnJywgJzcrJywgYmF0Y2hOb3JtYWxpemF0aW9uLCBwYXJzZUJhdGNoTm9ybWFsaXphdGlvbkF0dHJpYnV0ZXNdLFxuICBbJ0Nhc3QnLCAnJywgJzYrJywgY2FzdCwgcGFyc2VDYXN0QXR0cmlidXRlc10sXG4gIFsnQ2VpbCcsICcnLCAnNisnLCB1bmFyeU9wcy5jZWlsXSxcbiAgWydDbGlwJywgJycsICc2LTEwJywgdW5hcnlPcHMuY2xpcCwgdW5hcnlPcHMucGFyc2VDbGlwQXR0cmlidXRlc10sXG4gIFsnQ2xpcCcsICcnLCAnMTErJywgdW5hcnlPcHMuY2xpcFYxMV0sXG4gIFsnQ29uY2F0JywgJycsICc0KycsIGNvbmNhdCwgcGFyc2VDb25jYXRBdHRyaWJ1dGVzXSxcbiAgWydDb252JywgJycsICcxKycsIGNvbnYsIHBhcnNlQ29udkF0dHJpYnV0ZXNdLFxuICBbJ0NvbnZUcmFuc3Bvc2UnLCAnJywgJzErJywgY29udlRyYW5zcG9zZSwgcGFyc2VDb252VHJhbnNwb3NlQXR0cmlidXRlc10sXG4gIFsnQ29zJywgJycsICc3KycsIHVuYXJ5T3BzLmNvc10sXG4gIFsnRGl2JywgJycsICc3KycsIGJpbmFyeU9wcy5kaXZdLFxuICBbJ0Ryb3BvdXQnLCAnJywgJzcrJywgdW5hcnlPcHMuaWRlbnRpdHldLFxuICBbJ0RlcHRoVG9TcGFjZScsICcnLCAnMSsnLCBkZXB0aFRvU3BhY2UsIHBhcnNlRGVwdGhUb1NwYWNlQXR0cmlidXRlc10sXG4gIFsnRXF1YWwnLCAnJywgJzcrJywgYmluYXJ5T3BzLmVxdWFsXSxcbiAgWydFbHUnLCAnJywgJzYrJywgdW5hcnlPcHMuZWx1LCB1bmFyeU9wcy5wYXJzZUVsdUF0dHJpYnV0ZXNdLFxuICBbJ0V4cCcsICcnLCAnNisnLCB1bmFyeU9wcy5leHBdLFxuICBbJ0ZsYXR0ZW4nLCAnJywgJzErJywgZmxhdHRlbiwgcGFyc2VGbGF0dGVuQXR0cmlidXRlc10sXG4gIFsnRmxvb3InLCAnJywgJzYrJywgdW5hcnlPcHMuZmxvb3JdLFxuICBbJ0Z1c2VkQ29udicsICdjb20ubWljcm9zb2Z0JywgJzErJywgY29udiwgcGFyc2VDb252QXR0cmlidXRlc10sXG4gIFsnR2F0aGVyJywgJycsICcxKycsIGdhdGhlciwgcGFyc2VHYXRoZXJBdHRyaWJ1dGVzXSxcbiAgWydHZW1tJywgJycsICc3LTEwJywgZ2VtbSwgcGFyc2VHZW1tQXR0cmlidXRlc1Y3XSxcbiAgWydHZW1tJywgJycsICcxMSsnLCBnZW1tLCBwYXJzZUdlbW1BdHRyaWJ1dGVzVjExXSxcbiAgWydHbG9iYWxBdmVyYWdlUG9vbCcsICcnLCAnMSsnLCBnbG9iYWxBdmVyYWdlUG9vbCwgcGFyc2VHbG9iYWxBdmVyYWdlUG9vbEF0dHJpYnV0ZXNdLFxuICBbJ0dsb2JhbE1heFBvb2wnLCAnJywgJzErJywgZ2xvYmFsTWF4UG9vbF0sXG4gIFsnR3JlYXRlcicsICcnLCAnNysnLCBiaW5hcnlPcHMuZ3JlYXRlcl0sXG4gIFsnSWRlbnRpdHknLCAnJywgJzErJywgdW5hcnlPcHMuaWRlbnRpdHldLFxuICBbJ0ltYWdlU2NhbGVyJywgJycsICcxKycsIGltYWdlU2NhbGVyLCBwYXJzZUltYWdlU2NhbGVyQXR0cmlidXRlc10sXG4gIFsnSW5zdGFuY2VOb3JtYWxpemF0aW9uJywgJycsICc2KycsIGluc3RhbmNlTm9ybWFsaXphdGlvbiwgcGFyc2VJbnN0YW5jZU5vcm1hbGl6YXRpb25BdHRyaWJ1dGVzXSxcbiAgWydMZWFreVJlbHUnLCAnJywgJzYrJywgdW5hcnlPcHMubGVha3lSZWx1LCB1bmFyeU9wcy5wYXJzZUxlYWt5UmVsdUF0dHJpYnV0ZXNdLFxuICBbJ0xlc3MnLCAnJywgJzcrJywgYmluYXJ5T3BzLmxlc3NdLFxuICBbJ0xSTicsICcnLCAnMSsnLCBscm4sIHBhcnNlTHJuQXR0cmlidXRlc10sXG4gIFsnTG9nJywgJycsICc2KycsIHVuYXJ5T3BzLmxvZ10sXG4gIFsnTWF0TXVsJywgJycsICcxKycsIG1hdE11bCwgcGFyc2VNYXRNdWxBdHRyaWJ1dGVzXSxcbiAgLy8gVE9ETzogc3VwcG9ydCBuZXcgYXR0cmlidXRlcyBmb3IgTWF4UG9vbC04IGFuZCBNYXhQb29sLTEwXG4gIFsnTWF4UG9vbCcsICcnLCAnMSsnLCBtYXhQb29sLCBwYXJzZU1heFBvb2xBdHRyaWJ1dGVzXSxcbiAgWydNdWwnLCAnJywgJzcrJywgYmluYXJ5T3BzLm11bF0sXG4gIFsnTmVnJywgJycsICc2KycsIHVuYXJ5T3BzLm5lZ10sXG4gIFsnTm90JywgJycsICcxKycsIHVuYXJ5T3BzLm5vdF0sXG4gIFsnT3InLCAnJywgJzcrJywgYmluYXJ5T3BzLm9yXSxcbiAgWydQYWQnLCAnJywgJzItMTAnLCBwYWRWMiwgcGFyc2VQYWRBdHRyaWJ1dGVzVjJdLFxuICBbJ1BhZCcsICcnLCAnMTErJywgcGFkVjExLCBwYXJzZVBhZEF0dHJpYnV0ZXNWMTFdLFxuICBbJ1BvdycsICcnLCAnNysnLCBiaW5hcnlPcHMucG93XSxcbiAgWydQUmVsdScsICcnLCAnNysnLCBiaW5hcnlPcHMucFJlbHVdLFxuICBbJ1JlZHVjZUxvZ1N1bScsICcnLCAnMSsnLCByZWR1Y2VMb2dTdW0sIHBhcnNlUmVkdWNlQXR0cmlidXRlc10sXG4gIFsnUmVkdWNlTWF4JywgJycsICcxKycsIHJlZHVjZU1heCwgcGFyc2VSZWR1Y2VBdHRyaWJ1dGVzXSxcbiAgWydSZWR1Y2VNZWFuJywgJycsICcxKycsIHJlZHVjZU1lYW4sIHBhcnNlUmVkdWNlQXR0cmlidXRlc10sXG4gIFsnUmVkdWNlTWluJywgJycsICcxKycsIHJlZHVjZU1pbiwgcGFyc2VSZWR1Y2VBdHRyaWJ1dGVzXSxcbiAgWydSZWR1Y2VQcm9kJywgJycsICcxKycsIHJlZHVjZVByb2QsIHBhcnNlUmVkdWNlQXR0cmlidXRlc10sXG4gIFsnUmVkdWNlU3VtJywgJycsICcxLTEyJywgcmVkdWNlU3VtLCBwYXJzZVJlZHVjZUF0dHJpYnV0ZXNdLFxuICBbJ1JlZHVjZVN1bVNxdWFyZScsICcnLCAnMSsnLCByZWR1Y2VMb2dTdW1TcXVhcmUsIHBhcnNlUmVkdWNlQXR0cmlidXRlc10sXG4gIFsnUmVsdScsICcnLCAnNisnLCB1bmFyeU9wcy5yZWx1XSxcbiAgWydSZXNoYXBlJywgJycsICc1KycsIHJlc2hhcGVdLFxuICBbJ1Jlc2l6ZScsICcnLCAnMTAnLCByZXNpemUsIHBhcnNlUmVzaXplQXR0cmlidXRlc1YxMF0sXG4gIFsnUmVzaXplJywgJycsICcxMSsnLCByZXNpemUsIHBhcnNlUmVzaXplQXR0cmlidXRlc1YxMV0sXG4gIFsnU2hhcGUnLCAnJywgJzErJywgc2hhcGVdLFxuICBbJ1NpZ21vaWQnLCAnJywgJzYrJywgdW5hcnlPcHMuc2lnbW9pZF0sXG4gIFsnU2luJywgJycsICc3KycsIHVuYXJ5T3BzLnNpbl0sXG4gIFsnU2xpY2UnLCAnJywgJzEwKycsIHNsaWNlVjEwXSwgLy8gVE9ETzogc3VwcG9ydCAnc3RlcHMnIGZvciBTbGljZS0xMFxuICBbJ1NsaWNlJywgJycsICcxLTknLCBzbGljZSwgcGFyc2VTbGljZUF0dHJpYnV0ZXNdLFxuICAvLyBUaGUgXCJzZW1hbnRpY1wiIG1lYW5pbmcgb2YgYXhpcyBoYXMgY2hhbmdlZCBpbiBvcHNldC0xMy5cbiAgWydTb2Z0bWF4JywgJycsICcxLTEyJywgc29mdG1heCwgcGFyc2VTb2Z0bWF4QXR0cmlidXRlc10sXG4gIFsnU29mdG1heCcsICcnLCAnMTMrJywgc29mdG1heFYxMywgcGFyc2VTb2Z0bWF4QXR0cmlidXRlc1YxM10sXG4gIC8vICdTcGxpdCcgb3BlcmF0b3IgaGFzIGFuIG9wdGlvbmFsIGF0dHJpYnV0ZSAnc3BsaXQnXG4gIC8vIHRoaXMgYXR0cmlidXRlIGRldGVybWluZXMgaG93IHRoZSBzcGVjaWZpZWQgYXhpcyBvZiBpbnB1dCBkYXRhIGlzIHNwbGl0LlxuICAvLyBXaGVuIHRoZSBhdHRyaWJ1dGUgaXMgbWlzc2luZywgd2UgbmVlZCB0aGUgY291bnQgb2YgbnVtYmVyIG9mIG91dHB1dHNcbiAgLy8gc28gdGhhdCB3ZSBjYW4gZGV0ZXJtaW5lIHRoZSAnc3BsaXQnIGF0dHJpYnV0ZSBmcm9tIHRoZSBydW50aW1lIGlucHV0IHRvIHRoZSBPcGVyYXRvclxuICBbJ1NwbGl0JywgJycsICcyLTEyJywgc3BsaXQsIHBhcnNlU3BsaXRBdHRyaWJ1dGVzXSxcbiAgWydTcXJ0JywgJycsICc2KycsIHVuYXJ5T3BzLnNxcnRdLFxuICBbJ1NxdWVlemUnLCAnJywgJzEtMTInLCBzcXVlZXplLCBwYXJzZVNxdWVlemVBdHRyaWJ1dGVzXSxcbiAgWydTcXVlZXplJywgJycsICcxMysnLCBzcXVlZXplVjEzXSxcbiAgWydTdWInLCAnJywgJzcrJywgYmluYXJ5T3BzLnN1Yl0sXG4gIFsnU3VtJywgJycsICc2KycsIHN1bV0sXG4gIFsnVGFuJywgJycsICc3KycsIHVuYXJ5T3BzLnRhbl0sXG4gIFsnVGFuaCcsICcnLCAnNisnLCB1bmFyeU9wcy50YW5oXSxcbiAgWydUaWxlJywgJycsICc2KycsIHRpbGVdLFxuICBbJ1RyYW5zcG9zZScsICcnLCAnMSsnLCB0cmFuc3Bvc2UsIHBhcnNlVHJhbnNwb3NlQXR0cmlidXRlc10sXG4gIFsnVXBzYW1wbGUnLCAnJywgJzctOCcsIHVwc2FtcGxlLCBwYXJzZVVwc2FtcGxlQXR0cmlidXRlc1Y3XSxcbiAgWydVcHNhbXBsZScsICcnLCAnOScsIHVwc2FtcGxlLCBwYXJzZVVwc2FtcGxlQXR0cmlidXRlc1Y5XSxcbiAgWydVbnNxdWVlemUnLCAnJywgJzEtMTInLCB1bnNxdWVlemUsIHBhcnNlVW5zcXVlZXplQXR0cmlidXRlc10sXG4gIFsnVW5zcXVlZXplJywgJycsICcxMysnLCB1bnNxdWVlemVWMTNdLFxuICBbJ1hvcicsICcnLCAnNysnLCBiaW5hcnlPcHMueG9yXSxcbl07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmNvbnN0IElOTElORV9GVU5DX0RFRl9SRUdFWCA9IC9AaW5saW5lW1xcc1xcblxccl0rKFxcdyspW1xcc1xcblxccl0rKFswLTlhLXpBLVpfXSspXFxzKlxcKChbXildKilcXClcXHMqeygoW159XXxbXFxuXFxyXSkqKX0vZ207XG5jb25zdCBGVU5DX0NBTExfUkVHRVggPSAnKFxcXFx3Kyk/XFxcXHMrKFtfMC05YS16QS1aXSspXFxcXHMrPVxcXFxzK19fRlVOQ19fXFxcXCgoLiopXFxcXClcXFxccyo7Jztcbi8qKlxuICogR0xTTCBwcmVwcm9jZXNzb3IgcmVzcG9uc2libGUgZm9yIHJlc29sdmluZyBAaW5saW5lIGRpcmVjdGl2ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlcGxhY2VJbmxpbmVzKHNjcmlwdDogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3QgaW5saW5lRGVmczogeyBbbmFtZTogc3RyaW5nXTogeyBwYXJhbXM6IEFycmF5PHsgdHlwZTogc3RyaW5nOyBuYW1lOiBzdHJpbmcgfSB8IG51bGw+OyBib2R5OiBzdHJpbmcgfSB9ID0ge307XG4gIGxldCBtYXRjaDtcbiAgd2hpbGUgKChtYXRjaCA9IElOTElORV9GVU5DX0RFRl9SRUdFWC5leGVjKHNjcmlwdCkpICE9PSBudWxsKSB7XG4gICAgY29uc3QgcGFyYW1zID0gbWF0Y2hbM11cbiAgICAgIC5zcGxpdCgnLCcpXG4gICAgICAubWFwKChzKSA9PiB7XG4gICAgICAgIGNvbnN0IHRva2VucyA9IHMudHJpbSgpLnNwbGl0KCcgJyk7XG4gICAgICAgIGlmICh0b2tlbnMgJiYgdG9rZW5zLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIHJldHVybiB7IHR5cGU6IHRva2Vuc1swXSwgbmFtZTogdG9rZW5zWzFdIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9KVxuICAgICAgLmZpbHRlcigodikgPT4gdiAhPT0gbnVsbCk7XG4gICAgaW5saW5lRGVmc1ttYXRjaFsyXV0gPSB7IHBhcmFtcywgYm9keTogbWF0Y2hbNF0gfTtcbiAgfVxuICBmb3IgKGNvbnN0IG5hbWUgaW4gaW5saW5lRGVmcykge1xuICAgIGNvbnN0IHJlZ2V4U3RyaW5nID0gRlVOQ19DQUxMX1JFR0VYLnJlcGxhY2UoJ19fRlVOQ19fJywgbmFtZSk7XG4gICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKHJlZ2V4U3RyaW5nLCAnZ20nKTtcbiAgICB3aGlsZSAoKG1hdGNoID0gcmVnZXguZXhlYyhzY3JpcHQpKSAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgdHlwZSA9IG1hdGNoWzFdO1xuICAgICAgY29uc3QgdmFyaWFibGUgPSBtYXRjaFsyXTtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IG1hdGNoWzNdLnNwbGl0KCcsJyk7XG4gICAgICBjb25zdCBkZWNsTGluZSA9IHR5cGUgPyBgJHt0eXBlfSAke3ZhcmlhYmxlfTtgIDogJyc7XG4gICAgICBsZXQgbmV3Qm9keTogc3RyaW5nID0gaW5saW5lRGVmc1tuYW1lXS5ib2R5O1xuICAgICAgbGV0IHBhcmFtUmVkZWNMaW5lID0gJyc7XG4gICAgICBpbmxpbmVEZWZzW25hbWVdLnBhcmFtcy5mb3JFYWNoKCh2LCBpKSA9PiB7XG4gICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgcGFyYW1SZWRlY0xpbmUgKz0gYCR7di50eXBlfSAke3YubmFtZX0gPSAke3BhcmFtc1tpXX07XFxuYDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBuZXdCb2R5ID0gYCR7cGFyYW1SZWRlY0xpbmV9XFxuICR7bmV3Qm9keX1gO1xuICAgICAgbmV3Qm9keSA9IG5ld0JvZHkucmVwbGFjZSgncmV0dXJuJywgYCR7dmFyaWFibGV9ID0gYCk7XG4gICAgICBjb25zdCByZXBsYWNlbWVudCA9IGBcbiAgICAgICR7ZGVjbExpbmV9XG4gICAgICB7XG4gICAgICAgICR7bmV3Qm9keX1cbiAgICAgIH1cbiAgICAgIGA7XG4gICAgICBzY3JpcHQgPSBzY3JpcHQucmVwbGFjZShtYXRjaFswXSwgcmVwbGFjZW1lbnQpO1xuICAgIH1cbiAgfVxuICBzY3JpcHQgPSBzY3JpcHQucmVwbGFjZShJTkxJTkVfRlVOQ19ERUZfUkVHRVgsICcnKTtcbiAgcmV0dXJuIHNjcmlwdDtcbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnLi4vLi4vaW5zdHJ1bWVudCc7XG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICcuLi8uLi91dGlsJztcblxuLyoqIExheW91dCBwcmVmZXJlbmNlcyAqL1xuZXhwb3J0IGludGVyZmFjZSBXaWR0aEhlaWdodFByZWZzIHtcbiAgYnJlYWtBeGlzPzogbnVtYmVyO1xuICBpc1BhY2tlZD86IGJvb2xlYW47XG4gIHJldmVyc2VXSD86IGJvb2xlYW47XG59XG4vKipcbiAqIFRleHR1cmVMYXlvdXRTdHJhdGVneSBpcyBhbiBhYnN0cmFjdGlvbiBmb3IgZGlmZmVyZW50IHBsYW5zXG4gKiBmb3IgbWFwcGluZyBuLWRpbWVuc2lvbmFsIGFycmF5cyB0byAyRCB0ZXh0dXJlcyAoYW5kIGJhY2spXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGV4dHVyZUxheW91dFN0cmF0ZWd5IHtcbiAgY29tcHV0ZVRleHR1cmVXSChzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIHByZWZzPzogV2lkdGhIZWlnaHRQcmVmcyk6IFtudW1iZXIsIG51bWJlcl07XG59XG5cbi8qKlxuICogVGhpcyBzdHJhdGVneSB0cnkgdG8gZmluZCB0aGUgbWluaW1hbCBtYXgoVyxIKSB0aGF0IGZ1bGZpbGxzIChXICogSCA9PSB0b3RhbFNpemUpXG4gKi9cbmV4cG9ydCBjbGFzcyBBbHdheXNLZWVwT3JpZ2luYWxTaXplU3RyYXRlZ3kgaW1wbGVtZW50cyBUZXh0dXJlTGF5b3V0U3RyYXRlZ3kge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgbWF4VGV4dHVyZVNpemU6IG51bWJlcikge31cbiAgY29tcHV0ZVRleHR1cmVXSChzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIHByZWZzPzogV2lkdGhIZWlnaHRQcmVmcyk6IFtudW1iZXIsIG51bWJlcl0ge1xuICAgIC8vIHNjYWxhciB0ZW5zb3JcbiAgICBpZiAoc2hhcGUubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gWzEsIDFdO1xuICAgIH1cbiAgICBjb25zdCBtYXhUZXh0dXJlU2l6ZSA9IHRoaXMubWF4VGV4dHVyZVNpemU7XG4gICAgaWYgKHByZWZzICYmIHByZWZzLmJyZWFrQXhpcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBjaGVjayB0byBzZWUgaWYgZGltcyBmaXRcbiAgICAgIGNvbnN0IHdzaXplID0gcHJlZnMuYnJlYWtBeGlzID49IHNoYXBlLmxlbmd0aCA/IDEgOiBzaGFwZS5zbGljZShwcmVmcy5icmVha0F4aXMpLnJlZHVjZSgoYSwgYikgPT4gYSAqIGIpO1xuICAgICAgY29uc3QgaHNpemUgPSBwcmVmcy5icmVha0F4aXMgPD0gMCA/IDEgOiBzaGFwZS5zbGljZSgwLCBwcmVmcy5icmVha0F4aXMpLnJlZHVjZSgoYSwgYikgPT4gYSAqIGIpO1xuICAgICAgaWYgKHdzaXplID4gbWF4VGV4dHVyZVNpemUgfHwgaHNpemUgPiBtYXhUZXh0dXJlU2l6ZSkge1xuICAgICAgICAvLyBpZ25vcmUgcHJlZmVyZW5jZXNcbiAgICAgICAgLy8gY29udGludWUgd2l0aCBkZWZhdWx0IGxheW91dFxuICAgICAgICBMb2dnZXIudmVyYm9zZShcbiAgICAgICAgICAnVGV4dHVyZUxheW91dCcsXG4gICAgICAgICAgYEdpdmVuIHdpZHRoL2hlaWdodCBwcmVmZXJlbmNlcyB3ZXJlIHVuYXR0YWluYWJsZTogc2hhcGU6JHtzaGFwZX0sIGJyZWFrQXhpczoke3ByZWZzLmJyZWFrQXhpc31gLFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFt3c2l6ZSwgaHNpemVdO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0b3RhbFNpemUgPSBzaGFwZS5yZWR1Y2UoKGEsIGIpID0+IGEgKiBiKTtcblxuICAgIGxldCB3aWR0aCA9IE1hdGguZmxvb3IoTWF0aC5zcXJ0KHRvdGFsU2l6ZSkpO1xuXG4gICAgZm9yICg7IHdpZHRoIDwgbWF4VGV4dHVyZVNpemUgJiYgd2lkdGggPCB0b3RhbFNpemU7IHdpZHRoKyspIHtcbiAgICAgIGlmICh0b3RhbFNpemUgJSB3aWR0aCA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAod2lkdGggPj0gbWF4VGV4dHVyZVNpemUgfHwgdG90YWxTaXplICUgd2lkdGggIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGdpdmVuIGRpbWVuc2lvbnMgYXJlIG91dHNpZGUgdGhpcyBHUFUncyBib3VuZGFyaWVzOiAke3NoYXBlfWApO1xuICAgIH1cbiAgICByZXR1cm4gW3dpZHRoLCB0b3RhbFNpemUgLyB3aWR0aF07XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFByZWZlckxvZ2ljYWxTdHJhdGVneSBpbXBsZW1lbnRzIFRleHR1cmVMYXlvdXRTdHJhdGVneSB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBtYXhUZXh0dXJlU2l6ZTogbnVtYmVyKSB7fVxuICBjb21wdXRlVGV4dHVyZVdIKHNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgcHJlZnM/OiBXaWR0aEhlaWdodFByZWZzKTogW251bWJlciwgbnVtYmVyXSB7XG4gICAgY29uc3Qgd2ggPSB0aGlzLmNvbXB1dGVUZXh0dXJlKHNoYXBlLCBwcmVmcyk7XG4gICAgaWYgKHByZWZzICYmIHByZWZzLmlzUGFja2VkKSB7XG4gICAgICB3aFswXSAvPSAyO1xuICAgICAgd2hbMV0gLz0gMjtcbiAgICB9XG4gICAgaWYgKHByZWZzICYmIHByZWZzLnJldmVyc2VXSCkge1xuICAgICAgcmV0dXJuIFt3aFsxXSwgd2hbMF1dO1xuICAgIH1cbiAgICByZXR1cm4gd2g7XG4gIH1cblxuICBjb21wdXRlVGV4dHVyZShzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIHByZWZzPzogV2lkdGhIZWlnaHRQcmVmcyk6IFtudW1iZXIsIG51bWJlcl0ge1xuICAgIGNvbnN0IGlzUGFja2VkID0gcHJlZnMgJiYgcHJlZnMuaXNQYWNrZWQ7XG4gICAgLy8gc2NhbGFyIHRlbnNvclxuICAgIGlmIChzaGFwZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBpc1BhY2tlZCA/IFsyLCAyXSA6IFsxLCAxXTtcbiAgICB9XG4gICAgbGV0IG1heFRleHR1cmVTaXplID0gdGhpcy5tYXhUZXh0dXJlU2l6ZTtcbiAgICBpZiAocHJlZnMgJiYgcHJlZnMuYnJlYWtBeGlzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGNoZWNrIHRvIHNlZSBpZiBkaW1zIGZpdFxuICAgICAgY29uc3Qgd3NpemUgPSBwcmVmcy5icmVha0F4aXMgPj0gc2hhcGUubGVuZ3RoID8gMSA6IHNoYXBlLnNsaWNlKHByZWZzLmJyZWFrQXhpcykucmVkdWNlKChhLCBiKSA9PiBhICogYik7XG4gICAgICBjb25zdCBoc2l6ZSA9IHByZWZzLmJyZWFrQXhpcyA8PSAwID8gMSA6IHNoYXBlLnNsaWNlKDAsIHByZWZzLmJyZWFrQXhpcykucmVkdWNlKChhLCBiKSA9PiBhICogYik7XG4gICAgICBpZiAod3NpemUgPiBtYXhUZXh0dXJlU2l6ZSB8fCBoc2l6ZSA+IG1heFRleHR1cmVTaXplKSB7XG4gICAgICAgIC8vIGlnbm9yZSBwcmVmZXJlbmNlc1xuICAgICAgICAvLyBjb250aW51ZSB3aXRoIGRlZmF1bHQgbGF5b3V0XG4gICAgICAgIExvZ2dlci52ZXJib3NlKFxuICAgICAgICAgICdUZXh0dXJlTGF5b3V0JyxcbiAgICAgICAgICBgR2l2ZW4gd2lkdGgvaGVpZ2h0IHByZWZlcmVuY2VzIHdlcmUgdW5hdHRhaW5hYmxlOiBzaGFwZToke3NoYXBlfSwgYnJlYWtBeGlzOiR7cHJlZnMuYnJlYWtBeGlzfWAsXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW3dzaXplLCBoc2l6ZV07XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBsb2dTaGFwZSA9IHNoYXBlLnNsaWNlKDApO1xuICAgIGlmIChpc1BhY2tlZCkge1xuICAgICAgbWF4VGV4dHVyZVNpemUgPSBtYXhUZXh0dXJlU2l6ZSAqIDI7XG5cbiAgICAgIC8vIFRoaXMgbG9naWMgZW5zdXJlcyB3ZSBhY2N1cmF0ZWx5IGNvdW50IHRoZSBudW1iZXIgb2YgcGFja2VkIHRleGVscyBuZWVkZWRcbiAgICAgIC8vIHRvIGFjY29tbW9kYXRlIHRoZSB0ZW5zb3IuIFdlIGNhbiBvbmx5IHBhY2sgdmFsdWVzIGluIHRoZSBzYW1lIHRleGVsIGlmXG4gICAgICAvLyB0aGV5IGFyZSBmcm9tIGFkamFjZW50IHBhaXJzIG9mIHJvd3MvY29scyB3aXRoaW4gdGhlIHNhbWUgYmF0Y2guIFNvIGlmIGFcbiAgICAgIC8vIHRlbnNvciBoYXMgMyByb3dzLCB3ZSBwcmV0ZW5kIGl0IGhhcyA0IHJvd3MgaW4gb3JkZXIgdG8gYWNjb3VudCBmb3IgdGhlXG4gICAgICAvLyBmYWN0IHRoYXQgdGhlIHRleGVscyBjb250YWluaW5nIHRoZSB0aGlyZCByb3cgYXJlIGhhbGYgZW1wdHkuXG4gICAgICBsb2dTaGFwZSA9IGxvZ1NoYXBlLm1hcCgoX2QsIGkpID0+XG4gICAgICAgIGkgPj0gbG9nU2hhcGUubGVuZ3RoIC0gMiA/IChsb2dTaGFwZVtpXSAlIDIgPT09IDAgPyBsb2dTaGFwZVtpXSA6IGxvZ1NoYXBlW2ldICsgMSkgOiBsb2dTaGFwZVtpXSxcbiAgICAgICk7XG5cbiAgICAgIC8vIFBhY2tlZCB0ZXh0dXJlIGhlaWdodCBpcyBhdCBsZWFzdCAyICh0aGUgY2hhbm5lbCBoZWlnaHQgb2YgYSBzaW5nbGVcbiAgICAgIC8vIHRleGVsKS5cbiAgICAgIGlmIChsb2dTaGFwZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgbG9nU2hhcGUgPSBbMiwgbG9nU2hhcGVbMF1dO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIGxvZ2ljYWwgc2hhcGUgaXMgMiwgd2UgZG9uJ3Qgc3F1ZWV6ZSwgc2luY2Ugd2Ugd2FudCB0byBtYXRjaCBwaHlzaWNhbC5cbiAgICBpZiAobG9nU2hhcGUubGVuZ3RoICE9PSAyKSB7XG4gICAgICBjb25zdCBzcXVlZXplUmVzdWx0ID0gc3F1ZWV6ZVNoYXBlKGxvZ1NoYXBlKTtcbiAgICAgIGxvZ1NoYXBlID0gc3F1ZWV6ZVJlc3VsdC5uZXdTaGFwZTtcbiAgICB9XG5cbiAgICBjb25zdCBzaXplID0gc2l6ZUZyb21TaGFwZShsb2dTaGFwZSk7XG4gICAgaWYgKGxvZ1NoYXBlLmxlbmd0aCA8PSAxICYmIHNpemUgPD0gbWF4VGV4dHVyZVNpemUpIHtcbiAgICAgIHJldHVybiBbMSwgc2l6ZV07XG4gICAgfSBlbHNlIGlmIChsb2dTaGFwZS5sZW5ndGggPT09IDIgJiYgbG9nU2hhcGVbMF0gPD0gbWF4VGV4dHVyZVNpemUgJiYgbG9nU2hhcGVbMV0gPD0gbWF4VGV4dHVyZVNpemUpIHtcbiAgICAgIHJldHVybiBsb2dTaGFwZSBhcyBbbnVtYmVyLCBudW1iZXJdO1xuICAgIH0gZWxzZSBpZiAobG9nU2hhcGUubGVuZ3RoID09PSAzICYmIGxvZ1NoYXBlWzBdICogbG9nU2hhcGVbMV0gPD0gbWF4VGV4dHVyZVNpemUgJiYgbG9nU2hhcGVbMl0gPD0gbWF4VGV4dHVyZVNpemUpIHtcbiAgICAgIHJldHVybiBbbG9nU2hhcGVbMF0gKiBsb2dTaGFwZVsxXSwgbG9nU2hhcGVbMl1dO1xuICAgIH0gZWxzZSBpZiAobG9nU2hhcGUubGVuZ3RoID09PSAzICYmIGxvZ1NoYXBlWzBdIDw9IG1heFRleHR1cmVTaXplICYmIGxvZ1NoYXBlWzFdICogbG9nU2hhcGVbMl0gPD0gbWF4VGV4dHVyZVNpemUpIHtcbiAgICAgIHJldHVybiBbbG9nU2hhcGVbMF0sIGxvZ1NoYXBlWzFdICogbG9nU2hhcGVbMl1dO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICBsb2dTaGFwZS5sZW5ndGggPT09IDQgJiZcbiAgICAgIGxvZ1NoYXBlWzBdICogbG9nU2hhcGVbMV0gKiBsb2dTaGFwZVsyXSA8PSBtYXhUZXh0dXJlU2l6ZSAmJlxuICAgICAgbG9nU2hhcGVbM10gPD0gbWF4VGV4dHVyZVNpemVcbiAgICApIHtcbiAgICAgIHJldHVybiBbbG9nU2hhcGVbMF0gKiBsb2dTaGFwZVsxXSAqIGxvZ1NoYXBlWzJdLCBsb2dTaGFwZVszXV07XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGxvZ1NoYXBlLmxlbmd0aCA9PT0gNCAmJlxuICAgICAgbG9nU2hhcGVbMF0gPD0gbWF4VGV4dHVyZVNpemUgJiZcbiAgICAgIGxvZ1NoYXBlWzFdICogbG9nU2hhcGVbMl0gKiBsb2dTaGFwZVszXSA8PSBtYXhUZXh0dXJlU2l6ZVxuICAgICkge1xuICAgICAgcmV0dXJuIFtsb2dTaGFwZVswXSwgbG9nU2hhcGVbMV0gKiBsb2dTaGFwZVsyXSAqIGxvZ1NoYXBlWzNdXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzUGFja2VkKSB7XG4gICAgICAgIC8vIEZvciBwYWNrZWQgdGV4dHVyZXMgc2l6ZSBlcXVhbHMgdGhlIG51bWJlciBvZiBjaGFubmVscyByZXF1aXJlZCB0b1xuICAgICAgICAvLyBhY2NvbW1vZGF0ZSB0aGUgdGV4dHVyZSBkYXRhLiBIb3dldmVyIGluIG9yZGVyIHRvIHNxdWFyaWZ5IHN1Y2ggdGhhdFxuICAgICAgICAvLyBpbm5lciBkaW1lbnNpb25zIHN0YXkgZXZlbiwgd2UgcmV3cml0ZSBzaXplIHRvIGVxdWFsIHRoZSBudW1iZXIgb2ZcbiAgICAgICAgLy8gdGV4ZWxzLiBUaGVuIGluIHRoZSByZXR1cm4gc3RhdGVtZW50IHdlIHJlaHlkcmF0ZSB0aGUgc3F1YXJpZmllZFxuICAgICAgICAvLyBkaW1lbnNpb25zIHRvIGNoYW5uZWwgdW5pdHMuXG4gICAgICAgIHJldHVybiBzaXplVG9TcXVhcmlzaFNoYXBlKHNpemUgLyA0KS5tYXAoKGQpID0+IGQgKiAyKSBhcyBbbnVtYmVyLCBudW1iZXJdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNpemVUb1NxdWFyaXNoU2hhcGUoc2l6ZSk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzcXVlZXplU2hhcGUoc2hhcGU6IG51bWJlcltdLCBheGlzPzogbnVtYmVyW10pOiB7IG5ld1NoYXBlOiBudW1iZXJbXTsga2VwdERpbXM6IG51bWJlcltdIH0ge1xuICBjb25zdCBuZXdTaGFwZTogbnVtYmVyW10gPSBbXTtcbiAgY29uc3Qga2VwdERpbXM6IG51bWJlcltdID0gW107XG4gIGNvbnN0IGlzRW1wdHlBcnJheSA9IGF4aXMgIT0gbnVsbCAmJiBBcnJheS5pc0FycmF5KGF4aXMpICYmIGF4aXMubGVuZ3RoID09PSAwO1xuICBjb25zdCBheGVzID0gYXhpcyA9PSBudWxsIHx8IGlzRW1wdHlBcnJheSA/IG51bGwgOiBwYXJzZUF4aXNQYXJhbShheGlzLCBzaGFwZSkuc29ydCgpO1xuICBsZXQgaiA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2hhcGUubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoYXhlcyAhPSBudWxsKSB7XG4gICAgICBpZiAoYXhlc1tqXSA9PT0gaSAmJiBzaGFwZVtpXSAhPT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IHNxdWVlemUgYXhpcyAke2l9IHNpbmNlIGl0cyBkaW0gJyR7c2hhcGVbaV19JyBpcyBub3QgMWApO1xuICAgICAgfVxuICAgICAgaWYgKChheGVzW2pdID09IG51bGwgfHwgYXhlc1tqXSA+IGkpICYmIHNoYXBlW2ldID09PSAxKSB7XG4gICAgICAgIG5ld1NoYXBlLnB1c2goc2hhcGVbaV0pO1xuICAgICAgICBrZXB0RGltcy5wdXNoKGkpO1xuICAgICAgfVxuICAgICAgaWYgKGF4ZXNbal0gPD0gaSkge1xuICAgICAgICBqKys7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzaGFwZVtpXSAhPT0gMSkge1xuICAgICAgbmV3U2hhcGUucHVzaChzaGFwZVtpXSk7XG4gICAgICBrZXB0RGltcy5wdXNoKGkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4geyBuZXdTaGFwZSwga2VwdERpbXMgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQXhpc1BhcmFtKGF4aXM6IG51bWJlciB8IG51bWJlcltdLCBzaGFwZTogbnVtYmVyW10pOiBudW1iZXJbXSB7XG4gIGNvbnN0IHJhbmsgPSBzaGFwZS5sZW5ndGg7XG5cbiAgLy8gTm9ybWFsaXplIGlucHV0XG4gIGF4aXMgPSBheGlzID09IG51bGwgPyBzaGFwZS5tYXAoKF9zLCBpKSA9PiBpKSA6IChbXSBhcyBudW1iZXJbXSkuY29uY2F0KGF4aXMpO1xuXG4gIC8vIENoZWNrIGZvciB2YWxpZCByYW5nZVxuICBhc3NlcnQoXG4gICAgYXhpcy5ldmVyeSgoYXgpID0+IGF4ID49IC1yYW5rICYmIGF4IDwgcmFuayksXG4gICAgKCkgPT4gYEFsbCB2YWx1ZXMgaW4gYXhpcyBwYXJhbSBtdXN0IGJlIGluIHJhbmdlIFstJHtyYW5rfSwgJHtyYW5rfSkgYnV0IGAgKyBgZ290IGF4aXMgJHtheGlzfWAsXG4gICk7XG5cbiAgLy8gQ2hlY2sgZm9yIG9ubHkgaW50ZWdlcnNcbiAgYXNzZXJ0KGF4aXMuZXZlcnkoaXNJbnQpLCAoKSA9PiAnQWxsIHZhbHVlcyBpbiBheGlzIHBhcmFtIG11c3QgYmUgaW50ZWdlcnMgYnV0ICcgKyBgZ290IGF4aXMgJHtheGlzfWApO1xuXG4gIC8vIEhhbmRsZSBuZWdhdGl2ZSBheGlzLlxuICByZXR1cm4gYXhpcy5tYXAoKGEpID0+IChhIDwgMCA/IHJhbmsgKyBhIDogYSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzSW50KGE6IG51bWJlcik6IGJvb2xlYW4ge1xuICByZXR1cm4gYSAlIDEgPT09IDA7XG59XG5leHBvcnQgZnVuY3Rpb24gc2l6ZUZyb21TaGFwZShzaGFwZTogbnVtYmVyW10pOiBudW1iZXIge1xuICBpZiAoc2hhcGUubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gU2NhbGFyLlxuICAgIHJldHVybiAxO1xuICB9XG4gIGxldCBzaXplID0gc2hhcGVbMF07XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgc2hhcGUubGVuZ3RoOyBpKyspIHtcbiAgICBzaXplICo9IHNoYXBlW2ldO1xuICB9XG4gIHJldHVybiBzaXplO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFJvd3NDb2xzKHNoYXBlOiBudW1iZXJbXSk6IFtudW1iZXIsIG51bWJlcl0ge1xuICBpZiAoc2hhcGUubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgRXJyb3IoJ0Nhbm5vdCBnZXQgcm93cyBhbmQgY29sdW1ucyBvZiBhbiBlbXB0eSBzaGFwZSBhcnJheS4nKTtcbiAgfVxuXG4gIHJldHVybiBbc2hhcGUubGVuZ3RoID4gMSA/IHNoYXBlW3NoYXBlLmxlbmd0aCAtIDJdIDogMSwgc2hhcGVbc2hhcGUubGVuZ3RoIC0gMV1dO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNpemVUb1NxdWFyaXNoU2hhcGUoc2l6ZTogbnVtYmVyKTogW251bWJlciwgbnVtYmVyXSB7XG4gIGNvbnN0IHdpZHRoID0gTWF0aC5jZWlsKE1hdGguc3FydChzaXplKSk7XG4gIHJldHVybiBbd2lkdGgsIE1hdGguY2VpbChzaXplIC8gd2lkdGgpXTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRCYXRjaERpbShzaGFwZTogbnVtYmVyW10sIGRpbXNUb1NraXAgPSAyKTogbnVtYmVyIHtcbiAgcmV0dXJuIHNpemVGcm9tU2hhcGUoc2hhcGUuc2xpY2UoMCwgc2hhcGUubGVuZ3RoIC0gZGltc1RvU2tpcCkpO1xufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBBcnJheVV0aWwsIEJyb2FkY2FzdFV0aWwsIFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuXG5pbXBvcnQgeyBHbHNsQ29udGV4dCwgR2xzbExpYiwgR2xzbExpYlJvdXRpbmUgfSBmcm9tICcuL2dsc2wtZGVmaW5pdGlvbnMnO1xuaW1wb3J0IHsgZ2V0R2xzbCB9IGZyb20gJy4vZ2xzbC1zb3VyY2UnO1xuaW1wb3J0IHsgc3F1ZWV6ZVNoYXBlIH0gZnJvbSAnLi90ZXh0dXJlLWxheW91dC1zdHJhdGVneSc7XG5pbXBvcnQgeyBUZXh0dXJlTGF5b3V0IH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQge1xuICBnZW5lcmF0ZVNoYWRlckZ1bmNOYW1lRnJvbUlucHV0U2FtcGxlck5hbWUsXG4gIGdlbmVyYXRlU2hhZGVyRnVuY05hbWVGcm9tSW5wdXRTYW1wbGVyTmFtZUF0T3V0Q29vcmRzLFxuICBnZXRDb29yZHNEYXRhVHlwZSxcbiAgZ2V0R2xDaGFubmVscyxcbiAgZ2V0U3F1ZWV6ZWRQYXJhbXMsXG4gIHNxdWVlemVJbnB1dFNoYXBlLFxufSBmcm9tICcuL3V0aWxzJztcblxuLyoqXG4gKiBHTFNMIExpYnJhcnkgcmVzcG9uc2libGUgZm9yIGRhdGEgdHlwZXMgYW5kIHJvdXRpbmVzIGZvciBtYW5pcHVsYXRpbmdcbiAqIGNvb3JkaW5hdGVzIGFuZCBtYXBwaW5nIHRvL2Zyb20gdGVuc29yIGluZGljZXNcbiAqL1xuZXhwb3J0IGNsYXNzIENvb3Jkc0dsc2xMaWIgZXh0ZW5kcyBHbHNsTGliIHtcbiAgcmV0dXJuVHlwZTogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKGNvbnRleHQ6IEdsc2xDb250ZXh0KSB7XG4gICAgc3VwZXIoY29udGV4dCk7XG4gIH1cbiAgZ2V0RnVuY3Rpb25zKCk6IHsgW25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lIH0ge1xuICAgIHJldHVybiB7XG4gICAgICAuLi50aGlzLm9mZnNldFRvQ29vcmRzKCksXG4gICAgICAuLi50aGlzLmNvb3Jkc1RvT2Zmc2V0KCksXG4gICAgICAuLi50aGlzLnRvVmVjKCksXG4gICAgICAuLi50aGlzLnZhbHVlRnJvbSgpLFxuICAgICAgLy8gVE9ETyByZXR1cm4gdGhlc2Ugb25seSB3aGVuIHBhY2tpbmcgaXMgZW5hYmxlZC5cbiAgICAgIC4uLnRoaXMuZ2V0Q29tbW9uVXRpbEZ1bmNzKCksXG4gICAgICAuLi50aGlzLmdldElucHV0c1NhbXBsaW5nU25pcHBldHMoKSxcbiAgICAgIC4uLnRoaXMuZ2V0T3V0cHV0U2FtcGxpbmdTbmlwcGV0KCksXG4gICAgfTtcbiAgfVxuICBnZXRDdXN0b21UeXBlcygpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgLyoqXG4gICAqIFByb2R1Y2VzIGEgZnVuY3Rpb24gdGhhdCBjYW4gbWFwIGZyb21cbiAgICogMkQgbm9ybWFsemllZCBjb29yZGluYXRlcyAocyx0KSB0byBhIGZsYXQgb2Zmc2V0XG4gICAqL1xuICBwcm90ZWN0ZWQgb2Zmc2V0VG9Db29yZHMoKTogeyBbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmUgfSB7XG4gICAgY29uc3QgZnVuY05hbWUgPSAnb2Zmc2V0VG9Db29yZHMnO1xuICAgIHJldHVybiB7XG4gICAgICBvZmZzZXRUb0Nvb3JkczogbmV3IEdsc2xMaWJSb3V0aW5lKGBcbiAgICAgIHZlYzIgJHtmdW5jTmFtZX0oaW50IG9mZnNldCwgaW50IHdpZHRoLCBpbnQgaGVpZ2h0KSB7XG4gICAgICAgIGludCB0ID0gb2Zmc2V0IC8gd2lkdGg7XG4gICAgICAgIGludCBzID0gb2Zmc2V0IC0gdCp3aWR0aDtcbiAgICAgICAgdmVjMiBjb29yZHMgPSAodmVjMihzLHQpICsgdmVjMigwLjUsMC41KSkgLyB2ZWMyKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICByZXR1cm4gY29vcmRzO1xuICAgICAgfVxuICAgICAgYCksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9kdWNlcyBhIGZ1bmN0aW9uIHRoYXQgY2FuIG1hcCBmcm9tXG4gICAqIDJEIG5vcm1hbHppZWQgY29vcmRpbmF0ZXMgKHMsdCkgdG8gYSBmbGF0IG9mZnNldFxuICAgKi9cbiAgcHJvdGVjdGVkIGNvb3Jkc1RvT2Zmc2V0KCk6IHsgW25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lIH0ge1xuICAgIGNvbnN0IGZ1bmNOYW1lID0gJ2Nvb3Jkc1RvT2Zmc2V0JztcbiAgICByZXR1cm4ge1xuICAgICAgY29vcmRzVG9PZmZzZXQ6IG5ldyBHbHNsTGliUm91dGluZShgXG4gICAgICBpbnQgJHtmdW5jTmFtZX0odmVjMiBjb29yZHMsIGludCB3aWR0aCwgaW50IGhlaWdodCkge1xuICAgICAgICBmbG9hdCBzID0gY29vcmRzLnMgKiBmbG9hdCh3aWR0aCk7XG4gICAgICAgIGZsb2F0IHQgPSBjb29yZHMudCAqIGZsb2F0KGhlaWdodCk7XG4gICAgICAgIGludCBvZmZzZXQgPSBpbnQodCkgKiB3aWR0aCArIGludChzKTtcbiAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICAgIH1cbiAgICAgIGApLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIGNvZGUgZm9yIG91dHB1dCBzYW1wbGVyLlxuICAgKi9cblxuICBwcm90ZWN0ZWQgZ2V0T3V0cHV0U2FtcGxpbmdTbmlwcGV0KCk6IHsgW25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lIH0ge1xuICAgIGNvbnN0IG91dHB1dExheW91dCA9IHRoaXMuY29udGV4dC5vdXRwdXRUZXh0dXJlTGF5b3V0O1xuICAgIGlmIChvdXRwdXRMYXlvdXQuaXNQYWNrZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFBhY2tlZE91dHB1dFNhbXBsaW5nU25pcHBldChvdXRwdXRMYXlvdXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRVbnBhY2tlZE91dHB1dFNhbXBsaW5nU25pcHBldChvdXRwdXRMYXlvdXQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgY29kZSBmb3IgcGFja2VkIG91dHB1dCBzYW1wbGVyLlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldFBhY2tlZE91dHB1dFNhbXBsaW5nU25pcHBldChvdXRwdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQpOiB7IFtuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZSB9IHtcbiAgICBjb25zdCBvdXRTaGFwZSA9IG91dHB1dExheW91dC51bnBhY2tlZFNoYXBlO1xuICAgIGNvbnN0IG91dFRleFNoYXBlID0gW291dHB1dExheW91dC53aWR0aCwgb3V0cHV0TGF5b3V0LmhlaWdodF07XG4gICAgY29uc3QgcmVzdWx0OiB7IFtuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZSB9ID0ge307XG4gICAgY29uc3QgZnVuY05hbWUgPSAnZ2V0T3V0cHV0Q29vcmRzJztcbiAgICBzd2l0Y2ggKG91dFNoYXBlLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXN1bHRbZnVuY05hbWVdID0gdGhpcy5nZXRPdXRwdXRTY2FsYXJDb29yZHMoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJlc3VsdFtmdW5jTmFtZV0gPSB0aGlzLmdldE91dHB1dFBhY2tlZDFEQ29vcmRzKG91dFNoYXBlIGFzIFtudW1iZXJdLCBvdXRUZXhTaGFwZSBhcyBbbnVtYmVyLCBudW1iZXJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJlc3VsdFtmdW5jTmFtZV0gPSB0aGlzLmdldE91dHB1dFBhY2tlZDJEQ29vcmRzKG91dFNoYXBlIGFzIFtudW1iZXIsIG51bWJlcl0sIG91dFRleFNoYXBlIGFzIFtudW1iZXIsIG51bWJlcl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9IHRoaXMuZ2V0T3V0cHV0UGFja2VkM0RDb29yZHMoXG4gICAgICAgICAgb3V0U2hhcGUgYXMgW251bWJlciwgbnVtYmVyLCBudW1iZXJdLFxuICAgICAgICAgIG91dFRleFNoYXBlIGFzIFtudW1iZXIsIG51bWJlcl0sXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9IHRoaXMuZ2V0T3V0cHV0UGFja2VkTkRDb29yZHMob3V0U2hhcGUsIG91dFRleFNoYXBlIGFzIFtudW1iZXIsIG51bWJlcl0pO1xuICAgIH1cbiAgICBjb25zdCBnbHNsID0gZ2V0R2xzbCh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pO1xuICAgIC8vIFRPRE8gd2UgbmVlZCB0aGlzIHRvIHByb3Blcmx5IHJldHVybiBhIHBhY2tlZCB2ZWM0IGZyb20ga2VybmVscy5cbiAgICAvLyBSZXBsYWNlIGFsbCAne2dsc2wub3V0cHV0fSA9IHJlc3VsdCcgd2l0aCAnc2V0T3V0cHV0KHJlc3VsdCknIGluIGFsbCBrZXJuZWxzLlxuICAgIGNvbnN0IGZsb2F0VGV4dHVyZVNldFJHQkFTb3VyY2UgPSBgXG4gICAgICB2b2lkIHNldE91dHB1dCh2ZWM0IHZhbCkge1xuICAgICAgICAke2dsc2wub3V0cHV0fSA9IHZhbDtcbiAgICAgIH1cbiAgICBgO1xuICAgIGNvbnN0IGZsb2F0VGV4dHVyZVNldFJHQkFGdW5jTmFtZSA9ICdmbG9hdFRleHR1cmVTZXRSR0JBJztcbiAgICByZXN1bHRbZmxvYXRUZXh0dXJlU2V0UkdCQUZ1bmNOYW1lXSA9IG5ldyBHbHNsTGliUm91dGluZShmbG9hdFRleHR1cmVTZXRSR0JBU291cmNlKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBjb2RlIGZvciB1bnBhY2tlZCBvdXRwdXQgc2FtcGxlci5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRVbnBhY2tlZE91dHB1dFNhbXBsaW5nU25pcHBldChvdXRwdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQpOiB7IFtuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZSB9IHtcbiAgICBjb25zdCBvdXRTaGFwZSA9IG91dHB1dExheW91dC51bnBhY2tlZFNoYXBlO1xuICAgIGNvbnN0IG91dFRleFNoYXBlID0gW291dHB1dExheW91dC53aWR0aCwgb3V0cHV0TGF5b3V0LmhlaWdodF07XG4gICAgY29uc3QgcmVzdWx0OiB7IFtuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZSB9ID0ge307XG4gICAgY29uc3QgZnVuY05hbWUgPSAnZ2V0T3V0cHV0Q29vcmRzJztcbiAgICBzd2l0Y2ggKG91dFNoYXBlLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXN1bHRbZnVuY05hbWVdID0gdGhpcy5nZXRPdXRwdXRTY2FsYXJDb29yZHMoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJlc3VsdFtmdW5jTmFtZV0gPSB0aGlzLmdldE91dHB1dFVucGFja2VkMURDb29yZHMob3V0U2hhcGUgYXMgW251bWJlcl0sIG91dFRleFNoYXBlIGFzIFtudW1iZXIsIG51bWJlcl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9IHRoaXMuZ2V0T3V0cHV0VW5wYWNrZWQyRENvb3JkcyhcbiAgICAgICAgICBvdXRTaGFwZSBhcyBbbnVtYmVyLCBudW1iZXJdLFxuICAgICAgICAgIG91dFRleFNoYXBlIGFzIFtudW1iZXIsIG51bWJlcl0sXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICByZXN1bHRbZnVuY05hbWVdID0gdGhpcy5nZXRPdXRwdXRVbnBhY2tlZDNEQ29vcmRzKFxuICAgICAgICAgIG91dFNoYXBlIGFzIFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSxcbiAgICAgICAgICBvdXRUZXhTaGFwZSBhcyBbbnVtYmVyLCBudW1iZXJdLFxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9IHRoaXMuZ2V0T3V0cHV0VW5wYWNrZWQ0RENvb3JkcyhcbiAgICAgICAgICBvdXRTaGFwZSBhcyBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSxcbiAgICAgICAgICBvdXRUZXhTaGFwZSBhcyBbbnVtYmVyLCBudW1iZXJdLFxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNTpcbiAgICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9IHRoaXMuZ2V0T3V0cHV0VW5wYWNrZWQ1RENvb3JkcyhcbiAgICAgICAgICBvdXRTaGFwZSBhcyBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdLFxuICAgICAgICAgIG91dFRleFNoYXBlIGFzIFtudW1iZXIsIG51bWJlcl0sXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA2OlxuICAgICAgICByZXN1bHRbZnVuY05hbWVdID0gdGhpcy5nZXRPdXRwdXRVbnBhY2tlZDZEQ29vcmRzKFxuICAgICAgICAgIG91dFNoYXBlIGFzIFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSxcbiAgICAgICAgICBvdXRUZXhTaGFwZSBhcyBbbnVtYmVyLCBudW1iZXJdLFxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgb3V0cHV0IGRpbWVuc2lvbmFsaXR5OiAke291dFNoYXBlLmxlbmd0aH1gKTtcbiAgICB9XG4gICAgY29uc3QgZ2xzbCA9IGdldEdsc2wodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgICAvLyBUT0RPIHdlIG5lZWQgdGhpcyB0byBwcm9wZXJseSByZXR1cm4gYSBwYWNrZWQgdmVjNCBmcm9tIGtlcm5lbHMuXG4gICAgLy8gUmVwbGFjZSBhbGwgJ3tnbHNsLm91dHB1dH0gPSByZXN1bHQnIHdpdGggJ3NldE91dHB1dChyZXN1bHQpJyBpbiBhbGwga2VybmVscy5cbiAgICBjb25zdCBmbG9hdFRleHR1cmVTZXRSU291cmNlID0gYFxuICAgICAgICB2b2lkIHNldE91dHB1dChmbG9hdCB2YWwpIHtcbiAgICAgICAgICAke2dsc2wub3V0cHV0fSA9IHZlYzQodmFsLCAwLCAwLCAwKTtcbiAgICAgICAgfVxuICAgIGA7XG4gICAgY29uc3QgZmxvYXRUZXh0dXJlU2V0UkZ1bmNOYW1lID0gJ2Zsb2F0VGV4dHVyZVNldFInO1xuICAgIHJlc3VsdFtmbG9hdFRleHR1cmVTZXRSRnVuY05hbWVdID0gbmV3IEdsc2xMaWJSb3V0aW5lKGZsb2F0VGV4dHVyZVNldFJTb3VyY2UpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogU2NhbGFyIG91dHB1dCBjb29yZGluYXRlcy5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRPdXRwdXRTY2FsYXJDb29yZHMoKTogR2xzbExpYlJvdXRpbmUge1xuICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoYFxuICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgYCk7XG4gIH1cblxuICAvKipcbiAgICogMUQgcGFja2VkIG91dHB1dCBjb29yZGluYXRlcy5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRPdXRwdXRQYWNrZWQxRENvb3Jkcyhfc2hhcGU6IFtudW1iZXJdLCB0ZXhTaGFwZTogW251bWJlciwgbnVtYmVyXSk6IEdsc2xMaWJSb3V0aW5lIHtcbiAgICBjb25zdCBwYWNrZWRUZXhTaGFwZSA9IHRleFNoYXBlO1xuICAgIGxldCBzb3VyY2UgPSAnJztcbiAgICBpZiAocGFja2VkVGV4U2hhcGVbMF0gPT09IDEpIHtcbiAgICAgIHNvdXJjZSA9IGBcbiAgICAgICAgICBpbnQgZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIDIgKiBpbnQoVGV4Q29vcmRzLnkgKiAke3BhY2tlZFRleFNoYXBlWzFdfS4wKTtcbiAgICAgICAgICB9XG4gICAgICAgIGA7XG4gICAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSk7XG4gICAgfVxuXG4gICAgaWYgKHBhY2tlZFRleFNoYXBlWzFdID09PSAxKSB7XG4gICAgICBzb3VyY2UgPSBgXG4gICAgICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgICAgIHJldHVybiAyICogaW50KFRleENvb3Jkcy54ICogJHtwYWNrZWRUZXhTaGFwZVswXX0uMCk7XG4gICAgICAgICAgfVxuICAgICAgICBgO1xuICAgICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShzb3VyY2UpO1xuICAgIH1cblxuICAgIHNvdXJjZSA9IGBcbiAgICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKFRleENvb3Jkcy54eSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKCR7cGFja2VkVGV4U2hhcGVbMF19LCAke3BhY2tlZFRleFNoYXBlWzFdfSkpO1xuICAgICAgICAgIHJldHVybiAyICogKHJlc1RleFJDLnkgKiAke3BhY2tlZFRleFNoYXBlWzBdfSArIHJlc1RleFJDLngpO1xuICAgICAgICB9XG4gICAgICBgO1xuICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAyRCBwYWNrZWQgb3V0cHV0IGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldE91dHB1dFBhY2tlZDJEQ29vcmRzKHNoYXBlOiBbbnVtYmVyLCBudW1iZXJdLCB0ZXhTaGFwZTogW251bWJlciwgbnVtYmVyXSk6IEdsc2xMaWJSb3V0aW5lIHtcbiAgICBsZXQgc291cmNlID0gJyc7XG4gICAgaWYgKEFycmF5VXRpbC5hcnJheXNFcXVhbChzaGFwZSwgdGV4U2hhcGUpKSB7XG4gICAgICBzb3VyY2UgPSBgXG4gICAgICAgIGl2ZWMyIGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgICByZXR1cm4gMiAqIGl2ZWMyKFRleENvb3Jkcy54eSAqIHZlYzIoJHt0ZXhTaGFwZVswXX0sICR7dGV4U2hhcGVbMV19KSk7XG4gICAgICAgIH1cbiAgICAgIGA7XG4gICAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSk7XG4gICAgfVxuXG4gICAgY29uc3QgcGFja2VkVGV4U2hhcGUgPSB0ZXhTaGFwZTtcbiAgICAvLyB0ZXhlbHMgbmVlZGVkIHRvIGFjY29tbW9kYXRlIGEgbG9naWNhbCByb3dcbiAgICBjb25zdCB0ZXhlbHNJbkxvZ2ljYWxSb3cgPSBNYXRoLmNlaWwoc2hhcGVbMV0gLyAyKTtcblxuICAgIC8qKlxuICAgICAqIGdldE91dHB1dENvb3Jkc1xuICAgICAqXG4gICAgICogcmVzVGV4UkM6IFRoZSByb3dzIGFuZCBjb2x1bW5zIG9mIHRoZSB0ZXhlbHMuIElmIHlvdSBtb3ZlIG92ZXIgb25lXG4gICAgICogdGV4ZWwgdG8gdGhlIHJpZ2h0IGluIHRoZSBwYWNrZWQgdGV4dHVyZSwgeW91IGFyZSBtb3Zpbmcgb3ZlciBvbmUgY29sdW1uXG4gICAgICogKG5vdCB0d28pLlxuICAgICAqXG4gICAgICogaW5kZXg6IFRoZSB0ZXhlbCBpbmRleFxuICAgICAqL1xuICAgIHNvdXJjZSA9IGBcbiAgICAgICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke3BhY2tlZFRleFNoYXBlWzBdfSwgJHtwYWNrZWRUZXhTaGFwZVsxXX0pKTtcblxuICAgICAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnkgKiAke3BhY2tlZFRleFNoYXBlWzBdfSArIHJlc1RleFJDLng7XG5cbiAgICAgICAgICAvLyByZXZlcnNlIHIgYW5kIGMgb3JkZXIgZm9yIHBhY2tlZCB0ZXh0dXJlXG4gICAgICAgICAgaW50IHIgPSBpbW9kKGluZGV4LCAke3RleGVsc0luTG9naWNhbFJvd30pICogMjtcbiAgICAgICAgICBpbnQgYyA9IDIgKiAoaW5kZXggLyAke3RleGVsc0luTG9naWNhbFJvd30pO1xuXG4gICAgICAgICAgcmV0dXJuIGl2ZWMyKHIsIGMpO1xuICAgICAgICB9XG4gICAgICBgO1xuICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAzRCBwYWNrZWQgb3V0cHV0IGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldE91dHB1dFBhY2tlZDNEQ29vcmRzKHNoYXBlOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sIHRleFNoYXBlOiBbbnVtYmVyLCBudW1iZXJdKTogR2xzbExpYlJvdXRpbmUge1xuICAgIGNvbnN0IHBhY2tlZFRleFNoYXBlID0gW3RleFNoYXBlWzBdLCB0ZXhTaGFwZVsxXV07XG4gICAgY29uc3QgdGV4ZWxzSW5Mb2dpY2FsUm93ID0gTWF0aC5jZWlsKHNoYXBlWzJdIC8gMik7XG4gICAgY29uc3QgdGV4ZWxzSW5CYXRjaCA9IHRleGVsc0luTG9naWNhbFJvdyAqIE1hdGguY2VpbChzaGFwZVsxXSAvIDIpO1xuICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICAgICAgaXZlYzMgZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke3BhY2tlZFRleFNoYXBlWzBdfSwgJHtwYWNrZWRUZXhTaGFwZVsxXX0pKTtcbiAgICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy55ICogJHtwYWNrZWRUZXhTaGFwZVswXX0gKyByZXNUZXhSQy54O1xuXG4gICAgICAgICAgaW50IGIgPSBpbmRleCAvICR7dGV4ZWxzSW5CYXRjaH07XG4gICAgICAgICAgaW5kZXggLT0gYiAqICR7dGV4ZWxzSW5CYXRjaH07XG5cbiAgICAgICAgICAvLyByZXZlcnNlIHIgYW5kIGMgb3JkZXIgZm9yIHBhY2tlZCB0ZXh0dXJlXG4gICAgICAgICAgaW50IHIgPSBpbW9kKGluZGV4LCAke3RleGVsc0luTG9naWNhbFJvd30pICogMjtcbiAgICAgICAgICBpbnQgYyA9IDIgKiAoaW5kZXggLyAke3RleGVsc0luTG9naWNhbFJvd30pO1xuXG4gICAgICAgICAgcmV0dXJuIGl2ZWMzKGIsIHIsIGMpO1xuICAgICAgICB9XG4gICAgICBgO1xuICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBORCBwYWNrZWQgb3V0cHV0IGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldE91dHB1dFBhY2tlZE5EQ29vcmRzKHNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgdGV4U2hhcGU6IFtudW1iZXIsIG51bWJlcl0pOiBHbHNsTGliUm91dGluZSB7XG4gICAgY29uc3QgcGFja2VkVGV4U2hhcGUgPSBbdGV4U2hhcGVbMF0sIHRleFNoYXBlWzFdXTtcblxuICAgIGNvbnN0IHRleGVsc0luTG9naWNhbFJvdyA9IE1hdGguY2VpbChzaGFwZVtzaGFwZS5sZW5ndGggLSAxXSAvIDIpO1xuICAgIGNvbnN0IHRleGVsc0luQmF0Y2ggPSB0ZXhlbHNJbkxvZ2ljYWxSb3cgKiBNYXRoLmNlaWwoc2hhcGVbc2hhcGUubGVuZ3RoIC0gMl0gLyAyKTtcbiAgICBsZXQgdGV4ZWxzSW5CYXRjaE4gPSB0ZXhlbHNJbkJhdGNoO1xuICAgIGxldCBiYXRjaGVzID0gJyc7XG4gICAgbGV0IGNvb3JkcyA9ICdiLCByLCBjJztcblxuICAgIGZvciAobGV0IGIgPSAyOyBiIDwgc2hhcGUubGVuZ3RoIC0gMTsgYisrKSB7XG4gICAgICB0ZXhlbHNJbkJhdGNoTiAqPSBzaGFwZVtzaGFwZS5sZW5ndGggLSBiIC0gMV07XG4gICAgICBiYXRjaGVzID1cbiAgICAgICAgYFxuICAgICAgaW50IGIke2J9ID0gaW5kZXggLyAke3RleGVsc0luQmF0Y2hOfTtcbiAgICAgIGluZGV4IC09IGIke2J9ICogJHt0ZXhlbHNJbkJhdGNoTn07XG4gICAgYCArIGJhdGNoZXM7XG4gICAgICBjb29yZHMgPSBgYiR7Yn0sIGAgKyBjb29yZHM7XG4gICAgfVxuICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICAgIGl2ZWMke3NoYXBlLmxlbmd0aH0gZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKFRleENvb3Jkcy54eSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKCR7cGFja2VkVGV4U2hhcGVbMF19LCAke3BhY2tlZFRleFNoYXBlWzFdfSkpO1xuICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy55ICogJHtwYWNrZWRUZXhTaGFwZVswXX0gKyByZXNUZXhSQy54O1xuXG4gICAgICAgICR7YmF0Y2hlc31cblxuICAgICAgICBpbnQgYiA9IGluZGV4IC8gJHt0ZXhlbHNJbkJhdGNofTtcbiAgICAgICAgaW5kZXggLT0gYiAqICR7dGV4ZWxzSW5CYXRjaH07XG5cbiAgICAgICAgLy8gcmV2ZXJzZSByIGFuZCBjIG9yZGVyIGZvciBwYWNrZWQgdGV4dHVyZVxuICAgICAgICBpbnQgciA9IGltb2QoaW5kZXgsICR7dGV4ZWxzSW5Mb2dpY2FsUm93fSkgKiAyO1xuICAgICAgICBpbnQgYyA9IDIgKiAoaW5kZXggLyAke3RleGVsc0luTG9naWNhbFJvd30pO1xuXG4gICAgICAgIHJldHVybiBpdmVjJHtzaGFwZS5sZW5ndGh9KCR7Y29vcmRzfSk7XG4gICAgICB9XG4gICAgYDtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSk7XG4gIH1cblxuICAvKipcbiAgICogVW5wYWNrZWQgMUQgb3V0cHV0IGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldE91dHB1dFVucGFja2VkMURDb29yZHMoX3NoYXBlOiBbbnVtYmVyXSwgdGV4U2hhcGU6IFtudW1iZXIsIG51bWJlcl0pOiBHbHNsTGliUm91dGluZSB7XG4gICAgY29uc3Qgc291cmNlID0gYFxuICAgICAgICBpbnQgZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke3RleFNoYXBlWzBdfSwgJHt0ZXhTaGFwZVsxXX0pKTtcbiAgICAgICAgICByZXR1cm4gcmVzVGV4UkMueSAqICR7dGV4U2hhcGVbMF19ICsgcmVzVGV4UkMueDtcbiAgICAgICAgfVxuICAgICAgYDtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSk7XG4gIH1cblxuICAvKipcbiAgICogVW5wYWNrZWQgMkQgb3V0cHV0IGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldE91dHB1dFVucGFja2VkMkRDb29yZHMoc2hhcGU6IFtudW1iZXIsIG51bWJlcl0sIHRleFNoYXBlOiBbbnVtYmVyLCBudW1iZXJdKTogR2xzbExpYlJvdXRpbmUge1xuICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICAgICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke3RleFNoYXBlWzBdfSwgJHt0ZXhTaGFwZVsxXX0pKTtcbiAgICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy55ICogJHt0ZXhTaGFwZVswXX0gKyByZXNUZXhSQy54O1xuICAgICAgICAgIGludCByID0gaW5kZXggLyAke3NoYXBlWzFdfTtcbiAgICAgICAgICBpbnQgYyA9IGluZGV4IC0gciAqICR7c2hhcGVbMV19O1xuICAgICAgICAgIHJldHVybiBpdmVjMihyLCBjKTtcbiAgICAgICAgfVxuICAgICAgYDtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSk7XG4gIH1cblxuICAvKipcbiAgICogVW5wYWNrZWQgM0Qgb3V0cHV0IGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldE91dHB1dFVucGFja2VkM0RDb29yZHMoc2hhcGU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSwgdGV4U2hhcGU6IFtudW1iZXIsIG51bWJlcl0pOiBHbHNsTGliUm91dGluZSB7XG4gICAgbGV0IHNvdXJjZSA9ICcnO1xuICAgIGNvbnN0IHJhbmsgPSBzaGFwZS5sZW5ndGg7XG5cbiAgICBsZXQgc3RyaWRlcyA9IG51bGw7XG4gICAgaWYgKHJhbmsgPCAyKSB7XG4gICAgICBzdHJpZGVzID0gW107XG4gICAgfVxuXG4gICAgc3RyaWRlcyA9IG5ldyBBcnJheShyYW5rIC0gMSk7XG4gICAgc3RyaWRlc1tyYW5rIC0gMl0gPSBzaGFwZVtyYW5rIC0gMV07XG4gICAgZm9yIChsZXQgaSA9IHJhbmsgLSAzOyBpID49IDA7IC0taSkge1xuICAgICAgc3RyaWRlc1tpXSA9IHN0cmlkZXNbaSArIDFdICogc2hhcGVbaSArIDFdO1xuICAgIH1cbiAgICBjb25zdCBjb29yZHNUb0NvbXB1dGUgPSBbJ3InLCAnYycsICdkJ107XG4gICAgY29uc3QgY29vcmRzRnJvbUluZGV4U25pcHBldCA9IHN0cmlkZXNcbiAgICAgIC5tYXAoKHN0cmlkZSwgaSkgPT4ge1xuICAgICAgICBjb25zdCBsaW5lMSA9IGBpbnQgJHtjb29yZHNUb0NvbXB1dGVbaV19ID0gaW5kZXggLyAke3N0cmlkZX1gO1xuICAgICAgICBjb25zdCBsaW5lMiA9XG4gICAgICAgICAgaSA9PT0gc3RyaWRlcy5sZW5ndGggLSAxXG4gICAgICAgICAgICA/IGBpbnQgJHtjb29yZHNUb0NvbXB1dGVbaSArIDFdfSA9IGluZGV4IC0gJHtjb29yZHNUb0NvbXB1dGVbaV19ICogJHtzdHJpZGV9YFxuICAgICAgICAgICAgOiBgaW5kZXggLT0gJHtjb29yZHNUb0NvbXB1dGVbaV19ICogJHtzdHJpZGV9YDtcbiAgICAgICAgcmV0dXJuIGAke2xpbmUxfTsgJHtsaW5lMn07YDtcbiAgICAgIH0pXG4gICAgICAuam9pbignJyk7XG5cbiAgICBzb3VyY2UgPSBgXG4gICAgICAgIGl2ZWMzIGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKFRleENvb3Jkcy54eSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHt0ZXhTaGFwZVswXX0sICR7dGV4U2hhcGVbMV19KSk7XG4gICAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueSAqICR7dGV4U2hhcGVbMF19ICsgcmVzVGV4UkMueDtcbiAgICAgICAgICAke2Nvb3Jkc0Zyb21JbmRleFNuaXBwZXR9XG4gICAgICAgICAgcmV0dXJuIGl2ZWMzKHIsIGMsIGQpO1xuICAgICAgICB9XG4gICAgICBgO1xuICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnBhY2tlZCA0RCBvdXRwdXQgY29vcmRpbmF0ZXMuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0T3V0cHV0VW5wYWNrZWQ0RENvb3JkcyhcbiAgICBzaGFwZTogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gICAgdGV4U2hhcGU6IFtudW1iZXIsIG51bWJlcl0sXG4gICk6IEdsc2xMaWJSb3V0aW5lIHtcbiAgICBsZXQgc291cmNlID0gJyc7XG4gICAgY29uc3QgcmFuayA9IHNoYXBlLmxlbmd0aDtcblxuICAgIGxldCBzdHJpZGVzID0gbnVsbDtcbiAgICBpZiAocmFuayA8IDIpIHtcbiAgICAgIHN0cmlkZXMgPSBbXTtcbiAgICB9XG5cbiAgICBzdHJpZGVzID0gbmV3IEFycmF5KHJhbmsgLSAxKTtcbiAgICBzdHJpZGVzW3JhbmsgLSAyXSA9IHNoYXBlW3JhbmsgLSAxXTtcbiAgICBmb3IgKGxldCBpID0gcmFuayAtIDM7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBzdHJpZGVzW2ldID0gc3RyaWRlc1tpICsgMV0gKiBzaGFwZVtpICsgMV07XG4gICAgfVxuICAgIGNvbnN0IGNvb3Jkc1RvQ29tcHV0ZSA9IFsncicsICdjJywgJ2QnLCAnZDInXTtcbiAgICBjb25zdCBjb29yZHNGcm9tSW5kZXhTbmlwcGV0ID0gc3RyaWRlc1xuICAgICAgLm1hcCgoc3RyaWRlLCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IGxpbmUxID0gYGludCAke2Nvb3Jkc1RvQ29tcHV0ZVtpXX0gPSBpbmRleCAvICR7c3RyaWRlfWA7XG4gICAgICAgIGNvbnN0IGxpbmUyID1cbiAgICAgICAgICBpID09PSBzdHJpZGVzLmxlbmd0aCAtIDFcbiAgICAgICAgICAgID8gYGludCAke2Nvb3Jkc1RvQ29tcHV0ZVtpICsgMV19ID0gaW5kZXggLSAke2Nvb3Jkc1RvQ29tcHV0ZVtpXX0gKiAke3N0cmlkZX1gXG4gICAgICAgICAgICA6IGBpbmRleCAtPSAke2Nvb3Jkc1RvQ29tcHV0ZVtpXX0gKiAke3N0cmlkZX1gO1xuICAgICAgICByZXR1cm4gYCR7bGluZTF9OyAke2xpbmUyfTtgO1xuICAgICAgfSlcbiAgICAgIC5qb2luKCcnKTtcblxuICAgIHNvdXJjZSA9IGBcbiAgICAgIGl2ZWM0IGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKFRleENvb3Jkcy54eSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHt0ZXhTaGFwZVswXX0sICR7dGV4U2hhcGVbMV19KSk7XG4gICAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueSAqICR7dGV4U2hhcGVbMF19ICsgcmVzVGV4UkMueDtcbiAgICAgICAgICAke2Nvb3Jkc0Zyb21JbmRleFNuaXBwZXR9XG4gICAgICAgICAgcmV0dXJuIGl2ZWM0KHIsIGMsIGQsIGQyKTtcbiAgICAgICAgfVxuICAgICAgYDtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSk7XG4gIH1cblxuICAvKipcbiAgICogVW5wYWNrZWQgNUQgb3V0cHV0IGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldE91dHB1dFVucGFja2VkNURDb29yZHMoXG4gICAgc2hhcGU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gICAgdGV4U2hhcGU6IFtudW1iZXIsIG51bWJlcl0sXG4gICk6IEdsc2xMaWJSb3V0aW5lIHtcbiAgICBsZXQgc291cmNlID0gJyc7XG4gICAgY29uc3QgcmFuayA9IHNoYXBlLmxlbmd0aDtcblxuICAgIGxldCBzdHJpZGVzID0gbnVsbDtcbiAgICBpZiAocmFuayA8IDIpIHtcbiAgICAgIHN0cmlkZXMgPSBbXTtcbiAgICB9XG5cbiAgICBzdHJpZGVzID0gbmV3IEFycmF5KHJhbmsgLSAxKTtcbiAgICBzdHJpZGVzW3JhbmsgLSAyXSA9IHNoYXBlW3JhbmsgLSAxXTtcbiAgICBmb3IgKGxldCBpID0gcmFuayAtIDM7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBzdHJpZGVzW2ldID0gc3RyaWRlc1tpICsgMV0gKiBzaGFwZVtpICsgMV07XG4gICAgfVxuICAgIGNvbnN0IGNvb3Jkc1RvQ29tcHV0ZSA9IFsncicsICdjJywgJ2QnLCAnZDInLCAnZDMnXTtcbiAgICBjb25zdCBjb29yZHNGcm9tSW5kZXhTbmlwcGV0ID0gc3RyaWRlc1xuICAgICAgLm1hcCgoc3RyaWRlLCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IGxpbmUxID0gYGludCAke2Nvb3Jkc1RvQ29tcHV0ZVtpXX0gPSBpbmRleCAvICR7c3RyaWRlfWA7XG4gICAgICAgIGNvbnN0IGxpbmUyID1cbiAgICAgICAgICBpID09PSBzdHJpZGVzLmxlbmd0aCAtIDFcbiAgICAgICAgICAgID8gYGludCAke2Nvb3Jkc1RvQ29tcHV0ZVtpICsgMV19ID0gaW5kZXggLSAke2Nvb3Jkc1RvQ29tcHV0ZVtpXX0gKiAke3N0cmlkZX1gXG4gICAgICAgICAgICA6IGBpbmRleCAtPSAke2Nvb3Jkc1RvQ29tcHV0ZVtpXX0gKiAke3N0cmlkZX1gO1xuICAgICAgICByZXR1cm4gYCR7bGluZTF9OyAke2xpbmUyfTtgO1xuICAgICAgfSlcbiAgICAgIC5qb2luKCcnKTtcblxuICAgIHNvdXJjZSA9IGBcbiAgICAgIGl2ZWM1IGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKFRleENvb3Jkcy54eSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHt0ZXhTaGFwZVswXX0sICR7dGV4U2hhcGVbMV19KSk7XG4gICAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueSAqICR7dGV4U2hhcGVbMF19ICsgcmVzVGV4UkMueDtcbiAgICAgICAgICAke2Nvb3Jkc0Zyb21JbmRleFNuaXBwZXR9XG4gICAgICAgICAgcmV0dXJuIGl2ZWM1KHIsIGMsIGQsIGQyLCBkMyk7XG4gICAgICAgIH1cbiAgICAgIGA7XG4gICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShzb3VyY2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucGFja2VkIDZEIG91dHB1dCBjb29yZGluYXRlcy5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRPdXRwdXRVbnBhY2tlZDZEQ29vcmRzKFxuICAgIHNoYXBlOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gICAgdGV4U2hhcGU6IFtudW1iZXIsIG51bWJlcl0sXG4gICk6IEdsc2xMaWJSb3V0aW5lIHtcbiAgICBsZXQgc291cmNlID0gJyc7XG4gICAgY29uc3QgcmFuayA9IHNoYXBlLmxlbmd0aDtcblxuICAgIGxldCBzdHJpZGVzID0gbnVsbDtcbiAgICBpZiAocmFuayA8IDIpIHtcbiAgICAgIHN0cmlkZXMgPSBbXTtcbiAgICB9XG5cbiAgICBzdHJpZGVzID0gbmV3IEFycmF5KHJhbmsgLSAxKTtcbiAgICBzdHJpZGVzW3JhbmsgLSAyXSA9IHNoYXBlW3JhbmsgLSAxXTtcbiAgICBmb3IgKGxldCBpID0gcmFuayAtIDM7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBzdHJpZGVzW2ldID0gc3RyaWRlc1tpICsgMV0gKiBzaGFwZVtpICsgMV07XG4gICAgfVxuICAgIGNvbnN0IGNvb3Jkc1RvQ29tcHV0ZSA9IFsncicsICdjJywgJ2QnLCAnZDInLCAnZDMnLCAnZDQnXTtcbiAgICBjb25zdCBjb29yZHNGcm9tSW5kZXhTbmlwcGV0ID0gc3RyaWRlc1xuICAgICAgLm1hcCgoc3RyaWRlLCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IGxpbmUxID0gYGludCAke2Nvb3Jkc1RvQ29tcHV0ZVtpXX0gPSBpbmRleCAvICR7c3RyaWRlfWA7XG4gICAgICAgIGNvbnN0IGxpbmUyID1cbiAgICAgICAgICBpID09PSBzdHJpZGVzLmxlbmd0aCAtIDFcbiAgICAgICAgICAgID8gYGludCAke2Nvb3Jkc1RvQ29tcHV0ZVtpICsgMV19ID0gaW5kZXggLSAke2Nvb3Jkc1RvQ29tcHV0ZVtpXX0gKiAke3N0cmlkZX1gXG4gICAgICAgICAgICA6IGBpbmRleCAtPSAke2Nvb3Jkc1RvQ29tcHV0ZVtpXX0gKiAke3N0cmlkZX1gO1xuICAgICAgICByZXR1cm4gYCR7bGluZTF9OyAke2xpbmUyfTtgO1xuICAgICAgfSlcbiAgICAgIC5qb2luKCcnKTtcblxuICAgIHNvdXJjZSA9IGBcbiAgICAgaXZlYzYgZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihUZXhDb29yZHMueHkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHt0ZXhTaGFwZVswXX0sICR7dGV4U2hhcGVbMV19KSk7XG4gICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy55ICogJHt0ZXhTaGFwZVswXX0gKyByZXNUZXhSQy54O1xuICAgICAgICAgJHtjb29yZHNGcm9tSW5kZXhTbmlwcGV0fVxuICAgICAgICAgcmV0dXJuIGl2ZWM2KHIsIGMsIGQsIGQyLCBkMywgZDQpO1xuICAgICAgIH1cbiAgICAgYDtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIGNvZGUgZm9yIGNvbW1vbiBVViBjb29yZHMgY29tcHV0YXRpb24gdXRpbGl0eSBmdW5jdGlvbnMuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0Q29tbW9uVXRpbEZ1bmNzKCk6IHsgW25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lIH0ge1xuICAgIGNvbnN0IHJlc3VsdDogeyBbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmUgfSA9IHt9O1xuICAgIGxldCBmdW5jTmFtZSA9ICd1dkZyb21GbGF0JztcbiAgICByZXN1bHRbZnVuY05hbWVdID0gbmV3IEdsc2xMaWJSb3V0aW5lKGBcbiAgICB2ZWMyIHV2RnJvbUZsYXQoaW50IHRleE51bVIsIGludCB0ZXhOdW1DLCBpbnQgaW5kZXgpIHtcbiAgICAgIGludCB0ZXhDID0gaW5kZXggLyB0ZXhOdW1SO1xuICAgICAgaW50IHRleFIgPSBpbmRleCAtIHRleEMgKiB0ZXhOdW1SO1xuICAgICAgLy8gVE9ETzogc3dhcCB0ZXhSLCB0ZXhDIG9yZGVyIGluIGZvbGxvd2luZyBmdW5jdGlvbiBzbyByb3cgaXMgY29ycmVzcG9uZGluZyB0byB1IGFuZCBjb2x1bW4gaXMgY29ycmVzcG9uZGluZyB0b1xuICAgICAgLy8gICAgICAgdi5cbiAgICAgIHJldHVybiAodmVjMih0ZXhSLCB0ZXhDKSArIGhhbGZDUikgLyB2ZWMyKHRleE51bVIsIHRleE51bUMpO1xuICAgIH1cbiAgICBgKTtcbiAgICBmdW5jTmFtZSA9ICdwYWNrZWRVVmZyb20xRCc7XG4gICAgcmVzdWx0W2Z1bmNOYW1lXSA9IG5ldyBHbHNsTGliUm91dGluZShgXG4gICAgICB2ZWMyIHBhY2tlZFVWZnJvbTFEKGludCB0ZXhOdW1SLCBpbnQgdGV4TnVtQywgaW50IGluZGV4KSB7XG4gICAgICAgIGludCB0ZXhlbEluZGV4ID0gaW5kZXggLyAyO1xuICAgICAgICBpbnQgdGV4UiA9IHRleGVsSW5kZXggLyB0ZXhOdW1DO1xuICAgICAgICBpbnQgdGV4QyA9IHRleGVsSW5kZXggLSB0ZXhSICogdGV4TnVtQztcbiAgICAgICAgcmV0dXJuICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIodGV4TnVtQywgdGV4TnVtUik7XG4gICAgICB9XG4gICAgICBgKTtcbiAgICBmdW5jTmFtZSA9ICdwYWNrZWRVVmZyb20yRCc7XG4gICAgcmVzdWx0W2Z1bmNOYW1lXSA9IG5ldyBHbHNsTGliUm91dGluZShgXG4gICAgICB2ZWMyIHBhY2tlZFVWZnJvbTJEKGludCB0ZXhOdW1SLCBpbnQgdGV4TnVtQywgaW50IHRleGVsc0luTG9naWNhbFJvdywgaW50IHJvdywgaW50IGNvbCkge1xuICAgICAgICBpbnQgdGV4ZWxJbmRleCA9IChyb3cgLyAyKSAqIHRleGVsc0luTG9naWNhbFJvdyArIChjb2wgLyAyKTtcbiAgICAgICAgaW50IHRleFIgPSB0ZXhlbEluZGV4IC8gdGV4TnVtQztcbiAgICAgICAgaW50IHRleEMgPSB0ZXhlbEluZGV4IC0gdGV4UiAqIHRleE51bUM7XG4gICAgICAgIHJldHVybiAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKHRleE51bUMsIHRleE51bVIpO1xuICAgICAgfVxuICAgICAgYCk7XG4gICAgZnVuY05hbWUgPSAncGFja2VkVVZmcm9tM0QnO1xuICAgIHJlc3VsdFtmdW5jTmFtZV0gPSBuZXcgR2xzbExpYlJvdXRpbmUoYFxuICAgICAgdmVjMiBwYWNrZWRVVmZyb20zRChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsXG4gICAgICAgICAgaW50IHRleGVsc0luQmF0Y2gsIGludCB0ZXhlbHNJbkxvZ2ljYWxSb3csIGludCBiLFxuICAgICAgICAgIGludCByb3csIGludCBjb2wpIHtcbiAgICAgICAgaW50IGluZGV4ID0gYiAqIHRleGVsc0luQmF0Y2ggKyAocm93IC8gMikgKiB0ZXhlbHNJbkxvZ2ljYWxSb3cgKyAoY29sIC8gMik7XG4gICAgICAgIGludCB0ZXhSID0gaW5kZXggLyB0ZXhOdW1DO1xuICAgICAgICBpbnQgdGV4QyA9IGluZGV4IC0gdGV4UiAqIHRleE51bUM7XG4gICAgICAgIHJldHVybiAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKHRleE51bUMsIHRleE51bVIpO1xuICAgICAgfVxuICAgICAgYCk7XG4gICAgZnVuY05hbWUgPSAnc2FtcGxlVGV4dHVyZSc7XG4gICAgY29uc3QgZ2xzbCA9IGdldEdsc2wodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgICByZXN1bHRbZnVuY05hbWVdID0gbmV3IEdsc2xMaWJSb3V0aW5lKGBcbiAgICAgICAgZmxvYXQgc2FtcGxlVGV4dHVyZShzYW1wbGVyMkQgdGV4dHVyZVNhbXBsZXIsIHZlYzIgdXYpIHtcbiAgICAgICAgICAgIHJldHVybiAke2dsc2wudGV4dHVyZTJEfSh0ZXh0dXJlU2FtcGxlciwgdXYpLnI7XG4gICAgICAgIH1gKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdGluZyBzbmlwcGV0cyBmb3IgaW5wdXRzXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0SW5wdXRzU2FtcGxpbmdTbmlwcGV0cygpOiB7IFtuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZSB9IHtcbiAgICBjb25zdCByZXN1bHQ6IHsgW25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lIH0gPSB7fTtcbiAgICBjb25zdCBvdXRwdXRMYXlvdXQgPSB0aGlzLmNvbnRleHQub3V0cHV0VGV4dHVyZUxheW91dDtcbiAgICB0aGlzLmNvbnRleHQucHJvZ3JhbUluZm8uaW5wdXROYW1lcy5mb3JFYWNoKChzYW1wbGVyTmFtZSwgaSkgPT4ge1xuICAgICAgY29uc3QgaW5wdXRMYXlvdXQgPSB0aGlzLmNvbnRleHQuaW5wdXRUZXh0dXJlTGF5b3V0c1tpXTtcbiAgICAgIGNvbnN0IGZ1bmNOYW1lID0gZ2VuZXJhdGVTaGFkZXJGdW5jTmFtZUZyb21JbnB1dFNhbXBsZXJOYW1lKHNhbXBsZXJOYW1lKTtcbiAgICAgIGlmIChpbnB1dExheW91dC5pc1BhY2tlZCkge1xuICAgICAgICByZXN1bHRbZnVuY05hbWVdID0gdGhpcy5nZXRQYWNrZWRTYW1wbGVyRnJvbUlucHV0KGZ1bmNOYW1lLCBzYW1wbGVyTmFtZSwgaW5wdXRMYXlvdXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9IHRoaXMuZ2V0VW5wYWNrZWRTYW1wbGVyRnJvbUlucHV0KGZ1bmNOYW1lLCBzYW1wbGVyTmFtZSwgaW5wdXRMYXlvdXQpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBvdXRDb29yZEZ1bmNOYW1lID0gZ2VuZXJhdGVTaGFkZXJGdW5jTmFtZUZyb21JbnB1dFNhbXBsZXJOYW1lQXRPdXRDb29yZHMoc2FtcGxlck5hbWUpO1xuICAgICAgaWYgKGlucHV0TGF5b3V0LnVucGFja2VkU2hhcGUubGVuZ3RoIDw9IG91dHB1dExheW91dC51bnBhY2tlZFNoYXBlLmxlbmd0aCkge1xuICAgICAgICBpZiAoaW5wdXRMYXlvdXQuaXNQYWNrZWQpIHtcbiAgICAgICAgICByZXN1bHRbb3V0Q29vcmRGdW5jTmFtZV0gPSB0aGlzLmdldFBhY2tlZFNhbXBsZXJBdE91dHB1dENvb3JkcyhcbiAgICAgICAgICAgIG91dENvb3JkRnVuY05hbWUsXG4gICAgICAgICAgICBpbnB1dExheW91dCxcbiAgICAgICAgICAgIG91dHB1dExheW91dCxcbiAgICAgICAgICAgIHNhbXBsZXJOYW1lLFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0W291dENvb3JkRnVuY05hbWVdID0gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXJBdE91dHB1dENvb3JkcyhcbiAgICAgICAgICAgIG91dENvb3JkRnVuY05hbWUsXG4gICAgICAgICAgICBpbnB1dExheW91dCxcbiAgICAgICAgICAgIG91dHB1dExheW91dCxcbiAgICAgICAgICAgIHNhbXBsZXJOYW1lLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ29uc3RydWN0aW5nIHNuaXBwZXRzIGZvciBvdXRwdXQgY29vcmRpbmF0ZXMgb2Ygc2FtcGxlcnNcbiAgICovXG4gIHByb3RlY3RlZCBnZXRQYWNrZWRTYW1wbGVyQXRPdXRwdXRDb29yZHMoXG4gICAgZnVuY05hbWU6IHN0cmluZyxcbiAgICBpbnB1dExheW91dDogVGV4dHVyZUxheW91dCxcbiAgICBvdXRwdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQsXG4gICAgbmFtZTogc3RyaW5nLFxuICApOiBHbHNsTGliUm91dGluZSB7XG4gICAgY29uc3QgaW5TaGFwZSA9IGlucHV0TGF5b3V0LnVucGFja2VkU2hhcGU7XG4gICAgY29uc3Qgb3V0U2hhcGUgPSBvdXRwdXRMYXlvdXQudW5wYWNrZWRTaGFwZTtcbiAgICBjb25zdCB0ZXhOYW1lID0gbmFtZTtcbiAgICBjb25zdCB0ZXhGdW5jU25pcHBldCA9IGdlbmVyYXRlU2hhZGVyRnVuY05hbWVGcm9tSW5wdXRTYW1wbGVyTmFtZSh0ZXhOYW1lKTtcblxuICAgIGNvbnN0IGluUmFuayA9IGluU2hhcGUubGVuZ3RoO1xuICAgIGNvbnN0IG91dFJhbmsgPSBvdXRTaGFwZS5sZW5ndGg7XG5cbiAgICBjb25zdCBicm9hZGNhc3REaW1zID0gQnJvYWRjYXN0VXRpbC5nZXRCcm9hZGNhc3REaW1zKGluU2hhcGUsIG91dFNoYXBlKTtcblxuICAgIGNvbnN0IHR5cGUgPSBnZXRDb29yZHNEYXRhVHlwZShvdXRSYW5rKTtcbiAgICBjb25zdCByYW5rRGlmZiA9IG91dFJhbmsgLSBpblJhbms7XG4gICAgbGV0IGNvb3Jkc1NuaXBwZXQ6IHN0cmluZztcbiAgICBjb25zdCBmaWVsZHMgPSBnZXRHbENoYW5uZWxzKCk7XG5cbiAgICBpZiAoaW5SYW5rID09PSAwKSB7XG4gICAgICBjb29yZHNTbmlwcGV0ID0gJyc7XG4gICAgfSBlbHNlIGlmIChvdXRSYW5rIDwgMiAmJiBicm9hZGNhc3REaW1zLmxlbmd0aCA+PSAxKSB7XG4gICAgICBjb29yZHNTbmlwcGV0ID0gJ2Nvb3JkcyA9IDA7JztcbiAgICB9IGVsc2Uge1xuICAgICAgY29vcmRzU25pcHBldCA9IGJyb2FkY2FzdERpbXMubWFwKChkKSA9PiBgY29vcmRzLiR7ZmllbGRzW2QgKyByYW5rRGlmZl19ID0gMDtgKS5qb2luKCdcXG4nKTtcbiAgICB9XG4gICAgbGV0IHVucGFja2VkQ29vcmRzU25pcHBldCA9ICcnO1xuICAgIGlmIChvdXRSYW5rIDwgMiAmJiBpblJhbmsgPiAwKSB7XG4gICAgICB1bnBhY2tlZENvb3Jkc1NuaXBwZXQgPSAnY29vcmRzJztcbiAgICB9IGVsc2Uge1xuICAgICAgdW5wYWNrZWRDb29yZHNTbmlwcGV0ID0gaW5TaGFwZS5tYXAoKF9zLCBpKSA9PiBgY29vcmRzLiR7ZmllbGRzW2kgKyByYW5rRGlmZl19YCkuam9pbignLCAnKTtcbiAgICB9XG5cbiAgICBsZXQgb3V0cHV0ID0gJ3JldHVybiBvdXRwdXRWYWx1ZTsnO1xuICAgIGNvbnN0IGluU2l6ZSA9IFNoYXBlVXRpbC5zaXplKGluU2hhcGUpO1xuICAgIGNvbnN0IGlzSW5wdXRTY2FsYXIgPSBpblNpemUgPT09IDE7XG4gICAgY29uc3Qgb3V0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dFNoYXBlKTtcbiAgICBjb25zdCBpc091dHB1dFNjYWxhciA9IG91dFNpemUgPT09IDE7XG5cbiAgICBpZiAoaW5SYW5rID09PSAxICYmICFpc0lucHV0U2NhbGFyICYmICFpc091dHB1dFNjYWxhcikge1xuICAgICAgb3V0cHV0ID0gYFxuICAgICAgICByZXR1cm4gdmVjNChvdXRwdXRWYWx1ZS54eSwgb3V0cHV0VmFsdWUueHkpO1xuICAgICAgYDtcbiAgICB9IGVsc2UgaWYgKGlzSW5wdXRTY2FsYXIgJiYgIWlzT3V0cHV0U2NhbGFyKSB7XG4gICAgICBpZiAob3V0UmFuayA9PT0gMSkge1xuICAgICAgICBvdXRwdXQgPSBgXG4gICAgICAgICAgcmV0dXJuIHZlYzQob3V0cHV0VmFsdWUueCwgb3V0cHV0VmFsdWUueCwgMC4sIDAuKTtcbiAgICAgICAgYDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dHB1dCA9IGBcbiAgICAgICAgICByZXR1cm4gdmVjNChvdXRwdXRWYWx1ZS54KTtcbiAgICAgICAgYDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGJyb2FkY2FzdERpbXMubGVuZ3RoKSB7XG4gICAgICBjb25zdCByb3dzID0gaW5SYW5rIC0gMjtcbiAgICAgIGNvbnN0IGNvbHMgPSBpblJhbmsgLSAxO1xuXG4gICAgICBpZiAoYnJvYWRjYXN0RGltcy5pbmRleE9mKHJvd3MpID4gLTEgJiYgYnJvYWRjYXN0RGltcy5pbmRleE9mKGNvbHMpID4gLTEpIHtcbiAgICAgICAgb3V0cHV0ID0gJ3JldHVybiB2ZWM0KG91dHB1dFZhbHVlLngpOyc7XG4gICAgICB9IGVsc2UgaWYgKGJyb2FkY2FzdERpbXMuaW5kZXhPZihyb3dzKSA+IC0xKSB7XG4gICAgICAgIG91dHB1dCA9ICdyZXR1cm4gdmVjNChvdXRwdXRWYWx1ZS54LCBvdXRwdXRWYWx1ZS55LCAnICsgJ291dHB1dFZhbHVlLngsIG91dHB1dFZhbHVlLnkpOyc7XG4gICAgICB9IGVsc2UgaWYgKGJyb2FkY2FzdERpbXMuaW5kZXhPZihjb2xzKSA+IC0xKSB7XG4gICAgICAgIG91dHB1dCA9ICdyZXR1cm4gdmVjNChvdXRwdXRWYWx1ZS54eCwgb3V0cHV0VmFsdWUuenopOyc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc3dhcExhc3REaW1zU25pcHBldCA9IGBcbiAgICAgICAgaW50IGxhc3REaW0gPSBjb29yZHMuJHtmaWVsZHNbb3V0UmFuayAtIDFdfTtcbiAgICAgICAgY29vcmRzLiR7ZmllbGRzW291dFJhbmsgLSAxXX0gPSBjb29yZHMuJHtmaWVsZHNbb3V0UmFuayAtIDJdfTtcbiAgICAgICAgY29vcmRzLiR7ZmllbGRzW291dFJhbmsgLSAyXX0gPSBsYXN0RGltO1xuICAgICAgYDtcbiAgICBjb25zdCBzb3VyY2UgPSBgXG4gICAgICB2ZWM0ICR7ZnVuY05hbWV9KCkge1xuICAgICAgICAke3R5cGV9IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICAke3N3YXBMYXN0RGltc1NuaXBwZXR9XG4gICAgICAgICR7Y29vcmRzU25pcHBldH1cbiAgICAgICAgdmVjNCBvdXRwdXRWYWx1ZSA9ICR7dGV4RnVuY1NuaXBwZXR9KCR7dW5wYWNrZWRDb29yZHNTbmlwcGV0fSk7XG4gICAgICAgICR7b3V0cHV0fVxuICAgICAgfVxuICAgIGA7XG4gICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShzb3VyY2UsIFsnY29vcmRpbmF0ZXMuZ2V0T3V0cHV0Q29vcmRzJ10pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdGluZyBzbmlwcGV0cyBmb3IgdW5wYWNrZWQgb3V0cHV0IGNvb3JkaW5hdGVzIG9mIHNhbXBsZXJzXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0VW5wYWNrZWRTYW1wbGVyQXRPdXRwdXRDb29yZHMoXG4gICAgZnVuY05hbWU6IHN0cmluZyxcbiAgICBpbnB1dExheW91dDogVGV4dHVyZUxheW91dCxcbiAgICBvdXRwdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQsXG4gICAgbmFtZTogc3RyaW5nLFxuICApOiBHbHNsTGliUm91dGluZSB7XG4gICAgY29uc3Qgb3V0VGV4U2hhcGUgPSBbb3V0cHV0TGF5b3V0LndpZHRoLCBvdXRwdXRMYXlvdXQuaGVpZ2h0XTtcbiAgICBjb25zdCBpblRleFNoYXBlID0gW2lucHV0TGF5b3V0LndpZHRoLCBpbnB1dExheW91dC5oZWlnaHRdO1xuICAgIGNvbnN0IGluUmFuayA9IGlucHV0TGF5b3V0LnVucGFja2VkU2hhcGUubGVuZ3RoO1xuICAgIGNvbnN0IG91dFJhbmsgPSBvdXRwdXRMYXlvdXQudW5wYWNrZWRTaGFwZS5sZW5ndGg7XG4gICAgY29uc3QgaW5TaGFwZSA9IGlucHV0TGF5b3V0LnVucGFja2VkU2hhcGU7XG4gICAgY29uc3Qgb3V0U2hhcGUgPSBvdXRwdXRMYXlvdXQudW5wYWNrZWRTaGFwZTtcbiAgICBjb25zdCB0ZXhGdW5jU25pcHBldCA9IGdlbmVyYXRlU2hhZGVyRnVuY05hbWVGcm9tSW5wdXRTYW1wbGVyTmFtZShuYW1lKTtcblxuICAgIGlmIChpblJhbmsgPT09IG91dFJhbmsgJiYgQXJyYXlVdGlsLmFycmF5c0VxdWFsKGluVGV4U2hhcGUsIG91dFRleFNoYXBlKSkge1xuICAgICAgY29uc3Qgc291cmNlID0gYFxuICAgICAgICAgIGZsb2F0ICR7ZnVuY05hbWV9KCkge1xuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtuYW1lfSwgVGV4Q29vcmRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIGA7XG4gICAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSwgWydjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlJ10pO1xuICAgIH1cblxuICAgIGNvbnN0IHR5cGUgPSBnZXRDb29yZHNEYXRhVHlwZShvdXRSYW5rKTtcbiAgICBjb25zdCBicm9hZGNhc3REaW1zID0gQnJvYWRjYXN0VXRpbC5nZXRCcm9hZGNhc3REaW1zKGluU2hhcGUsIG91dFNoYXBlKTtcbiAgICBjb25zdCByYW5rRGlmZiA9IG91dFJhbmsgLSBpblJhbms7XG4gICAgbGV0IGNvb3Jkc1NuaXBwZXQ6IHN0cmluZztcbiAgICBjb25zdCBmaWVsZHMgPSBnZXRHbENoYW5uZWxzKCk7XG5cbiAgICBpZiAoaW5SYW5rID09PSAwKSB7XG4gICAgICBjb29yZHNTbmlwcGV0ID0gJyc7XG4gICAgfSBlbHNlIGlmIChvdXRSYW5rIDwgMiAmJiBicm9hZGNhc3REaW1zLmxlbmd0aCA+PSAxKSB7XG4gICAgICBjb29yZHNTbmlwcGV0ID0gJ2Nvb3JkcyA9IDA7JztcbiAgICB9IGVsc2Uge1xuICAgICAgY29vcmRzU25pcHBldCA9IGJyb2FkY2FzdERpbXMubWFwKChkKSA9PiBgY29vcmRzLiR7ZmllbGRzW2QgKyByYW5rRGlmZl19ID0gMDtgKS5qb2luKCdcXG4nKTtcbiAgICB9XG4gICAgbGV0IHVucGFja2VkQ29vcmRzU25pcHBldCA9ICcnO1xuICAgIGlmIChvdXRSYW5rIDwgMiAmJiBpblJhbmsgPiAwKSB7XG4gICAgICB1bnBhY2tlZENvb3Jkc1NuaXBwZXQgPSAnY29vcmRzJztcbiAgICB9IGVsc2Uge1xuICAgICAgdW5wYWNrZWRDb29yZHNTbmlwcGV0ID0gaW5wdXRMYXlvdXQudW5wYWNrZWRTaGFwZS5tYXAoKF9zLCBpKSA9PiBgY29vcmRzLiR7ZmllbGRzW2kgKyByYW5rRGlmZl19YCkuam9pbignLCAnKTtcbiAgICB9XG4gICAgY29uc3Qgc291cmNlID0gYFxuICAgICAgICBmbG9hdCAke2Z1bmNOYW1lfSgpIHtcbiAgICAgICAgICAke3R5cGV9IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICAgICR7Y29vcmRzU25pcHBldH1cbiAgICAgICAgICByZXR1cm4gJHt0ZXhGdW5jU25pcHBldH0oJHt1bnBhY2tlZENvb3Jkc1NuaXBwZXR9KTtcbiAgICAgICAgfVxuICAgICAgYDtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSwgWydjb29yZGluYXRlcy5nZXRPdXRwdXRDb29yZHMnXSk7XG4gIH1cblxuICAvKipcbiAgICogQ29uc3RydWN0aW5nIHNuaXBwZXRzIGZvciBwYWNrZWQgb3BlcmF0aW9ucy5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRQYWNrZWRTYW1wbGVyRnJvbUlucHV0KGZ1bmNOYW1lOiBzdHJpbmcsIG5hbWU6IHN0cmluZywgaW5wdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQpOiBHbHNsTGliUm91dGluZSB7XG4gICAgc3dpdGNoIChpbnB1dExheW91dC51bnBhY2tlZFNoYXBlLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRQYWNrZWRTYW1wbGVyU2NhbGFyKGZ1bmNOYW1lLCBuYW1lKTtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UGFja2VkU2FtcGxlcjFEKGZ1bmNOYW1lLCBuYW1lLCBpbnB1dExheW91dCk7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiB0aGlzLmdldFBhY2tlZFNhbXBsZXIyRChmdW5jTmFtZSwgbmFtZSwgaW5wdXRMYXlvdXQpO1xuICAgICAgY2FzZSAzOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRQYWNrZWRTYW1wbGVyM0QoZnVuY05hbWUsIG5hbWUsIGlucHV0TGF5b3V0KTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0aGlzLmdldFBhY2tlZFNhbXBsZXJORChmdW5jTmFtZSwgbmFtZSwgaW5wdXRMYXlvdXQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3Rpbmcgc25pcHBldHMgZm9yIHVucGFja2VkIG9wZXJhdGlvbnMuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0VW5wYWNrZWRTYW1wbGVyRnJvbUlucHV0KGZ1bmNOYW1lOiBzdHJpbmcsIG5hbWU6IHN0cmluZywgaW5wdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQpOiBHbHNsTGliUm91dGluZSB7XG4gICAgY29uc3Qgc2hhcGUgPSBpbnB1dExheW91dC51bnBhY2tlZFNoYXBlO1xuICAgIHN3aXRjaCAoc2hhcGUubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiB0aGlzLmdldFVucGFja2VkU2FtcGxlclNjYWxhcihmdW5jTmFtZSwgbmFtZSwgaW5wdXRMYXlvdXQpO1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXIxRChmdW5jTmFtZSwgbmFtZSwgaW5wdXRMYXlvdXQpO1xuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXIyRChmdW5jTmFtZSwgbmFtZSwgaW5wdXRMYXlvdXQpO1xuICAgICAgY2FzZSAzOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXIzRChmdW5jTmFtZSwgbmFtZSwgaW5wdXRMYXlvdXQpO1xuICAgICAgY2FzZSA0OlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXI0RChmdW5jTmFtZSwgbmFtZSwgaW5wdXRMYXlvdXQpO1xuICAgICAgY2FzZSA1OlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXI1RChmdW5jTmFtZSwgbmFtZSwgaW5wdXRMYXlvdXQpO1xuICAgICAgY2FzZSA2OlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXI2RChmdW5jTmFtZSwgbmFtZSwgaW5wdXRMYXlvdXQpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gVE9ETyBzdXBwb3J0IG1vcmUgZGltZW5zaW9uYWxpdGllc1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRpbWVuc2lvbiAke3NoYXBlLmxlbmd0aH0tRGApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQYWNrZWQgc2NhbGFyIHNuaXBwZXQuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0UGFja2VkU2FtcGxlclNjYWxhcihmdW5jTmFtZTogc3RyaW5nLCBuYW1lOiBzdHJpbmcpOiBHbHNsTGliUm91dGluZSB7XG4gICAgY29uc3QgZ2xzbCA9IGdldEdsc2wodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgICBjb25zdCBzb3VyY2UgPSBgXG4gICAgICAgICAgdmVjNCAke2Z1bmNOYW1lfSgpIHtcbiAgICAgICAgICAgIHJldHVybiAke2dsc2wudGV4dHVyZTJEfSgke25hbWV9LCBoYWxmQ1IpO1xuICAgICAgICAgIH1cbiAgICAgICAgYDtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSk7XG4gIH1cblxuICAvKipcbiAgICogUGFja2VkIDFEIHNuaXBwZXQuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0UGFja2VkU2FtcGxlcjFEKGZ1bmNOYW1lOiBzdHJpbmcsIG5hbWU6IHN0cmluZywgaW5wdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQpOiBHbHNsTGliUm91dGluZSB7XG4gICAgY29uc3QgdGV4U2hhcGUgPSBbaW5wdXRMYXlvdXQud2lkdGgsIGlucHV0TGF5b3V0LmhlaWdodF07XG4gICAgY29uc3QgcGFja2VkVGV4U2hhcGUgPSBbdGV4U2hhcGVbMV0sIHRleFNoYXBlWzBdXTtcbiAgICBjb25zdCBnbHNsID0gZ2V0R2xzbCh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pO1xuXG4gICAgY29uc3QgcGFja2VkU2FtcGxlciA9IGB2ZWM0ICR7ZnVuY05hbWV9KGludCBpbmRleCkge1xuICAgICAgdmVjMiB1diA9IHBhY2tlZFVWZnJvbTFEKFxuICAgICAgJHtwYWNrZWRUZXhTaGFwZVswXX0sICR7cGFja2VkVGV4U2hhcGVbMV19LCBpbmRleCk7XG4gICAgICByZXR1cm4gJHtnbHNsLnRleHR1cmUyRH0oJHtuYW1lfSwgdXYpO1xuICAgIH1gO1xuICAgIGNvbnN0IHNvdXJjZSA9IHBhY2tlZFNhbXBsZXI7XG4gICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShzb3VyY2UsIFsnY29vcmRpbmF0ZXMucGFja2VkVVZmcm9tMUQnXSk7XG4gIH1cblxuICAvKipcbiAgICogUGFja2VkIDJEIHNuaXBwZXQuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0UGFja2VkU2FtcGxlcjJEKGZ1bmNOYW1lOiBzdHJpbmcsIG5hbWU6IHN0cmluZywgaW5wdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQpOiBHbHNsTGliUm91dGluZSB7XG4gICAgY29uc3Qgc2hhcGUgPSBpbnB1dExheW91dC51bnBhY2tlZFNoYXBlO1xuICAgIGNvbnN0IHRleFNoYXBlID0gW2lucHV0TGF5b3V0LndpZHRoLCBpbnB1dExheW91dC5oZWlnaHRdO1xuICAgIGNvbnN0IGdsc2wgPSBnZXRHbHNsKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbik7XG4gICAgY29uc3QgdGV4TnVtUiA9IHRleFNoYXBlWzBdO1xuICAgIGNvbnN0IHRleE51bUMgPSB0ZXhTaGFwZVsxXTtcblxuICAgIGlmICh0ZXhTaGFwZSAhPSBudWxsICYmIEFycmF5VXRpbC5hcnJheXNFcXVhbChzaGFwZSwgdGV4U2hhcGUpKSB7XG4gICAgICBjb25zdCBwYWNrZWRTYW1wbGVyID0gYHZlYzQgJHtmdW5jTmFtZX0oaW50IHJvdywgaW50IGNvbCkge1xuICAgICAgICB2ZWMyIHV2ID0gKHZlYzIoY29sLCByb3cpICsgaGFsZkNSKSAvIHZlYzIoJHt0ZXhOdW1DfS4wLCAke3RleE51bVJ9LjApO1xuICAgICAgICByZXR1cm4gJHtnbHNsLnRleHR1cmUyRH0oJHtuYW1lfSwgdXYpO1xuICAgICAgfWA7XG5cbiAgICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUocGFja2VkU2FtcGxlcik7XG4gICAgfVxuICAgIGNvbnN0IHBhY2tlZFRleFNoYXBlID0gdGV4U2hhcGU7XG4gICAgY29uc3QgdmFsdWVzUGVyUm93ID0gTWF0aC5jZWlsKHNoYXBlWzFdIC8gMik7XG4gICAgY29uc3QgcGFja2VkU2FtcGxlciA9IGB2ZWM0ICR7ZnVuY05hbWV9KGludCByb3csIGludCBjb2wpIHtcbiAgICAgIHZlYzIgdXYgPSBwYWNrZWRVVmZyb20yRCgke3BhY2tlZFRleFNoYXBlWzFdfSwgJHtwYWNrZWRUZXhTaGFwZVswXX0sICR7dmFsdWVzUGVyUm93fSwgcm93LCBjb2wpO1xuICAgICAgcmV0dXJuICR7Z2xzbC50ZXh0dXJlMkR9KCR7bmFtZX0sIHV2KTtcbiAgICB9YDtcbiAgICBjb25zdCBzb3VyY2UgPSBwYWNrZWRTYW1wbGVyO1xuICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlLCBbJ2Nvb3JkaW5hdGVzLnBhY2tlZFVWZnJvbTJEJ10pO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhY2tlZCAzRCBzbmlwcGV0LlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldFBhY2tlZFNhbXBsZXIzRChmdW5jTmFtZTogc3RyaW5nLCBuYW1lOiBzdHJpbmcsIGlucHV0TGF5b3V0OiBUZXh0dXJlTGF5b3V0KTogR2xzbExpYlJvdXRpbmUge1xuICAgIGNvbnN0IHNoYXBlID0gaW5wdXRMYXlvdXQudW5wYWNrZWRTaGFwZTtcbiAgICBjb25zdCB0ZXhTaGFwZSA9IFtpbnB1dExheW91dC53aWR0aCwgaW5wdXRMYXlvdXQuaGVpZ2h0XTtcbiAgICBjb25zdCBwYWNrZWRUZXhTaGFwZSA9IFt0ZXhTaGFwZVswXSwgdGV4U2hhcGVbMV1dO1xuICAgIGNvbnN0IGdsc2wgPSBnZXRHbHNsKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbik7XG5cbiAgICBpZiAoc2hhcGVbMF0gPT09IDEpIHtcbiAgICAgIGNvbnN0IHNxdWVlemVkU2hhcGUgPSBzaGFwZS5zbGljZSgxKTtcbiAgICAgIGNvbnN0IGtlcHREaW1zID0gWzEsIDJdO1xuICAgICAgY29uc3QgbmV3SW5wdXRTaGFwZSA9IHNxdWVlemVJbnB1dFNoYXBlKHNoYXBlLCBzcXVlZXplZFNoYXBlKTtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IFsnYicsICdyb3cnLCAnY29sJ107XG4gICAgICAvLyBEZWVwIGNvcHkgb2YgaW5wdXQgdGV4dHVyZSBsYXlvdXQuXG4gICAgICBjb25zdCBuZXdJbnB1dExheW91dDogVGV4dHVyZUxheW91dCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoaW5wdXRMYXlvdXQpKTtcbiAgICAgIG5ld0lucHV0TGF5b3V0LnVucGFja2VkU2hhcGUgPSBuZXdJbnB1dFNoYXBlO1xuICAgICAgY29uc3Qgc2FtcGxlclJvdXRpbmUgPSB0aGlzLmdldFBhY2tlZFNhbXBsZXJGcm9tSW5wdXQoZnVuY05hbWUsIG5hbWUsIG5ld0lucHV0TGF5b3V0KTtcbiAgICAgIGNvbnN0IHBhY2tlZFNhbXBsZXIgPSBgJHtzYW1wbGVyUm91dGluZS5yb3V0aW5lQm9keX1cbiAgICAgIHZlYzQgJHtmdW5jTmFtZX0oaW50IGIsIGludCByb3csIGludCBjb2wpIHtcbiAgICAgICAgcmV0dXJuICR7ZnVuY05hbWV9KCR7Z2V0U3F1ZWV6ZWRQYXJhbXMocGFyYW1zLCBrZXB0RGltcyl9KTtcbiAgICAgIH0gYDtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IHBhY2tlZFNhbXBsZXI7XG4gICAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSwgc2FtcGxlclJvdXRpbmUuZGVwZW5kZW5jaWVzKTtcbiAgICB9XG4gICAgY29uc3QgdGV4TnVtUiA9IHBhY2tlZFRleFNoYXBlWzBdO1xuICAgIGNvbnN0IHRleE51bUMgPSBwYWNrZWRUZXhTaGFwZVsxXTtcblxuICAgIGNvbnN0IHZhbHVlc1BlclJvdyA9IE1hdGguY2VpbChzaGFwZVsyXSAvIDIpO1xuICAgIGNvbnN0IHRleGVsc0luQmF0Y2ggPSB2YWx1ZXNQZXJSb3cgKiBNYXRoLmNlaWwoc2hhcGVbMV0gLyAyKTtcblxuICAgIGNvbnN0IHBhY2tlZFNhbXBsZXIgPSBgdmVjNCAke2Z1bmNOYW1lfShpbnQgYiwgaW50IHJvdywgaW50IGNvbCkge1xuICAgICAgdmVjMiB1diA9IHBhY2tlZFVWZnJvbTNEKFxuICAgICAgICAke3RleE51bUN9LCAke3RleE51bVJ9LCAke3RleGVsc0luQmF0Y2h9LCAke3ZhbHVlc1BlclJvd30sIGIsIHJvdywgY29sKTtcbiAgICAgIHJldHVybiAke2dsc2wudGV4dHVyZTJEfSgke25hbWV9LCB1dik7fWA7XG4gICAgY29uc3Qgc291cmNlID0gcGFja2VkU2FtcGxlcjtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSwgWydjb29yZGluYXRlcy5wYWNrZWRVVmZyb20zRCddKTtcbiAgfVxuICAvKlxuICAgKiBQYWNrZWQgTkQgc25pcHBldC5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRQYWNrZWRTYW1wbGVyTkQoZnVuY05hbWU6IHN0cmluZywgbmFtZTogc3RyaW5nLCBpbnB1dExheW91dDogVGV4dHVyZUxheW91dCk6IEdsc2xMaWJSb3V0aW5lIHtcbiAgICBjb25zdCBzaGFwZSA9IGlucHV0TGF5b3V0LnVucGFja2VkU2hhcGU7XG4gICAgY29uc3QgcmFuayA9IHNoYXBlLmxlbmd0aDtcbiAgICBjb25zdCB0ZXhTaGFwZSA9IFtpbnB1dExheW91dC53aWR0aCwgaW5wdXRMYXlvdXQuaGVpZ2h0XTtcbiAgICBjb25zdCBnbHNsID0gZ2V0R2xzbCh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pO1xuXG4gICAgY29uc3QgcGFja2VkVGV4U2hhcGUgPSBbdGV4U2hhcGVbMF0sIHRleFNoYXBlWzFdXTtcbiAgICBjb25zdCB0ZXhOdW1SID0gcGFja2VkVGV4U2hhcGVbMV07XG4gICAgY29uc3QgdGV4TnVtQyA9IHBhY2tlZFRleFNoYXBlWzBdO1xuICAgIGNvbnN0IHZhbHVlc1BlclJvdyA9IE1hdGguY2VpbChzaGFwZVtyYW5rIC0gMV0gLyAyKTtcbiAgICBsZXQgdGV4ZWxzSW5CYXRjaCA9IHZhbHVlc1BlclJvdyAqIE1hdGguY2VpbChzaGFwZVtyYW5rIC0gMl0gLyAyKTtcbiAgICBsZXQgcGFyYW1zID0gJ2ludCBiLCBpbnQgcm93LCBpbnQgY29sJztcbiAgICBsZXQgaW5kZXggPSBgYiAqICR7dGV4ZWxzSW5CYXRjaH0gKyAocm93IC8gMikgKiAke3ZhbHVlc1BlclJvd30gKyAoY29sIC8gMilgO1xuICAgIGZvciAobGV0IGIgPSAyOyBiIDwgcmFuayAtIDE7IGIrKykge1xuICAgICAgcGFyYW1zID0gYGludCBiJHtifSwgYCArIHBhcmFtcztcbiAgICAgIHRleGVsc0luQmF0Y2ggKj0gc2hhcGVbcmFuayAtIGIgLSAxXTtcbiAgICAgIGluZGV4ID0gYGIke2J9ICogJHt0ZXhlbHNJbkJhdGNofSArIGAgKyBpbmRleDtcbiAgICB9XG4gICAgY29uc3QgcGFja2VkU2FtcGxlciA9IGB2ZWM0ICR7ZnVuY05hbWV9KCR7cGFyYW1zfSkge1xuICAgICAgaW50IGluZGV4ID0gJHtpbmRleH07XG4gICAgICBpbnQgdGV4UiA9IGluZGV4IC8gJHt0ZXhOdW1DfTtcbiAgICAgIGludCB0ZXhDID0gaW5kZXggLSB0ZXhSICogJHt0ZXhOdW1DfTtcbiAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKCR7dGV4TnVtQ30sICR7dGV4TnVtUn0pO1xuICAgICAgcmV0dXJuICR7Z2xzbC50ZXh0dXJlMkR9KCR7bmFtZX0sIHV2KTtcbiAgICB9YDtcbiAgICBjb25zdCBzb3VyY2UgPSBwYWNrZWRTYW1wbGVyO1xuICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnBhY2tlZCBzY2FsYXIgc25pcHBldC5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRVbnBhY2tlZFNhbXBsZXJTY2FsYXIoZnVuY05hbWU6IHN0cmluZywgbmFtZTogc3RyaW5nLCBpbnB1dExheW91dDogVGV4dHVyZUxheW91dCk6IEdsc2xMaWJSb3V0aW5lIHtcbiAgICBjb25zdCBbdGV4TnVtUiwgdGV4TnVtQ10gPSBbaW5wdXRMYXlvdXQud2lkdGgsIGlucHV0TGF5b3V0LmhlaWdodF07XG4gICAgaWYgKHRleE51bVIgPT09IDEgJiYgdGV4TnVtQyA9PT0gMSkge1xuICAgICAgY29uc3Qgc291cmNlID0gYFxuICAgICAgICAgIGZsb2F0ICR7ZnVuY05hbWV9KCkge1xuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtuYW1lfSwgaGFsZkNSKTtcbiAgICAgICAgICB9XG4gICAgICAgIGA7XG4gICAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSwgWydjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlJ10pO1xuICAgIH1cblxuICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICAgICAgZmxvYXQgJHtmdW5jTmFtZX0oKSB7XG4gICAgICAgICAgaW50IG9mZnNldF8ke25hbWV9ID0gY29vcmRzVG9PZmZzZXQoVGV4Q29vcmRzLCAke3RleE51bVJ9LCAke3RleE51bUN9KTtcbiAgICAgICAgICB2ZWMyIHV2ID0gdXZGcm9tRmxhdCgke3RleE51bVJ9LCAke3RleE51bUN9LCBvZmZzZXRfJHtuYW1lfSk7XG4gICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtuYW1lfSwgdXYpO1xuICAgICAgICB9XG4gICAgICBgO1xuICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlLCBbXG4gICAgICAnY29vcmRpbmF0ZXMudXZGcm9tRmxhdCcsXG4gICAgICAnY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZScsXG4gICAgICAnY29vcmRpbmF0ZXMuY29vcmRzVG9PZmZzZXQnLFxuICAgIF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucGFja2VkIDFEIHNuaXBwZXQuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0VW5wYWNrZWRTYW1wbGVyMUQoZnVuY05hbWU6IHN0cmluZywgbmFtZTogc3RyaW5nLCBpbnB1dExheW91dDogVGV4dHVyZUxheW91dCk6IEdsc2xMaWJSb3V0aW5lIHtcbiAgICBjb25zdCB0TnVtUiA9IGlucHV0TGF5b3V0LndpZHRoO1xuICAgIGNvbnN0IHROdW1DID0gaW5wdXRMYXlvdXQuaGVpZ2h0O1xuXG4gICAgaWYgKHROdW1DID09PSAxICYmIHROdW1SID09PSAxKSB7XG4gICAgICBjb25zdCBzb3VyY2UgPSBgXG4gICAgICAgIGZsb2F0ICR7ZnVuY05hbWV9KGludCBpbmRleCkge1xuICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7bmFtZX0sIGhhbGZDUik7XG4gICAgICAgIH1cbiAgICAgIGA7XG4gICAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSwgWydjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlJ10pO1xuICAgIH1cblxuICAgIGlmICh0TnVtQyA9PT0gMSkge1xuICAgICAgY29uc3Qgc291cmNlID0gYFxuICAgICAgICAgIGZsb2F0ICR7ZnVuY05hbWV9KGludCBpbmRleCkge1xuICAgICAgICAgICAgdmVjMiB1diA9IHZlYzIoKGZsb2F0KGluZGV4KSArIDAuNSkgLyAke3ROdW1SfS4wLCAwLjUpO1xuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtuYW1lfSwgdXYpO1xuICAgICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlLCBbJ2Nvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmUnXSk7XG4gICAgfVxuICAgIGlmICh0TnVtUiA9PT0gMSkge1xuICAgICAgY29uc3Qgc291cmNlID0gYFxuICAgICAgICAgIGZsb2F0ICR7ZnVuY05hbWV9KGludCBpbmRleCkge1xuICAgICAgICAgICAgdmVjMiB1diA9IHZlYzIoMC41LCAoZmxvYXQoaW5kZXgpICsgMC41KSAvICR7dE51bUN9LjApO1xuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtuYW1lfSwgdXYpO1xuICAgICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlLCBbJ2Nvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmUnXSk7XG4gICAgfVxuICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICAgICAgZmxvYXQgJHtmdW5jTmFtZX0oaW50IGluZGV4KSB7XG4gICAgICAgICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoJHt0TnVtUn0sICR7dE51bUN9LCBpbmRleCk7XG4gICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtuYW1lfSwgdXYpO1xuICAgICAgICB9XG4gICAgICBgO1xuICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlLCBbJ2Nvb3JkaW5hdGVzLnV2RnJvbUZsYXQnLCAnY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZSddKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnBhY2tlZCAyRCBzbmlwcGV0LlxuICAgKi9cblxuICBwcm90ZWN0ZWQgZ2V0VW5wYWNrZWRTYW1wbGVyMkQoZnVuY05hbWU6IHN0cmluZywgbmFtZTogc3RyaW5nLCBpbnB1dExheW91dDogVGV4dHVyZUxheW91dCk6IEdsc2xMaWJSb3V0aW5lIHtcbiAgICBjb25zdCBzaGFwZSA9IGlucHV0TGF5b3V0LnVucGFja2VkU2hhcGU7XG5cbiAgICAvLyBUT0RPOiBtb2RpZnkgcm93L2NvbCBvcmRlciBmb3Igb3RoZXIgZGltZW5zaW9ucy5cbiAgICBjb25zdCB0ZXhTaGFwZSA9IFtpbnB1dExheW91dC5oZWlnaHQsIGlucHV0TGF5b3V0LndpZHRoXTtcblxuICAgIGlmICh0ZXhTaGFwZSAhPSBudWxsICYmIEFycmF5VXRpbC5hcnJheXNFcXVhbChzaGFwZSwgdGV4U2hhcGUpKSB7XG4gICAgICBjb25zdCB0ZXhOdW1SID0gdGV4U2hhcGVbMV07XG4gICAgICBjb25zdCB0ZXhOdW1DID0gdGV4U2hhcGVbMF07XG4gICAgICBjb25zdCBzb3VyY2UgPSBgXG4gICAgICAgICAgZmxvYXQgJHtmdW5jTmFtZX0oaW50IHJvdywgaW50IGNvbCkge1xuICAgICAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHJvdywgY29sKSArIGhhbGZDUikgLyB2ZWMyKCR7dGV4TnVtUn0uMCwgJHt0ZXhOdW1DfS4wKTtcbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7bmFtZX0sIHV2KTtcbiAgICAgICAgICB9XG4gICAgICAgIGA7XG4gICAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSwgWydjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlJ10pO1xuICAgIH1cblxuICAgIGNvbnN0IHsgbmV3U2hhcGUsIGtlcHREaW1zIH0gPSBzcXVlZXplU2hhcGUoc2hhcGUgYXMgbnVtYmVyW10pO1xuICAgIGNvbnN0IHNxdWVlemVkU2hhcGUgPSBuZXdTaGFwZTtcbiAgICBpZiAoc3F1ZWV6ZWRTaGFwZS5sZW5ndGggPCBzaGFwZS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IG5ld0lucHV0U2hhcGUgPSBzcXVlZXplSW5wdXRTaGFwZShzaGFwZSwgc3F1ZWV6ZWRTaGFwZSk7XG4gICAgICAvLyBEZWVwIGNvcHkgb2YgaW5wdXQgdGV4dHVyZSBsYXlvdXQuXG4gICAgICBjb25zdCBuZXdJbnB1dExheW91dDogVGV4dHVyZUxheW91dCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoaW5wdXRMYXlvdXQpKTtcbiAgICAgIG5ld0lucHV0TGF5b3V0LnVucGFja2VkU2hhcGUgPSBuZXdJbnB1dFNoYXBlO1xuXG4gICAgICBjb25zdCBwYXJhbXMgPSBbJ2NvbCcsICdyb3cnXTtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICAgICAgICAke3RoaXMuZ2V0VW5wYWNrZWRTYW1wbGVyRnJvbUlucHV0KGZ1bmNOYW1lLCBuYW1lLCBuZXdJbnB1dExheW91dCkucm91dGluZUJvZHl9XG4gICAgICAgICAgZmxvYXQgJHtmdW5jTmFtZX0oaW50IHJvdywgaW50IGNvbCkge1xuICAgICAgICAgICAgcmV0dXJuICR7ZnVuY05hbWV9KCR7Z2V0U3F1ZWV6ZWRQYXJhbXMocGFyYW1zLCBrZXB0RGltcyl9KTtcbiAgICAgICAgICB9XG4gICAgICAgIGA7XG4gICAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSwgWydjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlJ10pO1xuICAgIH1cblxuICAgIGNvbnN0IHRleE51bVIgPSB0ZXhTaGFwZVsxXTtcbiAgICBjb25zdCB0ZXhOdW1DID0gdGV4U2hhcGVbMF07XG4gICAgaWYgKHRleE51bUMgPT09IDEpIHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICAgICAgICBmbG9hdCAke2Z1bmNOYW1lfShpbnQgcm93LCBpbnQgY29sKSB7XG4gICAgICAgICAgICBpbnQgb2Zmc2V0XyR7bmFtZX0gPSBjb29yZHNUb09mZnNldChUZXhDb29yZHMsICR7dGV4TnVtUn0sICR7dGV4TnVtQ30pO1xuICAgICAgICAgICAgZmxvYXQgaW5kZXggPSBkb3QodmVjMyhyb3csIGNvbCwgb2Zmc2V0XyR7bmFtZX0pLCB2ZWMzKCR7c2hhcGVbMV19LCAxLCAxKSk7XG4gICAgICAgICAgICB2ZWMyIHV2ID0gdmVjMigwLjUsIChpbmRleCArIDAuNSkgLyAke3RleE51bVJ9LjApO1xuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtuYW1lfSwgdXYpO1xuICAgICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlLCBbJ2Nvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmUnLCAnY29vcmRpbmF0ZXMuY29vcmRzVG9PZmZzZXQnXSk7XG4gICAgfVxuXG4gICAgaWYgKHRleE51bVIgPT09IDEpIHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICAgICAgICBmbG9hdCAke2Z1bmNOYW1lfShpbnQgcm93LCBpbnQgY29sKSB7XG4gICAgICAgICAgICBpbnQgb2Zmc2V0XyR7bmFtZX0gPSBjb29yZHNUb09mZnNldChUZXhDb29yZHMsICR7dGV4TnVtUn0sICR7dGV4TnVtQ30pO1xuICAgICAgICAgICAgZmxvYXQgaW5kZXggPSBkb3QodmVjMyhyb3csIGNvbCwgb2Zmc2V0XyR7bmFtZX0pLCB2ZWMzKCR7c2hhcGVbMV19LCAxLCAxKSk7XG4gICAgICAgICAgICB2ZWMyIHV2ID0gdmVjMigoaW5kZXggKyAwLjUpIC8gJHt0ZXhOdW1DfS4wLCAwLjUpO1xuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtuYW1lfSwgdXYpO1xuICAgICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlLCBbJ2Nvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmUnLCAnY29vcmRpbmF0ZXMuY29vcmRzVG9PZmZzZXQnXSk7XG4gICAgfVxuXG4gICAgY29uc3Qgc291cmNlID0gYFxuICAgICAgICBmbG9hdCAke2Z1bmNOYW1lfShpbnQgcm93LCBpbnQgY29sKSB7XG4gICAgICAgICAgaW50IGluZGV4ID0gY29sICogJHtzaGFwZVsxXX0gKyByb3c7XG4gICAgICAgICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoJHt0ZXhOdW1SfSwgJHt0ZXhOdW1DfSwgaW5kZXgpO1xuICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7bmFtZX0sIHV2KTtcbiAgICAgICAgfVxuICAgICAgYDtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSwgW1xuICAgICAgJ2Nvb3JkaW5hdGVzLnV2RnJvbUZsYXQnLFxuICAgICAgJ2Nvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmUnLFxuICAgICAgJ2Nvb3JkaW5hdGVzLmNvb3Jkc1RvT2Zmc2V0JyxcbiAgICBdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnBhY2tlZCAzRCBzbmlwcGV0LlxuICAgKi9cblxuICBwcm90ZWN0ZWQgZ2V0VW5wYWNrZWRTYW1wbGVyM0QoZnVuY05hbWU6IHN0cmluZywgbmFtZTogc3RyaW5nLCBpbnB1dExheW91dDogVGV4dHVyZUxheW91dCk6IEdsc2xMaWJSb3V0aW5lIHtcbiAgICBjb25zdCBzaGFwZSA9IGlucHV0TGF5b3V0LnVucGFja2VkU2hhcGU7XG4gICAgY29uc3Qgc3RyaWRlMCA9IHNoYXBlWzFdICogc2hhcGVbMl07XG4gICAgY29uc3Qgc3RyaWRlMSA9IHNoYXBlWzJdO1xuXG4gICAgY29uc3QgeyBuZXdTaGFwZSwga2VwdERpbXMgfSA9IHNxdWVlemVTaGFwZShzaGFwZSBhcyBudW1iZXJbXSk7XG4gICAgY29uc3Qgc3F1ZWV6ZWRTaGFwZSA9IG5ld1NoYXBlO1xuICAgIGlmIChzcXVlZXplZFNoYXBlLmxlbmd0aCA8IHNoYXBlLmxlbmd0aCkge1xuICAgICAgY29uc3QgbmV3SW5wdXRTaGFwZSA9IHNxdWVlemVJbnB1dFNoYXBlKHNoYXBlLCBzcXVlZXplZFNoYXBlKTtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IFsnYmF0Y2gnLCAnY29sJywgJ3JvdyddO1xuICAgICAgLy8gRGVlcCBjb3B5IG9mIGlucHV0IHRleHR1cmUgbGF5b3V0LlxuICAgICAgY29uc3QgbmV3SW5wdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGlucHV0TGF5b3V0KSk7XG4gICAgICBuZXdJbnB1dExheW91dC51bnBhY2tlZFNoYXBlID0gbmV3SW5wdXRTaGFwZTtcbiAgICAgIGNvbnN0IHJvdXRpbmUgPSB0aGlzLmdldFVucGFja2VkU2FtcGxlckZyb21JbnB1dChmdW5jTmFtZSwgbmFtZSwgbmV3SW5wdXRMYXlvdXQpO1xuICAgICAgLy8gVE9ETzogcmV2aXNpdCB0aGUgbG9naWMgaGVyZSB0byBtYWtlIGl0IHNpbXBsZXJcbiAgICAgIGNvbnN0IHJldkRpbXMgPSBrZXB0RGltcy5yZXZlcnNlKCk7XG4gICAgICBjb25zdCBzb3VyY2UgPSBgXG4gICAgICAgICAgJHtyb3V0aW5lLnJvdXRpbmVCb2R5fVxuICAgICAgICAgIGZsb2F0ICR7ZnVuY05hbWV9KGludCBiYXRjaCwgaW50IHJvdywgaW50IGNvbCkge1xuICAgICAgICAgICAgcmV0dXJuICR7ZnVuY05hbWV9KCR7Z2V0U3F1ZWV6ZWRQYXJhbXMocGFyYW1zLCByZXZEaW1zKX0pO1xuICAgICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlLCByb3V0aW5lLmRlcGVuZGVuY2llcyk7XG4gICAgfVxuXG4gICAgY29uc3QgdGV4TnVtUiA9IGlucHV0TGF5b3V0LndpZHRoO1xuICAgIGNvbnN0IHRleE51bUMgPSBpbnB1dExheW91dC5oZWlnaHQ7XG4gICAgY29uc3Qgc291cmNlID0gYFxuICAgICAgICAgIGZsb2F0ICR7ZnVuY05hbWV9KGludCBkZXB0aCwgaW50IHJvdywgaW50IGNvbCkge1xuICAgICAgICAgICAgLy8gRXhwbGljaXRseSB1c2UgaW50ZWdlciBvcGVyYXRpb25zIGFzIGRvdCgpIG9ubHkgd29ya3Mgb24gZmxvYXRzLlxuICAgICAgICAgICAgaW50IGluZGV4ID0gZGVwdGggKiAke3N0cmlkZTB9ICsgY29sICogJHtzdHJpZGUxfSArIHJvdztcbiAgICAgICAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KCR7dGV4TnVtUn0sICR7dGV4TnVtQ30sIGluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7bmFtZX0sIHV2KTtcbiAgICAgICAgICB9XG4gICAgICBgO1xuICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlLCBbXG4gICAgICAnY29vcmRpbmF0ZXMudXZGcm9tRmxhdCcsXG4gICAgICAnY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZScsXG4gICAgICAnY29vcmRpbmF0ZXMuY29vcmRzVG9PZmZzZXQnLFxuICAgIF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucGFja2VkIDREIHNuaXBwZXQuXG4gICAqL1xuXG4gIHByb3RlY3RlZCBnZXRVbnBhY2tlZFNhbXBsZXI0RChmdW5jTmFtZTogc3RyaW5nLCBuYW1lOiBzdHJpbmcsIGlucHV0TGF5b3V0OiBUZXh0dXJlTGF5b3V0KTogR2xzbExpYlJvdXRpbmUge1xuICAgIGNvbnN0IHNoYXBlID0gaW5wdXRMYXlvdXQudW5wYWNrZWRTaGFwZTtcbiAgICBjb25zdCBzdHJpZGUyID0gc2hhcGVbM107XG4gICAgY29uc3Qgc3RyaWRlMSA9IHNoYXBlWzJdICogc3RyaWRlMjtcbiAgICBjb25zdCBzdHJpZGUwID0gc2hhcGVbMV0gKiBzdHJpZGUxO1xuXG4gICAgLy9cbiAgICAvLyBUT0RPOiByZS1lbmFibGUgdGhpcyBzaG9ydGN1dCBvbmNlIHRoZSBpbmRleCBjYWxjdWxhdGlvbiBidWcgaXMgZml4ZWQuXG4gICAgLy9cbiAgICAvLyBjb25zdCB7bmV3U2hhcGUsIGtlcHREaW1zfSA9IHNxdWVlemVTaGFwZShzaGFwZSBhcyBudW1iZXJbXSk7XG4gICAgLy8gaWYgKG5ld1NoYXBlLmxlbmd0aCA8IHNoYXBlLmxlbmd0aCkge1xuICAgIC8vICAgY29uc3QgbmV3SW5wdXRTaGFwZSA9IHNxdWVlemVJbnB1dFNoYXBlKHNoYXBlLCBuZXdTaGFwZSk7XG4gICAgLy8gICBjb25zdCBwYXJhbXMgPSBbJ3JvdycsICdjb2wnLCAnZGVwdGgnLCAnZGVwdGgyJ107XG4gICAgLy8gICAvLyBEZWVwIGNvcHkgb2YgaW5wdXQgdGV4dHVyZSBsYXlvdXQuXG4gICAgLy8gICBjb25zdCBuZXdJbnB1dExheW91dDogVGV4dHVyZUxheW91dCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoaW5wdXRMYXlvdXQpKTtcbiAgICAvLyAgIG5ld0lucHV0TGF5b3V0LnVucGFja2VkU2hhcGUgPSBuZXdJbnB1dFNoYXBlO1xuICAgIC8vICAgY29uc3Qgc291cmNlID0gYFxuICAgIC8vICAgICAgICR7dGhpcy5nZXRVbnBhY2tlZFNhbXBsZXJGcm9tSW5wdXQoZnVuY05hbWUsIG5hbWUsIG5ld0lucHV0TGF5b3V0KS5yb3V0aW5lQm9keX1cbiAgICAvLyAgICAgICBmbG9hdCAke2Z1bmNOYW1lfShpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIpIHtcbiAgICAvLyAgICAgICAgIHJldHVybiAke2Z1bmNOYW1lfSgke2dldFNxdWVlemVkUGFyYW1zKHBhcmFtcywga2VwdERpbXMpfSk7XG4gICAgLy8gICAgICAgfVxuICAgIC8vICAgICBgO1xuICAgIC8vICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShcbiAgICAvLyAgICAgICBzb3VyY2UsIFsnY29vcmRpbmF0ZXMudXZGcm9tRmxhdCcsICdjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlJywgJ2Nvb3JkaW5hdGVzLmNvb3Jkc1RvT2Zmc2V0J10pO1xuICAgIC8vIH1cblxuICAgIGNvbnN0IHRleE51bVIgPSBpbnB1dExheW91dC53aWR0aDtcbiAgICBjb25zdCB0ZXhOdW1DID0gaW5wdXRMYXlvdXQuaGVpZ2h0O1xuICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICAgICAgZmxvYXQgJHtmdW5jTmFtZX0oaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyKSB7XG4gICAgICAgICAgaW50IGluZGV4ID0gcm93ICogJHtzdHJpZGUwfSArIGNvbCAqICR7c3RyaWRlMX0gK1xuICAgICAgICAgICAgICBkZXB0aDIgKiAke3N0cmlkZTJ9ICsgZGVwdGg7XG4gICAgICAgICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoJHt0ZXhOdW1SfSwgJHt0ZXhOdW1DfSwgaW5kZXgpO1xuICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7bmFtZX0sIHV2KTtcbiAgICAgICAgfVxuICAgICAgYDtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSwgWydjb29yZGluYXRlcy51dkZyb21GbGF0JywgJ2Nvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmUnXSk7XG4gIH1cblxuICAvKipcbiAgICogVW5wYWNrZWQgNUQgc25pcHBldC5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRVbnBhY2tlZFNhbXBsZXI1RChmdW5jTmFtZTogc3RyaW5nLCBuYW1lOiBzdHJpbmcsIGlucHV0TGF5b3V0OiBUZXh0dXJlTGF5b3V0KTogR2xzbExpYlJvdXRpbmUge1xuICAgIGNvbnN0IHNoYXBlID0gaW5wdXRMYXlvdXQudW5wYWNrZWRTaGFwZTtcbiAgICBjb25zdCBzdHJpZGUzID0gc2hhcGVbNF07XG4gICAgY29uc3Qgc3RyaWRlMiA9IHNoYXBlWzNdICogc3RyaWRlMztcbiAgICBjb25zdCBzdHJpZGUxID0gc2hhcGVbMl0gKiBzdHJpZGUyO1xuICAgIGNvbnN0IHN0cmlkZTAgPSBzaGFwZVsxXSAqIHN0cmlkZTE7XG5cbiAgICBjb25zdCB7IG5ld1NoYXBlLCBrZXB0RGltcyB9ID0gc3F1ZWV6ZVNoYXBlKHNoYXBlIGFzIG51bWJlcltdKTtcbiAgICBpZiAobmV3U2hhcGUubGVuZ3RoIDwgc2hhcGUubGVuZ3RoKSB7XG4gICAgICBjb25zdCBuZXdJbnB1dFNoYXBlID0gc3F1ZWV6ZUlucHV0U2hhcGUoc2hhcGUsIG5ld1NoYXBlKTtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IFsncm93JywgJ2NvbCcsICdkZXB0aCcsICdkZXB0aDInLCAnZGVwdGgzJ107XG4gICAgICAvLyBEZWVwIGNvcHkgb2YgaW5wdXQgdGV4dHVyZSBsYXlvdXQuXG4gICAgICBjb25zdCBuZXdJbnB1dExheW91dDogVGV4dHVyZUxheW91dCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoaW5wdXRMYXlvdXQpKTtcbiAgICAgIG5ld0lucHV0TGF5b3V0LnVucGFja2VkU2hhcGUgPSBuZXdJbnB1dFNoYXBlO1xuXG4gICAgICBjb25zdCBzb3VyY2UgPSBgXG4gICAgICAgICAgJHt0aGlzLmdldFVucGFja2VkU2FtcGxlckZyb21JbnB1dChmdW5jTmFtZSwgbmFtZSwgbmV3SW5wdXRMYXlvdXQpLnJvdXRpbmVCb2R5fVxuICAgICAgICAgIGZsb2F0ICR7ZnVuY05hbWV9KGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMiwgaW50IGRlcHRoMykge1xuICAgICAgICAgICAgcmV0dXJuICR7ZnVuY05hbWV9KCR7Z2V0U3F1ZWV6ZWRQYXJhbXMocGFyYW1zLCBrZXB0RGltcyl9KTtcbiAgICAgICAgICB9XG4gICAgICAgIGA7XG4gICAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSwgWydjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlJywgJ2Nvb3JkaW5hdGVzLnV2RnJvbUZsYXQnXSk7XG4gICAgfVxuXG4gICAgY29uc3QgdGV4TnVtUiA9IGlucHV0TGF5b3V0LndpZHRoO1xuICAgIGNvbnN0IHRleE51bUMgPSBpbnB1dExheW91dC5oZWlnaHQ7XG4gICAgY29uc3Qgc291cmNlID0gYFxuICAgICAgICBmbG9hdCAke2Z1bmNOYW1lfShpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIsIGludCBkZXB0aDMpIHtcbiAgICAgICAgICBpbnQgaW5kZXggPSByb3cgKiAke3N0cmlkZTB9ICsgY29sICogJHtzdHJpZGUxfSArIGRlcHRoICogJHtzdHJpZGUyfSArXG4gICAgICAgICAgZGVwdGgzICogJHtzdHJpZGUzfSArIGRlcHRoMjtcbiAgICAgICAgICB2ZWMyIHV2ID0gdXZGcm9tRmxhdCgke3RleE51bVJ9LCAke3RleE51bUN9LCBpbmRleCk7XG4gICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtuYW1lfSwgdXYpO1xuICAgICAgICB9XG4gICAgICBgO1xuICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlLCBbJ2Nvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmUnLCAnY29vcmRpbmF0ZXMudXZGcm9tRmxhdCddKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnBhY2tlZCA2RCBzbmlwcGV0LlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldFVucGFja2VkU2FtcGxlcjZEKGZ1bmNOYW1lOiBzdHJpbmcsIG5hbWU6IHN0cmluZywgaW5wdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQpOiBHbHNsTGliUm91dGluZSB7XG4gICAgY29uc3Qgc2hhcGUgPSBpbnB1dExheW91dC51bnBhY2tlZFNoYXBlO1xuICAgIGNvbnN0IHN0cmlkZTQgPSBzaGFwZVs1XTtcbiAgICBjb25zdCBzdHJpZGUzID0gc2hhcGVbNF0gKiBzdHJpZGU0O1xuICAgIGNvbnN0IHN0cmlkZTIgPSBzaGFwZVszXSAqIHN0cmlkZTM7XG4gICAgY29uc3Qgc3RyaWRlMSA9IHNoYXBlWzJdICogc3RyaWRlMjtcbiAgICBjb25zdCBzdHJpZGUwID0gc2hhcGVbMV0gKiBzdHJpZGUxO1xuXG4gICAgY29uc3QgeyBuZXdTaGFwZSwga2VwdERpbXMgfSA9IHNxdWVlemVTaGFwZShzaGFwZSBhcyBudW1iZXJbXSk7XG4gICAgaWYgKG5ld1NoYXBlLmxlbmd0aCA8IHNoYXBlLmxlbmd0aCkge1xuICAgICAgY29uc3QgbmV3SW5wdXRTaGFwZSA9IHNxdWVlemVJbnB1dFNoYXBlKHNoYXBlLCBuZXdTaGFwZSk7XG4gICAgICBjb25zdCBwYXJhbXMgPSBbJ3JvdycsICdjb2wnLCAnZGVwdGgnLCAnZGVwdGgyJywgJ2RlcHRoMycsICdkZXB0aDQnXTtcbiAgICAgIC8vIERlZXAgY29weSBvZiBpbnB1dCB0ZXh0dXJlIGxheW91dC5cbiAgICAgIGNvbnN0IG5ld0lucHV0TGF5b3V0OiBUZXh0dXJlTGF5b3V0ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShpbnB1dExheW91dCkpO1xuICAgICAgbmV3SW5wdXRMYXlvdXQudW5wYWNrZWRTaGFwZSA9IG5ld0lucHV0U2hhcGU7XG5cbiAgICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICAgICAgICAgICR7dGhpcy5nZXRVbnBhY2tlZFNhbXBsZXJGcm9tSW5wdXQoZnVuY05hbWUsIG5hbWUsIG5ld0lucHV0TGF5b3V0KS5yb3V0aW5lQm9keX1cbiAgICAgICAgICAgIGZsb2F0ICR7ZnVuY05hbWV9KGludCByb3csIGludCBjb2wsIGludCBkZXB0aCxcbiAgICAgICAgICAgICAgaW50IGRlcHRoMiwgaW50IGRlcHRoMywgaW50IGRlcHRoNCkge1xuICAgICAgICAgICAgICByZXR1cm4gJHtmdW5jTmFtZX0oJHtnZXRTcXVlZXplZFBhcmFtcyhwYXJhbXMsIGtlcHREaW1zKX0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGA7XG4gICAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSwgWydjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlJywgJ2Nvb3JkaW5hdGVzLnV2RnJvbUZsYXQnXSk7XG4gICAgfVxuXG4gICAgY29uc3QgdGV4TnVtUiA9IGlucHV0TGF5b3V0LndpZHRoO1xuICAgIGNvbnN0IHRleE51bUMgPSBpbnB1dExheW91dC5oZWlnaHQ7XG4gICAgY29uc3Qgc291cmNlID0gYFxuICAgICAgICAgIGZsb2F0ICR7ZnVuY05hbWV9KGludCByb3csIGludCBjb2wsIGludCBkZXB0aCxcbiAgICAgICAgICAgIGludCBkZXB0aDIsIGludCBkZXB0aDMsIGludCBkZXB0aDQpIHtcbiAgICAgICAgICAgIGludCBpbmRleCA9IHJvdyAqICR7c3RyaWRlMH0gKyBjb2wgKiAke3N0cmlkZTF9ICsgZGVwdGggKiAke3N0cmlkZTJ9ICtcbiAgICAgICAgICAgIGRlcHRoMiAqICR7c3RyaWRlM30gKyBkZXB0aDMgKiAke3N0cmlkZTR9ICsgZGVwdGg0O1xuICAgICAgICAgICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoJHt0ZXhOdW1SfSwgJHt0ZXhOdW1DfSwgaW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtuYW1lfSwgdXYpO1xuICAgICAgICAgIH1cbiAgICAgICAgYDtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSwgW1xuICAgICAgJ2Nvb3JkaW5hdGVzLnV2RnJvbUZsYXQnLFxuICAgICAgJ2Nvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmUnLFxuICAgICAgJ2Nvb3JkaW5hdGVzLmNvb3Jkc1RvT2Zmc2V0JyxcbiAgICBdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIHRoZSBtYWluIGZ1bmN0aW9uIHRvIG1hcCBmcm9tIHRoZSBnaXZlbiB0ZXh0dXJlIGNvb3JkaW5hdGVzIChzLHQpXG4gICAqIHRvIGxvZ2ljYWwgaW5kaWNlcyBmb3IgdGhlIG91dHB1dFxuICAgKiBUaGVyZSB3aWxsIG9ubHkgYmUgb25lIHNpbmdsZSB2YXJpYXRpb24gb2YgdGhpc1xuICAgKiBBbHNvIHNlZSBjb29yZHNUb09mZnNldCBhbmQgb2Zmc2V0VG9JbmRpY2VzIGZvciBpbnB1dC1zcGVjaWZpYyB2ZXJzaW9uc1xuICAgKi9cbiAgcHJvdGVjdGVkIHRvVmVjKCk6IHsgW25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lIH0ge1xuICAgIGNvbnN0IG91dHB1dCA9IHRoaXMuY29udGV4dC5vdXRwdXRUZXh0dXJlTGF5b3V0O1xuICAgIGNvbnN0IHJhbmsgPSBvdXRwdXQuc2hhcGUubGVuZ3RoO1xuICAgIGNvbnN0IHN0cmlkZXMgPSBvdXRwdXQuc3RyaWRlcztcbiAgICBjb25zdCB4U2NhbGUgPSBvdXRwdXQud2lkdGg7XG4gICAgY29uc3QgeVNjYWxlID0gb3V0cHV0LmhlaWdodDtcblxuICAgIGNvbnN0IHN0cmlkZXNCbG9jayA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuayAtIDE7ICsraSkge1xuICAgICAgc3RyaWRlc0Jsb2NrLnB1c2goYFxuICAgICAgICBjWyR7aX1dID0gb2Zmc2V0IC8gJHtzdHJpZGVzW2ldfTtgKTtcbiAgICAgIHN0cmlkZXNCbG9jay5wdXNoKGBcbiAgICAgICAgb2Zmc2V0IC09IGNbJHtpfV0gKiAke3N0cmlkZXNbaV19O2ApO1xuICAgIH1cbiAgICBzdHJpZGVzQmxvY2sucHVzaChgXG4gICAgICAgIGNbJHtyYW5rIC0gMX1dID0gb2Zmc2V0O2ApO1xuICAgIGNvbnN0IGJvZHkgPSBgXG4gICAgICB2b2lkIHRvVmVjKHZlYzIgdGV4Q29vcmRzLCBvdXQgaW50IGNbJHtyYW5rfV0pIHtcbiAgICAgICAgaW50IG9mZnNldCA9IGNvb3Jkc1RvT2Zmc2V0KHRleENvb3JkcywgJHt4U2NhbGV9LCAke3lTY2FsZX0pO1xuICAgICAgICAke3N0cmlkZXNCbG9jay5qb2luKCcnKX1cbiAgICAgIH1cbiAgICAgIHZvaWQgdG9WZWMoaW50IG9mZnNldCwgb3V0IGludCBjWyR7cmFua31dKSB7XG4gICAgICAgICR7c3RyaWRlc0Jsb2NrLmpvaW4oJycpfVxuICAgICAgfVxuICAgIGA7XG4gICAgcmV0dXJuIHsgdG9WZWM6IG5ldyBHbHNsTGliUm91dGluZShib2R5LCBbJ2Nvb3JkaW5hdGVzLmNvb3Jkc1RvT2Zmc2V0J10pIH07XG4gIH1cbiAgLyoqXG4gICAqIFRoZXNlIGFyZSB2YWx1ZSBnZXR0ZXIgZnVuY3Rpb25zIGdlbmVyYXRlZCBmb3IgZWFjaCBpbnB1dFxuICAgKiBFYWNoIGZ1bmN0aW9uIGlzIGhhcmR3aXJlZCB0byB0aGUgbmFtZSBhbmQgZGltZW5zaW9ucyBvZiB0aGUgaW5wdXRcbiAgICogQW4gJ19UJyB2YXJpYXRpb24gaXMgYWxzbyBwcm9kdWNlZCB3aGljaCBhY2Nlc3NlcyB2YWx1ZXMgYXMgaWYgdGhlXG4gICAqIGlucHV0IHdhcyB0cmFuc3Bvc2VkXG4gICAqL1xuICBwcm90ZWN0ZWQgdmFsdWVGcm9tKCk6IHsgW25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lIH0ge1xuICAgIGNvbnN0IHJlc3VsdDogeyBbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmUgfSA9IHt9O1xuICAgIHRoaXMuY29udGV4dC5wcm9ncmFtSW5mby5pbnB1dE5hbWVzLmZvckVhY2goKG5hbWUsIGkpID0+IHtcbiAgICAgIGNvbnN0IGxheW91dCA9IHRoaXMuY29udGV4dC5pbnB1dFRleHR1cmVMYXlvdXRzW2ldO1xuICAgICAgY29uc3Qgc2hhcGUgPSBsYXlvdXQudW5wYWNrZWRTaGFwZS5sZW5ndGggPiAwID8gbGF5b3V0LnVucGFja2VkU2hhcGUgOiBsYXlvdXQuc2hhcGU7XG4gICAgICBjb25zdCByYW5rID0gc2hhcGUubGVuZ3RoO1xuICAgICAgbGV0IGZ1bmNOYW1lID0gYF8ke25hbWV9YDtcbiAgICAgIHJlc3VsdFtmdW5jTmFtZV0gPSBuZXcgR2xzbExpYlJvdXRpbmUodGhpcy5nZXRWYWx1ZUZyb21TaW5nbGUobmFtZSwgcmFuaywgbGF5b3V0LndpZHRoLCBsYXlvdXQuaGVpZ2h0LCBmYWxzZSksIFtcbiAgICAgICAgYHNoYXBlVXRpbHMuaW5kaWNlc1RvT2Zmc2V0JHtmdW5jTmFtZX1gLFxuICAgICAgICAnY29vcmRpbmF0ZXMub2Zmc2V0VG9Db29yZHMnLFxuICAgICAgICAnZnJhZ2NvbG9yLmdldENvbG9yQXNGbG9hdCcsXG4gICAgICBdKTtcbiAgICAgIGZ1bmNOYW1lID0gZnVuY05hbWUgKyAnX1QnO1xuICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9IG5ldyBHbHNsTGliUm91dGluZSh0aGlzLmdldFZhbHVlRnJvbVNpbmdsZShuYW1lLCByYW5rLCBsYXlvdXQud2lkdGgsIGxheW91dC5oZWlnaHQsIHRydWUpLCBbXG4gICAgICAgIGBzaGFwZVV0aWxzLmluZGljZXNUb09mZnNldCR7ZnVuY05hbWV9YCxcbiAgICAgICAgJ2Nvb3JkaW5hdGVzLm9mZnNldFRvQ29vcmRzJyxcbiAgICAgICAgJ2ZyYWdjb2xvci5nZXRDb2xvckFzRmxvYXQnLFxuICAgICAgXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogUHJvZHVjZXMgb25lIHZhbHVlIGdldHRlciBmdW5jdGlvbiBmb3IgdGhlIG5hbWUgYW5kIHJhbmsgZ2l2ZW5cbiAgICogSWYgYSB0cmFuc3Bvc2UgaXMgc2V0IHByb3BlciBvZmZzZXRUb0Nvb3JkcyBtYXBwaW5nIHdpbGwgYmUgdXNlZFxuICAgKiBAcGFyYW0gbmFtZSBuYW1lIG9mIHRoZSBmdW5jdGlvblxuICAgKiBAcGFyYW0gcmFuayByYW5rIG9mIHRoZSBpbnB1dFxuICAgKiBAcGFyYW0gdHJhbnNwb3NlIHdoZXRoZXIgb3Igbm90IHNob3VsZCBnZW5lcmF0ZSBhIHRyYW5zcG9zZSB2YXJpYXRpb25cbiAgICovXG4gIHByb3RlY3RlZCBnZXRWYWx1ZUZyb21TaW5nbGUoXG4gICAgdmFyTmFtZTogc3RyaW5nLFxuICAgIHJhbms6IG51bWJlcixcbiAgICB3aWR0aDogbnVtYmVyLFxuICAgIGhlaWdodDogbnVtYmVyLFxuICAgIHRyYW5zcG9zZTogYm9vbGVhbixcbiAgKTogc3RyaW5nIHtcbiAgICBsZXQgbmFtZSA9IGBfJHt2YXJOYW1lfWA7XG4gICAgaWYgKHRyYW5zcG9zZSkge1xuICAgICAgbmFtZSA9IG5hbWUgKyAnX1QnO1xuICAgIH1cbiAgICBjb25zdCBnbHNsID0gZ2V0R2xzbCh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pO1xuICAgIHJldHVybiBgXG4gICAgICAgIGZsb2F0ICR7bmFtZX0oaW50IG1bJHtyYW5rfV0pIHtcbiAgICAgICAgICBpbnQgb2Zmc2V0ID0gaW5kaWNlc1RvT2Zmc2V0JHtuYW1lfShtKTtcbiAgICAgICAgICB2ZWMyIGNvb3JkcyA9IG9mZnNldFRvQ29vcmRzKG9mZnNldCwgJHt3aWR0aH0sICR7aGVpZ2h0fSk7XG4gICAgICAgICAgZmxvYXQgdmFsdWUgPSBnZXRDb2xvckFzRmxvYXQoJHtnbHNsLnRleHR1cmUyRH0oJHt2YXJOYW1lfSwgY29vcmRzKSk7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGA7XG4gIH1cblxuICAvKipcbiAgICogUHJvZHVjZXMgYSBwYWNrZWQgdmFsdWUgZ2V0dGVyIGZ1bmN0aW9uIGZvciB0aGUgbmFtZSBhbmQgcmFuayBnaXZlblxuICAgKiBJZiBhIHRyYW5zcG9zZSBpcyBzZXQgcHJvcGVyIG9mZnNldFRvQ29vcmRzIG1hcHBpbmcgd2lsbCBiZSB1c2VkXG4gICAqIEBwYXJhbSBuYW1lIG5hbWUgb2YgdGhlIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSByYW5rIHJhbmsgb2YgdGhlIGlucHV0XG4gICAqIEBwYXJhbSB0cmFuc3Bvc2Ugd2hldGhlciBvciBub3Qgc2hvdWxkIGdlbmVyYXRlIGEgdHJhbnNwb3NlIHZhcmlhdGlvblxuICAgKi9cbiAgcHJvdGVjdGVkIGdldFBhY2tlZFZhbHVlRnJvbShcbiAgICB2YXJOYW1lOiBzdHJpbmcsXG4gICAgcmFuazogbnVtYmVyLFxuICAgIHdpZHRoOiBudW1iZXIsXG4gICAgaGVpZ2h0OiBudW1iZXIsXG4gICAgdHJhbnNwb3NlOiBib29sZWFuLFxuICApOiBzdHJpbmcge1xuICAgIGxldCBuYW1lID0gYF8ke3Zhck5hbWV9X1BhY2tgO1xuICAgIGlmICh0cmFuc3Bvc2UpIHtcbiAgICAgIG5hbWUgPSBuYW1lICsgJ19UJztcbiAgICB9XG4gICAgY29uc3QgZ2xzbCA9IGdldEdsc2wodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgICByZXR1cm4gYFxuICAgICAgICB2ZWM0ICR7bmFtZX0oaW50IG1bJHtyYW5rfV0pIHtcbiAgICAgICAgICBpbnQgb2Zmc2V0ID0gaW5kaWNlc1RvT2Zmc2V0XyR7dmFyTmFtZX0obSk7XG4gICAgICAgICAgdmVjMiBjb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhvZmZzZXQsICR7d2lkdGh9LCAke2hlaWdodH0pO1xuICAgICAgICAgIHJldHVybiAke2dsc2wudGV4dHVyZTJEfSgke3Zhck5hbWV9LCBjb29yZHMpO1xuICAgICAgICB9XG4gICAgICAgIGA7XG4gIH1cbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgR2xzbENvbnRleHQsIEdsc2xMaWIsIEdsc2xMaWJSb3V0aW5lIH0gZnJvbSAnLi9nbHNsLWRlZmluaXRpb25zJztcblxuLyoqXG4gKiBUaGlzIEdMU0wgbGlicmFyeSBoYW5kbGVzIHJvdXRpbmVzIGNvbnZlcnRpbmdcbiAqIGZsb2F0MzIgdG8vZnJvbSBVbnNpZ25lZCBieXRlIG9yIGZsb2F0IDE2XG4gKi9cbmV4cG9ydCBjbGFzcyBFbmNvZGluZ0dsc2xMaWIgZXh0ZW5kcyBHbHNsTGliIHtcbiAgY29uc3RydWN0b3IoY29udGV4dDogR2xzbENvbnRleHQpIHtcbiAgICBzdXBlcihjb250ZXh0KTtcbiAgfVxuICBnZXRGdW5jdGlvbnMoKTogeyBbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmUgfSB7XG4gICAgcmV0dXJuIHsgLi4udGhpcy5lbmNvZGVGbG9hdDMyKCksIC4uLnRoaXMuZGVjb2RlRmxvYXQzMigpIH07XG4gIH1cbiAgZ2V0Q3VzdG9tVHlwZXMoKTogeyBbbmFtZTogc3RyaW5nXTogc3RyaW5nIH0ge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICBwcm90ZWN0ZWQgZW5jb2RlRmxvYXQzMigpOiB7IFtuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZSB9IHtcbiAgICByZXR1cm4ge1xuICAgICAgZW5jb2RlOiBuZXcgR2xzbExpYlJvdXRpbmUoYGhpZ2hwIHZlYzQgZW5jb2RlKGhpZ2hwIGZsb2F0IGYpIHtcbiAgICAgICAgcmV0dXJuIHZlYzQoZiwgMC4wLCAwLjAsIDAuMCk7XG4gICAgICB9XG4gICAgICAgIGApLFxuICAgIH07XG4gIH1cbiAgcHJvdGVjdGVkIGRlY29kZUZsb2F0MzIoKTogeyBbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmUgfSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRlY29kZTogbmV3IEdsc2xMaWJSb3V0aW5lKGBoaWdocCBmbG9hdCBkZWNvZGUoaGlnaHAgdmVjNCByZ2JhKSB7XG4gICAgICAgIHJldHVybiByZ2JhLnI7XG4gICAgICB9XG4gICAgICAgIGApLFxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIHJldHVybnMgdGhlIHJvdXRpbmUgdG8gZW5jb2RlIGVuY29kZSBhIDMyYml0IGZsb2F0IHRvIGEgdmVjNCAob2YgdW5zaWduZWQgYnl0ZXMpXG4gICAqIEBjcmVkaXQ6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzcwNTk5NjIvaG93LWRvLWktY29udmVydC1hLXZlYzQtcmdiYS12YWx1ZS10by1hLWZsb2F0XG4gICAqL1xuICBwcm90ZWN0ZWQgZW5jb2RlVWludDgoKTogeyBbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmUgfSB7XG4gICAgY29uc3QgZW5kaWFubmVzcyA9IEVuY29kaW5nR2xzbExpYi5pc0xpdHRsZUVuZGlhbigpID8gJ3JnYmEucmdiYT1yZ2JhLmFiZ3I7JyA6ICcnO1xuICAgIHJldHVybiB7XG4gICAgICBlbmNvZGU6IG5ldyBHbHNsTGliUm91dGluZShgXG4gICAgICBoaWdocCB2ZWM0IGVuY29kZShoaWdocCBmbG9hdCBmKSB7XG4gICAgICAgIGhpZ2hwIGZsb2F0IEYgPSBhYnMoZik7XG4gICAgICAgIGhpZ2hwIGZsb2F0IFNpZ24gPSBzdGVwKDAuMCwtZik7XG4gICAgICAgIGhpZ2hwIGZsb2F0IEV4cG9uZW50ID0gZmxvb3IobG9nMihGKSk7XG4gICAgICAgIGhpZ2hwIGZsb2F0IE1hbnRpc3NhID0gKGV4cDIoLSBFeHBvbmVudCkgKiBGKTtcbiAgICAgICAgRXhwb25lbnQgPSBmbG9vcihsb2cyKEYpICsgMTI3LjApICsgZmxvb3IobG9nMihNYW50aXNzYSkpO1xuICAgICAgICBoaWdocCB2ZWM0IHJnYmE7XG4gICAgICAgIHJnYmFbMF0gPSAxMjguMCAqIFNpZ24gICsgZmxvb3IoRXhwb25lbnQqZXhwMigtMS4wKSk7XG4gICAgICAgIHJnYmFbMV0gPSAxMjguMCAqIG1vZChFeHBvbmVudCwyLjApICsgbW9kKGZsb29yKE1hbnRpc3NhKjEyOC4wKSwxMjguMCk7XG4gICAgICAgIHJnYmFbMl0gPSBmbG9vcihtb2QoZmxvb3IoTWFudGlzc2EqZXhwMigyMy4wIC04LjApKSxleHAyKDguMCkpKTtcbiAgICAgICAgcmdiYVszXSA9IGZsb29yKGV4cDIoMjMuMCkqbW9kKE1hbnRpc3NhLGV4cDIoLTE1LjApKSk7XG4gICAgICAgICR7ZW5kaWFubmVzc31cbiAgICAgICAgcmdiYSA9IHJnYmEgLyAyNTUuMDsgLy8gdmFsdWVzIG5lZWQgdG8gYmUgbm9ybWFsaXplZCB0byBbMCwxXVxuICAgICAgICByZXR1cm4gcmdiYTtcbiAgICB9XG4gICAgICAgIGApLFxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIHJldHVybnMgdGhlIHJvdXRpbmUgdG8gZW5jb2RlIGEgdmVjNCBvZiB1bnNpZ25lZCBieXRlcyB0byBmbG9hdDMyXG4gICAqIEBjcmVkaXQ6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzcwNTk5NjIvaG93LWRvLWktY29udmVydC1hLXZlYzQtcmdiYS12YWx1ZS10by1hLWZsb2F0XG4gICAqL1xuICBwcm90ZWN0ZWQgZGVjb2RlVWludDgoKTogeyBbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmUgfSB7XG4gICAgY29uc3QgZW5kaWFubmVzcyA9IEVuY29kaW5nR2xzbExpYi5pc0xpdHRsZUVuZGlhbigpID8gJ3JnYmEucmdiYT1yZ2JhLmFiZ3I7JyA6ICcnO1xuICAgIHJldHVybiB7XG4gICAgICBkZWNvZGU6IG5ldyBHbHNsTGliUm91dGluZShgXG4gICAgICAgIGhpZ2hwIGZsb2F0IGRlY29kZShoaWdocCB2ZWM0IHJnYmEpIHtcbiAgICAgICAgICByZ2JhID0gcmdiYSAqIDI1NS4wOyAvLyB2YWx1ZXMgbmVlZCB0byBiZSBkZS1ub3JtYWxpemVkIGZyb20gWzAsMV0gdG8gWzAsMjU1XVxuICAgICAgICAgICR7ZW5kaWFubmVzc31cbiAgICAgICAgICBoaWdocCBmbG9hdCBTaWduID0gMS4wIC0gc3RlcCgxMjguMCxyZ2JhWzBdKSoyLjA7XG4gICAgICAgICAgaGlnaHAgZmxvYXQgRXhwb25lbnQgPSAyLjAgKiBtb2QocmdiYVswXSwxMjguMCkgKyBzdGVwKDEyOC4wLHJnYmFbMV0pIC0gMTI3LjA7XG4gICAgICAgICAgaGlnaHAgZmxvYXQgTWFudGlzc2EgPSBtb2QocmdiYVsxXSwxMjguMCkqNjU1MzYuMCArIHJnYmFbMl0qMjU2LjAgK3JnYmFbM10gKyBmbG9hdCgweDgwMDAwMCk7XG4gICAgICAgICAgaGlnaHAgZmxvYXQgUmVzdWx0ID0gIFNpZ24gKiBleHAyKEV4cG9uZW50KSAqIChNYW50aXNzYSAqIGV4cDIoLTIzLjAgKSk7XG4gICAgICAgICAgcmV0dXJuIFJlc3VsdDtcbiAgICAgIH1cbiAgICAgICAgYCksXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogRGV0ZXJtaW5lcyBpZiB0aGUgbWFjaGluZSBpcyBsaXR0bGUgZW5kaWFuIG9yIG5vdFxuICAgKiBAY3JlZGl0OiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9Ub29UYWxsTmF0ZS80NzUwOTUzXG4gICAqL1xuICBzdGF0aWMgaXNMaXR0bGVFbmRpYW4oKTogYm9vbGVhbiB7XG4gICAgY29uc3QgYiA9IG5ldyBBcnJheUJ1ZmZlcig0KTtcbiAgICBjb25zdCBhID0gbmV3IFVpbnQzMkFycmF5KGIpO1xuICAgIGNvbnN0IGMgPSBuZXcgVWludDhBcnJheShiKTtcbiAgICBhWzBdID0gMHhkZWFkYmVlZjtcbiAgICBpZiAoY1swXSA9PT0gMHhlZikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChjWzBdID09PSAweGRlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBlbmRpYW5uZXNzJyk7XG4gIH1cbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgR2xzbENvbnRleHQsIEdsc2xMaWIsIEdsc2xMaWJSb3V0aW5lIH0gZnJvbSAnLi9nbHNsLWRlZmluaXRpb25zJztcbmltcG9ydCB7IGdldEdsc2wgfSBmcm9tICcuL2dsc2wtc291cmNlJztcblxuLyoqXG4gKiBUaGlzIEdMU0wgbGlicmFyeSBoYW5kbGVzIHJvdXRpbmVzIGFyb3VuZCByZWFkaW5nIGEgdGV4bGV0IGFuZCB3cml0aW5nIHRvIGl0XG4gKiBSZWFkaW5nIGFuZCB3cml0aW5nIGNvdWxkIGJlIG1vcmUgdGhhbiBqdXN0IGRlYWxpbmcgd2l0aCBvbmUgY2hhbm5lbFxuICogSXQgbWF5IHJlcXVpcmUgZW5jb2RpbmcvZGVjb2RpbmcgdG8vZnJvbSA0IGNoYW5uZWxzIGludG8gb25lXG4gKi9cbmV4cG9ydCBjbGFzcyBGcmFnQ29sb3JHbHNsTGliIGV4dGVuZHMgR2xzbExpYiB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQ6IEdsc2xDb250ZXh0KSB7XG4gICAgc3VwZXIoY29udGV4dCk7XG4gIH1cbiAgZ2V0RnVuY3Rpb25zKCk6IHsgW25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lIH0ge1xuICAgIHJldHVybiB7IC4uLnRoaXMuc2V0RnJhZ0NvbG9yKCksIC4uLnRoaXMuZ2V0Q29sb3JBc0Zsb2F0KCkgfTtcbiAgfVxuICBnZXRDdXN0b21UeXBlcygpOiB7IFtuYW1lOiBzdHJpbmddOiBzdHJpbmcgfSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIHByb3RlY3RlZCBzZXRGcmFnQ29sb3IoKTogeyBbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmUgfSB7XG4gICAgY29uc3QgZ2xzbCA9IGdldEdsc2wodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0RnJhZ0NvbG9yOiBuZXcgR2xzbExpYlJvdXRpbmUoXG4gICAgICAgIGBcbiAgICAgICAgdm9pZCBzZXRGcmFnQ29sb3IoZmxvYXQgdmFsdWUpIHtcbiAgICAgICAgICAgICR7Z2xzbC5vdXRwdXR9ID0gZW5jb2RlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBgLFxuICAgICAgICBbJ2VuY29kaW5nLmVuY29kZSddLFxuICAgICAgKSxcbiAgICB9O1xuICB9XG4gIHByb3RlY3RlZCBnZXRDb2xvckFzRmxvYXQoKTogeyBbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmUgfSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdldENvbG9yQXNGbG9hdDogbmV3IEdsc2xMaWJSb3V0aW5lKFxuICAgICAgICBgXG4gICAgICAgIGZsb2F0IGdldENvbG9yQXNGbG9hdCh2ZWM0IGNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVjb2RlKGNvbG9yKTtcbiAgICAgICAgfVxuICAgICAgICBgLFxuICAgICAgICBbJ2VuY29kaW5nLmRlY29kZSddLFxuICAgICAgKSxcbiAgICB9O1xuICB9XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEdsc2xDb250ZXh0LCBHbHNsTGliLCBHbHNsTGliUm91dGluZSB9IGZyb20gJy4vZ2xzbC1kZWZpbml0aW9ucyc7XG5cbi8qKlxuICogR0xTTCBMaWJyYXJ5IHJlc3BvbnNpYmxlIGZvciBkYXRhIHR5cGVzIGFuZCByb3V0aW5lcyBmb3IgbWFuaXB1bGF0aW5nXG4gKiBjb29yZGluYXRlcyBhbmQgbWFwcGluZyB0by9mcm9tIHRlbnNvciBpbmRpY2VzXG4gKi9cbmV4cG9ydCBjbGFzcyBTaGFwZVV0aWxzR2xzbExpYiBleHRlbmRzIEdsc2xMaWIge1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0OiBHbHNsQ29udGV4dCkge1xuICAgIHN1cGVyKGNvbnRleHQpO1xuICB9XG4gIGdldEZ1bmN0aW9ucygpOiB7IFtuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZSB9IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4udGhpcy5iY2FzdEluZGV4KCksXG4gICAgICAuLi50aGlzLmJjYXN0TWF0bXVsSW5kZXgoKSxcbiAgICAgIC4uLnRoaXMub2Zmc2V0VG9JbmRpY2VzKCksXG4gICAgICAuLi50aGlzLmluZGljZXNUb09mZnNldCgpLFxuICAgICAgLi4udGhpcy5pbmNyZW1lbnRJbmRpY2VzKCksXG4gICAgfTtcbiAgfVxuICBnZXRDdXN0b21UeXBlcygpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgcHJvdGVjdGVkIGJjYXN0SW5kZXgoKTogeyBbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmUgfSB7XG4gICAgY29uc3Qgb3V0cHV0UmFuayA9IHRoaXMuY29udGV4dC5vdXRwdXRUZXh0dXJlTGF5b3V0LnNoYXBlLmxlbmd0aDtcbiAgICBjb25zdCByZXN1bHQ6IHsgW25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lIH0gPSB7fTtcbiAgICB0aGlzLmNvbnRleHQucHJvZ3JhbUluZm8uaW5wdXROYW1lcy5mb3JFYWNoKChuYW1lLCBpKSA9PiB7XG4gICAgICBjb25zdCBzaGFwZSA9IHRoaXMuY29udGV4dC5pbnB1dFRleHR1cmVMYXlvdXRzW2ldLnVucGFja2VkU2hhcGU7XG4gICAgICBpZiAoc2hhcGUubGVuZ3RoIDw9IG91dHB1dFJhbmspIHtcbiAgICAgICAgY29uc3QgcmFuayA9IHNoYXBlLmxlbmd0aDtcbiAgICAgICAgY29uc3QgZGltT2Zmc2V0ID0gb3V0cHV0UmFuayAtIHJhbms7XG4gICAgICAgIGNvbnN0IGZ1bmNOYW1lID0gYGJjYXN0SW5kaWNlc18ke25hbWV9YDtcbiAgICAgICAgbGV0IGJsb2NrID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuazsgKytpKSB7XG4gICAgICAgICAgYmxvY2sgKz0gYFxuICAgICAgICAgIHJlYWxJbmRpY2VzWyR7aX1dID0gaW50KCBtb2QoZmxvYXQoYmNhc3RlZEluZGljZXNbJHtkaW1PZmZzZXQgKyBpfV0pLCAke3NoYXBlW2ldfS4wKSApO1xuICAgICAgICAgIGA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYm9keSA9IGBcbiAgICAgICAgdm9pZCAke2Z1bmNOYW1lfSAoaW50IGJjYXN0ZWRJbmRpY2VzWyR7b3V0cHV0UmFua31dLCBvdXQgaW50IHJlYWxJbmRpY2VzWyR7cmFua31dKSB7XG4gICAgICAgICAgJHtibG9ja31cbiAgICAgICAgfVxuICAgICAgICBgO1xuICAgICAgICByZXN1bHRbZnVuY05hbWVdID0gbmV3IEdsc2xMaWJSb3V0aW5lKGJvZHkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcHJvdGVjdGVkIGJjYXN0TWF0bXVsSW5kZXgoKTogeyBbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmUgfSB7XG4gICAgY29uc3Qgb3V0cHV0UmFuayA9IHRoaXMuY29udGV4dC5vdXRwdXRUZXh0dXJlTGF5b3V0LnNoYXBlLmxlbmd0aDtcbiAgICBjb25zdCByZXN1bHQ6IHsgW25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lIH0gPSB7fTtcbiAgICB0aGlzLmNvbnRleHQucHJvZ3JhbUluZm8uaW5wdXROYW1lcy5mb3JFYWNoKChuYW1lLCBpKSA9PiB7XG4gICAgICBjb25zdCBzaGFwZSA9IHRoaXMuY29udGV4dC5pbnB1dFRleHR1cmVMYXlvdXRzW2ldLnNoYXBlO1xuICAgICAgaWYgKCEoc2hhcGUubGVuZ3RoIDwgMiB8fCBzaGFwZS5sZW5ndGggPiBvdXRwdXRSYW5rKSkge1xuICAgICAgICBjb25zdCByYW5rID0gc2hhcGUubGVuZ3RoO1xuICAgICAgICBjb25zdCBkaW1PZmZzZXQgPSBvdXRwdXRSYW5rIC0gcmFuaztcbiAgICAgICAgY29uc3QgZnVuY05hbWUgPSBgYmNhc3RNYXRtdWxJbmRpY2VzXyR7bmFtZX1gO1xuICAgICAgICBsZXQgYmxvY2sgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5rIC0gMjsgKytpKSB7XG4gICAgICAgICAgYmxvY2sgKz0gYFxuICAgICAgICAgIHJlYWxJbmRpY2VzWyR7aX1dID0gaW50KCBtb2QoZmxvYXQoYmNhc3RlZEluZGljZXNbJHtkaW1PZmZzZXQgKyBpfV0pLCAke3NoYXBlW2ldfS4wKSApO1xuICAgICAgICAgIGA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYm9keSA9IGBcbiAgICAgICAgdm9pZCAke2Z1bmNOYW1lfShpbnQgYmNhc3RlZEluZGljZXNbJHtvdXRwdXRSYW5rfV0sIG91dCBpbnQgcmVhbEluZGljZXNbJHtyYW5rfV0pIHtcbiAgICAgICAgICAke2Jsb2NrfVxuICAgICAgICAgIHJlYWxJbmRpY2VzWyR7cmFuayAtIDF9XSA9IGJjYXN0ZWRJbmRpY2VzWyR7b3V0cHV0UmFuayAtIDF9XTtcbiAgICAgICAgICByZWFsSW5kaWNlc1ske3JhbmsgLSAyfV0gPSBiY2FzdGVkSW5kaWNlc1ske291dHB1dFJhbmsgLSAyfV07XG4gICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9IG5ldyBHbHNsTGliUm91dGluZShib2R5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHByb3RlY3RlZCBpbmRpY2VzVG9PZmZzZXQoKTogeyBbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmUgfSB7XG4gICAgY29uc3QgcmVzdWx0OiB7IFtuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZSB9ID0ge307XG4gICAgdGhpcy5jb250ZXh0LnByb2dyYW1JbmZvLmlucHV0TmFtZXMuZm9yRWFjaCgobmFtZSwgaSkgPT4ge1xuICAgICAgY29uc3Qgc2hhcGUgPSB0aGlzLmNvbnRleHQuaW5wdXRUZXh0dXJlTGF5b3V0c1tpXS5zaGFwZTtcbiAgICAgIGNvbnN0IHN0cmlkZXMgPSB0aGlzLmNvbnRleHQuaW5wdXRUZXh0dXJlTGF5b3V0c1tpXS5zdHJpZGVzO1xuICAgICAgY29uc3QgcmFuayA9IHNoYXBlLmxlbmd0aDtcbiAgICAgIGxldCBmdW5jTmFtZSA9IGBpbmRpY2VzVG9PZmZzZXRfJHtuYW1lfWA7XG4gICAgICByZXN1bHRbZnVuY05hbWVdID0gbmV3IEdsc2xMaWJSb3V0aW5lKFNoYXBlVXRpbHNHbHNsTGliLmluZGV4VG9PZmZzZXRTaW5nbGUoZnVuY05hbWUsIHJhbmssIHN0cmlkZXMpKTtcbiAgICAgIGZ1bmNOYW1lID0gYGluZGljZXNUb09mZnNldF8ke25hbWV9X1RgO1xuICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9IG5ldyBHbHNsTGliUm91dGluZShcbiAgICAgICAgU2hhcGVVdGlsc0dsc2xMaWIuaW5kZXhUb09mZnNldFNpbmdsZShmdW5jTmFtZSwgcmFuaywgc3RyaWRlcy5zbGljZSgpLnJldmVyc2UoKSksXG4gICAgICApO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgc3RhdGljIGluZGV4VG9PZmZzZXRTaW5nbGUobmFtZTogc3RyaW5nLCByYW5rOiBudW1iZXIsIHN0cmlkZXM6IHJlYWRvbmx5IG51bWJlcltdKTogc3RyaW5nIHtcbiAgICBsZXQgYmxvY2sgPSAnJztcbiAgICBmb3IgKGxldCBpID0gcmFuayAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBibG9jayArPSBgXG4gICAgICAgIG9mZnNldCArPSBpbmRpY2VzWyR7aX1dICogJHtzdHJpZGVzW2ldfTtcbiAgICAgICAgYDtcbiAgICB9XG4gICAgcmV0dXJuIGBcbiAgICAgIGludCAke25hbWV9KGludCBpbmRpY2VzWyR7cmFua31dKSB7XG4gICAgICAgIGludCBvZmZzZXQgPSAwO1xuICAgICAgICAke2Jsb2NrfVxuICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgICAgfVxuICAgICAgYDtcbiAgfVxuICBwcm90ZWN0ZWQgb2Zmc2V0VG9JbmRpY2VzKCk6IHsgW25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lIH0ge1xuICAgIGNvbnN0IHJlc3VsdDogeyBbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmUgfSA9IHt9O1xuICAgIHRoaXMuY29udGV4dC5wcm9ncmFtSW5mby5pbnB1dE5hbWVzLmZvckVhY2goKG5hbWUsIGkpID0+IHtcbiAgICAgIGNvbnN0IHNoYXBlID0gdGhpcy5jb250ZXh0LmlucHV0VGV4dHVyZUxheW91dHNbaV0uc2hhcGU7XG4gICAgICBjb25zdCBzdHJpZGVzID0gdGhpcy5jb250ZXh0LmlucHV0VGV4dHVyZUxheW91dHNbaV0uc3RyaWRlcztcbiAgICAgIGNvbnN0IHJhbmsgPSBzaGFwZS5sZW5ndGg7XG4gICAgICBsZXQgZnVuY05hbWUgPSBgb2Zmc2V0VG9JbmRpY2VzXyR7bmFtZX1gO1xuICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9IG5ldyBHbHNsTGliUm91dGluZShTaGFwZVV0aWxzR2xzbExpYi5vZmZzZXRUb0luZGljZXNTaW5nbGUoZnVuY05hbWUsIHJhbmssIHN0cmlkZXMpKTtcbiAgICAgIGZ1bmNOYW1lID0gYG9mZnNldFRvSW5kaWNlc18ke25hbWV9X1RgO1xuICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9IG5ldyBHbHNsTGliUm91dGluZShcbiAgICAgICAgU2hhcGVVdGlsc0dsc2xMaWIub2Zmc2V0VG9JbmRpY2VzU2luZ2xlKGZ1bmNOYW1lLCByYW5rLCBzdHJpZGVzLnNsaWNlKCkucmV2ZXJzZSgpKSxcbiAgICAgICk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBzdGF0aWMgb2Zmc2V0VG9JbmRpY2VzU2luZ2xlKG5hbWU6IHN0cmluZywgcmFuazogbnVtYmVyLCBzdHJpZGVzOiByZWFkb25seSBudW1iZXJbXSk6IHN0cmluZyB7XG4gICAgY29uc3Qgc3RyaWRlc0Jsb2NrID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5rIC0gMTsgKytpKSB7XG4gICAgICBzdHJpZGVzQmxvY2sucHVzaChgXG4gICAgICBpbmRpY2VzWyR7aX1dID0gb2Zmc2V0IC8gJHtzdHJpZGVzW2ldfTtgKTtcbiAgICAgIHN0cmlkZXNCbG9jay5wdXNoKGBcbiAgICAgICAgb2Zmc2V0IC09IGluZGljZXNbJHtpfV0gKiAke3N0cmlkZXNbaV19O2ApO1xuICAgIH1cbiAgICBzdHJpZGVzQmxvY2sucHVzaChgXG4gICAgICBpbmRpY2VzWyR7cmFuayAtIDF9XSA9IG9mZnNldDtgKTtcbiAgICByZXR1cm4gYFxuICAgICAgdm9pZCAke25hbWV9KGludCBvZmZzZXQsIG91dCBpbnQgaW5kaWNlc1ske3Jhbmt9XSkge1xuICAgICAgICAke3N0cmlkZXNCbG9jay5qb2luKCcnKX1cbiAgICAgIH1cbiAgICAgIGA7XG4gIH1cbiAgcHJvdGVjdGVkIGluY3JlbWVudEluZGljZXMoKTogeyBbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmUgfSB7XG4gICAgY29uc3QgcmVzdWx0OiB7IFtuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZSB9ID0ge307XG4gICAgdGhpcy5jb250ZXh0LnByb2dyYW1JbmZvLmlucHV0TmFtZXMuZm9yRWFjaCgobmFtZSwgaSkgPT4ge1xuICAgICAgY29uc3Qgc2hhcGUgPSB0aGlzLmNvbnRleHQuaW5wdXRUZXh0dXJlTGF5b3V0c1tpXS5zaGFwZTtcbiAgICAgIGNvbnN0IHJhbmsgPSBzaGFwZS5sZW5ndGg7XG4gICAgICBjb25zdCBmdW5jTmFtZSA9IGBpbmNyZW1lbnRJbmRpY2VzXyR7bmFtZX1gO1xuICAgICAgbGV0IHNoYXBlSW5pdCA9ICcnO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5rOyArK2kpIHtcbiAgICAgICAgc2hhcGVJbml0ICs9IGBcbiAgICAgICAgc2hhcGVbJHtpfV0gPSAke3NoYXBlW2ldfTtgO1xuICAgICAgfVxuICAgICAgY29uc3QgYm9keSA9IGBcbiAgICAgICAgdm9pZCAke2Z1bmNOYW1lfShpbnQgYXhpcywgb3V0IGludCBpbmRpY2VzWyR7cmFua31dKSB7XG4gICAgICAgICAgaW50IHNoYXBlWyR7cmFua31dO1xuICAgICAgICAgICR7c2hhcGVJbml0fTtcbiAgICAgICAgICBmb3IoaW50IGkgPSAke3Jhbmt9IC0xIDsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIGlmKGkgPiBheGlzKSBjb250aW51ZTtcbiAgICAgICAgICAgIGluZGljZXNbaV0gKz0gMTtcbiAgICAgICAgICAgIGlmKGluZGljZXNbaV0gPCBzaGFwZVtpXSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZGljZXNbaV0gPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBgO1xuICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9IG5ldyBHbHNsTGliUm91dGluZShib2R5KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEdsc2xDb250ZXh0LCBHbHNsTGliLCBHbHNsTGliUm91dGluZSB9IGZyb20gJy4vZ2xzbC1kZWZpbml0aW9ucyc7XG5cbi8qKlxuICogR0xTTCBMaWJyYXJ5IHJlc3BvbnNpYmxlIGZvciB2ZWMgcm91dGluZXNcbiAqIFZlYyBpcyBhbiB2YXJpYmxlIGxlbmd0aCBpbnQgYXJyYXkuIFRoZSBsZW5ndGggaXMgZml4ZWQgYXQgdGhlIHRpbWUgb2ZcbiAqIGdlbmVyYXRpbmcgdGhlIGxpYnJhcnkgZnVuY3Rpb25zIGZyb20gdGhlIGRpbWVuc2lvbnMgb2YgdGhlIG91dHB1dC5cbiAqL1xuZXhwb3J0IGNsYXNzIFZlY0dsc2xMaWIgZXh0ZW5kcyBHbHNsTGliIHtcbiAgY29uc3RydWN0b3IoY29udGV4dDogR2xzbENvbnRleHQpIHtcbiAgICBzdXBlcihjb250ZXh0KTtcbiAgfVxuICBnZXRDdXN0b21UeXBlcygpOiB7IFtuYW1lOiBzdHJpbmddOiBzdHJpbmcgfSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIGdldEZ1bmN0aW9ucygpOiB7IFtuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZSB9IHtcbiAgICByZXR1cm4geyAuLi50aGlzLmJpbmFyeVZlY0Z1bmN0aW9ucygpLCAuLi50aGlzLmNvcHlWZWMoKSwgLi4udGhpcy5zZXRWZWNJdGVtKCksIC4uLnRoaXMuZ2V0VmVjSXRlbSgpIH07XG4gIH1cbiAgcHJvdGVjdGVkIGJpbmFyeVZlY0Z1bmN0aW9ucygpOiB7IFtuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZSB9IHtcbiAgICBjb25zdCBvdXRwdXRMYXlvdXQgPSB0aGlzLmNvbnRleHQub3V0cHV0VGV4dHVyZUxheW91dDtcbiAgICBjb25zdCByYW5rID0gb3V0cHV0TGF5b3V0LnNoYXBlLmxlbmd0aDtcbiAgICBjb25zdCBuYW1lT3A6IHsgW25hbWU6IHN0cmluZ106IHN0cmluZyB9ID0geyBhZGQ6ICcrPScsIHN1YjogJy09JywgbXVsOiAnKj0nLCBkaXY6ICcvPScgfTtcbiAgICBjb25zdCByZXN1bHQ6IHsgW25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lIH0gPSB7fTtcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gbmFtZU9wKSB7XG4gICAgICBjb25zdCBmbmFtZSA9IGAke25hbWV9VmVjYDtcbiAgICAgIGxldCBhc3NpZ25tZW50QmxvY2sgPSAnJztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuazsgKytpKSB7XG4gICAgICAgIGFzc2lnbm1lbnRCbG9jayArPSBgXG4gICAgICAgICAgZGVzdFske2l9XSAke25hbWVPcFtuYW1lXX0gc3JjWyR7aX1dO1xuICAgICAgICAgIGA7XG4gICAgICB9XG4gICAgICBjb25zdCBib2R5ID0gYFxuICAgICAgICB2b2lkICR7Zm5hbWV9KGludCBzcmNbJHtyYW5rfV0sIG91dCBpbnQgZGVzdFske3Jhbmt9XSkge1xuICAgICAgICAgICR7YXNzaWdubWVudEJsb2NrfVxuICAgICAgICB9XG4gICAgICAgIGA7XG4gICAgICByZXN1bHRbZm5hbWVdID0gbmV3IEdsc2xMaWJSb3V0aW5lKGJvZHkpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcHJvdGVjdGVkIGNvcHlWZWMoKTogeyBbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmUgfSB7XG4gICAgY29uc3Qgb3V0cHV0TGF5b3V0ID0gdGhpcy5jb250ZXh0Lm91dHB1dFRleHR1cmVMYXlvdXQ7XG4gICAgY29uc3QgcmFuayA9IG91dHB1dExheW91dC5zaGFwZS5sZW5ndGg7XG4gICAgbGV0IGFzc2lnbm1lbnRCbG9jayA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuazsgKytpKSB7XG4gICAgICBhc3NpZ25tZW50QmxvY2sgKz0gYFxuICAgICAgICBkZXN0WyR7aX1dID0gc3JjWyR7aX1dO1xuICAgICAgICBgO1xuICAgIH1cbiAgICBjb25zdCBib2R5ID0gYFxuICAgICAgdm9pZCBjb3B5VmVjKGludCBzcmNbJHtyYW5rfV0sIG91dCBpbnQgZGVzdFske3Jhbmt9XSkge1xuICAgICAgICAke2Fzc2lnbm1lbnRCbG9ja31cbiAgICAgIH1cbiAgICAgIGA7XG4gICAgcmV0dXJuIHsgY29weVZlYzogbmV3IEdsc2xMaWJSb3V0aW5lKGJvZHkpIH07XG4gIH1cblxuICBwcm90ZWN0ZWQgc2V0VmVjSXRlbSgpOiB7IFtuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZSB9IHtcbiAgICBjb25zdCBvdXRwdXRMYXlvdXQgPSB0aGlzLmNvbnRleHQub3V0cHV0VGV4dHVyZUxheW91dDtcbiAgICBjb25zdCByYW5rID0gb3V0cHV0TGF5b3V0LnNoYXBlLmxlbmd0aDtcbiAgICBsZXQgYmxvY2sgPSBgXG4gICAgICAgIGlmKGluZGV4IDwgMClcbiAgICAgICAgICAgIGluZGV4ID0ke3Jhbmt9ICsgaW5kZXg7XG4gICAgICAgIGlmIChpbmRleCA9PSAwKVxuICAgICAgICAgICAgbVswXSA9IHZhbHVlO1xuICAgICAgICBgO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcmFuayAtIDE7ICsraSkge1xuICAgICAgYmxvY2sgKz0gYFxuICAgICAgICBlbHNlIGlmIChpbmRleCA9PSAke2l9KVxuICAgICAgICAgICAgbVske2l9XSA9IHZhbHVlO1xuICAgICAgICAgICAgYDtcbiAgICB9XG4gICAgYmxvY2sgKz0gYFxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBtWyR7cmFuayAtIDF9XSA9IHZhbHVlO1xuICAgICAgICBgO1xuICAgIGNvbnN0IGJvZHkgPSBgXG4gICAgICB2b2lkIHNldFZlY0l0ZW0ob3V0IGludCBtWyR7cmFua31dLCBpbnQgaW5kZXgsIGludCB2YWx1ZSkge1xuICAgICAgICAke2Jsb2NrfVxuICAgICAgfVxuICAgICAgICBgO1xuICAgIHJldHVybiB7IHNldFZlY0l0ZW06IG5ldyBHbHNsTGliUm91dGluZShib2R5KSB9O1xuICB9XG4gIHByb3RlY3RlZCBnZXRWZWNJdGVtKCk6IHsgW25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lIH0ge1xuICAgIGNvbnN0IG91dHB1dExheW91dCA9IHRoaXMuY29udGV4dC5vdXRwdXRUZXh0dXJlTGF5b3V0O1xuICAgIGNvbnN0IHJhbmsgPSBvdXRwdXRMYXlvdXQuc2hhcGUubGVuZ3RoO1xuICAgIGxldCBibG9jayA9IGBcbiAgICAgICAgaWYoaW5kZXggPCAwKVxuICAgICAgICAgICAgaW5kZXggPSAke3Jhbmt9ICsgaW5kZXg7XG4gICAgICAgIGlmIChpbmRleCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIG1bMF07XG4gICAgICBgO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcmFuayAtIDE7ICsraSkge1xuICAgICAgYmxvY2sgKz0gYFxuICAgICAgICBlbHNlIGlmIChpbmRleCA9PSAke2l9KVxuICAgICAgICAgICAgcmV0dXJuIG1bJHtpfV07XG4gICAgICBgO1xuICAgIH1cbiAgICBibG9jayArPSBgXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBtWyR7cmFuayAtIDF9XTtcbiAgICAgICAgYDtcbiAgICBjb25zdCBib2R5ID0gYFxuICAgICAgaW50IGdldFZlY0l0ZW0oaW50IG1bJHtyYW5rfV0sIGludCBpbmRleCkge1xuICAgICAgICAke2Jsb2NrfVxuICAgICAgfVxuICAgIGA7XG4gICAgcmV0dXJuIHsgZ2V0VmVjSXRlbTogbmV3IEdsc2xMaWJSb3V0aW5lKGJvZHkpIH07XG4gIH1cbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgQ29vcmRzR2xzbExpYiB9IGZyb20gJy4vZ2xzbC1jb29yZGluYXRlLWxpYic7XG5pbXBvcnQgeyBHbHNsQ29udGV4dCwgR2xzbExpYiB9IGZyb20gJy4vZ2xzbC1kZWZpbml0aW9ucyc7XG5pbXBvcnQgeyBFbmNvZGluZ0dsc2xMaWIgfSBmcm9tICcuL2dsc2wtZW5jb2RpbmctbGliJztcbmltcG9ydCB7IEZyYWdDb2xvckdsc2xMaWIgfSBmcm9tICcuL2dsc2wtZnJhZ2NvbG9yLWxpYic7XG5pbXBvcnQgeyBTaGFwZVV0aWxzR2xzbExpYiB9IGZyb20gJy4vZ2xzbC1zaGFwZS11dGlscy1saWInO1xuaW1wb3J0IHsgVmVjR2xzbExpYiB9IGZyb20gJy4vZ2xzbC12ZWMtbGliJztcblxuZXhwb3J0IGNvbnN0IGdsc2xSZWdpc3RyeTogeyBbbmFtZTogc3RyaW5nXTogbmV3IChjb250ZXh0OiBHbHNsQ29udGV4dCkgPT4gR2xzbExpYiB9ID0ge1xuICBlbmNvZGluZzogRW5jb2RpbmdHbHNsTGliLFxuICBmcmFnY29sb3I6IEZyYWdDb2xvckdsc2xMaWIsXG4gIHZlYzogVmVjR2xzbExpYixcbiAgc2hhcGVVdGlsczogU2hhcGVVdGlsc0dsc2xMaWIsXG4gIGNvb3JkaW5hdGVzOiBDb29yZHNHbHNsTGliLFxuICAvLyAgJ2FycmF5cyc6IEFycmF5R2xzbFNMaWJcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEdsc2xDb250ZXh0LCBHbHNsTGliLCBHbHNsTGliUm91dGluZU5vZGUsIFRvcG9sb2dpY2FsU29ydEdsc2xSb3V0aW5lcyB9IGZyb20gJy4vZ2xzbC1kZWZpbml0aW9ucyc7XG5pbXBvcnQgeyByZXBsYWNlSW5saW5lcyB9IGZyb20gJy4vZ2xzbC1mdW5jdGlvbi1pbmxpbmVyJztcbmltcG9ydCB7IGdsc2xSZWdpc3RyeSB9IGZyb20gJy4vZ2xzbC1yZWdpc3RlcmVkLWxpYnMnO1xuaW1wb3J0IHsgZ2V0RGVmYXVsdEZyYWdTaGFkZXJNYWluLCBnZXRGcmFnU2hhZGVyUHJlYW1ibGUgfSBmcm9tICcuL2dsc2wtc291cmNlJztcbmltcG9ydCB7IFByb2dyYW1JbmZvLCBUZXh0dXJlTGF5b3V0LCBWYXJpYWJsZUluZm8gfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IFdlYkdMQ29udGV4dCB9IGZyb20gJy4vd2ViZ2wtY29udGV4dCc7XG5cbi8qKlxuICogUHJlcHJvY2Vzc29yIGZvciB0aGUgYWRkaXRpb25zIHRvIHRoZSBHTFNMIGxhbmd1YWdlXG4gKiBJdCBkZWFscyB3aXRoOlxuICogIEBpbmNsdWRlIGRpcmVjdGl2ZXNcbiAqICBAaW5saW5lXG4gKiAgTG9vcCB1bnJvbGxpbmcgKG5vdCBpbXBsZW1lbnRlZClcbiAqICBNYWNybyByZXNvbHV0aW9uIChub3QgaW1wbGVtZW50ZWQpXG4gKi9cbmV4cG9ydCBjbGFzcyBHbHNsUHJlcHJvY2Vzc29yIHtcbiAgcmVhZG9ubHkgY29udGV4dDogR2xzbENvbnRleHQ7XG4gIHJlYWRvbmx5IGxpYnM6IHsgW25hbWU6IHN0cmluZ106IEdsc2xMaWIgfSA9IHt9O1xuICByZWFkb25seSBnbHNsTGliUm91dGluZURlcGVuZGVuY3lHcmFwaDogeyBbcm91dGluZU5hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lTm9kZSB9ID0ge307XG5cbiAgY29uc3RydWN0b3IoXG4gICAgZ2xDb250ZXh0OiBXZWJHTENvbnRleHQsXG4gICAgcHJvZ3JhbUluZm86IFByb2dyYW1JbmZvLFxuICAgIGlucHV0VGV4dHVyZUxheW91dHM6IFRleHR1cmVMYXlvdXRbXSxcbiAgICBvdXRwdXRUZXh0dXJlTGF5b3V0OiBUZXh0dXJlTGF5b3V0LFxuICApIHtcbiAgICB0aGlzLmNvbnRleHQgPSBuZXcgR2xzbENvbnRleHQoZ2xDb250ZXh0LCBwcm9ncmFtSW5mbywgaW5wdXRUZXh0dXJlTGF5b3V0cywgb3V0cHV0VGV4dHVyZUxheW91dCk7XG5cbiAgICAvLyBjb25zdHJ1Y3QgR2xzbExpYnNcbiAgICBPYmplY3Qua2V5cyhnbHNsUmVnaXN0cnkpLmZvckVhY2goKG5hbWU6IHN0cmluZykgPT4ge1xuICAgICAgY29uc3QgbGliID0gbmV3IGdsc2xSZWdpc3RyeVtuYW1lXSh0aGlzLmNvbnRleHQpO1xuICAgICAgdGhpcy5saWJzW25hbWVdID0gbGliO1xuICAgIH0pO1xuXG4gICAgLy8gY29uc3RydWN0IEdsc2xSb3V0aW5lRGVwZW5kZW5jeUdyYXBoXG4gICAgY29uc3QgbWFwID0gdGhpcy5nbHNsTGliUm91dGluZURlcGVuZGVuY3lHcmFwaDtcbiAgICBmb3IgKGNvbnN0IGxpYk5hbWUgaW4gdGhpcy5saWJzKSB7XG4gICAgICBjb25zdCBsaWIgPSB0aGlzLmxpYnNbbGliTmFtZV07XG4gICAgICBjb25zdCByb3V0aW5lc0luTGliID0gbGliLmdldEZ1bmN0aW9ucygpO1xuICAgICAgZm9yIChjb25zdCByb3V0aW5lIGluIHJvdXRpbmVzSW5MaWIpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gbGliTmFtZSArICcuJyArIHJvdXRpbmU7XG4gICAgICAgIGxldCBjdXJyZW50Tm9kZTogR2xzbExpYlJvdXRpbmVOb2RlO1xuICAgICAgICBpZiAobWFwW2tleV0pIHtcbiAgICAgICAgICBjdXJyZW50Tm9kZSA9IG1hcFtrZXldO1xuICAgICAgICAgIGN1cnJlbnROb2RlLnJvdXRpbmVCb2R5ID0gcm91dGluZXNJbkxpYltyb3V0aW5lXS5yb3V0aW5lQm9keTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50Tm9kZSA9IG5ldyBHbHNsTGliUm91dGluZU5vZGUoa2V5LCByb3V0aW5lc0luTGliW3JvdXRpbmVdLnJvdXRpbmVCb2R5KTtcbiAgICAgICAgICBtYXBba2V5XSA9IGN1cnJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlcGVuZGVuY2llcyA9IHJvdXRpbmVzSW5MaWJbcm91dGluZV0uZGVwZW5kZW5jaWVzO1xuICAgICAgICBpZiAoZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZXBlbmRlbmNpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmICghbWFwW2RlcGVuZGVuY2llc1tpXV0pIHtcbiAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5ldyBHbHNsTGliUm91dGluZU5vZGUoZGVwZW5kZW5jaWVzW2ldKTtcbiAgICAgICAgICAgICAgbWFwW2RlcGVuZGVuY2llc1tpXV0gPSBub2RlO1xuICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5hZGREZXBlbmRlbmN5KG5vZGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY3VycmVudE5vZGUuYWRkRGVwZW5kZW5jeShtYXBbZGVwZW5kZW5jaWVzW2ldXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJlcHJvY2VzcygpOiBzdHJpbmcge1xuICAgIGNvbnN0IHByb2dyYW1JbmZvID0gdGhpcy5jb250ZXh0LnByb2dyYW1JbmZvO1xuICAgIGxldCBzb3VyY2UgPSBwcm9ncmFtSW5mby5zaGFkZXJTb3VyY2U7XG5cbiAgICAvLyBhcHBlbmQgbWFpbigpIGZ1bmN0aW9uXG4gICAgaWYgKCF0aGlzLmNvbnRleHQucHJvZ3JhbUluZm8uaGFzTWFpbikge1xuICAgICAgc291cmNlID0gYCR7c291cmNlfVxuICAgICAgJHtnZXREZWZhdWx0RnJhZ1NoYWRlck1haW4odGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uLCB0aGlzLmNvbnRleHQub3V0cHV0VGV4dHVyZUxheW91dC5zaGFwZS5sZW5ndGgpfWA7XG4gICAgfVxuICAgIC8vIHJlcGxhY2UgaW5saW5lc1xuICAgIHNvdXJjZSA9IHJlcGxhY2VJbmxpbmVzKHNvdXJjZSk7XG5cbiAgICAvLyBjb25jYXQgZmluYWwgc291cmNlIHN0cmluZ1xuICAgIHJldHVybiBgJHtnZXRGcmFnU2hhZGVyUHJlYW1ibGUodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uKX1cbiAgICAke3RoaXMuZ2V0VW5pZm9ybXMocHJvZ3JhbUluZm8uaW5wdXROYW1lcywgcHJvZ3JhbUluZm8udmFyaWFibGVzKX1cbiAgICAke3RoaXMuZ2V0SW1wb3J0cyhzb3VyY2UpfVxuICAgICR7c291cmNlfWA7XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0SW1wb3J0cyhzY3JpcHQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3Qgcm91dGluZXNJbmNsdWRlZCA9IHRoaXMuc2VsZWN0R2xzbExpYlJvdXRpbmVzVG9CZUluY2x1ZGVkKHNjcmlwdCk7XG5cbiAgICBpZiAocm91dGluZXNJbmNsdWRlZC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBsZXQgcm91dGluZXMgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvdXRpbmVzSW5jbHVkZWQubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmIChyb3V0aW5lc0luY2x1ZGVkW2ldLnJvdXRpbmVCb2R5KSB7XG4gICAgICAgIHJvdXRpbmVzICs9IHJvdXRpbmVzSW5jbHVkZWRbaV0ucm91dGluZUJvZHkgKyAnXFxuJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTWlzc2luZyBib2R5IGZvciB0aGUgR2xzbCBMaWJyYXJ5IHJvdXRpbmU6ICR7cm91dGluZXNJbmNsdWRlZFtpXS5uYW1lfWApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByb3V0aW5lcztcbiAgfVxuICBwcml2YXRlIHNlbGVjdEdsc2xMaWJSb3V0aW5lc1RvQmVJbmNsdWRlZChzY3JpcHQ6IHN0cmluZyk6IEdsc2xMaWJSb3V0aW5lTm9kZVtdIHtcbiAgICBjb25zdCBub2RlczogR2xzbExpYlJvdXRpbmVOb2RlW10gPSBbXTtcblxuICAgIE9iamVjdC5rZXlzKHRoaXMuZ2xzbExpYlJvdXRpbmVEZXBlbmRlbmN5R3JhcGgpLmZvckVhY2goKGNsYXNzQW5kUm91dGluZSkgPT4ge1xuICAgICAgY29uc3Qgcm91dGluZSA9IGNsYXNzQW5kUm91dGluZS5zcGxpdCgnLicpWzFdO1xuICAgICAgaWYgKHNjcmlwdC5pbmRleE9mKHJvdXRpbmUpICE9PSAtMSkge1xuICAgICAgICBub2Rlcy5wdXNoKHRoaXMuZ2xzbExpYlJvdXRpbmVEZXBlbmRlbmN5R3JhcGhbY2xhc3NBbmRSb3V0aW5lXSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gVG9wb2xvZ2ljYWxTb3J0R2xzbFJvdXRpbmVzLnJldHVybk9yZGVyZWROb2Rlcyhub2Rlcyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0VW5pZm9ybXMoc2FtcGxlcnM/OiBzdHJpbmdbXSwgdmFyaWFibGVzPzogVmFyaWFibGVJbmZvW10pOiBzdHJpbmcge1xuICAgIGNvbnN0IHVuaWZvcm1MaW5lczogc3RyaW5nW10gPSBbXTtcbiAgICBpZiAoc2FtcGxlcnMpIHtcbiAgICAgIGZvciAoY29uc3Qgc2FtcGxlciBvZiBzYW1wbGVycykge1xuICAgICAgICB1bmlmb3JtTGluZXMucHVzaChgdW5pZm9ybSBzYW1wbGVyMkQgJHtzYW1wbGVyfTtgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHZhcmlhYmxlcykge1xuICAgICAgZm9yIChjb25zdCB2YXJpYWJsZSBvZiB2YXJpYWJsZXMpIHtcbiAgICAgICAgdW5pZm9ybUxpbmVzLnB1c2goXG4gICAgICAgICAgYHVuaWZvcm0gJHt2YXJpYWJsZS50eXBlfSAke3ZhcmlhYmxlLm5hbWV9JHt2YXJpYWJsZS5hcnJheUxlbmd0aCA/IGBbJHt2YXJpYWJsZS5hcnJheUxlbmd0aH1dYCA6ICcnfTtgLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5pZm9ybUxpbmVzLmpvaW4oJ1xcbicpO1xuICB9XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IGVudiB9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5cbmltcG9ydCB7IExvZ2dlciwgUHJvZmlsZXIgfSBmcm9tICcuLi8uLi9pbnN0cnVtZW50JztcblxuaW1wb3J0IHsgR2xzbFByZXByb2Nlc3NvciB9IGZyb20gJy4vZ2xzbC1wcmVwcm9jZXNzb3InO1xuaW1wb3J0IHsgZ2V0VmVydGV4U2hhZGVyU291cmNlIH0gZnJvbSAnLi9nbHNsLXNvdXJjZSc7XG5pbXBvcnQgeyBUZXh0dXJlTGF5b3V0U3RyYXRlZ3kgfSBmcm9tICcuL3RleHR1cmUtbGF5b3V0LXN0cmF0ZWd5JztcbmltcG9ydCB7IEFydGlmYWN0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbVZhcmlhYmxlLCBUZXh0dXJlRGF0YSwgVGV4dHVyZUxheW91dCwgVmFyaWFibGVJbmZvIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBXZWJHTENvbnRleHQgfSBmcm9tICcuL3dlYmdsLWNvbnRleHQnO1xuXG4vKipcbiAqIFByb2dyYW1NYW5hZ2VyIGlzIHRoZSBtYWluIGNsYXNzIGJlaGluZCBydW5uaW5nIGNvbXB1dGF0aW9uc1xuICogSXQgYnVpbGRzIFByb2dyYW1JbmZvJ3MgaW50byBBcnRpZmFjdHNcbiAqIEl0IGNvbXBpbGVzIGdpdmVuIFByb2dyYW1JbmZvJ3MgaW50byBXZWJHTCBQcm9yYW1zIChjYWNoZWQgYXMgQXJ0aWZhY3RzKVxuICogVXNlcyB0aGUgYXJ0aWZhY3QgdG8gcnVuIHRoZSBjb21wdXRhdGlvbiBieSBjYWxsaW5nIERyYXcgb25cbiAqIHRoZSBXZWJHTCBkcmF3aW5nIGJ1ZmZlclxuICogUHJvZ3JhbU1hbmFnZXIgYXV0b21hdGljYWxseSBtYXBzIChiaW5kcykgaW5wdXQgdmFyaWFibGVzIHRvIHRoZWlyXG4gKiBjb3JyZXNwb25kaW5nIExvY2F0aW9uJ3MgaW4gdGhlIGJpbmFyeSBwcm9ncmFtXG4gKi9cbmV4cG9ydCBjbGFzcyBQcm9ncmFtTWFuYWdlciB7XG4gIHJlcG86IE1hcDx1bmtub3duLCBBcnRpZmFjdD47IC8vIHRoaXMgc2hvdWxkIGJlIHBlci1zZXNzaW9uIG9iamVjdFxuICB2ZXJ0ZXhTaGFkZXI6IFdlYkdMU2hhZGVyO1xuICBhdHRyaWJ1dGVzQm91bmQ6IGJvb2xlYW47XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIHByb2ZpbGVyOiBSZWFkb25seTxQcm9maWxlcj4sXG4gICAgcHVibGljIGdsQ29udGV4dDogV2ViR0xDb250ZXh0LFxuICAgIHB1YmxpYyB0ZXh0dXJlTGF5b3V0U3RyYXRlZ3k6IFRleHR1cmVMYXlvdXRTdHJhdGVneSxcbiAgKSB7XG4gICAgdGhpcy5yZXBvID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuYXR0cmlidXRlc0JvdW5kID0gZmFsc2U7XG4gIH1cbiAgZ2V0QXJ0aWZhY3Qoa2V5OiB1bmtub3duKTogQXJ0aWZhY3QgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLnJlcG8uZ2V0KGtleSk7XG4gIH1cbiAgc2V0QXJ0aWZhY3Qoa2V5OiB1bmtub3duLCBhcnRpZmFjdDogQXJ0aWZhY3QpOiB2b2lkIHtcbiAgICB0aGlzLnJlcG8uc2V0KGtleSwgYXJ0aWZhY3QpO1xuICB9XG4gIHJ1bihidWlsZEFydGlmYWN0OiBBcnRpZmFjdCwgaW5wdXRzOiBUZXh0dXJlRGF0YVtdLCBvdXRwdXQ6IFRleHR1cmVEYXRhKTogdm9pZCB7XG4gICAgdGhpcy5wcm9maWxlci5ldmVudChcbiAgICAgICdvcCcsXG4gICAgICBgUHJvZ3JhbU1hbmFnZXIucnVuICR7YnVpbGRBcnRpZmFjdC5wcm9ncmFtSW5mby5uYW1lID8/ICd1bmtub3duIGtlcm5lbCd9YCxcbiAgICAgICgpID0+IHtcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLmdsQ29udGV4dC5nbDtcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IGJ1aWxkQXJ0aWZhY3QucHJvZ3JhbTtcbiAgICAgICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmJpbmRPdXRwdXQob3V0cHV0KTtcbiAgICAgICAgICBpZiAoIXRoaXMuYXR0cmlidXRlc0JvdW5kKSB7XG4gICAgICAgICAgICB0aGlzLmJpbmRBdHRyaWJ1dGVzKGJ1aWxkQXJ0aWZhY3QuYXR0cmliTG9jYXRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5iaW5kVW5pZm9ybXMoYnVpbGRBcnRpZmFjdC51bmlmb3JtTG9jYXRpb25zLCBidWlsZEFydGlmYWN0LnByb2dyYW1JbmZvLnZhcmlhYmxlcyA/PyBbXSwgaW5wdXRzKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgTG9nZ2VyLmVycm9yKCdQcm9ncmFtTWFuYWdlcicsIGJ1aWxkQXJ0aWZhY3QucHJvZ3JhbUluZm8uc2hhZGVyU291cmNlKTtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm9maWxlci5ldmVudCgnYmFja2VuZCcsICdHbENvbnRleHQuZHJhdygpJywgKCkgPT4ge1xuICAgICAgICAgIHRoaXMuZ2xDb250ZXh0LmRyYXcoKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgdGhpcy5nbENvbnRleHQsXG4gICAgKTtcbiAgfVxuICBkaXNwb3NlKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLnZlcnRleFNoYWRlcikge1xuICAgICAgdGhpcy5nbENvbnRleHQuZGVsZXRlU2hhZGVyKHRoaXMudmVydGV4U2hhZGVyKTtcbiAgICB9XG4gICAgdGhpcy5yZXBvLmZvckVhY2goKGEpID0+IHRoaXMuZ2xDb250ZXh0LmRlbGV0ZVByb2dyYW0oYS5wcm9ncmFtKSk7XG4gIH1cbiAgYnVpbGQocHJvZ3JhbUluZm86IFByb2dyYW1JbmZvLCBpbnB1dFRleHR1cmVMYXlvdXRzOiBUZXh0dXJlTGF5b3V0W10sIG91dHB1dFRleHR1cmVMYXlvdXQ6IFRleHR1cmVMYXlvdXQpOiBBcnRpZmFjdCB7XG4gICAgcmV0dXJuIHRoaXMucHJvZmlsZXIuZXZlbnQoJ2JhY2tlbmQnLCAnUHJvZ3JhbU1hbmFnZXIuYnVpbGQnLCAoKSA9PiB7XG4gICAgICBjb25zdCBwcmVwcm9jZXNzb3IgPSBuZXcgR2xzbFByZXByb2Nlc3Nvcih0aGlzLmdsQ29udGV4dCwgcHJvZ3JhbUluZm8sIGlucHV0VGV4dHVyZUxheW91dHMsIG91dHB1dFRleHR1cmVMYXlvdXQpO1xuICAgICAgY29uc3QgZnJhZ1NjcmlwdCA9IHByZXByb2Nlc3Nvci5wcmVwcm9jZXNzKCk7XG4gICAgICBjb25zdCBwcm9ncmFtID0gdGhpcy5jb21waWxlKGZyYWdTY3JpcHQpO1xuICAgICAgY29uc3QgYXJ0aWZhY3QgPSB7XG4gICAgICAgIHByb2dyYW1JbmZvLFxuICAgICAgICBwcm9ncmFtLFxuICAgICAgICB1bmlmb3JtTG9jYXRpb25zOiB0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbnMoXG4gICAgICAgICAgcHJvZ3JhbSxcbiAgICAgICAgICBwcmVwcm9jZXNzb3IuY29udGV4dC5wcm9ncmFtSW5mby5pbnB1dE5hbWVzLFxuICAgICAgICAgIHByZXByb2Nlc3Nvci5jb250ZXh0LnByb2dyYW1JbmZvLnZhcmlhYmxlcyxcbiAgICAgICAgKSxcbiAgICAgICAgYXR0cmliTG9jYXRpb25zOiB0aGlzLmdldEF0dHJpYkxvY2F0aW9ucyhwcm9ncmFtKSxcbiAgICAgIH07XG4gICAgICByZXR1cm4gYXJ0aWZhY3Q7XG4gICAgfSk7XG4gIH1cbiAgcHJvdGVjdGVkIGNvbXBpbGUoZnJhZ1NoYWRlclNjcmlwdDogc3RyaW5nKTogV2ViR0xQcm9ncmFtIHtcbiAgICBpZiAoIXRoaXMudmVydGV4U2hhZGVyKSB7XG4gICAgICBMb2dnZXIudmVyYm9zZSgnUHJvcmdyYW1NYW5hZ2VyJywgJ0NvbXBpbGluZyBhbmQgY2FjaGluZyBWZXJ0ZXggc2hhZGVyIGZvciB0aGUgZmlyc3QgdGltZScpO1xuICAgICAgY29uc3QgdmVydGV4U2hhZGVyU2NyaXB0ID0gZ2V0VmVydGV4U2hhZGVyU291cmNlKHRoaXMuZ2xDb250ZXh0LnZlcnNpb24pO1xuICAgICAgdGhpcy52ZXJ0ZXhTaGFkZXIgPSB0aGlzLmdsQ29udGV4dC5jb21waWxlU2hhZGVyKHZlcnRleFNoYWRlclNjcmlwdCwgdGhpcy5nbENvbnRleHQuZ2wuVkVSVEVYX1NIQURFUik7XG4gICAgfVxuICAgIGlmIChlbnYuZGVidWcpIHtcbiAgICAgIExvZ2dlci52ZXJib3NlKFxuICAgICAgICAnUHJvcmdyYW1NYW5hZ2VyJyxcbiAgICAgICAgYEZyYWdTaGFkZXI6XG4ke2ZyYWdTaGFkZXJTY3JpcHR9XG5gLFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgZnJhZ1NoYWRlciA9IHRoaXMuZ2xDb250ZXh0LmNvbXBpbGVTaGFkZXIoZnJhZ1NoYWRlclNjcmlwdCwgdGhpcy5nbENvbnRleHQuZ2wuRlJBR01FTlRfU0hBREVSKTtcbiAgICBjb25zdCBwcm9ncmFtID0gdGhpcy5nbENvbnRleHQuY3JlYXRlUHJvZ3JhbSh0aGlzLnZlcnRleFNoYWRlciwgZnJhZ1NoYWRlcik7XG4gICAgdGhpcy5nbENvbnRleHQuZGVsZXRlU2hhZGVyKGZyYWdTaGFkZXIpO1xuICAgIHJldHVybiBwcm9ncmFtO1xuICB9XG4gIGJpbmRPdXRwdXQodGQ6IFRleHR1cmVEYXRhKTogdm9pZCB7XG4gICAgY29uc3Qgd2lkdGggPSB0ZC53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSB0ZC5oZWlnaHQ7XG4gICAgTG9nZ2VyLnZlcmJvc2UoXG4gICAgICAnUHJvcmdyYW1NYW5hZ2VyJyxcbiAgICAgIGBCaW5kaW5nIG91dHB1dCB0ZXh0dXJlIHRvIEZyYW1lYnVmZmVyOiB3L2g9JHt3aWR0aH0vJHtoZWlnaHR9LCBzaGFwZT0ke3RkLnNoYXBlfSwgdHlwZT0ke3RkLnRlbnNvci50eXBlfWAsXG4gICAgKTtcbiAgICB0aGlzLmdsQ29udGV4dC5hdHRhY2hGcmFtZWJ1ZmZlcih0ZC50ZXh0dXJlLCB3aWR0aCwgaGVpZ2h0KTtcbiAgfVxuICBiaW5kQXR0cmlidXRlcyhhdHRyaWJMb2NhdGlvbnM6IEFydGlmYWN0LkF0dHJpYkxvY2F0aW9ucyk6IHZvaWQge1xuICAgIGNvbnN0IHBvc2l0aW9uSGFuZGxlID0gYXR0cmliTG9jYXRpb25zLnBvc2l0aW9uO1xuICAgIGNvbnN0IHRleHR1cmVDb29yZEhhbmRsZSA9IGF0dHJpYkxvY2F0aW9ucy50ZXh0dXJlQ29vcmQ7XG4gICAgdGhpcy5nbENvbnRleHQuc2V0VmVydGV4QXR0cmlidXRlcyhwb3NpdGlvbkhhbmRsZSwgdGV4dHVyZUNvb3JkSGFuZGxlKTtcbiAgICB0aGlzLmF0dHJpYnV0ZXNCb3VuZCA9IHRydWU7XG4gIH1cbiAgYmluZFVuaWZvcm1zKFxuICAgIHVuaWZvcm1Mb2NhdGlvbnM6IEFydGlmYWN0LlVuaWZvcm1Mb2NhdGlvbnMsXG4gICAgdmFyaWFibGVzOiBQcm9ncmFtVmFyaWFibGVbXSxcbiAgICB0ZXh0dXJlczogVGV4dHVyZURhdGFbXSxcbiAgKTogdm9pZCB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsQ29udGV4dC5nbDtcbiAgICBsZXQgdGV4dHVyZVBvc2l0aW9uID0gMDtcbiAgICBmb3IgKGNvbnN0IHsgbmFtZSwgdHlwZSwgbG9jYXRpb24sIGFycmF5TGVuZ3RoIH0gb2YgdW5pZm9ybUxvY2F0aW9ucykge1xuICAgICAgY29uc3QgdmFsdWUgPSB2YXJpYWJsZXMuZmluZCgodikgPT4gdi5uYW1lID09PSBuYW1lKT8uZGF0YTtcbiAgICAgIGlmICh0eXBlICE9PSAnc2FtcGxlcjJEJyAmJiAhdmFsdWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB2YXJpYWJsZSAnJHtuYW1lfScgZG9lcyBub3QgaGF2ZSBkYXRhIGRlZmluZWQgaW4gcHJvZ3JhbSBpbmZvYCk7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnc2FtcGxlcjJEJzpcbiAgICAgICAgICB0aGlzLmJpbmRUZXh0dXJlKHRleHR1cmVzW3RleHR1cmVQb3NpdGlvbl0sIGxvY2F0aW9uLCB0ZXh0dXJlUG9zaXRpb24pO1xuICAgICAgICAgIHRleHR1cmVQb3NpdGlvbisrO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdmbG9hdCc6XG4gICAgICAgICAgaWYgKGFycmF5TGVuZ3RoKSB7XG4gICAgICAgICAgICBnbC51bmlmb3JtMWZ2KGxvY2F0aW9uLCB2YWx1ZSBhcyBudW1iZXJbXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsLnVuaWZvcm0xZihsb2NhdGlvbiwgdmFsdWUgYXMgbnVtYmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2ludCc6XG4gICAgICAgICAgaWYgKGFycmF5TGVuZ3RoKSB7XG4gICAgICAgICAgICBnbC51bmlmb3JtMWl2KGxvY2F0aW9uLCB2YWx1ZSBhcyBudW1iZXJbXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsLnVuaWZvcm0xaShsb2NhdGlvbiwgdmFsdWUgYXMgbnVtYmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmlmb3JtIG5vdCBpbXBsZW1lbnRlZDogJHt0eXBlfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBiaW5kVGV4dHVyZSh0ZDogVGV4dHVyZURhdGEsIHVuaWZvcm1IYW5kbGU6IFdlYkdMVW5pZm9ybUxvY2F0aW9uLCBwb3NpdGlvbjogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5nbENvbnRleHQuYmluZFRleHR1cmVUb1VuaWZvcm0odGQudGV4dHVyZSwgcG9zaXRpb24sIHVuaWZvcm1IYW5kbGUpO1xuICB9XG4gIGdldEF0dHJpYkxvY2F0aW9ucyhwcm9ncmFtOiBXZWJHTFByb2dyYW0pOiBBcnRpZmFjdC5BdHRyaWJMb2NhdGlvbnMge1xuICAgIHJldHVybiB7XG4gICAgICBwb3NpdGlvbjogdGhpcy5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAncG9zaXRpb24nKSxcbiAgICAgIHRleHR1cmVDb29yZDogdGhpcy5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAndGV4dHVyZUNvb3JkJyksXG4gICAgfTtcbiAgfVxuICBnZXRVbmlmb3JtTG9jYXRpb25zKFxuICAgIHByb2dyYW06IFdlYkdMUHJvZ3JhbSxcbiAgICBzYW1wbGVycz86IHN0cmluZ1tdLFxuICAgIHZhcmlhYmxlcz86IFZhcmlhYmxlSW5mb1tdLFxuICApOiBBcnRpZmFjdC5Vbmlmb3JtTG9jYXRpb25zIHtcbiAgICBjb25zdCB1bmlmb3JtTG9jYXRpb25zOiBBcnRpZmFjdC5Vbmlmb3JtTG9jYXRpb25zID0gW107XG4gICAgaWYgKHNhbXBsZXJzKSB7XG4gICAgICBmb3IgKGNvbnN0IHNhbXBsZXIgb2Ygc2FtcGxlcnMpIHtcbiAgICAgICAgdW5pZm9ybUxvY2F0aW9ucy5wdXNoKHtcbiAgICAgICAgICBuYW1lOiBzYW1wbGVyLFxuICAgICAgICAgIHR5cGU6ICdzYW1wbGVyMkQnLFxuICAgICAgICAgIGxvY2F0aW9uOiB0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBzYW1wbGVyKSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh2YXJpYWJsZXMpIHtcbiAgICAgIGZvciAoY29uc3QgdmFyaWFibGUgb2YgdmFyaWFibGVzKSB7XG4gICAgICAgIHVuaWZvcm1Mb2NhdGlvbnMucHVzaCh7IC4uLnZhcmlhYmxlLCBsb2NhdGlvbjogdGhpcy5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgdmFyaWFibGUubmFtZSkgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmlmb3JtTG9jYXRpb25zO1xuICB9XG4gIGdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtOiBXZWJHTFByb2dyYW0sIG5hbWU6IHN0cmluZyk6IFdlYkdMVW5pZm9ybUxvY2F0aW9uIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2xDb250ZXh0LmdsO1xuICAgIGNvbnN0IHJlZmVyZW5jZSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBuYW1lKTtcbiAgICBpZiAocmVmZXJlbmNlID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuaWZvcm0gJHtuYW1lfSBub3QgZm91bmQuYCk7XG4gICAgfVxuICAgIHJldHVybiByZWZlcmVuY2U7XG4gIH1cbiAgZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbTogV2ViR0xQcm9ncmFtLCBuYW1lOiBzdHJpbmcpOiBudW1iZXIge1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbENvbnRleHQuZ2w7XG4gICAgY29uc3QgYXR0cmlidXRlTG9jYXRpb246IG51bWJlciA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIG5hbWUpO1xuICAgIHJldHVybiBhdHRyaWJ1dGVMb2NhdGlvbjtcbiAgfVxufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBMb2dnZXIsIFByb2ZpbGVyIH0gZnJvbSAnLi4vLi4vaW5zdHJ1bWVudCc7XG5pbXBvcnQgeyBUZW5zb3IgfSBmcm9tICcuLi8uLi90ZW5zb3InO1xuXG5pbXBvcnQgeyBFbmNvZGVyLCBFbmNvZGVyVXNhZ2UgfSBmcm9tICcuL3RleHR1cmUtZGF0YS1lbmNvZGVyJztcbmltcG9ydCB7IFRleHR1cmVMYXlvdXRTdHJhdGVneSB9IGZyb20gJy4vdGV4dHVyZS1sYXlvdXQtc3RyYXRlZ3knO1xuaW1wb3J0IHsgVGV4dHVyZURhdGEsIFRleHR1cmVMYXlvdXQgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IFdlYkdMQ29udGV4dCB9IGZyb20gJy4vd2ViZ2wtY29udGV4dCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGV4dHVyZU1hbmFnZXJDb25maWcge1xuICByZXVzZVRleHR1cmVzPzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBUZXh0dXJlTWFuYWdlciBpcyB0aGUgbWFpbmx5IHJlc3BvbnNpYmxlIGZvciBjYWNoaW5nIFRleHR1cmVzXG4gKiBUZXh0dXJlcyBhcmUgY2FjaGVkIGluIDIgbGV2ZWxzOlxuICogICAxLiB0aGUgdGV4dXJlcyB3aGljaCBhcmUgYXNzb2NpYXRlZCB3aXRoIGEgZGF0YUlkIChmcm9tIFRlbnNvcilcbiAqICAgIENhY2hpbmcgdGhlc2UgaXMgY3J1Y2lhbCB0byBwZXJmb3JtYW5jZS4gVGhlc2UgYXJlIEluLXVzZSBUZXh0dXJlc1xuICogICAyLiB0ZXh0dXJlcyB3aGljaCBhcmUgbm90IGluIHVzZSBieSBhbnkgY3VycmVudCBQcm9ncmFtSW5mby9UZW5zb3JcbiAqICAgICBUaGVzZSBhcmUgY2FsbGVkIEZyZWUgVGV4dHVyZXNcbiAqIFRleHR1cmVNYW5hZ2VyIGlzIGFsc28gdXNlZCB0byBoZWxwIGNyZWF0aW5nIHRleHR1cmVzLiBGb3IgdGhpcyBpdFxuICogdXNlcyBXZWJHTENvbnRleHQgYW5kIFRleHR1cmVMYXlvdXRTdHJhdGVneVxuICovXG5leHBvcnQgY2xhc3MgVGV4dHVyZU1hbmFnZXIge1xuICBwcml2YXRlIHJlYWRvbmx5IGluVXNlVGV4dHVyZXM6IE1hcDxzdHJpbmcsIFdlYkdMVGV4dHVyZVtdPjtcbiAgcHJpdmF0ZSByZWFkb25seSBpZGxlVGV4dHVyZXM6IE1hcDxzdHJpbmcsIFdlYkdMVGV4dHVyZVtdPjtcbiAgcHJpdmF0ZSByZWFkb25seSB0ZXh0dXJlTG9va3VwOiBNYXA8V2ViR0xUZXh0dXJlLCBzdHJpbmc+O1xuICBwcml2YXRlIHJlYWRvbmx5IHBlbmRpbmdSZWFkOiBNYXA8VGVuc29yLklkLCBBcnJheTwoYXJyOiBUZW5zb3IuTnVtYmVyVHlwZSkgPT4gdm9pZD4+ID0gbmV3IE1hcCgpO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBnbENvbnRleHQ6IFdlYkdMQ29udGV4dCxcbiAgICBwdWJsaWMgbGF5b3V0U3RyYXRlZ3k6IFRleHR1cmVMYXlvdXRTdHJhdGVneSxcbiAgICBwdWJsaWMgcHJvZmlsZXI6IFJlYWRvbmx5PFByb2ZpbGVyPixcbiAgICBwcml2YXRlIGNvbmZpZzogVGV4dHVyZU1hbmFnZXJDb25maWcsXG4gICkge1xuICAgIGlmIChjb25maWcucmV1c2VUZXh0dXJlcykge1xuICAgICAgdGhpcy5pblVzZVRleHR1cmVzID0gbmV3IE1hcCgpO1xuICAgICAgdGhpcy5pZGxlVGV4dHVyZXMgPSBuZXcgTWFwKCk7XG4gICAgICB0aGlzLnRleHR1cmVMb29rdXAgPSBuZXcgTWFwKCk7XG4gICAgfVxuICB9XG4gIGNyZWF0ZVRleHR1cmVGcm9tTGF5b3V0KFxuICAgIGRhdGFUeXBlOiBUZW5zb3IuRGF0YVR5cGUsXG4gICAgbGF5b3V0OiBUZXh0dXJlTGF5b3V0LFxuICAgIGRhdGE/OiBUZW5zb3IuTnVtYmVyVHlwZSxcbiAgICB1c2FnZT86IEVuY29kZXJVc2FnZSxcbiAgKSB7XG4gICAgY29uc3QgdGV4dHVyZURhdGFUeXBlID0gdGhpcy50b0VuY29kZXJUeXBlKGRhdGFUeXBlKTtcblxuICAgIGNvbnN0IGVuY29kZXIgPSB0aGlzLmdsQ29udGV4dC5nZXRFbmNvZGVyKHRleHR1cmVEYXRhVHlwZSwgbGF5b3V0LmNoYW5uZWxzIHx8IDEsIHVzYWdlKTtcbiAgICBpZiAobGF5b3V0LmlzUGFja2VkICYmIHVzYWdlID09PSBFbmNvZGVyVXNhZ2UuVXBsb2FkT25seSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG4gICAgY29uc3Qgd2lkdGggPSBsYXlvdXQud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gbGF5b3V0LmhlaWdodDtcblxuICAgIGxldCBrZXk6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICBsZXQgaW5Vc2VUZXh0dXJlczogV2ViR0xUZXh0dXJlW10gfCB1bmRlZmluZWQ7XG4gICAgaWYgKHRoaXMuY29uZmlnLnJldXNlVGV4dHVyZXMpIHtcbiAgICAgIGtleSA9IGAke3dpZHRofXgke2hlaWdodH1fJHtlbmNvZGVyLmZvcm1hdH1fJHtlbmNvZGVyLmludGVybmFsRm9ybWF0fV8ke2VuY29kZXIudGV4dHVyZVR5cGV9YDtcbiAgICAgIGluVXNlVGV4dHVyZXMgPSB0aGlzLmluVXNlVGV4dHVyZXMuZ2V0KGtleSk7XG4gICAgICBpZiAoIWluVXNlVGV4dHVyZXMpIHtcbiAgICAgICAgaW5Vc2VUZXh0dXJlcyA9IFtdO1xuICAgICAgICB0aGlzLmluVXNlVGV4dHVyZXMuc2V0KGtleSwgaW5Vc2VUZXh0dXJlcyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGlkbGVUZXh0dXJlcyA9IHRoaXMuaWRsZVRleHR1cmVzLmdldChrZXkpO1xuICAgICAgaWYgKGlkbGVUZXh0dXJlcyAmJiBpZGxlVGV4dHVyZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCB0ZXh0dXJlID0gaWRsZVRleHR1cmVzLnBvcCgpITtcbiAgICAgICAgaW5Vc2VUZXh0dXJlcy5wdXNoKHRleHR1cmUpO1xuICAgICAgICBpZiAodXNhZ2UgPT09IEVuY29kZXJVc2FnZS5VcGxvYWRPbmx5KSB7XG4gICAgICAgICAgdGhpcy5nbENvbnRleHQudXBkYXRlVGV4dHVyZSh0ZXh0dXJlLCB3aWR0aCwgaGVpZ2h0LCBlbmNvZGVyLCB0aGlzLnRvVGV4dHVyZURhdGEoZGF0YVR5cGUsIGRhdGEpISk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHR1cmU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgTG9nZ2VyLnZlcmJvc2UoJ1RleHR1cmVNYW5hZ2VyJywgYENyZWF0aW5nIG5ldyB0ZXh0dXJlIG9mIHNpemUgJHtsYXlvdXQud2lkdGh9eCR7bGF5b3V0LmhlaWdodH1gKTtcbiAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy5nbENvbnRleHQuYWxsb2NhdGVUZXh0dXJlKHdpZHRoLCBoZWlnaHQsIGVuY29kZXIsIHRoaXMudG9UZXh0dXJlRGF0YShkYXRhVHlwZSwgZGF0YSkpO1xuXG4gICAgaWYgKHRoaXMuY29uZmlnLnJldXNlVGV4dHVyZXMpIHtcbiAgICAgIGluVXNlVGV4dHVyZXMhLnB1c2godGV4dHVyZSk7XG4gICAgICB0aGlzLnRleHR1cmVMb29rdXAuc2V0KHRleHR1cmUsIGtleSEpO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dHVyZTtcbiAgfVxuICByZWFkVGV4dHVyZSh0ZDogVGV4dHVyZURhdGEsIGRhdGFUeXBlOiBUZW5zb3IuRGF0YVR5cGUsIGNoYW5uZWxzPzogbnVtYmVyKTogVGVuc29yLk51bWJlclR5cGUge1xuICAgIGlmICghY2hhbm5lbHMpIHtcbiAgICAgIGNoYW5uZWxzID0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucHJvZmlsZXIuZXZlbnQoJ2JhY2tlbmQnLCAnVGV4dHVyZU1hbmFnZXIucmVhZFRleHR1cmUnLCAoKSA9PiB7XG4gICAgICBjb25zdCBkYXRhU2l6ZSA9IHRkLnNoYXBlLnJlZHVjZSgoYSwgYikgPT4gYSAqIGIpICogY2hhbm5lbHMhO1xuICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZ2xDb250ZXh0LnJlYWRUZXh0dXJlKFxuICAgICAgICB0ZC50ZXh0dXJlLFxuICAgICAgICB0ZC53aWR0aCxcbiAgICAgICAgdGQuaGVpZ2h0LFxuICAgICAgICBkYXRhU2l6ZSxcbiAgICAgICAgdGhpcy50b0VuY29kZXJUeXBlKGRhdGFUeXBlKSxcbiAgICAgICAgY2hhbm5lbHMhLFxuICAgICAgKTtcbiAgICAgIHJldHVybiB0aGlzLnRvVGVuc29yRGF0YShkYXRhVHlwZSwgZGF0YSk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgcmVhZFRleHR1cmVBc3luYyh0ZDogVGV4dHVyZURhdGEsIGRhdGFUeXBlOiBUZW5zb3IuRGF0YVR5cGUsIGNoYW5uZWxzPzogbnVtYmVyKTogUHJvbWlzZTxUZW5zb3IuTnVtYmVyVHlwZT4ge1xuICAgIGNvbnN0IGRhdGFJZCA9IHRkLnRlbnNvci5kYXRhSWQ7XG4gICAgaWYgKCFjaGFubmVscykge1xuICAgICAgY2hhbm5lbHMgPSAxO1xuICAgIH1cbiAgICBpZiAodGhpcy5wZW5kaW5nUmVhZC5oYXMoZGF0YUlkKSkge1xuICAgICAgY29uc3Qgc3Vic2NyaWJlcnMgPSB0aGlzLnBlbmRpbmdSZWFkLmdldChkYXRhSWQpO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPFRlbnNvci5OdW1iZXJUeXBlPigocmVzb2x2ZSkgPT4gc3Vic2NyaWJlcnM/LnB1c2gocmVzb2x2ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wcm9maWxlci5ldmVudCgnYmFja2VuZCcsICdUZXh0dXJlTWFuYWdlci5yZWFkVGV4dHVyZUFzeW5jJywgYXN5bmMgKCkgPT4ge1xuICAgICAgdGhpcy5wZW5kaW5nUmVhZC5zZXQoZGF0YUlkLCBbXSk7XG4gICAgICBjb25zdCBkYXRhU2l6ZSA9IHRkLnNoYXBlLnJlZHVjZSgoYSwgYikgPT4gYSAqIGIpICogY2hhbm5lbHMhO1xuICAgICAgLy8gYWRkIGEgZmVuY2Ugd2FpdGluZyBmb3IgdGhlIGRhdGEgdG8gYmUgcmVhZHlcbiAgICAgIGF3YWl0IHRoaXMuZ2xDb250ZXh0LmNyZWF0ZUFuZFdhaXRGb3JGZW5jZSgpO1xuICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZ2xDb250ZXh0LnJlYWRUZXh0dXJlKFxuICAgICAgICB0ZC50ZXh0dXJlLFxuICAgICAgICB0ZC53aWR0aCxcbiAgICAgICAgdGQuaGVpZ2h0LFxuICAgICAgICBkYXRhU2l6ZSxcbiAgICAgICAgdGhpcy50b0VuY29kZXJUeXBlKGRhdGFUeXBlKSxcbiAgICAgICAgY2hhbm5lbHMhLFxuICAgICAgKTtcbiAgICAgIGNvbnN0IHRlbnNvckRhdGEgPSB0aGlzLnRvVGVuc29yRGF0YShkYXRhVHlwZSwgZGF0YSk7XG4gICAgICBjb25zdCBzdWJzY3JpYmVycyA9IHRoaXMucGVuZGluZ1JlYWQuZ2V0KGRhdGFJZCk7XG4gICAgICB0aGlzLnBlbmRpbmdSZWFkLmRlbGV0ZShkYXRhSWQpO1xuICAgICAgc3Vic2NyaWJlcnM/LmZvckVhY2goKHJlc29sdmUpID0+IHJlc29sdmUodGVuc29yRGF0YSkpO1xuICAgICAgcmV0dXJuIHRlbnNvckRhdGE7XG4gICAgfSk7XG4gIH1cbiAgcmVhZFVpbnQ4VGV4dHVyZUFzRmxvYXQodGQ6IFRleHR1cmVEYXRhKTogRmxvYXQzMkFycmF5IHtcbiAgICByZXR1cm4gdGhpcy5wcm9maWxlci5ldmVudCgnYmFja2VuZCcsICdUZXh0dXJlTWFuYWdlci5yZWFkVWludDhUZXh0dXJlQXNGbG9hdCcsICgpID0+IHtcbiAgICAgIGNvbnN0IGRhdGFTaXplID0gdGQuc2hhcGUucmVkdWNlKChhLCBiKSA9PiBhICogYik7XG4gICAgICBjb25zdCBkYXRhID0gdGhpcy5nbENvbnRleHQucmVhZFRleHR1cmUodGQudGV4dHVyZSwgdGQud2lkdGgsIHRkLmhlaWdodCwgZGF0YVNpemUgKiA0LCAnYnl0ZScsIDQpO1xuICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCwgZGF0YVNpemUpO1xuICAgIH0pO1xuICB9XG4gIHJlbGVhc2VUZXh0dXJlKHRleHR1cmVEYXRhOiBUZXh0dXJlRGF0YSwgZGVsZXRlVGV4dHVyZT86IGJvb2xlYW4pOiB2b2lkIHtcbiAgICBsZXQga2V5OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgaWYgKHRoaXMuY29uZmlnLnJldXNlVGV4dHVyZXMpIHtcbiAgICAgIGtleSA9IHRoaXMudGV4dHVyZUxvb2t1cC5nZXQodGV4dHVyZURhdGEudGV4dHVyZSk7XG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIGlmIChkZWxldGVUZXh0dXJlKSB7XG4gICAgICAgICAgdGhpcy50ZXh0dXJlTG9va3VwLmRlbGV0ZShrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluVXNlVGV4dHVyZXMgPSB0aGlzLmluVXNlVGV4dHVyZXMuZ2V0KGtleSk7XG4gICAgICAgIGlmIChpblVzZVRleHR1cmVzKSB7XG4gICAgICAgICAgY29uc3QgaW5kZXggPSBpblVzZVRleHR1cmVzLmluZGV4T2YodGV4dHVyZURhdGEudGV4dHVyZSk7XG4gICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgaW5Vc2VUZXh0dXJlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgbGV0IGlkbGVUZXh0dXJlcyA9IHRoaXMuaWRsZVRleHR1cmVzLmdldChrZXkpO1xuICAgICAgICAgICAgaWYgKCFpZGxlVGV4dHVyZXMpIHtcbiAgICAgICAgICAgICAgaWRsZVRleHR1cmVzID0gW107XG4gICAgICAgICAgICAgIHRoaXMuaWRsZVRleHR1cmVzLnNldChrZXksIGlkbGVUZXh0dXJlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZGxlVGV4dHVyZXMucHVzaCh0ZXh0dXJlRGF0YS50ZXh0dXJlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWtleSB8fCBkZWxldGVUZXh0dXJlKSB7XG4gICAgICBMb2dnZXIudmVyYm9zZSgnVGV4dHVyZU1hbmFnZXInLCBgRGVsZXRpbmcgdGV4dHVyZSBvZiBzaXplICR7dGV4dHVyZURhdGEud2lkdGh9eCR7dGV4dHVyZURhdGEuaGVpZ2h0fWApO1xuICAgICAgdGhpcy5nbENvbnRleHQuZGVsZXRlVGV4dHVyZSh0ZXh0dXJlRGF0YS50ZXh0dXJlKTtcbiAgICB9XG4gIH1cbiAgdG9UZW5zb3JEYXRhKGRhdGFUeXBlOiBUZW5zb3IuRGF0YVR5cGUsIGRhdGE6IEVuY29kZXIuRGF0YUFycmF5VHlwZSk6IFRlbnNvci5OdW1iZXJUeXBlIHtcbiAgICBzd2l0Y2ggKGRhdGFUeXBlKSB7XG4gICAgICBjYXNlICdpbnQxNic6XG4gICAgICAgIHJldHVybiBkYXRhIGluc3RhbmNlb2YgSW50MTZBcnJheSA/IGRhdGEgOiBJbnQxNkFycmF5LmZyb20oZGF0YSk7XG4gICAgICBjYXNlICdpbnQzMic6XG4gICAgICAgIHJldHVybiBkYXRhIGluc3RhbmNlb2YgSW50MzJBcnJheSA/IGRhdGEgOiBJbnQzMkFycmF5LmZyb20oZGF0YSk7XG4gICAgICBjYXNlICdpbnQ4JzpcbiAgICAgICAgcmV0dXJuIGRhdGEgaW5zdGFuY2VvZiBJbnQ4QXJyYXkgPyBkYXRhIDogSW50OEFycmF5LmZyb20oZGF0YSk7XG4gICAgICBjYXNlICd1aW50MTYnOlxuICAgICAgICByZXR1cm4gZGF0YSBpbnN0YW5jZW9mIFVpbnQxNkFycmF5ID8gZGF0YSA6IFVpbnQxNkFycmF5LmZyb20oZGF0YSk7XG4gICAgICBjYXNlICd1aW50MzInOlxuICAgICAgICByZXR1cm4gZGF0YSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5ID8gZGF0YSA6IFVpbnQzMkFycmF5LmZyb20oZGF0YSk7XG4gICAgICBjYXNlICd1aW50OCc6XG4gICAgICBjYXNlICdib29sJzpcbiAgICAgICAgcmV0dXJuIGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gZGF0YSA6IFVpbnQ4QXJyYXkuZnJvbShkYXRhKTtcbiAgICAgIGNhc2UgJ2Zsb2F0MzInOlxuICAgICAgICByZXR1cm4gZGF0YSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSA/IGRhdGEgOiBGbG9hdDMyQXJyYXkuZnJvbShkYXRhKTtcbiAgICAgIGNhc2UgJ2Zsb2F0NjQnOlxuICAgICAgICByZXR1cm4gZGF0YSBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheSA/IGRhdGEgOiBGbG9hdDY0QXJyYXkuZnJvbShkYXRhKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGVuc29yRGF0YSB0eXBlICR7ZGF0YVR5cGV9IGlzIG5vdCBzdXBwb3J0ZWRgKTtcbiAgICB9XG4gIH1cbiAgdG9UZXh0dXJlRGF0YShfZGF0YVR5cGU6IFRlbnNvci5EYXRhVHlwZSwgZGF0YTogVGVuc29yLk51bWJlclR5cGUgfCB1bmRlZmluZWQpOiBFbmNvZGVyLkRhdGFBcnJheVR5cGUgfCB1bmRlZmluZWQge1xuICAgIGlmICghZGF0YSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGEgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgPyBkYXRhIDogbmV3IEZsb2F0MzJBcnJheShkYXRhKTtcbiAgICAvKlxuICAgIHN3aXRjaCAoZGF0YVR5cGUpIHtcbiAgICAgIGNhc2UgJ2ludDE2JzpcbiAgICAgIGNhc2UgJ2ludDMyJzpcbiAgICAgIGNhc2UgJ3VpbnQxNic6XG4gICAgICBjYXNlICd1aW50MzInOlxuICAgICAgICByZXR1cm4gKGRhdGEuY29uc3RydWN0b3IgPT09IFVpbnQzMkFycmF5KSA/IGRhdGEgYXMgVWludDMyQXJyYXkgOiBuZXcgVWludDMyQXJyYXkoZGF0YSk7XG4gICAgICBjYXNlICdpbnQ4JzpcbiAgICAgIGNhc2UgJ3VpbnQ4JzpcbiAgICAgIGNhc2UgJ2Jvb2wnOlxuICAgICAgICByZXR1cm4gKGRhdGEuY29uc3RydWN0b3IgPT09IFVpbnQ4QXJyYXkpID8gZGF0YSBhcyBVaW50OEFycmF5IDogbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gICAgICBjYXNlICdmbG9hdDMyJzpcbiAgICAgIGNhc2UgJ2Zsb2F0NjQnOlxuICAgICAgICByZXR1cm4gKGRhdGEuY29uc3RydWN0b3IgPT09IEZsb2F0MzJBcnJheSkgPyBkYXRhIGFzIEZsb2F0MzJBcnJheSA6IG5ldyBGbG9hdDMyQXJyYXkoZGF0YSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRlbnNvckRhdGEgdHlwZSAke2RhdGFUeXBlfSBpcyBub3Qgc3VwcG9ydGVkYCk7XG4gICAgfVxuICAgICovXG4gIH1cbiAgdG9FbmNvZGVyVHlwZShfZGF0YVR5cGU6IFRlbnNvci5EYXRhVHlwZSk6IEVuY29kZXIuRGF0YVR5cGUge1xuICAgIHJldHVybiAnZmxvYXQnO1xuICAgIC8vIHN3aXRjaCAoZGF0YVR5cGUpIHtcbiAgICAvLyAgIGNhc2UgJ2ludDE2JzpcbiAgICAvLyAgIGNhc2UgJ2ludDMyJzpcbiAgICAvLyAgIGNhc2UgJ3VpbnQxNic6XG4gICAgLy8gICBjYXNlICd1aW50MzInOlxuICAgIC8vICAgICByZXR1cm4gJ2ludCc7XG4gICAgLy8gICBjYXNlICd1aW50OCc6XG4gICAgLy8gICBjYXNlICdib29sJzpcbiAgICAvLyAgICAgcmV0dXJuICdieXRlJztcbiAgICAvLyAgIGNhc2UgJ2Zsb2F0MzInOlxuICAgIC8vICAgY2FzZSAnZmxvYXQ2NCc6XG4gICAgLy8gICAgIHJldHVybiAnZmxvYXQnO1xuICAgIC8vICAgZGVmYXVsdDpcbiAgICAvLyAgICAgdGhyb3cgbmV3IEVycm9yKGBUZW5zb3JEYXRhIHR5cGUgJHtkYXRhVHlwZX0gaXMgbm90IHN1cHBvcnRlZGApO1xuICAgIC8vIH1cbiAgfVxuICBjbGVhckFjdGl2ZVRleHR1cmVzKCk6IHZvaWQge1xuICAgIHRoaXMuZ2xDb250ZXh0LmNsZWFyQWN0aXZlVGV4dHVyZXMoKTtcbiAgfVxufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBTZXNzaW9uSGFuZGxlciB9IGZyb20gJy4uLy4uL2JhY2tlbmQnO1xuaW1wb3J0IHsgR3JhcGggfSBmcm9tICcuLi8uLi9ncmFwaCc7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICcuLi8uLi9pbnN0cnVtZW50JztcbmltcG9ydCB7IE9wZXJhdG9yIH0gZnJvbSAnLi4vLi4vb3BlcmF0b3JzJztcbmltcG9ydCB7IE9wU2V0LCByZXNvbHZlT3BlcmF0b3IgfSBmcm9tICcuLi8uLi9vcHNldCc7XG5pbXBvcnQgeyBTZXNzaW9uIH0gZnJvbSAnLi4vLi4vc2Vzc2lvbic7XG5pbXBvcnQgeyBUZW5zb3IgfSBmcm9tICcuLi8uLi90ZW5zb3InO1xuaW1wb3J0IHsgV2ViR0xCYWNrZW5kIH0gZnJvbSAnLi4vYmFja2VuZC13ZWJnbCc7XG5cbmltcG9ydCB7IFdlYkdMSW5mZXJlbmNlSGFuZGxlciB9IGZyb20gJy4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHsgV0VCR0xfT1BfUkVTT0xWRV9SVUxFUyB9IGZyb20gJy4vb3AtcmVzb2x2ZS1ydWxlcyc7XG5pbXBvcnQgeyBQcm9ncmFtTWFuYWdlciB9IGZyb20gJy4vcHJvZ3JhbS1tYW5hZ2VyJztcbmltcG9ydCB7IFByZWZlckxvZ2ljYWxTdHJhdGVneSwgVGV4dHVyZUxheW91dFN0cmF0ZWd5IH0gZnJvbSAnLi90ZXh0dXJlLWxheW91dC1zdHJhdGVneSc7XG5pbXBvcnQgeyBUZXh0dXJlTWFuYWdlciB9IGZyb20gJy4vdGV4dHVyZS1tYW5hZ2VyJztcbmltcG9ydCB7IFRleHR1cmVEYXRhIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBjbGFzcyBXZWJHTFNlc3Npb25IYW5kbGVyIGltcGxlbWVudHMgU2Vzc2lvbkhhbmRsZXIge1xuICBwcm9ncmFtTWFuYWdlcjogUHJvZ3JhbU1hbmFnZXI7XG4gIHRleHR1cmVNYW5hZ2VyOiBUZXh0dXJlTWFuYWdlcjtcbiAgbGF5b3V0U3RyYXRlZ3k6IFRleHR1cmVMYXlvdXRTdHJhdGVneTtcbiAgcGFja2VkVGV4dHVyZURhdGFDYWNoZTogTWFwPFRlbnNvci5JZCwgVGV4dHVyZURhdGE+O1xuICB1bnBhY2tlZFRleHR1cmVEYXRhQ2FjaGU6IE1hcDxUZW5zb3IuSWQsIFRleHR1cmVEYXRhPjtcbiAgcGFjazJ1bnBhY2tNYXA6IE1hcDxUZW5zb3IuSWQsIFRlbnNvci5JZD47XG4gIHVucGFjazJwYWNrTWFwOiBNYXA8VGVuc29yLklkLCBUZW5zb3IuSWQ+O1xuICBpbml0aWFsaXplcnM6IFNldDxUZW5zb3IuSWQ+O1xuICBwYWNrPzogYm9vbGVhbjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgcmVhZG9ubHkgYmFja2VuZDogV2ViR0xCYWNrZW5kLFxuICAgIHB1YmxpYyByZWFkb25seSBjb250ZXh0OiBTZXNzaW9uLkNvbnRleHQsXG4gICkge1xuICAgIHRoaXMubGF5b3V0U3RyYXRlZ3kgPSBuZXcgUHJlZmVyTG9naWNhbFN0cmF0ZWd5KGJhY2tlbmQuZ2xDb250ZXh0Lm1heFRleHR1cmVTaXplKTtcbiAgICB0aGlzLnByb2dyYW1NYW5hZ2VyID0gbmV3IFByb2dyYW1NYW5hZ2VyKHRoaXMuY29udGV4dC5wcm9maWxlciwgYmFja2VuZC5nbENvbnRleHQsIHRoaXMubGF5b3V0U3RyYXRlZ3kpO1xuICAgIHRoaXMudGV4dHVyZU1hbmFnZXIgPSBuZXcgVGV4dHVyZU1hbmFnZXIoYmFja2VuZC5nbENvbnRleHQsIHRoaXMubGF5b3V0U3RyYXRlZ3ksIHRoaXMuY29udGV4dC5wcm9maWxlciwge1xuICAgICAgcmV1c2VUZXh0dXJlczogYmFja2VuZC50ZXh0dXJlQ2FjaGVNb2RlID09PSAnZnVsbCcsXG4gICAgfSk7XG4gICAgdGhpcy5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlID0gbmV3IE1hcCgpO1xuICAgIHRoaXMudW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlID0gbmV3IE1hcCgpO1xuICAgIHRoaXMucGFjayA9IGJhY2tlbmQucGFjaztcbiAgICB0aGlzLnBhY2sydW5wYWNrTWFwID0gbmV3IE1hcCgpO1xuICAgIHRoaXMudW5wYWNrMnBhY2tNYXAgPSBuZXcgTWFwKCk7XG4gIH1cblxuICBjcmVhdGVJbmZlcmVuY2VIYW5kbGVyKCkge1xuICAgIHJldHVybiBuZXcgV2ViR0xJbmZlcmVuY2VIYW5kbGVyKHRoaXMpO1xuICB9XG4gIG9uR3JhcGhJbml0aWFsaXplZChncmFwaDogR3JhcGgpOiB2b2lkIHtcbiAgICBjb25zdCBpbml0aWFsaXplcnMgPSBncmFwaFxuICAgICAgLmdldFZhbHVlcygpXG4gICAgICAuZmlsdGVyKCh2KSA9PiB2LmZyb20gPT09IC0xICYmIHYudGVuc29yKVxuICAgICAgLm1hcCgodikgPT4gdi50ZW5zb3IhLmRhdGFJZCk7XG4gICAgdGhpcy5pbml0aWFsaXplcnMgPSBuZXcgU2V0KGluaXRpYWxpemVycyk7XG4gIH1cbiAgaXNJbml0aWFsaXplcih0ZW5zb3JJZDogVGVuc29yLklkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaW5pdGlhbGl6ZXJzID8gdGhpcy5pbml0aWFsaXplcnMuaGFzKHRlbnNvcklkKSA6IGZhbHNlO1xuICB9XG4gIGFkZEluaXRpYWxpemVyKHRlbnNvcklkOiBUZW5zb3IuSWQpOiB2b2lkIHtcbiAgICB0aGlzLmluaXRpYWxpemVycy5hZGQodGVuc29ySWQpO1xuICB9XG4gIGdldFRleHR1cmVEYXRhKHRlbnNvcklkOiBUZW5zb3IuSWQsIGlzUGFja2VkOiBib29sZWFuKTogVGV4dHVyZURhdGEgfCB1bmRlZmluZWQge1xuICAgIGlmIChpc1BhY2tlZCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFja2VkVGV4dHVyZURhdGFDYWNoZS5nZXQodGVuc29ySWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy51bnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUuZ2V0KHRlbnNvcklkKTtcbiAgICB9XG4gIH1cbiAgc2V0VGV4dHVyZURhdGEodGVuc29ySWQ6IFRlbnNvci5JZCwgdGV4dHVyZURhdGE6IFRleHR1cmVEYXRhLCBpc1BhY2tlZCA9IGZhbHNlKTogdm9pZCB7XG4gICAgTG9nZ2VyLnZlcmJvc2UoJ1dlYkdMU2Vzc2lvbkhhbmRsZXInLCAnU3RvcmluZyBUZXh0dXJlIGRhdGEgaW4gY2FjaGUnKTtcbiAgICBpZiAoaXNQYWNrZWQpIHtcbiAgICAgIHRoaXMucGFja2VkVGV4dHVyZURhdGFDYWNoZS5zZXQodGVuc29ySWQsIHRleHR1cmVEYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51bnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUuc2V0KHRlbnNvcklkLCB0ZXh0dXJlRGF0YSk7XG4gICAgfVxuICB9XG4gIGRpc3Bvc2UoKTogdm9pZCB7XG4gICAgdGhpcy5wcm9ncmFtTWFuYWdlci5kaXNwb3NlKCk7XG4gICAgdGhpcy50ZXh0dXJlTWFuYWdlci5jbGVhckFjdGl2ZVRleHR1cmVzKCk7XG4gICAgdGhpcy5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlLmZvckVhY2goKHRkKSA9PiB0aGlzLnRleHR1cmVNYW5hZ2VyLnJlbGVhc2VUZXh0dXJlKHRkLCB0cnVlKSk7XG4gICAgdGhpcy5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlID0gbmV3IE1hcCgpO1xuICAgIHRoaXMudW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlLmZvckVhY2goKHRkKSA9PiB0aGlzLnRleHR1cmVNYW5hZ2VyLnJlbGVhc2VUZXh0dXJlKHRkLCB0cnVlKSk7XG4gICAgdGhpcy51bnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUgPSBuZXcgTWFwKCk7XG4gIH1cbiAgcmVzb2x2ZShub2RlOiBHcmFwaC5Ob2RlLCBvcHNldHM6IHJlYWRvbmx5IE9wU2V0W10sIGdyYXBoOiBHcmFwaCk6IE9wZXJhdG9yIHtcbiAgICBjb25zdCBvcCA9IHJlc29sdmVPcGVyYXRvcihub2RlLCBvcHNldHMsIFdFQkdMX09QX1JFU09MVkVfUlVMRVMpO1xuICAgIHJldHVybiB7IGltcGw6IG9wLm9wSW1wbCwgY29udGV4dDogb3Aub3BJbml0ID8gb3Aub3BJbml0KG5vZGUsIGdyYXBoKSA6IG5vZGUgfTtcbiAgfVxufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBlbnYgfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG5pbXBvcnQgKiBhcyBEYXRhRW5jb2RlcnMgZnJvbSAnLi90ZXh0dXJlLWRhdGEtZW5jb2Rlcic7XG5pbXBvcnQgeyBEYXRhRW5jb2RlciwgRW5jb2RlciwgRW5jb2RlclVzYWdlIH0gZnJvbSAnLi90ZXh0dXJlLWRhdGEtZW5jb2Rlcic7XG5pbXBvcnQgeyByZXBlYXRlZFRyeSB9IGZyb20gJy4vdXRpbHMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIEZlbmNlQ29udGV4dCB7XG4gIHF1ZXJ5OiBXZWJHTFN5bmMgfCBudWxsO1xuICBpc0ZlbmNlUGFzc2VkKCk6IGJvb2xlYW47XG59XG5cbnR5cGUgUG9sbEl0ZW0gPSB7XG4gIGlzRG9uZUZuOiAoKSA9PiBib29sZWFuO1xuICByZXNvbHZlRm46ICgpID0+IHZvaWQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gbGluZWFyU2VhcmNoTGFzdFRydWUoYXJyOiBBcnJheTwoKSA9PiBib29sZWFuPik6IG51bWJlciB7XG4gIGxldCBpID0gMDtcbiAgZm9yICg7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBpc0RvbmUgPSBhcnJbaV0oKTtcbiAgICBpZiAoIWlzRG9uZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBpIC0gMTtcbn1cblxuLyoqXG4gKiBBYnN0cmFjdGlvbiBhbmQgd3JhcHBlciBhcm91bmQgV2ViR0xSZW5kZXJpbmdDb250ZXh0IGFuZCBpdHMgb3BlcmF0aW9uc1xuICovXG5leHBvcnQgY2xhc3MgV2ViR0xDb250ZXh0IHtcbiAgZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dDtcbiAgdmVyc2lvbjogMSB8IDI7XG5cbiAgcHJpdmF0ZSB2ZXJ0ZXhidWZmZXI6IFdlYkdMQnVmZmVyO1xuICBwcml2YXRlIGZyYW1lYnVmZmVyOiBXZWJHTEZyYW1lYnVmZmVyO1xuXG4gIC8vIFdlYkdMIGZsYWdzIGFuZCB2aXRhbCBwYXJhbWV0ZXJzXG4gIHByaXZhdGUgaXNGbG9hdFRleHR1cmVBdHRhY2hhYmxlVG9GcmFtZUJ1ZmZlcjogYm9vbGVhbjtcbiAgaXNGbG9hdDMyRG93bmxvYWRTdXBwb3J0ZWQ6IGJvb2xlYW47XG4gIGlzUmVuZGVyRmxvYXQzMlN1cHBvcnRlZDogYm9vbGVhbjtcbiAgaXNCbGVuZFN1cHBvcnRlZDogYm9vbGVhbjtcbiAgbWF4VGV4dHVyZVNpemU6IG51bWJlcjtcbiAgLy8gcHJpdmF0ZSBtYXhDb21iaW5lZFRleHR1cmVJbWFnZVVuaXRzOiBudW1iZXI7XG4gIHByaXZhdGUgbWF4VGV4dHVyZUltYWdlVW5pdHM6IG51bWJlcjtcbiAgLy8gcHJpdmF0ZSBtYXhDdWJlTWFwVGV4dHVyZVNpemU6IG51bWJlcjtcbiAgLy8gcHJpdmF0ZSBzaGFkaW5nTGFuZ3VhZ2VWZXJzaW9uOiBzdHJpbmc7XG4gIC8vIHByaXZhdGUgd2ViZ2xWZW5kb3I6IHN0cmluZztcbiAgLy8gcHJpdmF0ZSB3ZWJnbFZlcnNpb246IHN0cmluZztcblxuICAvLyBXZWJHTDIgZmxhZ3MgYW5kIHZpdGFsIHBhcmFtZXRlcnNcbiAgLy8gcHJpdmF0ZSBtYXgzRFRleHR1cmVTaXplOiBudW1iZXI7XG4gIC8vIHByaXZhdGUgbWF4QXJyYXlUZXh0dXJlTGF5ZXJzOiBudW1iZXI7XG4gIC8vIHByaXZhdGUgbWF4Q29sb3JBdHRhY2htZW50czogbnVtYmVyO1xuICAvLyBwcml2YXRlIG1heERyYXdCdWZmZXJzOiBudW1iZXI7XG5cbiAgLy8gV2ViR0wgZXh0ZW5zaW9uc1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2FtZWxjYXNlXG4gIHRleHR1cmVGbG9hdEV4dGVuc2lvbjogT0VTX3RleHR1cmVfZmxvYXQgfCBudWxsO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2FtZWxjYXNlXG4gIHRleHR1cmVIYWxmRmxvYXRFeHRlbnNpb246IE9FU190ZXh0dXJlX2hhbGZfZmxvYXQgfCBudWxsO1xuXG4gIC8vIFdlYkdMMiBleHRlbnNpb25zXG4gIGNvbG9yQnVmZmVyRmxvYXRFeHRlbnNpb246IHVua25vd24gfCBudWxsO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG4gIGRpc2pvaW50VGltZXJRdWVyeVdlYmdsMkV4dGVuc2lvbjogeyBUSU1FX0VMQVBTRURfRVhUOiBHTGVudW07IEdQVV9ESVNKT0lOVF9FWFQ6IEdMZW51bSB9IHwgbnVsbDtcblxuICBwcml2YXRlIGRpc3Bvc2VkOiBib29sZWFuO1xuICBwcml2YXRlIGZyYW1lQnVmZmVyQm91bmQgPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCB2ZXJzaW9uOiAxIHwgMikge1xuICAgIHRoaXMuZ2wgPSBnbDtcbiAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuXG4gICAgdGhpcy5nZXRFeHRlbnNpb25zKCk7XG4gICAgdGhpcy52ZXJ0ZXhidWZmZXIgPSB0aGlzLmNyZWF0ZVZlcnRleGJ1ZmZlcigpO1xuICAgIHRoaXMuZnJhbWVidWZmZXIgPSB0aGlzLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgdGhpcy5xdWVyeVZpdGFsUGFyYW1ldGVycygpO1xuICB9XG5cbiAgYWxsb2NhdGVUZXh0dXJlKHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyLCBlbmNvZGVyOiBEYXRhRW5jb2RlciwgZGF0YT86IEVuY29kZXIuRGF0YUFycmF5VHlwZSk6IFdlYkdMVGV4dHVyZSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgIC8vIGNyZWF0ZSB0aGUgdGV4dHVyZVxuICAgIGNvbnN0IHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgLy8gYmluZCB0aGUgdGV4dHVyZSBzbyB0aGUgZm9sbG93aW5nIG1ldGhvZHMgZWZmZWN0IHRoaXMgdGV4dHVyZS5cbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgIGNvbnN0IGJ1ZmZlciA9IGRhdGEgPyBlbmNvZGVyLmVuY29kZShkYXRhLCB3aWR0aCAqIGhlaWdodCkgOiBudWxsO1xuICAgIGdsLnRleEltYWdlMkQoXG4gICAgICBnbC5URVhUVVJFXzJELFxuICAgICAgMCwgLy8gTGV2ZWwgb2YgZGV0YWlsLlxuICAgICAgZW5jb2Rlci5pbnRlcm5hbEZvcm1hdCxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgMCwgLy8gQWx3YXlzIDAgaW4gT3BlbkdMIEVTLlxuICAgICAgZW5jb2Rlci5mb3JtYXQsXG4gICAgICBlbmNvZGVyLnRleHR1cmVUeXBlLFxuICAgICAgYnVmZmVyLFxuICAgICk7XG4gICAgdGhpcy5jaGVja0Vycm9yKCk7XG4gICAgcmV0dXJuIHRleHR1cmUgYXMgV2ViR0xUZXh0dXJlO1xuICB9XG4gIHVwZGF0ZVRleHR1cmUoXG4gICAgdGV4dHVyZTogV2ViR0xUZXh0dXJlLFxuICAgIHdpZHRoOiBudW1iZXIsXG4gICAgaGVpZ2h0OiBudW1iZXIsXG4gICAgZW5jb2RlcjogRGF0YUVuY29kZXIsXG4gICAgZGF0YTogRW5jb2Rlci5EYXRhQXJyYXlUeXBlLFxuICApOiB2b2lkIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgY29uc3QgYnVmZmVyID0gZW5jb2Rlci5lbmNvZGUoZGF0YSwgd2lkdGggKiBoZWlnaHQpO1xuICAgIGdsLnRleFN1YkltYWdlMkQoXG4gICAgICBnbC5URVhUVVJFXzJELFxuICAgICAgMCwgLy8gbGV2ZWxcbiAgICAgIDAsIC8vIHhvZmZzZXRcbiAgICAgIDAsIC8vIHlvZmZzZXRcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgZW5jb2Rlci5mb3JtYXQsXG4gICAgICBlbmNvZGVyLnRleHR1cmVUeXBlLFxuICAgICAgYnVmZmVyLFxuICAgICk7XG4gICAgdGhpcy5jaGVja0Vycm9yKCk7XG4gIH1cbiAgYXR0YWNoRnJhbWVidWZmZXIodGV4dHVyZTogV2ViR0xUZXh0dXJlLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICAvLyBNYWtlIGl0IHRoZSB0YXJnZXQgZm9yIGZyYW1lYnVmZmVyIG9wZXJhdGlvbnMgLSBpbmNsdWRpbmcgcmVuZGVyaW5nLlxuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5mcmFtZWJ1ZmZlcik7XG4gICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCB0ZXh0dXJlLCAwKTsgLy8gMCwgd2UgYXJlbid0IHVzaW5nIE1JUE1BUHNcbiAgICB0aGlzLmNoZWNrRXJyb3IoKTtcbiAgICBnbC52aWV3cG9ydCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBnbC5zY2lzc29yKDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICB9XG4gIHJlYWRUZXh0dXJlKFxuICAgIHRleHR1cmU6IFdlYkdMVGV4dHVyZSxcbiAgICB3aWR0aDogbnVtYmVyLFxuICAgIGhlaWdodDogbnVtYmVyLFxuICAgIGRhdGFTaXplOiBudW1iZXIsXG4gICAgZGF0YVR5cGU6IEVuY29kZXIuRGF0YVR5cGUsXG4gICAgY2hhbm5lbHM6IG51bWJlcixcbiAgKTogRW5jb2Rlci5EYXRhQXJyYXlUeXBlIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgaWYgKCFjaGFubmVscykge1xuICAgICAgY2hhbm5lbHMgPSAxO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuZnJhbWVCdWZmZXJCb3VuZCkge1xuICAgICAgdGhpcy5hdHRhY2hGcmFtZWJ1ZmZlcih0ZXh0dXJlLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG4gICAgY29uc3QgZW5jb2RlciA9IHRoaXMuZ2V0RW5jb2RlcihkYXRhVHlwZSwgY2hhbm5lbHMpO1xuICAgIGNvbnN0IGJ1ZmZlciA9IGVuY29kZXIuYWxsb2NhdGUod2lkdGggKiBoZWlnaHQpO1xuICAgIC8vIGJpbmQgdGV4dHVyZSB0byBmcmFtZWJ1ZmZlclxuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSwgMCk7IC8vIDAsIHdlIGFyZW4ndCB1c2luZyBNSVBNQVBzXG4gICAgLy8gVE9ETzogQ2hlY2sgaWYgZnJhbWVidWZmZXIgaXMgcmVhZHlcbiAgICBnbC5yZWFkUGl4ZWxzKDAsIDAsIHdpZHRoLCBoZWlnaHQsIGdsLlJHQkEsIGVuY29kZXIudGV4dHVyZVR5cGUsIGJ1ZmZlcik7XG4gICAgdGhpcy5jaGVja0Vycm9yKCk7XG4gICAgLy8gdW5iaW5kIEZCXG4gICAgcmV0dXJuIGVuY29kZXIuZGVjb2RlKGJ1ZmZlciwgZGF0YVNpemUpO1xuICB9XG5cbiAgaXNGcmFtZWJ1ZmZlclJlYWR5KCk6IGJvb2xlYW4ge1xuICAgIC8vIFRPRE86IEltcGxlbWVudCBsb2dpYyB0byBjaGVjayBpZiB0aGUgZnJhbWVidWZmZXIgaXMgcmVhZHlcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBnZXRBY3RpdmVUZXh0dXJlKCk6IHN0cmluZyB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgIGNvbnN0IG4gPSBnbC5nZXRQYXJhbWV0ZXIodGhpcy5nbC5BQ1RJVkVfVEVYVFVSRSk7XG4gICAgcmV0dXJuIGBURVhUVVJFJHtuIC0gZ2wuVEVYVFVSRTB9YDtcbiAgfVxuICBnZXRUZXh0dXJlQmluZGluZygpOiBXZWJHTFRleHR1cmUge1xuICAgIHJldHVybiB0aGlzLmdsLmdldFBhcmFtZXRlcih0aGlzLmdsLlRFWFRVUkVfQklORElOR18yRCk7XG4gIH1cbiAgZ2V0RnJhbWVidWZmZXJCaW5kaW5nKCk6IFdlYkdMRnJhbWVidWZmZXIge1xuICAgIHJldHVybiB0aGlzLmdsLmdldFBhcmFtZXRlcih0aGlzLmdsLkZSQU1FQlVGRkVSX0JJTkRJTkcpO1xuICB9XG4gIHNldFZlcnRleEF0dHJpYnV0ZXMocG9zaXRpb25IYW5kbGU6IG51bWJlciwgdGV4dHVyZUNvb3JkSGFuZGxlOiBudW1iZXIpOiB2b2lkIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihwb3NpdGlvbkhhbmRsZSwgMywgZ2wuRkxPQVQsIGZhbHNlLCAyMCwgMCk7XG4gICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocG9zaXRpb25IYW5kbGUpO1xuICAgIGlmICh0ZXh0dXJlQ29vcmRIYW5kbGUgIT09IC0xKSB7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRleHR1cmVDb29yZEhhbmRsZSwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAyMCwgMTIpO1xuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGV4dHVyZUNvb3JkSGFuZGxlKTtcbiAgICB9XG4gICAgdGhpcy5jaGVja0Vycm9yKCk7XG4gIH1cbiAgY3JlYXRlUHJvZ3JhbSh2ZXJ0ZXhTaGFkZXI6IFdlYkdMU2hhZGVyLCBmcmFnU2hhZGVyOiBXZWJHTFNoYWRlcik6IFdlYkdMUHJvZ3JhbSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgIGNvbnN0IHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCkhO1xuXG4gICAgLy8gdGhlIHByb2dyYW0gY29uc2lzdHMgb2Ygb3VyIHNoYWRlcnNcbiAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdmVydGV4U2hhZGVyKTtcbiAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ1NoYWRlcik7XG4gICAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XG4gICAgcmV0dXJuIHByb2dyYW07XG4gIH1cbiAgY29tcGlsZVNoYWRlcihzaGFkZXJTb3VyY2U6IHN0cmluZywgc2hhZGVyVHlwZTogbnVtYmVyKTogV2ViR0xTaGFkZXIge1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICBjb25zdCBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoc2hhZGVyVHlwZSk7XG4gICAgaWYgKCFzaGFkZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgY3JlYXRlU2hhZGVyKCkgcmV0dXJuZWQgbnVsbCB3aXRoIHR5cGUgJHtzaGFkZXJUeXBlfWApO1xuICAgIH1cblxuICAgIGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNoYWRlclNvdXJjZSk7XG4gICAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xuICAgIGlmIChnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjb21waWxlIHNoYWRlcjogJHtnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcil9XG5TaGFkZXIgc291cmNlOlxuJHtzaGFkZXJTb3VyY2V9YCk7XG4gICAgfVxuICAgIHJldHVybiBzaGFkZXI7XG4gIH1cbiAgZGVsZXRlU2hhZGVyKHNoYWRlcjogV2ViR0xTaGFkZXIpOiB2b2lkIHtcbiAgICB0aGlzLmdsLmRlbGV0ZVNoYWRlcihzaGFkZXIpO1xuICB9XG4gIGJpbmRUZXh0dXJlVG9Vbmlmb3JtKHRleHR1cmU6IFdlYkdMVGV4dHVyZSwgcG9zaXRpb246IG51bWJlciwgdW5pZm9ybUhhbmRsZTogV2ViR0xVbmlmb3JtTG9jYXRpb24pOiB2b2lkIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHBvc2l0aW9uKTtcbiAgICB0aGlzLmNoZWNrRXJyb3IoKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICB0aGlzLmNoZWNrRXJyb3IoKTtcbiAgICBnbC51bmlmb3JtMWkodW5pZm9ybUhhbmRsZSwgcG9zaXRpb24pO1xuICAgIHRoaXMuY2hlY2tFcnJvcigpO1xuICB9XG4gIGRyYXcoKTogdm9pZCB7XG4gICAgdGhpcy5nbC5kcmF3QXJyYXlzKHRoaXMuZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQpO1xuICAgIHRoaXMuY2hlY2tFcnJvcigpO1xuICB9XG4gIGNoZWNrRXJyb3IoKTogdm9pZCB7XG4gICAgaWYgKGVudi5kZWJ1Zykge1xuICAgICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgICAgY29uc3QgZXJyb3IgPSBnbC5nZXRFcnJvcigpO1xuICAgICAgbGV0IGxhYmVsID0gJyc7XG4gICAgICBzd2l0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNhc2UgZ2wuTk9fRVJST1I6XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIGdsLklOVkFMSURfRU5VTTpcbiAgICAgICAgICBsYWJlbCA9ICdJTlZBTElEX0VOVU0nO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGdsLklOVkFMSURfVkFMVUU6XG4gICAgICAgICAgbGFiZWwgPSAnSU5WQUxJRF9WQUxVRSc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgZ2wuSU5WQUxJRF9PUEVSQVRJT046XG4gICAgICAgICAgbGFiZWwgPSAnSU5WQUxJRF9PUEVSQVRJT04nO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGdsLklOVkFMSURfRlJBTUVCVUZGRVJfT1BFUkFUSU9OOlxuICAgICAgICAgIGxhYmVsID0gJ0lOVkFMSURfRlJBTUVCVUZGRVJfT1BFUkFUSU9OJztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBnbC5PVVRfT0ZfTUVNT1JZOlxuICAgICAgICAgIGxhYmVsID0gJ09VVF9PRl9NRU1PUlknO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGdsLkNPTlRFWFRfTE9TVF9XRUJHTDpcbiAgICAgICAgICBsYWJlbCA9ICdDT05URVhUX0xPU1RfV0VCR0wnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGxhYmVsID0gYFVua25vd24gV2ViR0wgRXJyb3I6ICR7ZXJyb3IudG9TdHJpbmcoMTYpfWA7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobGFiZWwpO1xuICAgIH1cbiAgfVxuICBkZWxldGVUZXh0dXJlKHRleHR1cmU6IFdlYkdMVGV4dHVyZSk6IHZvaWQge1xuICAgIHRoaXMuZ2wuZGVsZXRlVGV4dHVyZSh0ZXh0dXJlKTtcbiAgfVxuICBkZWxldGVQcm9ncmFtKHByb2dyYW06IFdlYkdMUHJvZ3JhbSk6IHZvaWQge1xuICAgIHRoaXMuZ2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKTtcbiAgfVxuICBnZXRFbmNvZGVyKGRhdGFUeXBlOiBFbmNvZGVyLkRhdGFUeXBlLCBjaGFubmVsczogbnVtYmVyLCB1c2FnZTogRW5jb2RlclVzYWdlID0gRW5jb2RlclVzYWdlLkRlZmF1bHQpOiBEYXRhRW5jb2RlciB7XG4gICAgaWYgKHRoaXMudmVyc2lvbiA9PT0gMikge1xuICAgICAgcmV0dXJuIG5ldyBEYXRhRW5jb2RlcnMuUmVkRmxvYXQzMkRhdGFFbmNvZGVyKHRoaXMuZ2wgYXMgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCwgY2hhbm5lbHMpO1xuICAgIH1cblxuICAgIHN3aXRjaCAoZGF0YVR5cGUpIHtcbiAgICAgIGNhc2UgJ2Zsb2F0JzpcbiAgICAgICAgaWYgKHVzYWdlID09PSBFbmNvZGVyVXNhZ2UuVXBsb2FkT25seSB8fCB0aGlzLmlzUmVuZGVyRmxvYXQzMlN1cHBvcnRlZCkge1xuICAgICAgICAgIHJldHVybiBuZXcgRGF0YUVuY29kZXJzLlJHQkFGbG9hdERhdGFFbmNvZGVyKHRoaXMuZ2wsIGNoYW5uZWxzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbmV3IERhdGFFbmNvZGVycy5SR0JBRmxvYXREYXRhRW5jb2RlcihcbiAgICAgICAgICAgIHRoaXMuZ2wsXG4gICAgICAgICAgICBjaGFubmVscyxcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZUhhbGZGbG9hdEV4dGVuc2lvbiEuSEFMRl9GTE9BVF9PRVMsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAnaW50JzpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbiAgICAgIGNhc2UgJ2J5dGUnOlxuICAgICAgICByZXR1cm4gbmV3IERhdGFFbmNvZGVycy5VaW50OERhdGFFbmNvZGVyKHRoaXMuZ2wsIGNoYW5uZWxzKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkYXRhVHlwZTogJHtkYXRhVHlwZX1gKTtcbiAgICB9XG4gIH1cbiAgY2xlYXJBY3RpdmVUZXh0dXJlcygpOiB2b2lkIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgZm9yIChsZXQgdW5pdCA9IDA7IHVuaXQgPCB0aGlzLm1heFRleHR1cmVJbWFnZVVuaXRzOyArK3VuaXQpIHtcbiAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB1bml0KTtcbiAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpO1xuICAgIH1cbiAgfVxuICBkaXNwb3NlKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmRpc3Bvc2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuICAgIGdsLmRlbGV0ZUZyYW1lYnVmZmVyKHRoaXMuZnJhbWVidWZmZXIpO1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBudWxsKTtcbiAgICBnbC5kZWxldGVCdWZmZXIodGhpcy52ZXJ0ZXhidWZmZXIpO1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIG51bGwpO1xuICAgIGdsLmZpbmlzaCgpO1xuICAgIHRoaXMuZGlzcG9zZWQgPSB0cnVlO1xuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVEZWZhdWx0R2VvbWV0cnkoKTogRmxvYXQzMkFycmF5IHtcbiAgICAvLyBTZXRzIG9mIHgseSx6KD0wKSxzLHQgY29vcmRpbmF0ZXMuXG4gICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoW1xuICAgICAgLTEuMCxcbiAgICAgIDEuMCxcbiAgICAgIDAuMCxcbiAgICAgIDAuMCxcbiAgICAgIDEuMCwgLy8gdXBwZXIgbGVmdFxuICAgICAgLTEuMCxcbiAgICAgIC0xLjAsXG4gICAgICAwLjAsXG4gICAgICAwLjAsXG4gICAgICAwLjAsIC8vIGxvd2VyIGxlZnRcbiAgICAgIDEuMCxcbiAgICAgIDEuMCxcbiAgICAgIDAuMCxcbiAgICAgIDEuMCxcbiAgICAgIDEuMCwgLy8gdXBwZXIgcmlnaHRcbiAgICAgIDEuMCxcbiAgICAgIC0xLjAsXG4gICAgICAwLjAsXG4gICAgICAxLjAsXG4gICAgICAwLjAsIC8vIGxvd2VyIHJpZ2h0XG4gICAgXSk7XG4gIH1cbiAgcHJpdmF0ZSBjcmVhdGVWZXJ0ZXhidWZmZXIoKTogV2ViR0xCdWZmZXIge1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICBjb25zdCBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBpZiAoIWJ1ZmZlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjcmVhdGVCdWZmZXIoKSByZXR1cm5lZCBudWxsJyk7XG4gICAgfVxuICAgIGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5jcmVhdGVEZWZhdWx0R2VvbWV0cnkoKTtcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcbiAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnksIGdsLlNUQVRJQ19EUkFXKTtcbiAgICB0aGlzLmNoZWNrRXJyb3IoKTtcbiAgICByZXR1cm4gYnVmZmVyO1xuICB9XG4gIHByaXZhdGUgY3JlYXRlRnJhbWVidWZmZXIoKTogV2ViR0xGcmFtZWJ1ZmZlciB7XG4gICAgY29uc3QgZmIgPSB0aGlzLmdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgaWYgKCFmYikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjcmVhdGVGcmFtZWJ1ZmZlciByZXR1cm5lZCBudWxsJyk7XG4gICAgfVxuICAgIHJldHVybiBmYjtcbiAgfVxuXG4gIHByaXZhdGUgcXVlcnlWaXRhbFBhcmFtZXRlcnMoKTogdm9pZCB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuXG4gICAgdGhpcy5pc0Zsb2F0VGV4dHVyZUF0dGFjaGFibGVUb0ZyYW1lQnVmZmVyID0gdGhpcy5jaGVja0Zsb2F0VGV4dHVyZUF0dGFjaGFibGVUb0ZyYW1lQnVmZmVyKCk7XG4gICAgdGhpcy5pc1JlbmRlckZsb2F0MzJTdXBwb3J0ZWQgPSB0aGlzLmNoZWNrUmVuZGVyRmxvYXQzMigpO1xuICAgIHRoaXMuaXNGbG9hdDMyRG93bmxvYWRTdXBwb3J0ZWQgPSB0aGlzLmNoZWNrRmxvYXQzMkRvd25sb2FkKCk7XG5cbiAgICBpZiAodGhpcy52ZXJzaW9uID09PSAxICYmICF0aGlzLnRleHR1cmVIYWxmRmxvYXRFeHRlbnNpb24gJiYgIXRoaXMuaXNSZW5kZXJGbG9hdDMyU3VwcG9ydGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JvdGggZmxvYXQzMiBhbmQgZmxvYXQxNiBUZXh0dXJlVHlwZSBhcmUgbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cblxuICAgIHRoaXMuaXNCbGVuZFN1cHBvcnRlZCA9ICF0aGlzLmlzUmVuZGVyRmxvYXQzMlN1cHBvcnRlZCB8fCB0aGlzLmNoZWNrRmxvYXQzMkJsZW5kKCk7XG5cbiAgICAvLyB0aGlzLm1heENvbWJpbmVkVGV4dHVyZUltYWdlVW5pdHMgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX0NPTUJJTkVEX1RFWFRVUkVfSU1BR0VfVU5JVFMpO1xuICAgIHRoaXMubWF4VGV4dHVyZVNpemUgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX1RFWFRVUkVfU0laRSk7XG4gICAgdGhpcy5tYXhUZXh0dXJlSW1hZ2VVbml0cyA9IGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVEVYVFVSRV9JTUFHRV9VTklUUyk7XG4gICAgLy8gdGhpcy5tYXhDdWJlTWFwVGV4dHVyZVNpemUgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX0NVQkVfTUFQX1RFWFRVUkVfU0laRSk7XG4gICAgLy8gdGhpcy5zaGFkaW5nTGFuZ3VhZ2VWZXJzaW9uID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLlNIQURJTkdfTEFOR1VBR0VfVkVSU0lPTik7XG4gICAgLy8gdGhpcy53ZWJnbFZlbmRvciA9IGdsLmdldFBhcmFtZXRlcihnbC5WRU5ET1IpO1xuICAgIC8vIHRoaXMud2ViZ2xWZXJzaW9uID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLlZFUlNJT04pO1xuXG4gICAgaWYgKHRoaXMudmVyc2lvbiA9PT0gMikge1xuICAgICAgLy8gdGhpcy5tYXgzRFRleHR1cmVTaXplID0gZ2wuZ2V0UGFyYW1ldGVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuTUFYXzNEX1RFWFRVUkVfU0laRSk7XG4gICAgICAvLyB0aGlzLm1heEFycmF5VGV4dHVyZUxheWVycyA9IGdsLmdldFBhcmFtZXRlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk1BWF9BUlJBWV9URVhUVVJFX0xBWUVSUyk7XG4gICAgICAvLyB0aGlzLm1heENvbG9yQXR0YWNobWVudHMgPSBnbC5nZXRQYXJhbWV0ZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5NQVhfQ09MT1JfQVRUQUNITUVOVFMpO1xuICAgICAgLy8gdGhpcy5tYXhEcmF3QnVmZmVycyA9IGdsLmdldFBhcmFtZXRlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk1BWF9EUkFXX0JVRkZFUlMpO1xuICAgIH1cbiAgfVxuICBwcml2YXRlIGdldEV4dGVuc2lvbnMoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMudmVyc2lvbiA9PT0gMikge1xuICAgICAgdGhpcy5jb2xvckJ1ZmZlckZsb2F0RXh0ZW5zaW9uID0gdGhpcy5nbC5nZXRFeHRlbnNpb24oJ0VYVF9jb2xvcl9idWZmZXJfZmxvYXQnKTtcbiAgICAgIHRoaXMuZGlzam9pbnRUaW1lclF1ZXJ5V2ViZ2wyRXh0ZW5zaW9uID0gdGhpcy5nbC5nZXRFeHRlbnNpb24oJ0VYVF9kaXNqb2ludF90aW1lcl9xdWVyeV93ZWJnbDInKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50ZXh0dXJlRmxvYXRFeHRlbnNpb24gPSB0aGlzLmdsLmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXQnKTtcbiAgICAgIHRoaXMudGV4dHVyZUhhbGZGbG9hdEV4dGVuc2lvbiA9IHRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKCdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0Jyk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjaGVja0Zsb2F0VGV4dHVyZUF0dGFjaGFibGVUb0ZyYW1lQnVmZmVyKCk6IGJvb2xlYW4ge1xuICAgIC8vIHRlc3Qgd2hldGhlciBGbG9hdDMyIHRleHR1cmUgaXMgc3VwcG9ydGVkOlxuICAgIC8vIFNURVAuMSBjcmVhdGUgYSBmbG9hdCB0ZXh0dXJlXG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgIGNvbnN0IHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuICAgIGNvbnN0IGludGVybmFsRm9ybWF0ID0gdGhpcy52ZXJzaW9uID09PSAyID8gKGdsIGFzIHVua25vd24gYXMgeyBSR0JBMzJGOiBudW1iZXIgfSkuUkdCQTMyRiA6IGdsLlJHQkE7XG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBpbnRlcm5hbEZvcm1hdCwgMSwgMSwgMCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIG51bGwpO1xuICAgIC8vIFNURVAuMiBiaW5kIGEgZnJhbWUgYnVmZmVyXG4gICAgY29uc3QgZnJhbWVCdWZmZXIgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZnJhbWVCdWZmZXIpO1xuICAgIC8vIFNURVAuMyBhdHRhY2ggdGV4dHVyZSB0byBmcmFtZWJ1ZmZlclxuICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSwgMCk7XG4gICAgLy8gU1RFUC40IHRlc3Qgd2hldGhlciBmcmFtZWJ1ZmZlciBpcyBjb21wbGV0ZVxuICAgIGNvbnN0IGlzQ29tcGxldGUgPSBnbC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKGdsLkZSQU1FQlVGRkVSKSA9PT0gZ2wuRlJBTUVCVUZGRVJfQ09NUExFVEU7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcbiAgICBnbC5kZWxldGVUZXh0dXJlKHRleHR1cmUpO1xuICAgIGdsLmRlbGV0ZUZyYW1lYnVmZmVyKGZyYW1lQnVmZmVyKTtcbiAgICByZXR1cm4gaXNDb21wbGV0ZTtcbiAgfVxuXG4gIHByaXZhdGUgY2hlY2tSZW5kZXJGbG9hdDMyKCk6IGJvb2xlYW4ge1xuICAgIGlmICh0aGlzLnZlcnNpb24gPT09IDIpIHtcbiAgICAgIGlmICghdGhpcy5jb2xvckJ1ZmZlckZsb2F0RXh0ZW5zaW9uKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCF0aGlzLnRleHR1cmVGbG9hdEV4dGVuc2lvbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmlzRmxvYXRUZXh0dXJlQXR0YWNoYWJsZVRvRnJhbWVCdWZmZXI7XG4gIH1cblxuICBwcml2YXRlIGNoZWNrRmxvYXQzMkRvd25sb2FkKCk6IGJvb2xlYW4ge1xuICAgIGlmICh0aGlzLnZlcnNpb24gPT09IDIpIHtcbiAgICAgIGlmICghdGhpcy5jb2xvckJ1ZmZlckZsb2F0RXh0ZW5zaW9uKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCF0aGlzLnRleHR1cmVGbG9hdEV4dGVuc2lvbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9jb2xvcl9idWZmZXJfZmxvYXQnKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmlzRmxvYXRUZXh0dXJlQXR0YWNoYWJsZVRvRnJhbWVCdWZmZXI7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciBHTF9CTEVORCBpcyBzdXBwb3J0ZWRcbiAgICovXG4gIHByaXZhdGUgY2hlY2tGbG9hdDMyQmxlbmQoKTogYm9vbGVhbiB7XG4gICAgLy8gaXQgbG9va3MgbGlrZSBjdXJyZW50bHkgKDIwMTktMDUtMDgpIHRoZXJlIGlzIG5vIGVhc3kgd2F5IHRvIGRldGVjdCB3aGV0aGVyIEJMRU5EIGlzIHN1cHBvcnRlZFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvb25ueGpzL2lzc3Vlcy8xNDVcblxuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcblxuICAgIGxldCB0ZXh0dXJlOiBXZWJHTFRleHR1cmUgfCBudWxsIHwgdW5kZWZpbmVkO1xuICAgIGxldCBmcmFtZUJ1ZmZlcjogV2ViR0xGcmFtZWJ1ZmZlciB8IG51bGwgfCB1bmRlZmluZWQ7XG4gICAgbGV0IHZlcnRleFNoYWRlcjogV2ViR0xTaGFkZXIgfCBudWxsIHwgdW5kZWZpbmVkO1xuICAgIGxldCBmcmFnbWVudFNoYWRlcjogV2ViR0xTaGFkZXIgfCBudWxsIHwgdW5kZWZpbmVkO1xuICAgIGxldCBwcm9ncmFtOiBXZWJHTFByb2dyYW0gfCBudWxsIHwgdW5kZWZpbmVkO1xuXG4gICAgdHJ5IHtcbiAgICAgIHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICBmcmFtZUJ1ZmZlciA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuICAgICAgY29uc3QgaW50ZXJuYWxGb3JtYXQgPSB0aGlzLnZlcnNpb24gPT09IDIgPyAoZ2wgYXMgdW5rbm93biBhcyB7IFJHQkEzMkY6IG51bWJlciB9KS5SR0JBMzJGIDogZ2wuUkdCQTtcbiAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgaW50ZXJuYWxGb3JtYXQsIDEsIDEsIDAsIGdsLlJHQkEsIGdsLkZMT0FULCBudWxsKTtcblxuICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZUJ1ZmZlcik7XG4gICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRleHR1cmUsIDApO1xuXG4gICAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xuXG4gICAgICB2ZXJ0ZXhTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoZ2wuVkVSVEVYX1NIQURFUik7XG4gICAgICBpZiAoIXZlcnRleFNoYWRlcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBnbC5zaGFkZXJTb3VyY2UodmVydGV4U2hhZGVyLCAndm9pZCBtYWluKCl7fScpO1xuICAgICAgZ2wuY29tcGlsZVNoYWRlcih2ZXJ0ZXhTaGFkZXIpO1xuXG4gICAgICBmcmFnbWVudFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihnbC5GUkFHTUVOVF9TSEFERVIpO1xuICAgICAgaWYgKCFmcmFnbWVudFNoYWRlcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBnbC5zaGFkZXJTb3VyY2UoZnJhZ21lbnRTaGFkZXIsICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7dm9pZCBtYWluKCl7Z2xfRnJhZ0NvbG9yPXZlYzQoMC41KTt9Jyk7XG4gICAgICBnbC5jb21waWxlU2hhZGVyKGZyYWdtZW50U2hhZGVyKTtcblxuICAgICAgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgICAgIGlmICghcHJvZ3JhbSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdmVydGV4U2hhZGVyKTtcbiAgICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBmcmFnbWVudFNoYWRlcik7XG4gICAgICBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgIGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XG5cbiAgICAgIGdsLmRyYXdBcnJheXMoZ2wuUE9JTlRTLCAwLCAxKTtcbiAgICAgIHJldHVybiBnbC5nZXRFcnJvcigpID09PSBnbC5OT19FUlJPUjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZ2wuZGlzYWJsZShnbC5CTEVORCk7XG5cbiAgICAgIGlmIChwcm9ncmFtKSB7XG4gICAgICAgIGdsLmRlbGV0ZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgICB9XG4gICAgICBpZiAodmVydGV4U2hhZGVyKSB7XG4gICAgICAgIGdsLmRlbGV0ZVNoYWRlcih2ZXJ0ZXhTaGFkZXIpO1xuICAgICAgfVxuICAgICAgaWYgKGZyYWdtZW50U2hhZGVyKSB7XG4gICAgICAgIGdsLmRlbGV0ZVNoYWRlcihmcmFnbWVudFNoYWRlcik7XG4gICAgICB9XG4gICAgICBpZiAoZnJhbWVCdWZmZXIpIHtcbiAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcbiAgICAgICAgZ2wuZGVsZXRlRnJhbWVidWZmZXIoZnJhbWVCdWZmZXIpO1xuICAgICAgfVxuICAgICAgaWYgKHRleHR1cmUpIHtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG4gICAgICAgIGdsLmRlbGV0ZVRleHR1cmUodGV4dHVyZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYmVnaW5UaW1lcigpOiBXZWJHTFF1ZXJ5IHtcbiAgICBpZiAodGhpcy52ZXJzaW9uID09PSAyICYmIHRoaXMuZGlzam9pbnRUaW1lclF1ZXJ5V2ViZ2wyRXh0ZW5zaW9uKSB7XG4gICAgICBjb25zdCBnbDIgPSB0aGlzLmdsIGFzIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQ7XG4gICAgICBjb25zdCBleHQgPSB0aGlzLmRpc2pvaW50VGltZXJRdWVyeVdlYmdsMkV4dGVuc2lvbjtcblxuICAgICAgY29uc3QgcXVlcnkgPSBnbDIuY3JlYXRlUXVlcnkoKSBhcyBXZWJHTFF1ZXJ5O1xuICAgICAgZ2wyLmJlZ2luUXVlcnkoZXh0LlRJTUVfRUxBUFNFRF9FWFQsIHF1ZXJ5KTtcbiAgICAgIHJldHVybiBxdWVyeTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVE9ETzogYWRkIHdlYmdsIDEgaGFuZGxpbmcuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYkdMMSBwcm9maWxpbmcgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgfVxuICB9XG5cbiAgZW5kVGltZXIoKSB7XG4gICAgaWYgKHRoaXMudmVyc2lvbiA9PT0gMiAmJiB0aGlzLmRpc2pvaW50VGltZXJRdWVyeVdlYmdsMkV4dGVuc2lvbikge1xuICAgICAgY29uc3QgZ2wyID0gdGhpcy5nbCBhcyBXZWJHTDJSZW5kZXJpbmdDb250ZXh0O1xuICAgICAgY29uc3QgZXh0ID0gdGhpcy5kaXNqb2ludFRpbWVyUXVlcnlXZWJnbDJFeHRlbnNpb247XG4gICAgICBnbDIuZW5kUXVlcnkoZXh0LlRJTUVfRUxBUFNFRF9FWFQpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPOiBhZGQgd2ViZ2wgMSBoYW5kbGluZy5cbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViR0wxIHByb2ZpbGluZyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cbiAgfVxuXG4gIGlzVGltZXJSZXN1bHRBdmFpbGFibGUocXVlcnk6IFdlYkdMUXVlcnkpOiBib29sZWFuIHtcbiAgICBsZXQgYXZhaWxhYmxlID0gZmFsc2UsXG4gICAgICBkaXNqb2ludCA9IGZhbHNlO1xuICAgIGlmICh0aGlzLnZlcnNpb24gPT09IDIgJiYgdGhpcy5kaXNqb2ludFRpbWVyUXVlcnlXZWJnbDJFeHRlbnNpb24pIHtcbiAgICAgIGNvbnN0IGdsMiA9IHRoaXMuZ2wgYXMgV2ViR0wyUmVuZGVyaW5nQ29udGV4dDtcbiAgICAgIGNvbnN0IGV4dCA9IHRoaXMuZGlzam9pbnRUaW1lclF1ZXJ5V2ViZ2wyRXh0ZW5zaW9uO1xuXG4gICAgICBhdmFpbGFibGUgPSBnbDIuZ2V0UXVlcnlQYXJhbWV0ZXIocXVlcnksIGdsMi5RVUVSWV9SRVNVTFRfQVZBSUxBQkxFKTtcbiAgICAgIGRpc2pvaW50ID0gZ2wyLmdldFBhcmFtZXRlcihleHQuR1BVX0RJU0pPSU5UX0VYVCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRPRE86IGFkZCB3ZWJnbCAxIGhhbmRsaW5nLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJHTDEgcHJvZmlsaW5nIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGF2YWlsYWJsZSAmJiAhZGlzam9pbnQ7XG4gIH1cblxuICBnZXRUaW1lclJlc3VsdChxdWVyeTogV2ViR0xRdWVyeSk6IG51bWJlciB7XG4gICAgbGV0IHRpbWVFbGFwc2VkID0gMDtcbiAgICBpZiAodGhpcy52ZXJzaW9uID09PSAyKSB7XG4gICAgICBjb25zdCBnbDIgPSB0aGlzLmdsIGFzIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQ7XG4gICAgICB0aW1lRWxhcHNlZCA9IGdsMi5nZXRRdWVyeVBhcmFtZXRlcihxdWVyeSwgZ2wyLlFVRVJZX1JFU1VMVCk7XG4gICAgICBnbDIuZGVsZXRlUXVlcnkocXVlcnkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPOiBhZGQgd2ViZ2wgMSBoYW5kbGluZy5cbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViR0wxIHByb2ZpbGluZyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cbiAgICAvLyByZXR1cm4gbWlsaXNlY29uZHNcbiAgICByZXR1cm4gdGltZUVsYXBzZWQgLyAxMDAwMDAwO1xuICB9XG5cbiAgYXN5bmMgd2FpdEZvclF1ZXJ5QW5kR2V0VGltZShxdWVyeTogV2ViR0xRdWVyeSk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgYXdhaXQgcmVwZWF0ZWRUcnkoKCkgPT4gdGhpcy5pc1RpbWVyUmVzdWx0QXZhaWxhYmxlKHF1ZXJ5KSk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VGltZXJSZXN1bHQocXVlcnkpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGNyZWF0ZUFuZFdhaXRGb3JGZW5jZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBmZW5jZUNvbnRleHQgPSB0aGlzLmNyZWF0ZUZlbmNlKHRoaXMuZ2wpO1xuICAgIHJldHVybiB0aGlzLnBvbGxGZW5jZShmZW5jZUNvbnRleHQpO1xuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVGZW5jZShnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0KTogRmVuY2VDb250ZXh0IHtcbiAgICBsZXQgaXNGZW5jZVBhc3NlZDogKCkgPT4gYm9vbGVhbjtcbiAgICBjb25zdCBnbDIgPSBnbCBhcyBXZWJHTDJSZW5kZXJpbmdDb250ZXh0O1xuICAgIGNvbnN0IHF1ZXJ5ID0gZ2wyLmZlbmNlU3luYyhnbDIuU1lOQ19HUFVfQ09NTUFORFNfQ09NUExFVEUsIDApO1xuICAgIGdsLmZsdXNoKCk7XG4gICAgaWYgKHF1ZXJ5ID09PSBudWxsKSB7XG4gICAgICBpc0ZlbmNlUGFzc2VkID0gKCkgPT4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaXNGZW5jZVBhc3NlZCA9ICgpID0+IHtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gZ2wyLmNsaWVudFdhaXRTeW5jKHF1ZXJ5LCAwLCAwKTtcbiAgICAgICAgcmV0dXJuIHN0YXR1cyA9PT0gZ2wyLkFMUkVBRFlfU0lHTkFMRUQgfHwgc3RhdHVzID09PSBnbDIuQ09ORElUSU9OX1NBVElTRklFRDtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7IHF1ZXJ5LCBpc0ZlbmNlUGFzc2VkIH07XG4gIH1cblxuICBhc3luYyBwb2xsRmVuY2UoZmVuY2VDb250ZXh0OiBGZW5jZUNvbnRleHQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUpID0+IHtcbiAgICAgIHZvaWQgdGhpcy5hZGRJdGVtVG9Qb2xsKFxuICAgICAgICAoKSA9PiBmZW5jZUNvbnRleHQuaXNGZW5jZVBhc3NlZCgpLFxuICAgICAgICAoKSA9PiByZXNvbHZlKCksXG4gICAgICApO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBpdGVtc1RvUG9sbDogUG9sbEl0ZW1bXSA9IFtdO1xuXG4gIHBvbGxJdGVtcygpOiB2b2lkIHtcbiAgICAvLyBGaW5kIHRoZSBsYXN0IHF1ZXJ5IHRoYXQgaGFzIGZpbmlzaGVkLlxuICAgIGNvbnN0IGluZGV4ID0gbGluZWFyU2VhcmNoTGFzdFRydWUodGhpcy5pdGVtc1RvUG9sbC5tYXAoKHgpID0+IHguaXNEb25lRm4pKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBpbmRleDsgKytpKSB7XG4gICAgICBjb25zdCB7IHJlc29sdmVGbiB9ID0gdGhpcy5pdGVtc1RvUG9sbFtpXTtcbiAgICAgIHJlc29sdmVGbigpO1xuICAgIH1cbiAgICB0aGlzLml0ZW1zVG9Qb2xsID0gdGhpcy5pdGVtc1RvUG9sbC5zbGljZShpbmRleCArIDEpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBhZGRJdGVtVG9Qb2xsKGlzRG9uZUZuOiAoKSA9PiBib29sZWFuLCByZXNvbHZlRm46ICgpID0+IHZvaWQpIHtcbiAgICB0aGlzLml0ZW1zVG9Qb2xsLnB1c2goeyBpc0RvbmVGbiwgcmVzb2x2ZUZuIH0pO1xuICAgIGlmICh0aGlzLml0ZW1zVG9Qb2xsLmxlbmd0aCA+IDEpIHtcbiAgICAgIC8vIFdlIGFscmVhZHkgaGF2ZSBhIHJ1bm5pbmcgbG9vcCB0aGF0IHBvbGxzLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBTdGFydCBhIG5ldyBsb29wIHRoYXQgcG9sbHMuXG4gICAgYXdhaXQgcmVwZWF0ZWRUcnkoKCkgPT4ge1xuICAgICAgdGhpcy5wb2xsSXRlbXMoKTtcbiAgICAgIC8vIEVuZCB0aGUgbG9vcCBpZiBubyBtb3JlIGl0ZW1zIHRvIHBvbGwuXG4gICAgICByZXR1cm4gdGhpcy5pdGVtc1RvUG9sbC5sZW5ndGggPT09IDA7XG4gICAgfSk7XG4gIH1cbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnLi4vLi4vaW5zdHJ1bWVudCc7XG5cbmltcG9ydCB7IFdlYkdMQ29udGV4dCB9IGZyb20gJy4vd2ViZ2wtY29udGV4dCc7XG5cbmNvbnN0IGNhY2hlOiB7IFtjb250ZXh0SWQ6IHN0cmluZ106IFdlYkdMQ29udGV4dCB9ID0ge307XG5cbi8qKlxuICogVGhpcyBmYWN0b3J5IGZ1bmN0aW9uIGNyZWF0ZXMgcHJvcGVyIFdlYkdMUmVuZGVyaW5nQ29udGV4dCBiYXNlZCBvblxuICogdGhlIGN1cnJlbnQgYnJvd3NlcnMgY2FwYWJpbGl0aWVzXG4gKiBUaGUgb3JkZXIgaXMgZnJvbSBoaWdoZXIvbW9zdCByZWNlbnQgdmVyc2lvbnMgdG8gbW9zdCBiYXNpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlV2ViR0xDb250ZXh0KGNvbnRleHRJZD86ICd3ZWJnbCcgfCAnd2ViZ2wyJyk6IFdlYkdMQ29udGV4dCB7XG4gIGxldCBjb250ZXh0OiBXZWJHTENvbnRleHQgfCB1bmRlZmluZWQ7XG4gIGlmICgoIWNvbnRleHRJZCB8fCBjb250ZXh0SWQgPT09ICd3ZWJnbDInKSAmJiAnd2ViZ2wyJyBpbiBjYWNoZSkge1xuICAgIGNvbnRleHQgPSBjYWNoZS53ZWJnbDI7XG4gIH0gZWxzZSBpZiAoKCFjb250ZXh0SWQgfHwgY29udGV4dElkID09PSAnd2ViZ2wnKSAmJiAnd2ViZ2wnIGluIGNhY2hlKSB7XG4gICAgY29udGV4dCA9IGNhY2hlLndlYmdsO1xuICB9XG5cbiAgaWYgKCFjb250ZXh0KSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIHRyeSB0byBjcmVhdGUgd2ViZ2wgY29udGV4dCBmcm9tIGFuIG9mZnNjcmVlbiBjYW52YXNcbiAgICAgIGNvbnN0IG9mZnNjcmVlbkNhbnZhcyA9IGNyZWF0ZU9mZnNjcmVlbkNhbnZhcygpO1xuICAgICAgY29udGV4dCA9IGNyZWF0ZU5ld1dlYkdMQ29udGV4dChvZmZzY3JlZW5DYW52YXMsIGNvbnRleHRJZCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gaWYgZmFpbGVkLCBmYWxsYmFjayB0byB0cnkgdG8gdXNlIGEgbm9ybWFsIGNhbnZhcyBlbGVtZW50XG4gICAgICBjb25zdCBjYW52YXMgPSBjcmVhdGVDYW52YXMoKTtcbiAgICAgIGNvbnRleHQgPSBjcmVhdGVOZXdXZWJHTENvbnRleHQoY2FudmFzLCBjb250ZXh0SWQpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnRleHRJZCA9IGNvbnRleHRJZCB8fCBjb250ZXh0LnZlcnNpb24gPT09IDEgPyAnd2ViZ2wnIDogJ3dlYmdsMic7XG4gIGNvbnN0IGdsID0gY29udGV4dC5nbDtcblxuICBjYWNoZVtjb250ZXh0SWRdID0gY29udGV4dDtcblxuICBpZiAoZ2wuaXNDb250ZXh0TG9zdCgpKSB7XG4gICAgZGVsZXRlIGNhY2hlW2NvbnRleHRJZF07XG4gICAgcmV0dXJuIGNyZWF0ZVdlYkdMQ29udGV4dChjb250ZXh0SWQpO1xuICB9XG5cbiAgZ2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTtcbiAgZ2wuZGlzYWJsZShnbC5TVEVOQ0lMX1RFU1QpO1xuICBnbC5kaXNhYmxlKGdsLkJMRU5EKTtcbiAgZ2wuZGlzYWJsZShnbC5ESVRIRVIpO1xuICBnbC5kaXNhYmxlKGdsLlBPTFlHT05fT0ZGU0VUX0ZJTEwpO1xuICBnbC5kaXNhYmxlKGdsLlNBTVBMRV9DT1ZFUkFHRSk7XG4gIGdsLmVuYWJsZShnbC5TQ0lTU09SX1RFU1QpO1xuICBnbC5lbmFibGUoZ2wuQ1VMTF9GQUNFKTtcbiAgZ2wuY3VsbEZhY2UoZ2wuQkFDSyk7XG5cbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVOZXdXZWJHTENvbnRleHQoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCwgY29udGV4dElkPzogJ3dlYmdsJyB8ICd3ZWJnbDInKTogV2ViR0xDb250ZXh0IHtcbiAgY29uc3QgY29udGV4dEF0dHJpYnV0ZXM6IFdlYkdMQ29udGV4dEF0dHJpYnV0ZXMgPSB7XG4gICAgYWxwaGE6IGZhbHNlLFxuICAgIGRlcHRoOiBmYWxzZSxcbiAgICBhbnRpYWxpYXM6IGZhbHNlLFxuICAgIHN0ZW5jaWw6IGZhbHNlLFxuICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogZmFsc2UsXG4gICAgcHJlbXVsdGlwbGllZEFscGhhOiBmYWxzZSxcbiAgICBmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0OiBmYWxzZSxcbiAgfTtcbiAgbGV0IGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQgfCBudWxsO1xuICBjb25zdCBjYSA9IGNvbnRleHRBdHRyaWJ1dGVzO1xuICBpZiAoIWNvbnRleHRJZCB8fCBjb250ZXh0SWQgPT09ICd3ZWJnbDInKSB7XG4gICAgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wyJywgY2EpO1xuICAgIGlmIChnbCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5ldyBXZWJHTENvbnRleHQoZ2wsIDIpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIExvZ2dlci53YXJuaW5nKCdHbENvbnRleHRGYWN0b3J5JywgYGZhaWxlZCB0byBjcmVhdGUgV2ViR0xDb250ZXh0IHVzaW5nIGNvbnRleHRJZCAnd2ViZ2wyJy4gRXJyb3I6ICR7ZXJyfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIWNvbnRleHRJZCB8fCBjb250ZXh0SWQgPT09ICd3ZWJnbCcpIHtcbiAgICBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcsIGNhKSB8fCAoY2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIGNhKSBhcyBXZWJHTFJlbmRlcmluZ0NvbnRleHQpO1xuICAgIGlmIChnbCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5ldyBXZWJHTENvbnRleHQoZ2wsIDEpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIExvZ2dlci53YXJuaW5nKFxuICAgICAgICAgICdHbENvbnRleHRGYWN0b3J5JyxcbiAgICAgICAgICBgZmFpbGVkIHRvIGNyZWF0ZSBXZWJHTENvbnRleHQgdXNpbmcgY29udGV4dElkICd3ZWJnbCcgb3IgJ2V4cGVyaW1lbnRhbC13ZWJnbCcuIEVycm9yOiAke2Vycn1gLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignV2ViR0wgaXMgbm90IHN1cHBvcnRlZCcpO1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5kZWNsYXJlIGxldCBPZmZzY3JlZW5DYW52YXM6IHsgbmV3ICh3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcik6IEhUTUxDYW52YXNFbGVtZW50IH07XG5cbmZ1bmN0aW9uIGNyZWF0ZUNhbnZhcygpOiBIVE1MQ2FudmFzRWxlbWVudCB7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZmFpbGVkIHRvIGNyZWF0ZSBjYW52YXM6IGRvY3VtZW50IGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgfVxuICBjb25zdCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gIGNhbnZhcy53aWR0aCA9IDE7XG4gIGNhbnZhcy5oZWlnaHQgPSAxO1xuICByZXR1cm4gY2FudmFzO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVPZmZzY3JlZW5DYW52YXMoKTogSFRNTENhbnZhc0VsZW1lbnQge1xuICBpZiAodHlwZW9mIE9mZnNjcmVlbkNhbnZhcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdmYWlsZWQgdG8gY3JlYXRlIG9mZnNjcmVlbiBjYW52YXM6IE9mZnNjcmVlbkNhbnZhcyBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBPZmZzY3JlZW5DYW52YXMoMSwgMSk7XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IGVudiB9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5cbmltcG9ydCB7IEJhY2tlbmQsIFNlc3Npb25IYW5kbGVyIH0gZnJvbSAnLi4vYmFja2VuZCc7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICcuLi9pbnN0cnVtZW50JztcbmltcG9ydCB7IFNlc3Npb24gfSBmcm9tICcuLi9zZXNzaW9uJztcblxuaW1wb3J0IHsgV2ViR0xTZXNzaW9uSGFuZGxlciB9IGZyb20gJy4vd2ViZ2wvc2Vzc2lvbi1oYW5kbGVyJztcbmltcG9ydCB7IFdlYkdMQ29udGV4dCB9IGZyb20gJy4vd2ViZ2wvd2ViZ2wtY29udGV4dCc7XG5pbXBvcnQgeyBjcmVhdGVXZWJHTENvbnRleHQgfSBmcm9tICcuL3dlYmdsL3dlYmdsLWNvbnRleHQtZmFjdG9yeSc7XG5cbi8qKlxuICogV2ViR0xCYWNrZW5kIGlzIHRoZSBlbnRyeSBwb2ludCBmb3IgYWxsIFdlYkdMIG9wZWFydGlvbnNcbiAqIFdoZW4gaXQgc3RhcnRzIGl0IGNyZWF0ZWQgdGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogYW5kIG90aGVyIG1haW4gZnJhbWV3b3JrIGNvbXBvbmVudHMgc3VjaCBhcyBQcm9ncmFtIGFuZCBUZXh0dXJlIE1hbmFnZXJzXG4gKi9cbmV4cG9ydCBjbGFzcyBXZWJHTEJhY2tlbmQgaW1wbGVtZW50cyBCYWNrZW5kIHtcbiAgZ2xDb250ZXh0OiBXZWJHTENvbnRleHQ7XG5cbiAgZ2V0IGNvbnRleHRJZCgpOiAnd2ViZ2wnIHwgJ3dlYmdsMicgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiBlbnYud2ViZ2wuY29udGV4dElkO1xuICB9XG4gIHNldCBjb250ZXh0SWQodmFsdWU6ICd3ZWJnbCcgfCAnd2ViZ2wyJyB8IHVuZGVmaW5lZCkge1xuICAgIGVudi53ZWJnbC5jb250ZXh0SWQgPSB2YWx1ZTtcbiAgfVxuXG4gIGdldCBtYXRtdWxNYXhCYXRjaFNpemUoKTogbnVtYmVyIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gZW52LndlYmdsLm1hdG11bE1heEJhdGNoU2l6ZTtcbiAgfVxuICBzZXQgbWF0bXVsTWF4QmF0Y2hTaXplKHZhbHVlOiBudW1iZXIgfCB1bmRlZmluZWQpIHtcbiAgICBlbnYud2ViZ2wubWF0bXVsTWF4QmF0Y2hTaXplID0gdmFsdWU7XG4gIH1cblxuICBnZXQgdGV4dHVyZUNhY2hlTW9kZSgpOiAnaW5pdGlhbGl6ZXJPbmx5JyB8ICdmdWxsJyB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIGVudi53ZWJnbC50ZXh0dXJlQ2FjaGVNb2RlO1xuICB9XG4gIHNldCB0ZXh0dXJlQ2FjaGVNb2RlKHZhbHVlOiAnaW5pdGlhbGl6ZXJPbmx5JyB8ICdmdWxsJyB8IHVuZGVmaW5lZCkge1xuICAgIGVudi53ZWJnbC50ZXh0dXJlQ2FjaGVNb2RlID0gdmFsdWU7XG4gIH1cblxuICBnZXQgcGFjaygpOiBib29sZWFuIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gZW52LndlYmdsLnBhY2s7XG4gIH1cbiAgc2V0IHBhY2sodmFsdWU6IGJvb2xlYW4gfCB1bmRlZmluZWQpIHtcbiAgICBlbnYud2ViZ2wucGFjayA9IHZhbHVlO1xuICB9XG5cbiAgZ2V0IGFzeW5jKCk6IGJvb2xlYW4gfCB1bmRlZmluZWQge1xuICAgIHJldHVybiBlbnYud2ViZ2wuYXN5bmM7XG4gIH1cbiAgc2V0IGFzeW5jKHZhbHVlOiBib29sZWFuIHwgdW5kZWZpbmVkKSB7XG4gICAgZW52LndlYmdsLmFzeW5jID0gdmFsdWU7XG4gIH1cblxuICBpbml0aWFsaXplKCk6IGJvb2xlYW4ge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmdsQ29udGV4dCA9IGNyZWF0ZVdlYkdMQ29udGV4dCh0aGlzLmNvbnRleHRJZCk7XG4gICAgICBpZiAodHlwZW9mIHRoaXMubWF0bXVsTWF4QmF0Y2hTaXplICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aGlzLm1hdG11bE1heEJhdGNoU2l6ZSA9IDE2O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0aGlzLnRleHR1cmVDYWNoZU1vZGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMudGV4dHVyZUNhY2hlTW9kZSA9ICdmdWxsJztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5wYWNrICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdGhpcy5wYWNrID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHRoaXMuYXN5bmMgIT09ICdib29sZWFuJykge1xuICAgICAgICB0aGlzLmFzeW5jID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIExvZ2dlci5zZXRXaXRoRW52KGVudik7XG5cbiAgICAgIGlmICghZW52LndlYmdsLmNvbnRleHQpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVudi53ZWJnbCwgJ2NvbnRleHQnLCB7IHZhbHVlOiB0aGlzLmdsQ29udGV4dC5nbCB9KTtcbiAgICAgIH1cblxuICAgICAgTG9nZ2VyLnZlcmJvc2UoXG4gICAgICAgICdXZWJHTEJhY2tlbmQnLFxuICAgICAgICBgQ3JlYXRlZCBXZWJHTENvbnRleHQ6ICR7dHlwZW9mIHRoaXMuZ2xDb250ZXh0fSB3aXRoIG1hdG11bE1heEJhdGNoU2l6ZTogJHtcbiAgICAgICAgICB0aGlzLm1hdG11bE1heEJhdGNoU2l6ZVxuICAgICAgICB9OyB0ZXh0dXJlQ2FjaGVNb2RlOiAke3RoaXMudGV4dHVyZUNhY2hlTW9kZX07IHBhY2s6ICR7dGhpcy5wYWNrfTsgYXN5bmM6ICR7dGhpcy5hc3luY30uYCxcbiAgICAgICk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBMb2dnZXIud2FybmluZygnV2ViR0xCYWNrZW5kJywgYFVuYWJsZSB0byBpbml0aWFsaXplIFdlYkdMQmFja2VuZC4gJHtlfWApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBjcmVhdGVTZXNzaW9uSGFuZGxlcihjb250ZXh0OiBTZXNzaW9uLkNvbnRleHQpOiBTZXNzaW9uSGFuZGxlciB7XG4gICAgcmV0dXJuIG5ldyBXZWJHTFNlc3Npb25IYW5kbGVyKHRoaXMsIGNvbnRleHQpO1xuICB9XG4gIGRpc3Bvc2UoKTogdm9pZCB7XG4gICAgdGhpcy5nbENvbnRleHQuZGlzcG9zZSgpO1xuICB9XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IFdlYkdMQmFja2VuZCB9IGZyb20gJy4vYmFja2VuZHMvYmFja2VuZC13ZWJnbCc7XG5pbXBvcnQgeyBHcmFwaCB9IGZyb20gJy4vZ3JhcGgnO1xuaW1wb3J0IHsgT3BlcmF0b3IgfSBmcm9tICcuL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBPcFNldCB9IGZyb20gJy4vb3BzZXQnO1xuaW1wb3J0IHsgU2Vzc2lvbiB9IGZyb20gJy4vc2Vzc2lvbic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW5mZXJlbmNlSGFuZGxlciB7XG4gIC8qKlxuICAgKiBkaXNwb3NlIHRoZSBpbmZlcmVuY2UgaGFuZGxlci4gaXQgd2lsbCBiZSBjYWxsZWQgYXMgdGhlIGxhc3Qgc3RlcCBpbiBTZXNzaW9uLnJ1bigpXG4gICAqL1xuICBkaXNwb3NlKCk6IHZvaWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2Vzc2lvbkhhbmRsZXIge1xuICAvKipcbiAgICogdHJhbnNmb3JtIHRoZSBncmFwaCBhdCBpbml0aWFsaXphdGlvbiB0aW1lXG4gICAqIEBwYXJhbSBncmFwaFRyYW5zZm9ybWVyIHRoZSBncmFwaCB0cmFuc2Zvcm1lciB0byBtYW5pcHVsYXRlIHRoZSBtb2RlbCBncmFwaFxuICAgKi9cbiAgdHJhbnNmb3JtR3JhcGg/KGdyYXBoVHJhbnNmb3JtZXI6IEdyYXBoLlRyYW5zZm9ybWVyKTogdm9pZDtcblxuICAvKipcbiAgICogY3JlYXRlIGFuIGluc3RhbmNlIG9mIEluZmVyZW5jZUhhbmRsZXIgdG8gdXNlIGluIGEgU2Vzc2lvbi5ydW4oKSBjYWxsXG4gICAqL1xuICBjcmVhdGVJbmZlcmVuY2VIYW5kbGVyKCk6IEluZmVyZW5jZUhhbmRsZXI7XG5cbiAgLyoqXG4gICAqIGRpc3Bvc2UgdGhlIHNlc3Npb24gaGFuZGxlci4gaXQgd2lsbCBiZSBjYWxsZWQgd2hlbiBhIHNlc3Npb24gaXMgYmVpbmcgZGlzcG9zZWQgZXhwbGljaXRseVxuICAgKi9cbiAgZGlzcG9zZSgpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBSZXNvbHZlcyB0aGUgb3BlcmF0b3IgZnJvbSB0aGUgbmFtZSBhbmQgb3BzZXQgdmVyc2lvbjsgYmFja2VuZCBzcGVjaWZpY1xuICAgKiBAcGFyYW0gbm9kZSB0aGUgbm9kZSB0byByZXNvbHZlXG4gICAqIEBwYXJhbSBvcHNldHMgYSBsaXN0IG9mIG9wc2V0cyB0aGF0IGV4cG9ydGVkIGZyb20gdGhlIG1vZGVsXG4gICAqIEBwYXJhbSBncmFwaCB0aGUgY29tcGxldGVseSBpbml0aWFsaXplZCBncmFwaFxuICAgKi9cbiAgcmVzb2x2ZShub2RlOiBHcmFwaC5Ob2RlLCBvcHNldHM6IHJlYWRvbmx5IE9wU2V0W10sIGdyYXBoOiBHcmFwaCk6IE9wZXJhdG9yO1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBsZXQncyB0aGUgc2Vzc2lvbkhhbmRsZXIga25vdyB0aGF0IHRoZSBncmFwaCBpbml0aWFsaXphdGlvbiBpcyBjb21wbGV0ZVxuICAgKiBAcGFyYW0gZ3JhcGggdGhlIGNvbXBsZXRlbHkgaW5pdGlhbGl6ZWQgZ3JhcGhcbiAgICovXG4gIG9uR3JhcGhJbml0aWFsaXplZD8oZ3JhcGg6IEdyYXBoKTogdm9pZDtcblxuICAvKipcbiAgICogYSByZWZlcmVuY2UgdG8gdGhlIGNvcnJlc3BvbmRpbmcgYmFja2VuZFxuICAgKi9cbiAgcmVhZG9ubHkgYmFja2VuZDogQmFja2VuZDtcblxuICAvKipcbiAgICogYSByZWZlcmVuY2UgdG8gdGhlIHNlc3Npb24gY29udGV4dFxuICAgKi9cbiAgcmVhZG9ubHkgY29udGV4dDogU2Vzc2lvbi5Db250ZXh0O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJhY2tlbmQge1xuICAvKipcbiAgICogaW5pdGlhbGl6ZSB0aGUgYmFja2VuZC4gd2lsbCBiZSBjYWxsZWQgb25seSBvbmNlLCB3aGVuIHRoZSBmaXJzdCB0aW1lIHRoZVxuICAgKiBiYWNrZW5kIGl0IHRvIGJlIHVzZWRcbiAgICovXG4gIGluaXRpYWxpemUoKTogYm9vbGVhbiB8IFByb21pc2U8Ym9vbGVhbj47XG5cbiAgLyoqXG4gICAqIGNyZWF0ZSBhbiBpbnN0YW5jZSBvZiBTZXNzaW9uSGFuZGxlciB0byB1c2UgaW4gYSBTZXNzaW9uIG9iamVjdCdzIGxpZmVjeWNsZVxuICAgKi9cbiAgY3JlYXRlU2Vzc2lvbkhhbmRsZXIoY29udGV4dDogU2Vzc2lvbi5Db250ZXh0KTogU2Vzc2lvbkhhbmRsZXI7XG5cbiAgLyoqXG4gICAqIGRpc3Bvc2UgdGhlIGJhY2tlbmQuIGN1cnJlbnRseSB0aGlzIHdpbGwgbm90IGJlIGNhbGxlZFxuICAgKi9cbiAgZGlzcG9zZSgpOiB2b2lkO1xufVxuXG4vLyBjYWNoZXMgYWxsIGluaXRpYWxpemVkIGJhY2tlbmQgaW5zdGFuY2VzXG5jb25zdCBiYWNrZW5kc0NhY2hlOiBNYXA8c3RyaW5nLCBCYWNrZW5kPiA9IG5ldyBNYXAoKTtcblxuZXhwb3J0IGNvbnN0IGJhY2tlbmQ6IHsgW25hbWU6IHN0cmluZ106IEJhY2tlbmQgfSA9IHtcbiAgd2ViZ2w6IG5ldyBXZWJHTEJhY2tlbmQoKSxcbn07XG5cbi8qKlxuICogUmVzb2x2ZSBhIHJlZmVyZW5jZSB0byB0aGUgYmFja2VuZC4gSWYgYSBoaW50IGlzIHNwZWNpZmllZCwgdGhlIGNvcnJlc3BvbmRpbmdcbiAqIGJhY2tlbmQgd2lsbCBiZSB1c2VkLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZUJhY2tlbmQoaGludD86IHN0cmluZyB8IHJlYWRvbmx5IHN0cmluZ1tdKTogUHJvbWlzZTxCYWNrZW5kPiB7XG4gIGlmICghaGludCkge1xuICAgIHJldHVybiByZXNvbHZlQmFja2VuZChbJ3dlYmdsJ10pO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGhpbnRzID0gdHlwZW9mIGhpbnQgPT09ICdzdHJpbmcnID8gW2hpbnRdIDogaGludDtcblxuICAgIGZvciAoY29uc3QgYmFja2VuZEhpbnQgb2YgaGludHMpIHtcbiAgICAgIGNvbnN0IGNhY2hlID0gYmFja2VuZHNDYWNoZS5nZXQoYmFja2VuZEhpbnQpO1xuICAgICAgaWYgKGNhY2hlKSB7XG4gICAgICAgIHJldHVybiBjYWNoZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYmFja2VuZCA9IGF3YWl0IHRyeUxvYWRCYWNrZW5kKGJhY2tlbmRIaW50KTtcbiAgICAgIGlmIChiYWNrZW5kKSB7XG4gICAgICAgIHJldHVybiBiYWNrZW5kO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignbm8gYXZhaWxhYmxlIGJhY2tlbmQgdG8gdXNlJyk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHRyeUxvYWRCYWNrZW5kKGJhY2tlbmRIaW50OiBzdHJpbmcpOiBQcm9taXNlPEJhY2tlbmQgfCB1bmRlZmluZWQ+IHtcbiAgY29uc3QgYmFja2VuZE9iaiA9IGJhY2tlbmQ7XG5cbiAgaWYgKHR5cGVvZiBiYWNrZW5kT2JqW2JhY2tlbmRIaW50XSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNCYWNrZW5kKGJhY2tlbmRPYmpbYmFja2VuZEhpbnRdKSkge1xuICAgIGNvbnN0IGJhY2tlbmQgPSBiYWNrZW5kT2JqW2JhY2tlbmRIaW50XTtcbiAgICBsZXQgaW5pdCA9IGJhY2tlbmQuaW5pdGlhbGl6ZSgpO1xuICAgIGlmICh0eXBlb2YgaW5pdCA9PT0gJ29iamVjdCcgJiYgJ3RoZW4nIGluIGluaXQpIHtcbiAgICAgIGluaXQgPSBhd2FpdCBpbml0O1xuICAgIH1cbiAgICBpZiAoaW5pdCkge1xuICAgICAgYmFja2VuZHNDYWNoZS5zZXQoYmFja2VuZEhpbnQsIGJhY2tlbmQpO1xuICAgICAgcmV0dXJuIGJhY2tlbmQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaXNCYWNrZW5kKG9iajogdW5rbm93bikge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICBjb25zdCBvID0gb2JqIGFzIGFueTtcblxuICAvLyBjaGVjayBpZiBhbiBvYmplY3QgaXMgYSBCYWNrZW5kIGluc3RhbmNlXG4gIGlmIChcbiAgICAnaW5pdGlhbGl6ZScgaW4gbyAmJlxuICAgIHR5cGVvZiBvLmluaXRpYWxpemUgPT09ICdmdW5jdGlvbicgJiYgLy8gaW5pdGlhbGl6ZSgpXG4gICAgJ2NyZWF0ZVNlc3Npb25IYW5kbGVyJyBpbiBvICYmXG4gICAgdHlwZW9mIG8uY3JlYXRlU2Vzc2lvbkhhbmRsZXIgPT09ICdmdW5jdGlvbicgJiYgLy8gY3JlYXRlU2Vzc2lvbkhhbmRsZXIoKVxuICAgICdkaXNwb3NlJyBpbiBvICYmXG4gICAgdHlwZW9mIG8uZGlzcG9zZSA9PT0gJ2Z1bmN0aW9uJyAvLyBkaXNwb3NlKClcbiAgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCB0eXBlIEJhY2tlbmRUeXBlID0gQmFja2VuZDtcbmV4cG9ydCB0eXBlIFNlc3Npb25IYW5kbGVyVHlwZSA9IFJldHVyblR5cGU8QmFja2VuZFR5cGVbJ2NyZWF0ZVNlc3Npb25IYW5kbGVyJ10+O1xuZXhwb3J0IHR5cGUgSW5mZXJlbmNlSGFuZGxlclR5cGUgPSBSZXR1cm5UeXBlPFNlc3Npb25IYW5kbGVyVHlwZVsnY3JlYXRlSW5mZXJlbmNlSGFuZGxlciddPjtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgU2Vzc2lvbkhhbmRsZXIgfSBmcm9tICcuL2JhY2tlbmQnO1xuaW1wb3J0IHsgR3JhcGggfSBmcm9tICcuL2dyYXBoJztcbmltcG9ydCB7IExvZ2dlciwgUHJvZmlsZXIgfSBmcm9tICcuL2luc3RydW1lbnQnO1xuaW1wb3J0IHsgT3BlcmF0b3IgfSBmcm9tICcuL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBUZW5zb3IgfSBmcm9tICcuL3RlbnNvcic7XG5cbmNsYXNzIEtlcm5lbE9wIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIG9wOiBPcGVyYXRvcixcbiAgICBwdWJsaWMgbm9kZTogR3JhcGguTm9kZSxcbiAgKSB7fVxufVxuXG5leHBvcnQgY2xhc3MgRXhlY3V0aW9uUGxhbiB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgZ3JhcGg6IEdyYXBoLFxuICAgIG9wczogT3BlcmF0b3JbXSxcbiAgICBwcml2YXRlIHByb2ZpbGVyOiBSZWFkb25seTxQcm9maWxlcj4sXG4gICkge1xuICAgIHRoaXMuaW5pdGlhbGl6ZShvcHMpO1xuICB9XG5cbiAgaW5pdGlhbGl6ZShvcHM6IE9wZXJhdG9yW10pIHtcbiAgICB0aGlzLnByb2ZpbGVyLmV2ZW50KCdzZXNzaW9uJywgJ0V4ZWN1dGlvblBsYW4uaW5pdGlhbGl6ZScsICgpID0+IHtcbiAgICAgIGNvbnN0IGdyYXBoTm9kZXMgPSB0aGlzLmdyYXBoLmdldE5vZGVzKCk7XG4gICAgICBpZiAoZ3JhcGhOb2Rlcy5sZW5ndGggIT09IG9wcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc2l6ZSBvZiBub2RlcyBhbmQgT1BzIGRvIG5vdCBtYXRjaC4nKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fb3BzID0gb3BzLm1hcCgob3AsIGkpID0+IG5ldyBLZXJuZWxPcChvcCwgZ3JhcGhOb2Rlc1tpXSkpO1xuICAgICAgdGhpcy5yZXNldCgpO1xuXG4gICAgICAvLyBsb29rIGZvciBzdGFydGVyIG5vZGUocylcbiAgICAgIHRoaXMuX3N0YXJ0ZXIgPSBbXTtcbiAgICAgIHRoaXMuX29wcy5mb3JFYWNoKChvcCwgaSkgPT4ge1xuICAgICAgICBsZXQgcmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICBmb3IgKGNvbnN0IGlucHV0IG9mIG9wLm5vZGUuaW5wdXRzKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIXRoaXMuX3ZhbHVlc1tpbnB1dF0gJiYgLy8gbm90IGFuIGluaXRpYWxpemVkIGlucHV0XG4gICAgICAgICAgICB0aGlzLmdyYXBoLmdldElucHV0SW5kaWNlcygpLmluZGV4T2YoaW5wdXQpID09PSAtMSAvLyBub3QgbW9kZWwgaW5wdXRcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJlc29sdmVkID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc29sdmVkKSB7XG4gICAgICAgICAgdGhpcy5fc3RhcnRlci5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHJlc2V0KCkge1xuICAgIHRoaXMuX3ZhbHVlcyA9IHRoaXMuZ3JhcGguZ2V0VmFsdWVzKCkubWFwKChpKSA9PiBpLnRlbnNvcik7XG4gIH1cblxuICBhc3luYyBleGVjdXRlKHNlc3Npb25IYW5kbGVyOiBTZXNzaW9uSGFuZGxlciwgbW9kZWxJbnB1dHM6IFRlbnNvcltdKTogUHJvbWlzZTxUZW5zb3JbXT4ge1xuICAgIHJldHVybiB0aGlzLnByb2ZpbGVyLmV2ZW50KCdzZXNzaW9uJywgJ0V4ZWN1dGlvblBsYW4uZXhlY3V0ZScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIHJlc2V0IG1lZGllbSByZXN1bHRcbiAgICAgIHRoaXMucmVzZXQoKTtcblxuICAgICAgLy8gY3JlYXRlIGluZmVyZW5jZSBoYW5kbGVyXG4gICAgICBjb25zdCBpbmZlcmVuY2VIYW5kbGVyID0gc2Vzc2lvbkhhbmRsZXIuY3JlYXRlSW5mZXJlbmNlSGFuZGxlcigpO1xuXG4gICAgICAvLyBwb3B1bGF0ZSBpbnB1dHMgdmFsdWVcbiAgICAgIGNvbnN0IGdyYXBoSW5wdXRzID0gdGhpcy5ncmFwaC5nZXRJbnB1dEluZGljZXMoKTtcbiAgICAgIGlmIChtb2RlbElucHV0cy5sZW5ndGggIT09IGdyYXBoSW5wdXRzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYG51bWJlciBvZiBpbnB1dCB0ZW5zb3JzIGRvbid0IG1hdGNoIHRoZSBudW1iZXIgb2YgaW5wdXRzIHRvIHRoZSBtb2RlbDogYWN0dWFsOiAke1xuICAgICAgICAgICAgbW9kZWxJbnB1dHMubGVuZ3RoXG4gICAgICAgICAgfSBleHBlY3RlZDogJHtncmFwaElucHV0cy5sZW5ndGh9YCxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgbW9kZWxJbnB1dHMuZm9yRWFjaCgoaW5wdXQsIGkpID0+IHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBncmFwaElucHV0c1tpXTtcbiAgICAgICAgdGhpcy5fdmFsdWVzW2luZGV4XSA9IGlucHV0O1xuICAgICAgfSk7XG5cbiAgICAgIC8vIHByZXBhcmUgcnVubmluZyBzZXF1ZW5jZVxuICAgICAgY29uc3Qgc2VxdWVuY2U6IG51bWJlcltdID0gdGhpcy5fc3RhcnRlci5zbGljZSgwKTtcblxuICAgICAgLy8gZXhlY3V0aW9uIGl0ZXJhdGlvbnNcbiAgICAgIGNvbnN0IGdyYXBoVmFsdWVzID0gdGhpcy5ncmFwaC5nZXRWYWx1ZXMoKTtcbiAgICAgIGNvbnN0IGdyYXBoTm9kZXMgPSB0aGlzLmdyYXBoLmdldE5vZGVzKCk7XG5cbiAgICAgIGxldCByZWFyID0gMDtcbiAgICAgIHdoaWxlIChyZWFyIDwgc2VxdWVuY2UubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHRoaXNPcEluZGV4ID0gc2VxdWVuY2VbcmVhcisrXTtcbiAgICAgICAgY29uc3QgdGhpc09wID0gdGhpcy5fb3BzW3RoaXNPcEluZGV4XTtcblxuICAgICAgICAvLyBjaGVjayBpbnB1dFxuICAgICAgICBjb25zdCBpbnB1dExpc3QgPSB0aGlzT3Aubm9kZS5pbnB1dHMubWFwKChpKSA9PiB0aGlzLl92YWx1ZXNbaV0pO1xuICAgICAgICBpZiAoaW5wdXRMaXN0LmluZGV4T2YodW5kZWZpbmVkKSAhPT0gLTEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVucmVzb2x2ZWQgaW5wdXQgZGV0ZWN0ZWQ6IG9wOiAke3RoaXNPcC5ub2RlfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcnVuXG4gICAgICAgIGNvbnN0IGlucHV0VGVuc29ycyA9IGlucHV0TGlzdCBhcyBUZW5zb3JbXTtcbiAgICAgICAgTG9nZ2VyLnZlcmJvc2UoXG4gICAgICAgICAgJ0V4ZWNQbGFuJyxcbiAgICAgICAgICBgUnVubmluZyBvcDoke3RoaXNPcC5ub2RlLm5hbWV9ICgke2lucHV0VGVuc29yc1xuICAgICAgICAgICAgLm1hcCgodCwgaSkgPT4gYCcke3RoaXNPcC5ub2RlLmlucHV0c1tpXX0nOiAke3QudHlwZX1bJHt0LmRpbXMuam9pbignLCcpfV1gKVxuICAgICAgICAgICAgLmpvaW4oJywgJyl9KWAsXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3Qgb3V0cHV0TGlzdCA9IGF3YWl0IHRoaXMucHJvZmlsZXIuZXZlbnQoJ25vZGUnLCB0aGlzT3Aubm9kZS5uYW1lLCBhc3luYyAoKSA9PlxuICAgICAgICAgIHRoaXNPcC5vcC5pbXBsKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0VGVuc29ycywgdGhpc09wLm9wLmNvbnRleHQpLFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIGNoZWNrIG91dHB1dFxuICAgICAgICBpZiAob3V0cHV0TGlzdC5sZW5ndGggIT09IHRoaXNPcC5ub2RlLm91dHB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0aGUgc2l6ZSBvZiBvdXRwdXQgZG9lcyBub3QgbWF0Y2ggbW9kZWwgZGVmaW5pdGlvbi4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbGwgdmFsdWVcbiAgICAgICAgb3V0cHV0TGlzdC5mb3JFYWNoKChvdXRwdXQsIGkpID0+IHtcbiAgICAgICAgICBjb25zdCBqID0gdGhpc09wLm5vZGUub3V0cHV0c1tpXTtcbiAgICAgICAgICBpZiAodGhpcy5fdmFsdWVzW2pdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG91dHB1dCBbJHtqfV0gYWxyZWFkeSBoYXMgdmFsdWU6IG9wOiR7dGhpc09wLm5vZGUubmFtZX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fdmFsdWVzW2pdID0gb3V0cHV0O1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyByZXNvbHZlIGRvd25zdHJlYW0gbm9kZXNcbiAgICAgICAgY29uc3QgZG93bnN0cmVhbU5vZGVzID0gbmV3IFNldDxudW1iZXI+KCk7XG4gICAgICAgIG91dHB1dExpc3QuZm9yRWFjaCgoX291dHB1dCwgaSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGogPSB0aGlzT3Aubm9kZS5vdXRwdXRzW2ldO1xuICAgICAgICAgIGZvciAoY29uc3QgY3VycmVudERvd25zdHJlYW1Ob2RlSW5kZXggb2YgZ3JhcGhWYWx1ZXNbal0udG8pIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnREb3duc3RyZWFtTm9kZSA9IGdyYXBoTm9kZXNbY3VycmVudERvd25zdHJlYW1Ob2RlSW5kZXhdO1xuICAgICAgICAgICAgbGV0IHJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgayBvZiBjdXJyZW50RG93bnN0cmVhbU5vZGUuaW5wdXRzKSB7XG4gICAgICAgICAgICAgIGlmICghdGhpcy5fdmFsdWVzW2tdKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc29sdmVkKSB7XG4gICAgICAgICAgICAgIGRvd25zdHJlYW1Ob2Rlcy5hZGQoY3VycmVudERvd25zdHJlYW1Ob2RlSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHNlcXVlbmNlLnB1c2goLi4uZG93bnN0cmVhbU5vZGVzKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb3V0cHV0OiBUZW5zb3JbXSA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmdyYXBoLmdldE91dHB1dEluZGljZXMoKS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBvdXRwdXRJbmRleCA9IHRoaXMuZ3JhcGguZ2V0T3V0cHV0SW5kaWNlcygpW2ldO1xuICAgICAgICBjb25zdCBvdXRwdXRUZW5zb3IgPSB0aGlzLl92YWx1ZXNbb3V0cHV0SW5kZXhdO1xuICAgICAgICBpZiAob3V0cHV0VGVuc29yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHJlcXVpcmVkIG91dHB1dCBbJHtvdXRwdXRJbmRleH1dIGRvZXMgbm90IGhhdmUgdmFsdWVgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3V0cHV0SW5kZXggPT09IDApIHtcbiAgICAgICAgICBhd2FpdCBvdXRwdXRUZW5zb3IuZ2V0RGF0YSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcbiAgICAgICAgICBvdXRwdXRUZW5zb3IuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXQucHVzaChvdXRwdXRUZW5zb3IpO1xuICAgICAgfVxuICAgICAgTG9nZ2VyLnZlcmJvc2UoJ0V4ZWNQbGFuJywgJ2Rpc3Bvc2luZyBvZiBpbmZlcmVuY2VIYW5kbGVyJyk7XG4gICAgICBpbmZlcmVuY2VIYW5kbGVyLmRpc3Bvc2UoKTtcbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfSk7XG4gIH1cblxuICBfdmFsdWVzOiBBcnJheTxUZW5zb3IgfCB1bmRlZmluZWQ+O1xuICBfb3BzOiBLZXJuZWxPcFtdO1xuICBfc3RhcnRlcjogbnVtYmVyW107XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCBMb25nIGZyb20gJ2xvbmcnO1xuXG5pbXBvcnQgeyBvbm54cnVudGltZSB9IGZyb20gJy4vb3J0LXNjaGVtYS9mbGF0YnVmZmVycy9vcnQtZ2VuZXJhdGVkJztcbmltcG9ydCB7IG9ubnggfSBmcm9tICcuL29ydC1zY2hlbWEvcHJvdG9idWYvb25ueCc7XG5pbXBvcnQgeyBUZW5zb3IgfSBmcm9tICcuL3RlbnNvcic7XG5pbXBvcnQgeyBkZWNvZGVVdGY4U3RyaW5nLCBMb25nVXRpbCB9IGZyb20gJy4vdXRpbCc7XG5cbmltcG9ydCBvcnRGYnMgPSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzO1xuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgQXR0cmlidXRlIHtcbiAgZXhwb3J0IGludGVyZmFjZSBEYXRhVHlwZU1hcCB7XG4gICAgZmxvYXQ6IG51bWJlcjtcbiAgICBpbnQ6IG51bWJlcjtcbiAgICBzdHJpbmc6IHN0cmluZztcbiAgICB0ZW5zb3I6IFRlbnNvcjtcbiAgICBmbG9hdHM6IG51bWJlcltdO1xuICAgIGludHM6IG51bWJlcltdO1xuICAgIHN0cmluZ3M6IHN0cmluZ1tdO1xuICAgIHRlbnNvcnM6IFRlbnNvcltdO1xuICB9XG5cbiAgZXhwb3J0IHR5cGUgRGF0YVR5cGUgPSBrZXlvZiBEYXRhVHlwZU1hcDtcbn1cblxudHlwZSBWYWx1ZVR5cGVzID0gQXR0cmlidXRlLkRhdGFUeXBlTWFwW0F0dHJpYnV0ZS5EYXRhVHlwZV07XG5cbnR5cGUgVmFsdWUgPSBbVmFsdWVUeXBlcywgQXR0cmlidXRlLkRhdGFUeXBlXTtcblxuZXhwb3J0IGNsYXNzIEF0dHJpYnV0ZSB7XG4gIGNvbnN0cnVjdG9yKGF0dHJpYnV0ZXM6IG9ubnguSUF0dHJpYnV0ZVByb3RvW10gfCBvcnRGYnMuQXR0cmlidXRlW10gfCBudWxsIHwgdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5fYXR0cmlidXRlcyA9IG5ldyBNYXAoKTtcbiAgICBpZiAoYXR0cmlidXRlcyAhPT0gbnVsbCAmJiBhdHRyaWJ1dGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGZvciAoY29uc3QgYXR0ciBvZiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIGlmIChhdHRyIGluc3RhbmNlb2Ygb25ueC5BdHRyaWJ1dGVQcm90bykge1xuICAgICAgICAgIHRoaXMuX2F0dHJpYnV0ZXMuc2V0KGF0dHIubmFtZSwgW0F0dHJpYnV0ZS5nZXRWYWx1ZShhdHRyKSwgQXR0cmlidXRlLmdldFR5cGUoYXR0cildKTtcbiAgICAgICAgfSBlbHNlIGlmIChhdHRyIGluc3RhbmNlb2Ygb3J0RmJzLkF0dHJpYnV0ZSkge1xuICAgICAgICAgIHRoaXMuX2F0dHJpYnV0ZXMuc2V0KGF0dHIubmFtZSgpISwgW0F0dHJpYnV0ZS5nZXRWYWx1ZShhdHRyKSwgQXR0cmlidXRlLmdldFR5cGUoYXR0cildKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2F0dHJpYnV0ZXMuc2l6ZSA8IGF0dHJpYnV0ZXMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZHVwbGljYXRlZCBhdHRyaWJ1dGUgbmFtZXMnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzZXQoa2V5OiBzdHJpbmcsIHR5cGU6IEF0dHJpYnV0ZS5EYXRhVHlwZSwgdmFsdWU6IFZhbHVlVHlwZXMpOiB2b2lkIHtcbiAgICB0aGlzLl9hdHRyaWJ1dGVzLnNldChrZXksIFt2YWx1ZSwgdHlwZV0pO1xuICB9XG4gIGRlbGV0ZShrZXk6IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMuX2F0dHJpYnV0ZXMuZGVsZXRlKGtleSk7XG4gIH1cbiAgZ2V0RmxvYXQoa2V5OiBzdHJpbmcsIGRlZmF1bHRWYWx1ZT86IEF0dHJpYnV0ZS5EYXRhVHlwZU1hcFsnZmxvYXQnXSkge1xuICAgIHJldHVybiB0aGlzLmdldChrZXksICdmbG9hdCcsIGRlZmF1bHRWYWx1ZSk7XG4gIH1cblxuICBnZXRJbnQoa2V5OiBzdHJpbmcsIGRlZmF1bHRWYWx1ZT86IEF0dHJpYnV0ZS5EYXRhVHlwZU1hcFsnaW50J10pIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoa2V5LCAnaW50JywgZGVmYXVsdFZhbHVlKTtcbiAgfVxuXG4gIGdldFN0cmluZyhrZXk6IHN0cmluZywgZGVmYXVsdFZhbHVlPzogQXR0cmlidXRlLkRhdGFUeXBlTWFwWydzdHJpbmcnXSkge1xuICAgIHJldHVybiB0aGlzLmdldChrZXksICdzdHJpbmcnLCBkZWZhdWx0VmFsdWUpO1xuICB9XG5cbiAgZ2V0VGVuc29yKGtleTogc3RyaW5nLCBkZWZhdWx0VmFsdWU/OiBBdHRyaWJ1dGUuRGF0YVR5cGVNYXBbJ3RlbnNvciddKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KGtleSwgJ3RlbnNvcicsIGRlZmF1bHRWYWx1ZSk7XG4gIH1cblxuICBnZXRGbG9hdHMoa2V5OiBzdHJpbmcsIGRlZmF1bHRWYWx1ZT86IEF0dHJpYnV0ZS5EYXRhVHlwZU1hcFsnZmxvYXRzJ10pIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoa2V5LCAnZmxvYXRzJywgZGVmYXVsdFZhbHVlKTtcbiAgfVxuXG4gIGdldEludHMoa2V5OiBzdHJpbmcsIGRlZmF1bHRWYWx1ZT86IEF0dHJpYnV0ZS5EYXRhVHlwZU1hcFsnaW50cyddKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KGtleSwgJ2ludHMnLCBkZWZhdWx0VmFsdWUpO1xuICB9XG5cbiAgZ2V0U3RyaW5ncyhrZXk6IHN0cmluZywgZGVmYXVsdFZhbHVlPzogQXR0cmlidXRlLkRhdGFUeXBlTWFwWydzdHJpbmdzJ10pIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoa2V5LCAnc3RyaW5ncycsIGRlZmF1bHRWYWx1ZSk7XG4gIH1cblxuICBnZXRUZW5zb3JzKGtleTogc3RyaW5nLCBkZWZhdWx0VmFsdWU/OiBBdHRyaWJ1dGUuRGF0YVR5cGVNYXBbJ3RlbnNvcnMnXSkge1xuICAgIHJldHVybiB0aGlzLmdldChrZXksICd0ZW5zb3JzJywgZGVmYXVsdFZhbHVlKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0PFYgZXh0ZW5kcyBBdHRyaWJ1dGUuRGF0YVR5cGVNYXBbQXR0cmlidXRlLkRhdGFUeXBlXT4oXG4gICAga2V5OiBzdHJpbmcsXG4gICAgdHlwZTogQXR0cmlidXRlLkRhdGFUeXBlLFxuICAgIGRlZmF1bHRWYWx1ZT86IFYsXG4gICk6IFYge1xuICAgIGNvbnN0IHZhbHVlQW5kVHlwZSA9IHRoaXMuX2F0dHJpYnV0ZXMuZ2V0KGtleSk7XG4gICAgaWYgKHZhbHVlQW5kVHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihgcmVxdWlyZWQgYXR0cmlidXRlIG5vdCBmb3VuZDogJHtrZXl9YCk7XG4gICAgfVxuICAgIGlmICh2YWx1ZUFuZFR5cGVbMV0gIT09IHR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdHlwZSBtaXNtYXRjaDogZXhwZWN0ZWQgJHt0eXBlfSBidXQgZ290ICR7dmFsdWVBbmRUeXBlWzFdfWApO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVBbmRUeXBlWzBdIGFzIFY7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBnZXRUeXBlKGF0dHI6IG9ubnguSUF0dHJpYnV0ZVByb3RvIHwgb3J0RmJzLkF0dHJpYnV0ZSk6IEF0dHJpYnV0ZS5EYXRhVHlwZSB7XG4gICAgY29uc3QgdHlwZSA9IGF0dHIgaW5zdGFuY2VvZiBvbm54LkF0dHJpYnV0ZVByb3RvID8gYXR0ci50eXBlIDogKGF0dHIgYXMgb3J0RmJzLkF0dHJpYnV0ZSkudHlwZSgpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuRkxPQVQ6XG4gICAgICAgIHJldHVybiAnZmxvYXQnO1xuICAgICAgY2FzZSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuSU5UOlxuICAgICAgICByZXR1cm4gJ2ludCc7XG4gICAgICBjYXNlIG9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5TVFJJTkc6XG4gICAgICAgIHJldHVybiAnc3RyaW5nJztcbiAgICAgIGNhc2Ugb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlRFTlNPUjpcbiAgICAgICAgcmV0dXJuICd0ZW5zb3InO1xuICAgICAgY2FzZSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuRkxPQVRTOlxuICAgICAgICByZXR1cm4gJ2Zsb2F0cyc7XG4gICAgICBjYXNlIG9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5JTlRTOlxuICAgICAgICByZXR1cm4gJ2ludHMnO1xuICAgICAgY2FzZSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuU1RSSU5HUzpcbiAgICAgICAgcmV0dXJuICdzdHJpbmdzJztcbiAgICAgIGNhc2Ugb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlRFTlNPUlM6XG4gICAgICAgIHJldHVybiAndGVuc29ycyc7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGF0dHJpYnV0ZSB0eXBlIGlzIG5vdCBzdXBwb3J0ZWQgeWV0OiAke29ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZVt0eXBlXX1gKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBnZXRWYWx1ZShhdHRyOiBvbm54LklBdHRyaWJ1dGVQcm90byB8IG9ydEZicy5BdHRyaWJ1dGUpIHtcbiAgICBjb25zdCBhdHRyVHlwZSA9IGF0dHIgaW5zdGFuY2VvZiBvbm54LkF0dHJpYnV0ZVByb3RvID8gYXR0ci50eXBlIDogKGF0dHIgYXMgb3J0RmJzLkF0dHJpYnV0ZSkudHlwZSgpO1xuICAgIGlmIChhdHRyVHlwZSA9PT0gb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLkdSQVBIIHx8IGF0dHJUeXBlID09PSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuR1JBUEhTKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dyYXBoIGF0dHJpYnV0ZSBpcyBub3Qgc3VwcG9ydGVkIHlldCcpO1xuICAgIH1cblxuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5nZXRWYWx1ZU5vQ2hlY2soYXR0cik7XG5cbiAgICAvLyBjYXN0IExPTkcgdG8gbnVtYmVyXG4gICAgaWYgKGF0dHJUeXBlID09PSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuSU5UICYmIExvbmdVdGlsLmlzTG9uZyh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBMb25nVXRpbC5sb25nVG9OdW1iZXIodmFsdWUgYXMgTG9uZyB8IGZsYXRidWZmZXJzLkxvbmcpO1xuICAgIH1cblxuICAgIC8vIGNhc3QgTE9OR1tdIHRvIG51bWJlcltdXG4gICAgaWYgKGF0dHJUeXBlID09PSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuSU5UUykge1xuICAgICAgY29uc3QgYXJyID0gdmFsdWUgYXMgQXJyYXk8bnVtYmVyIHwgTG9uZyB8IGZsYXRidWZmZXJzLkxvbmc+O1xuICAgICAgY29uc3QgbnVtYmVyVmFsdWU6IG51bWJlcltdID0gbmV3IEFycmF5PG51bWJlcj4oYXJyLmxlbmd0aCk7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG1heWJlTG9uZyA9IGFycltpXTtcbiAgICAgICAgbnVtYmVyVmFsdWVbaV0gPSBMb25nVXRpbC5sb25nVG9OdW1iZXIobWF5YmVMb25nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bWJlclZhbHVlO1xuICAgIH1cblxuICAgIC8vIGNhc3Qgb25ueC5UZW5zb3JQcm90byB0byBvbm54anMuVGVuc29yXG4gICAgaWYgKGF0dHJUeXBlID09PSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuVEVOU09SKSB7XG4gICAgICByZXR1cm4gYXR0ciBpbnN0YW5jZW9mIG9ubnguQXR0cmlidXRlUHJvdG9cbiAgICAgICAgPyBUZW5zb3IuZnJvbVByb3RvKHZhbHVlIGFzIG9ubnguSVRlbnNvclByb3RvKVxuICAgICAgICA6IFRlbnNvci5mcm9tT3J0VGVuc29yKHZhbHVlIGFzIG9ydEZicy5UZW5zb3IpO1xuICAgIH1cblxuICAgIC8vIGNhc3Qgb25ueC5UZW5zb3JQcm90b1tdIHRvIG9ubnhqcy5UZW5zb3JbXVxuICAgIGlmIChhdHRyVHlwZSA9PT0gb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlRFTlNPUlMpIHtcbiAgICAgIGlmIChhdHRyIGluc3RhbmNlb2Ygb25ueC5BdHRyaWJ1dGVQcm90bykge1xuICAgICAgICBjb25zdCB0ZW5zb3JQcm90b3MgPSB2YWx1ZSBhcyBvbm54LklUZW5zb3JQcm90b1tdO1xuICAgICAgICByZXR1cm4gdGVuc29yUHJvdG9zLm1hcCgodmFsdWUpID0+IFRlbnNvci5mcm9tUHJvdG8odmFsdWUpKTtcbiAgICAgIH0gZWxzZSBpZiAoYXR0ciBpbnN0YW5jZW9mIG9ydEZicy5BdHRyaWJ1dGUpIHtcbiAgICAgICAgY29uc3QgdGVuc29yUHJvdG9zID0gdmFsdWUgYXMgb3J0RmJzLlRlbnNvcltdO1xuICAgICAgICByZXR1cm4gdGVuc29yUHJvdG9zLm1hcCgodmFsdWUpID0+IFRlbnNvci5mcm9tT3J0VGVuc29yKHZhbHVlKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2FzdCBVaW50OEFycmF5IHRvIHN0cmluZ1xuICAgIGlmIChhdHRyVHlwZSA9PT0gb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlNUUklORykge1xuICAgICAgLy8gc3RyaW5nIGluIG9ubnggYXR0cmlidXRlIGlzIG9mIHVpbnQ4YXJyYXkgdHlwZSwgc28gd2UgbmVlZCB0byBjb252ZXJ0IGl0IHRvIHN0cmluZyBiZWxvdy4gV2hpbGUgaW4gb3J0IGZvcm1hdCxcbiAgICAgIC8vIHN0cmluZyBhdHRyaWJ1dGVzIGFyZSByZXR1cm5lZCBhcyBzdHJpbmcsIHNvIG5vIGNvbnZlcnNpb24gaXMgbmVlZGVkLlxuICAgICAgaWYgKGF0dHIgaW5zdGFuY2VvZiBvbm54LkF0dHJpYnV0ZVByb3RvKSB7XG4gICAgICAgIGNvbnN0IHV0ZjhTdHJpbmcgPSB2YWx1ZSBhcyBVaW50OEFycmF5O1xuICAgICAgICByZXR1cm4gZGVjb2RlVXRmOFN0cmluZyh1dGY4U3RyaW5nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjYXN0IFVpbnQ4QXJyYXlbXSB0byBzdHJpbmdbXVxuICAgIGlmIChhdHRyVHlwZSA9PT0gb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlNUUklOR1MpIHtcbiAgICAgIC8vIHN0cmluZ3MgaW4gb25ueCBhdHRyaWJ1dGUgaXMgcmV0dXJuZWQgYXMgdWludDhhcnJheVtdLCBzbyB3ZSBuZWVkIHRvIGNvbnZlcnQgaXQgdG8gc3RyaW5nW10gYmVsb3cuIFdoaWxlIGluIG9ydFxuICAgICAgLy8gZm9ybWF0IHN0cmluZ3MgYXR0cmlidXRlcyBhcmUgcmV0dXJuZWQgYXMgc3RyaW5nW10sIHNvIG5vIGNvbnZlcnNpb24gaXMgbmVlZGVkLlxuICAgICAgaWYgKGF0dHIgaW5zdGFuY2VvZiBvbm54LkF0dHJpYnV0ZVByb3RvKSB7XG4gICAgICAgIGNvbnN0IHV0ZjhTdHJpbmdzID0gdmFsdWUgYXMgVWludDhBcnJheVtdO1xuICAgICAgICByZXR1cm4gdXRmOFN0cmluZ3MubWFwKGRlY29kZVV0ZjhTdHJpbmcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZSBhcyBWYWx1ZVR5cGVzO1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgZ2V0VmFsdWVOb0NoZWNrKGF0dHI6IG9ubnguSUF0dHJpYnV0ZVByb3RvIHwgb3J0RmJzLkF0dHJpYnV0ZSkge1xuICAgIHJldHVybiBhdHRyIGluc3RhbmNlb2Ygb25ueC5BdHRyaWJ1dGVQcm90b1xuICAgICAgPyB0aGlzLmdldFZhbHVlTm9DaGVja0Zyb21Pbm54Rm9ybWF0KGF0dHIpXG4gICAgICA6IHRoaXMuZ2V0VmFsdWVOb0NoZWNrRnJvbU9ydEZvcm1hdChhdHRyIGFzIG9ydEZicy5BdHRyaWJ1dGUpO1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgZ2V0VmFsdWVOb0NoZWNrRnJvbU9ubnhGb3JtYXQoYXR0cjogb25ueC5JQXR0cmlidXRlUHJvdG8pIHtcbiAgICBzd2l0Y2ggKGF0dHIudHlwZSEpIHtcbiAgICAgIGNhc2Ugb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLkZMT0FUOlxuICAgICAgICByZXR1cm4gYXR0ci5mO1xuICAgICAgY2FzZSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuSU5UOlxuICAgICAgICByZXR1cm4gYXR0ci5pO1xuICAgICAgY2FzZSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuU1RSSU5HOlxuICAgICAgICByZXR1cm4gYXR0ci5zO1xuICAgICAgY2FzZSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuVEVOU09SOlxuICAgICAgICByZXR1cm4gYXR0ci50O1xuICAgICAgY2FzZSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuR1JBUEg6XG4gICAgICAgIHJldHVybiBhdHRyLmc7XG4gICAgICBjYXNlIG9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5GTE9BVFM6XG4gICAgICAgIHJldHVybiBhdHRyLmZsb2F0cztcbiAgICAgIGNhc2Ugb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLklOVFM6XG4gICAgICAgIHJldHVybiBhdHRyLmludHM7XG4gICAgICBjYXNlIG9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5TVFJJTkdTOlxuICAgICAgICByZXR1cm4gYXR0ci5zdHJpbmdzO1xuICAgICAgY2FzZSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuVEVOU09SUzpcbiAgICAgICAgcmV0dXJuIGF0dHIudGVuc29ycztcbiAgICAgIGNhc2Ugb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLkdSQVBIUzpcbiAgICAgICAgcmV0dXJuIGF0dHIuZ3JhcGhzO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBhdHRyaWJ1dGUgdHlwZTogJHtvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGVbYXR0ci50eXBlIV19YCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgZ2V0VmFsdWVOb0NoZWNrRnJvbU9ydEZvcm1hdChhdHRyOiBvcnRGYnMuQXR0cmlidXRlKSB7XG4gICAgc3dpdGNoIChhdHRyLnR5cGUoKSkge1xuICAgICAgY2FzZSBvcnRGYnMuQXR0cmlidXRlVHlwZS5GTE9BVDpcbiAgICAgICAgcmV0dXJuIGF0dHIuZigpO1xuICAgICAgY2FzZSBvcnRGYnMuQXR0cmlidXRlVHlwZS5JTlQ6XG4gICAgICAgIHJldHVybiBhdHRyLmkoKTtcbiAgICAgIGNhc2Ugb3J0RmJzLkF0dHJpYnV0ZVR5cGUuU1RSSU5HOlxuICAgICAgICByZXR1cm4gYXR0ci5zKCk7XG4gICAgICBjYXNlIG9ydEZicy5BdHRyaWJ1dGVUeXBlLlRFTlNPUjpcbiAgICAgICAgcmV0dXJuIGF0dHIudCgpO1xuICAgICAgY2FzZSBvcnRGYnMuQXR0cmlidXRlVHlwZS5HUkFQSDpcbiAgICAgICAgcmV0dXJuIGF0dHIuZygpO1xuICAgICAgY2FzZSBvcnRGYnMuQXR0cmlidXRlVHlwZS5GTE9BVFM6XG4gICAgICAgIHJldHVybiBhdHRyLmZsb2F0c0FycmF5KCk7XG4gICAgICBjYXNlIG9ydEZicy5BdHRyaWJ1dGVUeXBlLklOVFM6IHtcbiAgICAgICAgY29uc3QgaW50cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF0dHIuaW50c0xlbmd0aCgpOyBpKyspIHtcbiAgICAgICAgICBpbnRzLnB1c2goYXR0ci5pbnRzKGkpISk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGludHM7XG4gICAgICB9XG4gICAgICBjYXNlIG9ydEZicy5BdHRyaWJ1dGVUeXBlLlNUUklOR1M6IHtcbiAgICAgICAgY29uc3Qgc3RyaW5ncyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF0dHIuc3RyaW5nc0xlbmd0aCgpOyBpKyspIHtcbiAgICAgICAgICBzdHJpbmdzLnB1c2goYXR0ci5zdHJpbmdzKGkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyaW5ncztcbiAgICAgIH1cbiAgICAgIGNhc2Ugb3J0RmJzLkF0dHJpYnV0ZVR5cGUuVEVOU09SUzoge1xuICAgICAgICBjb25zdCB0ZW5zb3JzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXR0ci50ZW5zb3JzTGVuZ3RoKCk7IGkrKykge1xuICAgICAgICAgIHRlbnNvcnMucHVzaChhdHRyLnRlbnNvcnMoaSkhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVuc29ycztcbiAgICAgIH1cbiAgICAgIC8vIGNhc2Ugb3J0RmJzLkF0dHJpYnV0ZVR5cGUuR1JBUEhTOlxuICAgICAgLy8gVE9ETzogU3ViZ3JhcGggbm90IHN1cHBvcnRlZCB5ZXQuXG4gICAgICAvLyBjb25zdCBncmFwaHMgPSBbXTtcbiAgICAgIC8vIGZvciAobGV0IGkgPSAwOyBpIDwgYXR0ci5ncmFwaHNMZW5ndGgoKTsgaSsrKSB7XG4gICAgICAvLyAgIGdyYXBocy5wdXNoKGF0dHIuZ3JhcGhzKGkpISk7XG4gICAgICAvLyB9XG4gICAgICAvLyByZXR1cm4gZ3JhcGhzO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBhdHRyaWJ1dGUgdHlwZTogJHtvcnRGYnMuQXR0cmlidXRlVHlwZVthdHRyLnR5cGUoKV19YCk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9hdHRyaWJ1dGVzOiBNYXA8c3RyaW5nLCBWYWx1ZT47XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEF0dHJpYnV0ZSB9IGZyb20gJy4vYXR0cmlidXRlJztcbmltcG9ydCB7IG9ubnhydW50aW1lIH0gZnJvbSAnLi9vcnQtc2NoZW1hL2ZsYXRidWZmZXJzL29ydC1nZW5lcmF0ZWQnO1xuaW1wb3J0IHsgb25ueCB9IGZyb20gJy4vb3J0LXNjaGVtYS9wcm90b2J1Zi9vbm54JztcbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4vdGVuc29yJztcbmltcG9ydCB7IExvbmdVdGlsLCBNQVhfQ0xJUCwgTUlOX0NMSVAsIFByb3RvVXRpbCB9IGZyb20gJy4vdXRpbCc7XG5cbmltcG9ydCBvcnRGYnMgPSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzO1xuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgR3JhcGgge1xuICBleHBvcnQgaW50ZXJmYWNlIFNoYXBlIHtcbiAgICByZWFkb25seSBkaW1zOiByZWFkb25seSBudW1iZXJbXTtcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIFZhbHVlVHlwZSB7XG4gICAgcmVhZG9ubHkgdGVuc29yVHlwZTogVGVuc29yLkRhdGFUeXBlO1xuICAgIHJlYWRvbmx5IHNoYXBlOiBTaGFwZTtcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIFZhbHVlIHtcbiAgICAvLyB0aGUgdGVuc29yIGRhdGEuIGVtcHR5IGZvciBub24taW5pdGlhbGl6ZWQgaW5wdXRzXG4gICAgcmVhZG9ubHkgdGVuc29yPzogVGVuc29yO1xuXG4gICAgLy8gaW5kZXggdG8gdGhlIE5vZGUgd2hlcmUgdGhlIHZhbHVlIGNvbWVzIGZyb20uIC0xIGZvciBpbml0aWFsaXplci5cbiAgICByZWFkb25seSBmcm9tOiBudW1iZXI7XG5cbiAgICAvLyBpbmRpY2VzIHRvIHRoZSBOb2RlcyB3aGVyZSB0aGUgdmFsdWVzIGdvIHRvLlxuICAgIHJlYWRvbmx5IHRvOiByZWFkb25seSBudW1iZXJbXTtcblxuICAgIC8vIHZhbHVlIHR5cGUgc3BlY2lmaWNhdGlvbi4gZW1wdHkgZm9yIG5vbi1pbnB1dCB2YWx1ZXMuXG4gICAgcmVhZG9ubHkgdHlwZT86IFZhbHVlVHlwZTtcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIE5vZGUge1xuICAgIC8vIG5hbWUgb2YgdGhlIG5vZGVcbiAgICByZWFkb25seSBuYW1lOiBzdHJpbmc7XG5cbiAgICAvLyB0aGUgb3BlcmF0b3IgdHlwZVxuICAgIHJlYWRvbmx5IG9wVHlwZTogc3RyaW5nO1xuXG4gICAgLy8gaW5kaWNlcyB0byB0aGUgVmFsdWVzIHdoZXJlIHRoZSBpbnB1dHMgY29tZSBmcm9tLlxuICAgIHJlYWRvbmx5IGlucHV0czogcmVhZG9ubHkgbnVtYmVyW107XG5cbiAgICAvLyBpbmRpY2VzIHRvIHRoZSBWYWx1ZXMgd2hlcmUgdGhlIG91dHB1cyBnbyB0by5cbiAgICByZWFkb25seSBvdXRwdXRzOiByZWFkb25seSBudW1iZXJbXTtcblxuICAgIC8vIHRoZSBhdHRyaWJ1dGVzIHRoYXQgdXNlZCBieSB0aGUgb3BlcmF0b3JcbiAgICByZWFkb25seSBhdHRyaWJ1dGVzOiBBdHRyaWJ1dGU7XG4gIH1cblxuICAvKipcbiAgICogYSBUcmFuc2Zvcm1lciBpcyBhbiBpbnN0YW5jZSB0aGF0IGFsbG93cyBhbGwgcG9zc2libGUgdHJhbnNmb3JtYXRpb24gb3BlcmF0aW9ucyB0aGF0IGFwcGxpZWQgdG8gYSBncmFwaFxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUcmFuc2Zvcm1lciB7XG4gICAgcmVtb3ZlQWxsSWRlbnRpdHlOb2RlcygpOiB2b2lkO1xuICAgIHJlbW92ZUFsbERyb3BvdXROb2RlcygpOiB2b2lkO1xuICAgIGZ1c2VDb252QWN0aXZhdGlvbk5vZGVzKCk6IHZvaWQ7XG4gICAgLy8gVE9ETzogYWRkIGdlbmVyaWMgZnVuY3Rpb25zIHRvIG1hbmlwdWxhdGUgdGhlIGdyYXBoXG4gIH1cblxuICAvLyBhbiBpbml0aWFsaXplciBjYW4gdXNlIHRyYW5zZm9ybWVyIHRvIHRyYW5zZm9ybSB0aGUgZ3JhcGhcbiAgZXhwb3J0IGludGVyZmFjZSBJbml0aWFsaXplciB7XG4gICAgdHJhbnNmb3JtR3JhcGgodHJhbnNmb3JtZXI6IFRyYW5zZm9ybWVyKTogdm9pZDtcbiAgfVxufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlZGVjbGFyZVxuZXhwb3J0IGludGVyZmFjZSBHcmFwaCB7XG4gIGdldElucHV0SW5kaWNlcygpOiByZWFkb25seSBudW1iZXJbXTtcbiAgZ2V0SW5wdXROYW1lcygpOiByZWFkb25seSBzdHJpbmdbXTtcbiAgZ2V0T3V0cHV0SW5kaWNlcygpOiByZWFkb25seSBudW1iZXJbXTtcbiAgZ2V0T3V0cHV0TmFtZXMoKTogcmVhZG9ubHkgc3RyaW5nW107XG4gIGdldFZhbHVlcygpOiByZWFkb25seSBHcmFwaC5WYWx1ZVtdO1xuICBnZXROb2RlcygpOiByZWFkb25seSBHcmFwaC5Ob2RlW107XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb24sIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZWRlY2xhcmVcbmV4cG9ydCBjb25zdCBHcmFwaCA9IHtcbiAgLyoqXG4gICAqIGNvbnN0cnVjdCBhIGdyYXBoIGZyb20gYSBncmFwaCBwcm90b2J1ZiB0eXBlXG4gICAqL1xuICBmcm9tOiAoZ3JhcGhQcm90bzogb25ueC5JR3JhcGhQcm90byB8IG9ydEZicy5HcmFwaCwgaW5pdGlhbGl6ZXI/OiBHcmFwaC5Jbml0aWFsaXplcikgPT5cbiAgICBuZXcgR3JhcGhJbXBsKGdyYXBoUHJvdG8sIGluaXRpYWxpemVyKSxcbn07XG5cbmNsYXNzIFZhbHVlIGltcGxlbWVudHMgR3JhcGguVmFsdWUge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZUluZm8/OiBvbm54LklWYWx1ZUluZm9Qcm90bykge1xuICAgIHRoaXMuX2Zyb20gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdG8gPSBbXTtcbiAgICB0aGlzLnRlbnNvciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnR5cGUgPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAodmFsdWVJbmZvKSB7XG4gICAgICB0aGlzLnR5cGUgPSBQcm90b1V0aWwudGVuc29yVmFsdWVUeXBlRnJvbVByb3RvKHZhbHVlSW5mby50eXBlIS50ZW5zb3JUeXBlISk7XG4gICAgfVxuICB9XG5cbiAgX2Zyb20/OiBudW1iZXI7IC8vIC0xIHJlcHJlc2VudCBmcm9tIGluaXRpYWxpemVyXG4gIGdldCBmcm9tKCkge1xuICAgIHJldHVybiB0aGlzLl9mcm9tITtcbiAgfVxuICBfdG86IG51bWJlcltdO1xuICBnZXQgdG8oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RvO1xuICB9XG4gIHR5cGU/OiBHcmFwaC5WYWx1ZVR5cGU7XG4gIHRlbnNvcj86IFRlbnNvcjtcbn1cblxuY2xhc3MgTm9kZSBpbXBsZW1lbnRzIEdyYXBoLk5vZGUge1xuICBjb25zdHJ1Y3Rvcihfbm9kZVByb3RvOiBvbm54LklOb2RlUHJvdG8gfCBvcnRGYnMuTm9kZSwgbmFtZT86IHN0cmluZykge1xuICAgIGlmIChfbm9kZVByb3RvIGluc3RhbmNlb2Ygb25ueC5Ob2RlUHJvdG8pIHtcbiAgICAgIHRoaXMubmFtZSA9IF9ub2RlUHJvdG8ubmFtZTtcbiAgICAgIHRoaXMub3BUeXBlID0gX25vZGVQcm90by5vcFR5cGU7XG4gICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBuZXcgQXR0cmlidXRlKF9ub2RlUHJvdG8uYXR0cmlidXRlKTtcbiAgICB9IGVsc2UgaWYgKF9ub2RlUHJvdG8gaW5zdGFuY2VvZiBvcnRGYnMuTm9kZSkge1xuICAgICAgdGhpcy5uYW1lID0gbmFtZSA/PyBfbm9kZVByb3RvLm5hbWUoKSE7XG4gICAgICB0aGlzLm9wVHlwZSA9IF9ub2RlUHJvdG8ub3BUeXBlKCkhO1xuICAgICAgdGhpcy5hdHRyaWJ1dGVzID0gbmV3IEF0dHJpYnV0ZShQcm90b1V0aWwudGVuc29yQXR0cmlidXRlc0Zyb21PUlRGb3JtYXQoX25vZGVQcm90bykpO1xuICAgIH1cblxuICAgIHRoaXMuaW5wdXRzID0gW107XG4gICAgdGhpcy5vdXRwdXRzID0gW107XG4gICAgdGhpcy5leGVjdXRlTm9kZSA9IHRydWU7XG4gIH1cblxuICBuYW1lOiBzdHJpbmc7XG4gIG9wVHlwZTogc3RyaW5nO1xuICBpbnB1dHM6IG51bWJlcltdO1xuICBvdXRwdXRzOiBudW1iZXJbXTtcbiAgYXR0cmlidXRlczogQXR0cmlidXRlO1xuICBleGVjdXRlTm9kZTogYm9vbGVhbjtcbn1cblxuY2xhc3MgR3JhcGhJbXBsIGltcGxlbWVudHMgR3JhcGgsIEdyYXBoLlRyYW5zZm9ybWVyIHtcbiAgcHJpdmF0ZSBfYWxsRGF0YTogVmFsdWVbXTtcblxuICBwcml2YXRlIF9hbGxJbnB1dEluZGljZXM6IG51bWJlcltdO1xuICBwcml2YXRlIF9hbGxJbnB1dE5hbWVzOiBzdHJpbmdbXTtcblxuICBwcml2YXRlIF9hbGxPdXRwdXRJbmRpY2VzOiBudW1iZXJbXTtcbiAgcHJpdmF0ZSBfYWxsT3V0cHV0TmFtZXM6IHN0cmluZ1tdO1xuXG4gIHByaXZhdGUgX25vZGVzOiBOb2RlW107XG5cbiAgY29uc3RydWN0b3IoZ3JhcGg6IG9ubnguSUdyYXBoUHJvdG8gfCBvcnRGYnMuR3JhcGgsIGdyYXBoSW5pdGlhbGl6ZXI/OiBHcmFwaC5Jbml0aWFsaXplcikge1xuICAgIGlmICghZ3JhcGgpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2dyYXBoIGlzIGVtcHR5Jyk7XG4gICAgfVxuXG4gICAgLy8gYnVpbGQgdGhlIGdyYXBoIC0gd2lsbCB0aHJvdyBleGNlcHRpb25zIGlmIHNvbWV0aGluZyBmYXRhbCBpcyBkZXRlY3RlZFxuICAgIHRoaXMuYnVpbGRHcmFwaChncmFwaCk7XG5cbiAgICAvLyBleGVjdXRlIGFueSB0cmFuc2Zvcm1hdGlvbiBsb2dpYyBmb3IgdGhlIGdyYXBoIChpZiBhcHBsaWNhYmxlKVxuICAgIHRoaXMudHJhbnNmb3JtR3JhcGgoZ3JhcGhJbml0aWFsaXplcik7XG5cbiAgICAvLyBjaGVjayBmb3IgY3ljbGVzIGFuZCBvdGhlciBpbmNvbnNpc3RlbmNpZXMgLSB3aWxsIHRocm93IGV4Y2VwdGlvbnMgaWYgc29tZXRoaW5nIGZhdGFsIGlzIGRldGVjdGVkXG4gICAgdGhpcy5jaGVja0lzQWN5Y2xpYygpO1xuICB9XG5cbiAgZ2V0SW5wdXRJbmRpY2VzKCk6IHJlYWRvbmx5IG51bWJlcltdIHtcbiAgICByZXR1cm4gdGhpcy5fYWxsSW5wdXRJbmRpY2VzO1xuICB9XG5cbiAgZ2V0SW5wdXROYW1lcygpOiByZWFkb25seSBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHRoaXMuX2FsbElucHV0TmFtZXM7XG4gIH1cblxuICBnZXRPdXRwdXRJbmRpY2VzKCk6IHJlYWRvbmx5IG51bWJlcltdIHtcbiAgICByZXR1cm4gdGhpcy5fYWxsT3V0cHV0SW5kaWNlcztcbiAgfVxuXG4gIGdldE91dHB1dE5hbWVzKCk6IHJlYWRvbmx5IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gdGhpcy5fYWxsT3V0cHV0TmFtZXM7XG4gIH1cblxuICBnZXRWYWx1ZXMoKTogcmVhZG9ubHkgR3JhcGguVmFsdWVbXSB7XG4gICAgcmV0dXJuIHRoaXMuX2FsbERhdGE7XG4gIH1cblxuICBnZXROb2RlcygpOiByZWFkb25seSBHcmFwaC5Ob2RlW10ge1xuICAgIHJldHVybiB0aGlzLl9ub2RlcztcbiAgfVxuXG4gIHByaXZhdGUgYnVpbGRHcmFwaChncmFwaDogb25ueC5JR3JhcGhQcm90byB8IG9ydEZicy5HcmFwaCkge1xuICAgIC8vIGJ1aWxkIHRoZSBncmFwaCAtIHdpbGwgdGhyb3cgZXhjZXB0aW9ucyBpZiBzb21ldGhpbmcgZmF0YWwgaXMgZGV0ZWN0ZWRcbiAgICBpZiAoZ3JhcGggaW5zdGFuY2VvZiBvbm54LkdyYXBoUHJvdG8pIHtcbiAgICAgIHRoaXMuYnVpbGRHcmFwaEZyb21Pbm54Rm9ybWF0KGdyYXBoKTtcbiAgICB9IGVsc2UgaWYgKGdyYXBoIGluc3RhbmNlb2Ygb3J0RmJzLkdyYXBoKSB7XG4gICAgICB0aGlzLmJ1aWxkR3JhcGhGcm9tT3J0Rm9ybWF0KGdyYXBoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignR3JhcGggdHlwZSBpcyBub3Qgc3VwcG9ydGVkLicpO1xuICAgIH1cbiAgfVxuICBwcml2YXRlIGJ1aWxkR3JhcGhGcm9tT25ueEZvcm1hdChncmFwaDogb25ueC5JR3JhcGhQcm90bykge1xuICAgIGNvbnN0IGRhdGFJbmRpY2VzID0gbmV3IE1hcDxzdHJpbmcsIG51bWJlcj4oKTtcbiAgICB0aGlzLl9hbGxEYXRhID0gW107XG5cbiAgICB0aGlzLl9hbGxJbnB1dEluZGljZXMgPSBbXTtcbiAgICB0aGlzLl9hbGxJbnB1dE5hbWVzID0gW107XG5cbiAgICB0aGlzLl9hbGxPdXRwdXRJbmRpY2VzID0gW107XG4gICAgdGhpcy5fYWxsT3V0cHV0TmFtZXMgPSBbXTtcblxuICAgIHRoaXMuX25vZGVzID0gW107XG5cbiAgICBjb25zdCBub2Rlc0luZGljZXMgPSBuZXcgTWFwPHN0cmluZywgbnVtYmVyPigpO1xuXG4gICAgLy8gc2NhbiBhbGwgaW5wdXRzXG4gICAgaWYgKCFncmFwaC5pbnB1dCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIGluZm9ybWF0aW9uIGluIGdyYXBoOiBpbnB1dCcpO1xuICAgIH1cbiAgICBjb25zdCBpbnB1dFZhbHVlTmFtZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGkgb2YgZ3JhcGguaW5wdXQpIHtcbiAgICAgIGlmIChkYXRhSW5kaWNlcy5oYXMoaS5uYW1lISkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkdXBsaWNhdGVkIGlucHV0IG5hbWU6ICR7aS5uYW1lfWApO1xuICAgICAgfVxuICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gdGhpcy5fYWxsRGF0YS5wdXNoKG5ldyBWYWx1ZShpKSkgLSAxO1xuICAgICAgZGF0YUluZGljZXMuc2V0KGkubmFtZSEsIGN1cnJlbnRJbmRleCk7XG4gICAgICBpbnB1dFZhbHVlTmFtZXMucHVzaChpLm5hbWUhKTtcbiAgICB9XG5cbiAgICAvLyBzY2FuIGFsbCBpbml0aWFsaXplcnNcbiAgICBpZiAoIWdyYXBoLmluaXRpYWxpemVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgaW5mb3JtYXRpb24gaW4gZ3JhcGg6IGluaXRpYWxpemVyJyk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgaSBvZiBncmFwaC5pbml0aWFsaXplcikge1xuICAgICAgbGV0IGluZGV4ID0gZGF0YUluZGljZXMuZ2V0KGkubmFtZSEpO1xuICAgICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBuZXcgVmFsdWUoKTtcbiAgICAgICAgdmFsdWUudHlwZSA9IHtcbiAgICAgICAgICBzaGFwZTogeyBkaW1zOiBQcm90b1V0aWwudGVuc29yRGltc0Zyb21Qcm90byhpLmRpbXMhKSB9LFxuICAgICAgICAgIHRlbnNvclR5cGU6IFByb3RvVXRpbC50ZW5zb3JEYXRhVHlwZUZyb21Qcm90byhpLmRhdGFUeXBlISksXG4gICAgICAgIH07XG4gICAgICAgIGluZGV4ID0gdGhpcy5fYWxsRGF0YS5wdXNoKHZhbHVlKSAtIDE7XG4gICAgICAgIGRhdGFJbmRpY2VzLnNldChpLm5hbWUhLCBpbmRleCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9hbGxEYXRhW2luZGV4XS5fZnJvbSA9IC0xO1xuICAgICAgdGhpcy5fYWxsRGF0YVtpbmRleF0udGVuc29yID0gVGVuc29yLmZyb21Qcm90byhpKTtcbiAgICB9XG5cbiAgICAvLyBmaWx0ZXIgb3V0IGlucHV0IGluZGljZXNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2FsbERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghdGhpcy5fYWxsRGF0YVtpXS50ZW5zb3IpIHtcbiAgICAgICAgdGhpcy5fYWxsSW5wdXRJbmRpY2VzLnB1c2goaSk7XG4gICAgICAgIHRoaXMuX2FsbElucHV0TmFtZXMucHVzaChpbnB1dFZhbHVlTmFtZXNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNjYW4gYWxsIG91dHB1dHNcbiAgICBpZiAoIWdyYXBoLm91dHB1dCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIGluZm9ybWF0aW9uIGluIGdyYXBoOiBvdXRwdXQnKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBpIG9mIGdyYXBoLm91dHB1dCkge1xuICAgICAgaWYgKGRhdGFJbmRpY2VzLmhhcyhpLm5hbWUhKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGR1cGxpY2F0ZWQgb3V0cHV0IG5hbWU6ICR7aS5uYW1lfWApO1xuICAgICAgfVxuICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gdGhpcy5fYWxsRGF0YS5wdXNoKG5ldyBWYWx1ZShpKSkgLSAxO1xuICAgICAgZGF0YUluZGljZXMuc2V0KGkubmFtZSEsIGN1cnJlbnRJbmRleCk7XG4gICAgICB0aGlzLl9hbGxPdXRwdXRJbmRpY2VzLnB1c2goY3VycmVudEluZGV4KTtcbiAgICAgIHRoaXMuX2FsbE91dHB1dE5hbWVzLnB1c2goaS5uYW1lISk7XG4gICAgfVxuXG4gICAgLy8gc2NhbiBhbGwgbm9kZXNcbiAgICBpZiAoIWdyYXBoLm5vZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBpbmZvcm1hdGlvbiBpbiBncmFwaDogbm9kZScpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IG5vZGVQcm90byBvZiBncmFwaC5ub2RlKSB7XG4gICAgICBpZiAoIW5vZGVQcm90by5uYW1lKSB7XG4gICAgICAgIC8vIGFzc2lnbiBhIG5hbWUgdG8gdGhlIG5vZGUgaWYgaXQgZG9lc24ndCBoYXZlIG9uZVxuICAgICAgICBmb3IgKGxldCBwaWNrID0gMDsgOyBwaWNrKyspIHtcbiAgICAgICAgICBjb25zdCBuYW1lID0gYHVubmFtZWRfJHtub2RlUHJvdG8ub3BUeXBlfV8ke3BpY2t9YDtcbiAgICAgICAgICBpZiAoIW5vZGVzSW5kaWNlcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIG5vZGVQcm90by5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobm9kZXNJbmRpY2VzLmhhcyhub2RlUHJvdG8ubmFtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkdXBsaWNhdGVkIG5vZGUgbmFtZTogJHtub2RlUHJvdG8ubmFtZX1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IHRoaXMuX25vZGVzLnB1c2gobmV3IE5vZGUobm9kZVByb3RvKSkgLSAxO1xuICAgICAgbm9kZXNJbmRpY2VzLnNldChub2RlUHJvdG8ubmFtZSwgY3VycmVudEluZGV4KTtcbiAgICB9XG5cbiAgICAvLyBzY2FuIG5vZGUncyBvdXRwdXRzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9ub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuX25vZGVzW2ldO1xuICAgICAgY29uc3Qgbm9kZVByb3RvID0gZ3JhcGgubm9kZVtpXTtcbiAgICAgIGlmICghbm9kZVByb3RvLm91dHB1dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG1pc3Npbmcgb3V0cHV0IGZvciBub2RlOiAke25vZGVQcm90by5uYW1lfWApO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBvdXRwdXQgb2Ygbm9kZVByb3RvLm91dHB1dCkge1xuICAgICAgICBsZXQgZGF0YUluZGV4ID0gZGF0YUluZGljZXMuZ2V0KG91dHB1dCk7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YUluZGV4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGRhdGFJbmRleCA9IHRoaXMuX2FsbERhdGEucHVzaChuZXcgVmFsdWUoKSkgLSAxO1xuICAgICAgICAgIGRhdGFJbmRpY2VzLnNldChvdXRwdXQsIGRhdGFJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5vdXRwdXRzLnB1c2goZGF0YUluZGV4KTtcblxuICAgICAgICBpZiAodGhpcy5fYWxsRGF0YVtkYXRhSW5kZXhdLl9mcm9tICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG11bHRpcGxlIG5vZGVzIG91dHB1dCB0byBvbmUgZGF0YSB2YWx1ZTogJHtkYXRhSW5kZXh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYWxsRGF0YVtkYXRhSW5kZXhdLl9mcm9tID0gaTtcblxuICAgICAgICAvLyBmb3IgdGhlICdDb25zdGFudCcgb3BlcmF0b3IsIGp1c3QgY3JlYXRlIGEgbmV3IGVkZ2UgaW4gdGhlIGdyYXBoIGNvcnJlc3BvbmRpbmcgdG8gdGhlICdvdXRwdXQnIG9mIHRoZVxuICAgICAgICAvLyBvcGVyYXRvciBhbmQgaWdub3JlIHRoZSBub2RlIGZyb20gdGhlIGdyYXBoXG4gICAgICAgIGlmIChub2RlUHJvdG8ub3BUeXBlID09PSAnQ29uc3RhbnQnKSB7XG4gICAgICAgICAgaWYgKCFub2RlUHJvdG8uYXR0cmlidXRlIHx8IG5vZGVQcm90by5hdHRyaWJ1dGUubGVuZ3RoICE9PSAxIHx8ICFub2RlUHJvdG8uYXR0cmlidXRlWzBdLnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBhdHRyaWJ1dGVzIG9yIG1pc3NpbmcgdGVuc29yIHZhbHVlIGluIGF0dHJpYnV0ZXMgZm9yIHRoaXMgQ29uc3RhbnQgb3BlcmF0b3InKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFub2RlUHJvdG8ub3V0cHV0IHx8IG5vZGVQcm90by5vdXRwdXQubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3Npbmcgb3V0cHV0IG9yIGluY29ycmVjdCBudW1iZXIgb2Ygb3V0cHV0cyBmb3IgdGhpcyBDb25zdGFudCBvcGVyYXRvcicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlLm91dHB1dHMucG9wKCk7XG4gICAgICAgICAgbm9kZS5leGVjdXRlTm9kZSA9IGZhbHNlO1xuXG4gICAgICAgICAgdGhpcy5fYWxsRGF0YVtkYXRhSW5kZXhdLl9mcm9tID0gLTE7XG4gICAgICAgICAgdGhpcy5fYWxsRGF0YVtkYXRhSW5kZXhdLnRlbnNvciA9IFRlbnNvci5mcm9tUHJvdG8obm9kZVByb3RvLmF0dHJpYnV0ZVswXS50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNjYW4gbm9kZSdzIGlucHV0c1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLl9ub2Rlc1tpXTtcbiAgICAgIGNvbnN0IG5vZGVQcm90byA9IGdyYXBoLm5vZGVbaV07XG5cbiAgICAgIGlmICghbm9kZVByb3RvLmlucHV0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbWlzc2luZyBpbnB1dCBmb3Igbm9kZTogJHtub2RlUHJvdG8ubmFtZX1gKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgaW5wdXQgb2Ygbm9kZVByb3RvLmlucHV0KSB7XG4gICAgICAgIGNvbnN0IGRhdGFJbmRleCA9IGRhdGFJbmRpY2VzLmdldChpbnB1dCk7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YUluZGV4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIC8vIGhhbmRsZSBleGNlcHRpb24gd2hlbiBvcHNldCA+IDkgYW5kIHJvaSAvIHNjYWxlcyBub3QgZ2l2ZW5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBpbnB1dCA9PT0gJycgJiZcbiAgICAgICAgICAgIChub2RlUHJvdG8uaW5wdXQubGVuZ3RoID09PSAzIHx8IG5vZGVQcm90by5pbnB1dC5sZW5ndGggPT09IDQpICYmXG4gICAgICAgICAgICBub2RlUHJvdG8ub3BUeXBlID09PSAnUmVzaXplJ1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5yZWNvZ25pemVkIGlucHV0ICcke2lucHV0fScgZm9yIG5vZGU6ICR7bm9kZVByb3RvLm5hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5pbnB1dHMucHVzaChkYXRhSW5kZXgpO1xuXG4gICAgICAgIHRoaXMuX2FsbERhdGFbZGF0YUluZGV4XS5fdG8ucHVzaChpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHByaXZhdGUgYnVpbGRHcmFwaEZyb21PcnRGb3JtYXQoZ3JhcGg6IG9ydEZicy5HcmFwaCkge1xuICAgIGNvbnN0IGRhdGFJbmRpY2VzID0gbmV3IE1hcDxzdHJpbmcsIG51bWJlcj4oKTtcbiAgICB0aGlzLl9hbGxEYXRhID0gW107XG5cbiAgICB0aGlzLl9hbGxJbnB1dEluZGljZXMgPSBbXTtcbiAgICB0aGlzLl9hbGxJbnB1dE5hbWVzID0gW107XG5cbiAgICB0aGlzLl9hbGxPdXRwdXRJbmRpY2VzID0gW107XG4gICAgdGhpcy5fYWxsT3V0cHV0TmFtZXMgPSBbXTtcblxuICAgIHRoaXMuX25vZGVzID0gW107XG5cbiAgICBjb25zdCBub2Rlc0luZGljZXMgPSBuZXcgTWFwPHN0cmluZywgbnVtYmVyPigpO1xuXG4gICAgLy8gc2NhbiBhbGwgaW5wdXRzXG4gICAgY29uc3QgaW5wdXRWYWx1ZU5hbWVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncmFwaC5pbnB1dHNMZW5ndGgoKTsgaSsrKSB7XG4gICAgICBjb25zdCBpbnB1dE5hbWUgPSBncmFwaC5pbnB1dHMoaSk7XG4gICAgICBpZiAoZGF0YUluZGljZXMuaGFzKGlucHV0TmFtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkdXBsaWNhdGVkIGlucHV0IG5hbWU6ICR7aW5wdXROYW1lfWApO1xuICAgICAgfVxuICAgICAgLy8gRmluZCB0aGUgaW5wdXQgdHlwZUluZm8gZnJvbSBub2RlYXJnc1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBncmFwaC5ub2RlQXJnc0xlbmd0aCgpOyBqKyspIHtcbiAgICAgICAgaWYgKGdyYXBoLm5vZGVBcmdzKGopPy5uYW1lKCkgPT09IGlucHV0TmFtZSkge1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gbmV3IFZhbHVlKCk7XG4gICAgICAgICAgY29uc3QgdmFsdWVUeXBlID0gZ3JhcGgubm9kZUFyZ3Moaik/LnR5cGUoKT8udmFsdWVUeXBlKCk7XG4gICAgICAgICAgaWYgKHZhbHVlVHlwZSAhPT0gb3J0RmJzLlR5cGVJbmZvVmFsdWUudGVuc29yX3R5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCB2YWx1ZSB0eXBlIGZvciB0aGUgbm9kZUFyZy4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgdmFsdWVJbmZvID0gZ3JhcGgubm9kZUFyZ3MoaikhLnR5cGUoKSEudmFsdWUobmV3IG9ydEZicy5UZW5zb3JUeXBlQW5kU2hhcGUoKSkhO1xuICAgICAgICAgIGNvbnN0IHR5cGUgPSBQcm90b1V0aWwudGVuc29yRGF0YVR5cGVGcm9tUHJvdG8odmFsdWVJbmZvLmVsZW1UeXBlKCkpO1xuICAgICAgICAgIGNvbnN0IHNoYXBlID0gdmFsdWVJbmZvLnNoYXBlKCkhO1xuICAgICAgICAgIGNvbnN0IGRpbXMgPSBbXTtcbiAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHNoYXBlLmRpbUxlbmd0aCgpITsgaysrKSB7XG4gICAgICAgICAgICBkaW1zLnB1c2goTG9uZ1V0aWwubG9uZ1RvTnVtYmVyKHNoYXBlLmRpbShrKSEudmFsdWUoKSEuZGltVmFsdWUoKSEpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsdWUudHlwZSA9IHsgc2hhcGU6IHsgZGltcyB9LCB0ZW5zb3JUeXBlOiB0eXBlIH07XG4gICAgICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gdGhpcy5fYWxsRGF0YS5wdXNoKHZhbHVlKSAtIDE7XG4gICAgICAgICAgZGF0YUluZGljZXMuc2V0KGlucHV0TmFtZSwgY3VycmVudEluZGV4KTtcbiAgICAgICAgICBpbnB1dFZhbHVlTmFtZXMucHVzaChpbnB1dE5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGNoZWNrIGluaXRpYWxpemVyc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JhcGguaW5pdGlhbGl6ZXJzTGVuZ3RoKCk7IGkrKykge1xuICAgICAgY29uc3QgaW5pdGlhbGl6ZXIgPSBncmFwaC5pbml0aWFsaXplcnMoaSkhO1xuICAgICAgbGV0IGluZGV4ID0gZGF0YUluZGljZXMuZ2V0KGluaXRpYWxpemVyLm5hbWUoKSEpO1xuICAgICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBuZXcgVmFsdWUoKTtcbiAgICAgICAgY29uc3QgZGltcyA9IFByb3RvVXRpbC50ZW5zb3JEaW1zRnJvbU9SVEZvcm1hdChpbml0aWFsaXplcik7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBQcm90b1V0aWwudGVuc29yRGF0YVR5cGVGcm9tUHJvdG8oaW5pdGlhbGl6ZXIuZGF0YVR5cGUoKSk7XG4gICAgICAgIHZhbHVlLnR5cGUgPSB7IHNoYXBlOiB7IGRpbXMgfSwgdGVuc29yVHlwZTogdHlwZSB9O1xuICAgICAgICBpbmRleCA9IHRoaXMuX2FsbERhdGEucHVzaCh2YWx1ZSkgLSAxO1xuICAgICAgICBkYXRhSW5kaWNlcy5zZXQoaW5pdGlhbGl6ZXIubmFtZSgpISwgaW5kZXgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fYWxsRGF0YVtpbmRleF0uX2Zyb20gPSAtMTtcbiAgICAgIHRoaXMuX2FsbERhdGFbaW5kZXhdLnRlbnNvciA9IFRlbnNvci5mcm9tT3J0VGVuc29yKGluaXRpYWxpemVyKTtcbiAgICB9XG5cbiAgICAvLyBmaWx0ZXIgb3V0IGlucHV0IGluZGljZXNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2FsbERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghdGhpcy5fYWxsRGF0YVtpXS50ZW5zb3IpIHtcbiAgICAgICAgdGhpcy5fYWxsSW5wdXRJbmRpY2VzLnB1c2goaSk7XG4gICAgICAgIHRoaXMuX2FsbElucHV0TmFtZXMucHVzaChpbnB1dFZhbHVlTmFtZXNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNjYW4gYWxsIG91dHB1dHNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyYXBoLm91dHB1dHNMZW5ndGgoKTsgaSsrKSB7XG4gICAgICBjb25zdCBvdXRwdXROYW1lID0gZ3JhcGgub3V0cHV0cyhpKTtcbiAgICAgIGlmIChkYXRhSW5kaWNlcy5oYXMob3V0cHV0TmFtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkdXBsaWNhdGVkIG91dHB1dCBuYW1lOiAke291dHB1dE5hbWV9YCk7XG4gICAgICB9XG4gICAgICBjb25zdCBjdXJyZW50SW5kZXggPSB0aGlzLl9hbGxEYXRhLnB1c2gobmV3IFZhbHVlKCkpIC0gMTtcbiAgICAgIGRhdGFJbmRpY2VzLnNldChvdXRwdXROYW1lLCBjdXJyZW50SW5kZXgpO1xuICAgICAgdGhpcy5fYWxsT3V0cHV0SW5kaWNlcy5wdXNoKGN1cnJlbnRJbmRleCk7XG4gICAgICB0aGlzLl9hbGxPdXRwdXROYW1lcy5wdXNoKG91dHB1dE5hbWUpO1xuICAgIH1cblxuICAgIC8vIHNjYW4gYWxsIG5vZGVzXG4gICAgaWYgKCFncmFwaC5ub2Rlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIGluZm9ybWF0aW9uIGluIGdyYXBoOiBub2RlJyk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JhcGgubm9kZXNMZW5ndGgoKTsgaSsrKSB7XG4gICAgICBjb25zdCBub2RlUHJvdG8gPSBncmFwaC5ub2RlcyhpKTtcbiAgICAgIGxldCBuYW1lID0gbm9kZVByb3RvIS5uYW1lKCk7XG4gICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgLy8gYXNzaWduIGEgbmFtZSB0byB0aGUgbm9kZSBpZiBpdCBkb2Vzbid0IGhhdmUgb25lXG4gICAgICAgIGZvciAobGV0IHBpY2sgPSAwOyA7IHBpY2srKykge1xuICAgICAgICAgIG5hbWUgPSBgdW5uYW1lZF8ke25vZGVQcm90byEub3BUeXBlKCl9XyR7cGlja31gO1xuICAgICAgICAgIGlmICghbm9kZXNJbmRpY2VzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgLy8gYW4gdW5pcXVlIG5hbWUgaXMgZm91bmQuIGJyZWFrLlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChub2Rlc0luZGljZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZHVwbGljYXRlZCBub2RlIG5hbWU6ICR7bmFtZX1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IHRoaXMuX25vZGVzLnB1c2gobmV3IE5vZGUobm9kZVByb3RvISwgbmFtZSkpIC0gMTtcbiAgICAgIG5vZGVzSW5kaWNlcy5zZXQobmFtZSwgY3VycmVudEluZGV4KTtcbiAgICB9XG5cbiAgICAvLyBzY2FuIG5vZGUncyBvdXRwdXRzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9ub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuX25vZGVzW2ldO1xuICAgICAgY29uc3Qgbm9kZVByb3RvID0gZ3JhcGgubm9kZXMoaSk7XG4gICAgICBpZiAobm9kZVByb3RvID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBub2RlIGV4aXN0cyBhdCBpbmRleCAke2l9YCk7XG4gICAgICB9XG4gICAgICBpZiAobm9kZVByb3RvPy5vdXRwdXRzTGVuZ3RoKCkgPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBtaXNzaW5nIG91dHB1dCBmb3Igbm9kZTogJHtub2RlUHJvdG8ubmFtZX1gKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbm9kZVByb3RvPy5vdXRwdXRzTGVuZ3RoKCk7IGorKykge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBub2RlUHJvdG8/Lm91dHB1dHMoaik7XG4gICAgICAgIGxldCBkYXRhSW5kZXggPSBkYXRhSW5kaWNlcy5nZXQob3V0cHV0KTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhSW5kZXggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgZGF0YUluZGV4ID0gdGhpcy5fYWxsRGF0YS5wdXNoKG5ldyBWYWx1ZSgpKSAtIDE7XG4gICAgICAgICAgZGF0YUluZGljZXMuc2V0KG91dHB1dCwgZGF0YUluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLm91dHB1dHMucHVzaChkYXRhSW5kZXgpO1xuXG4gICAgICAgIGlmICh0aGlzLl9hbGxEYXRhW2RhdGFJbmRleF0uX2Zyb20gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbXVsdGlwbGUgbm9kZXMgb3V0cHV0IHRvIG9uZSBkYXRhIHZhbHVlOiAke2RhdGFJbmRleH1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hbGxEYXRhW2RhdGFJbmRleF0uX2Zyb20gPSBpO1xuXG4gICAgICAgIC8vIGZvciB0aGUgJ0NvbnN0YW50JyBvcGVyYXRvciwganVzdCBjcmVhdGUgYSBuZXcgZWRnZSBpbiB0aGUgZ3JhcGggY29ycmVzcG9uZGluZyB0byB0aGUgJ291dHB1dCcgb2YgdGhlXG4gICAgICAgIC8vIG9wZXJhdG9yIGFuZCBpZ25vcmUgdGhlIG5vZGUgZnJvbSB0aGUgZ3JhcGhcbiAgICAgICAgaWYgKG5vZGVQcm90by5vcFR5cGUoKSA9PT0gJ0NvbnN0YW50Jykge1xuICAgICAgICAgIGlmIChub2RlUHJvdG8uYXR0cmlidXRlc0xlbmd0aCgpICE9PSAxIHx8ICFub2RlUHJvdG8uYXR0cmlidXRlcygwKSEudCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgYXR0cmlidXRlcyBvciBtaXNzaW5nIHRlbnNvciB2YWx1ZSBpbiBhdHRyaWJ1dGVzIGZvciB0aGlzIENvbnN0YW50IG9wZXJhdG9yJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChub2RlUHJvdG8ub3V0cHV0c0xlbmd0aCgpICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3Npbmcgb3V0cHV0IG9yIGluY29ycmVjdCBudW1iZXIgb2Ygb3V0cHV0cyBmb3IgdGhpcyBDb25zdGFudCBvcGVyYXRvcicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlLm91dHB1dHMucG9wKCk7XG4gICAgICAgICAgbm9kZS5leGVjdXRlTm9kZSA9IGZhbHNlO1xuXG4gICAgICAgICAgdGhpcy5fYWxsRGF0YVtkYXRhSW5kZXhdLl9mcm9tID0gLTE7XG4gICAgICAgICAgdGhpcy5fYWxsRGF0YVtkYXRhSW5kZXhdLnRlbnNvciA9IFRlbnNvci5mcm9tT3J0VGVuc29yKG5vZGVQcm90by5hdHRyaWJ1dGVzKDApIS50KCkhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNjYW4gbm9kZSdzIGlucHV0c1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLl9ub2Rlc1tpXTtcbiAgICAgIGNvbnN0IG5vZGVQcm90byA9IGdyYXBoLm5vZGVzKGkpITtcblxuICAgICAgaWYgKG5vZGVQcm90by5pbnB1dHNMZW5ndGgoKSA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG1pc3NpbmcgaW5wdXQgZm9yIG5vZGU6ICR7bm9kZVByb3RvLm5hbWV9YCk7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG5vZGVQcm90by5pbnB1dHNMZW5ndGgoKSE7IGorKykge1xuICAgICAgICBjb25zdCBpbnB1dCA9IG5vZGVQcm90by5pbnB1dHMoaikhO1xuICAgICAgICBjb25zdCBkYXRhSW5kZXggPSBkYXRhSW5kaWNlcy5nZXQoaW5wdXQpO1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFJbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVucmVjb2duaXplZCBpbnB1dCAnJHtpbnB1dH0nIGZvciBub2RlOiAke25vZGVQcm90byEubmFtZSgpfWApO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUuaW5wdXRzLnB1c2goZGF0YUluZGV4KTtcblxuICAgICAgICB0aGlzLl9hbGxEYXRhW2RhdGFJbmRleF0uX3RvLnB1c2goaSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjaGVja0lzQWN5Y2xpYygpIHtcbiAgICAvLyBnbyB0aHJvdWdoIHRoZSBncmFwaCBhbmQgY2hlY2sgZm9yIGN5Y2xlcyBvciBvdGhlciBmYXRhbCBpbmNvbnNpc3RlbmNpZXNcbiAgICBjb25zdCBzdGFydGVyczogU2V0PG51bWJlcj4gPSBuZXcgU2V0PG51bWJlcj4oKTtcbiAgICB0aGlzLl9hbGxJbnB1dEluZGljZXMuZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgY29uc3QgZGF0YSA9IHRoaXMuX2FsbERhdGFbaV07XG4gICAgICBkYXRhLl90by5mb3JFYWNoKChqKSA9PiB7XG4gICAgICAgIHN0YXJ0ZXJzLmFkZChqKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gSXRlcmF0aXZlIERGUyB0byBjaGVjayBmb3IgY3ljbGVzXG4gICAgY29uc3Qgbm9kZXNTdGFjayA9IEFycmF5LmZyb20oc3RhcnRlcnMpO1xuICAgIGNvbnN0IG5vZGVzU3RhdGUgPSBuZXcgQXJyYXk8c3RyaW5nPih0aGlzLl9ub2Rlcy5sZW5ndGgpLmZpbGwoJ3doaXRlJyk7XG5cbiAgICB3aGlsZSAobm9kZXNTdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBub2RlSW5kZXggPSBub2Rlc1N0YWNrLnBvcCgpITtcbiAgICAgIC8vIHRoaXMgbm9kZSBoYXMgbm93IGJlZW4gcHJvY2Vzc2VkIGNvbXBsZXRlbHkuIE1hcmsgdGhpcyBub2RlICdibGFjaycgdG8gZGVub3RlIHRoaXMuXG4gICAgICBpZiAobm9kZXNTdGF0ZVtub2RlSW5kZXhdID09PSAnZ3JheScpIHtcbiAgICAgICAgbm9kZXNTdGF0ZVtub2RlSW5kZXhdID0gJ2JsYWNrJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHRoaXMgbm9kZSBpcyB1bmRlciBwcm9jZXNzaW5nIHN0YWdlLiBtYXJrIHRoaXMgbm9kZSAnZ3JheScgdG8gZGVub3RlIHRoaXMuXG4gICAgICAgIG5vZGVzU3RhY2sucHVzaChub2RlSW5kZXgpO1xuICAgICAgICBub2Rlc1N0YXRlW25vZGVJbmRleF0gPSAnZ3JheSc7XG5cbiAgICAgICAgdGhpcy5fbm9kZXNbbm9kZUluZGV4XS5vdXRwdXRzLmZvckVhY2goKG91dGdvaW5nRWRnZUluZGV4KSA9PiB7XG4gICAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuX2FsbERhdGFbb3V0Z29pbmdFZGdlSW5kZXhdO1xuICAgICAgICAgIGlmICh0eXBlb2YgZGF0YS50ZW5zb3IgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vZGUgb3V0cHV0cyBzaG91bGQgbm90IGJlIGluaXRpYWxpemVkJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkYXRhLl9mcm9tICE9PSBub2RlSW5kZXgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImZyb20gcHJvcGVydHkgb2YgdGhlIFZhbHVlIG9iamVjdCBkb2Vzbid0IG1hdGNoIGluZGV4IG9mIE5vZGUgYmVpbmcgcHJvY2Vzc2VkXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkYXRhLl90by5mb3JFYWNoKChkb3duc3RyZWFtTm9kZUluZGV4KSA9PiB7XG4gICAgICAgICAgICAvLyBiYWNrIGVkZ2UgZm91bmQgLSBjeWNsaWNcbiAgICAgICAgICAgIGlmIChub2Rlc1N0YXRlW2Rvd25zdHJlYW1Ob2RlSW5kZXhdID09PSAnZ3JheScpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtb2RlbCBncmFwaCBpcyBjeWNsaWMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRyZWUgZWRnZSBmb3VuZCAtIGNvbnRpbnVlIHByb2Nlc3NpbmcgYnkgYWRkaW5nIGl0IHRvIHN0YWNrXG4gICAgICAgICAgICBlbHNlIGlmIChub2Rlc1N0YXRlW2Rvd25zdHJlYW1Ob2RlSW5kZXhdID09PSAnd2hpdGUnKSB7XG4gICAgICAgICAgICAgIG5vZGVzU3RhY2sucHVzaChkb3duc3RyZWFtTm9kZUluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB0cmFuc2Zvcm1HcmFwaChncmFwaEluaXRpYWxpemVyPzogR3JhcGguSW5pdGlhbGl6ZXIpOiB2b2lkIHtcbiAgICAvLyBhcHBseSBjb21tb24gdHJhbnNmb3JtXG4gICAgdGhpcy5yZW1vdmVBbGxJZGVudGl0eU5vZGVzKCk7XG4gICAgdGhpcy5yZW1vdmVBbGxEcm9wb3V0Tm9kZXMoKTtcbiAgICB0aGlzLmZ1c2VDb252QWN0aXZhdGlvbk5vZGVzKCk7XG4gICAgLy8gYXBwbHkgaW5pdGlhbGl6ZXIgc3BlY2lmaWMgdHJhbnNmb3JtXG4gICAgaWYgKGdyYXBoSW5pdGlhbGl6ZXIpIHtcbiAgICAgIGdyYXBoSW5pdGlhbGl6ZXIudHJhbnNmb3JtR3JhcGgodGhpcyk7XG4gICAgfVxuXG4gICAgLy8gZmluYWxpemUgZ3JhcGhcbiAgICB0aGlzLmZpbmFsaXplR3JhcGgoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBmaW5hbGl6ZSB0aGUgZ3JhcGguXG4gICAqXG4gICAqIHRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIGNhbGxlZCBhZnRlciBhbGwgdGhlIHRyYW5zZm9ybWF0aW9uIGNvbXBsZXRlZC5cbiAgICogdGhpcyBmdW5jdGlvbiByZW1vdmVzIGFsbCB1bm5lY2Vzc2FyeSBub2RlcyBhbmQgdmFsdWVzIGZyb20gdGhlIGdyYXBoXG4gICAqL1xuICBmaW5hbGl6ZUdyYXBoKCkge1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIC8vIGRlbGV0ZSBhbGwgbm9kZXMgdGhhdCBhcmUgbm90IGJlaW5nIGV4ZWN1dGVkXG4gICAgLy8gVGhlIGdyYXBoIGlzIHJlcHJlc2VudGVkIHVzaW5nIHRoZXNlIHR3byBhcnJheXNcbiAgICAvLyB0aGlzLl9ub2RlcyAtIEFycmF5IGhvbGRpbmcgdGhlIGtlcm5lbHMgdG8gZXhlY3V0ZSAtIGVhY2ggZW50cnkgaXMgYSBrZXJuZWwgcG9pbnRpbmcgdG8gdGhpcy5fYWxsRGF0YVxuICAgIC8vIHRoaXMuX2FsbERhdGEgLSBob2xkIDIgZmllbGRzIC0gdG8gW10gJiBmcm9tIC0gdGhlc2UgZmVpbGVkcyBob2xkIHRoZSBncmFwaCBtYXAgZm9yIGlucHV0cyBhbmQgb3V0cHV0cyBwZXIgbm9kZVxuICAgIC8vIG5ld0luZGljZXMgLSByZW1hcHBpbmcgdGhlIGdyYXBoIGFmdGVyIHJlYWRpbmcgdGhlIGZsYWcgJ2V4ZWN1dGVOb2RlJ1xuICAgIGNvbnN0IG5ld0luZGljZXMgPSBuZXcgQXJyYXk8bnVtYmVyPih0aGlzLl9ub2Rlcy5sZW5ndGgsIDApO1xuICAgIGxldCBub2RlUG9zc2l0aW9uID0gMDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIGdpdmluZyBuZXcgaW5kZXhlcyB0byB0aGUgbm9kZXMgYmFzZWQgb24gZXhlY3V0aW9uIGZsYWdcbiAgICAgIG5ld0luZGljZXNbaV0gPSBub2RlUG9zc2l0aW9uO1xuICAgICAgaWYgKHRoaXMuX25vZGVzW2ldLmV4ZWN1dGVOb2RlKSB7XG4gICAgICAgIGlmIChub2RlUG9zc2l0aW9uICE9PSBpKSB7XG4gICAgICAgICAgdGhpcy5fbm9kZXNbbm9kZVBvc3NpdGlvbl0gPSB0aGlzLl9ub2Rlc1tpXTtcbiAgICAgICAgfVxuICAgICAgICBub2RlUG9zc2l0aW9uKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkZWxldGUgYWxsIG91dHB1dCB2YWx1ZXNcbiAgICAgICAgdGhpcy5fbm9kZXNbaV0ub3V0cHV0cy5mb3JFYWNoKChpbmQpID0+IHtcbiAgICAgICAgICB0aGlzLl9hbGxEYXRhW2luZF0uX2Zyb20gPSAtMjtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZpbmcgdGhlIHVudXNlZCBub2Rlc1xuICAgIHRoaXMuX25vZGVzLnNwbGljZShub2RlUG9zc2l0aW9uLCB0aGlzLl9ub2Rlcy5sZW5ndGggLSBub2RlUG9zc2l0aW9uKTtcblxuICAgIC8vIFVwZGF0aW5nIHRoaXMuX2FsbERhdGEgYWNjb3JkaW5nIHRvIHRoZSBuZXcgdGhpcy5fbm9kZXNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2FsbERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGN1cnJlbnREYXRhID0gdGhpcy5fYWxsRGF0YVtpXTtcbiAgICAgIGlmIChjdXJyZW50RGF0YS5fZnJvbSAhPT0gdW5kZWZpbmVkICYmIGN1cnJlbnREYXRhLl9mcm9tICE9PSAtMSAmJiBjdXJyZW50RGF0YS5fZnJvbSAhPT0gLTIpIHtcbiAgICAgICAgY3VycmVudERhdGEuX2Zyb20gPSBuZXdJbmRpY2VzW2N1cnJlbnREYXRhLl9mcm9tXTtcbiAgICAgIH1cblxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjdXJyZW50RGF0YS5fdG8ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKGN1cnJlbnREYXRhLl90b1tqXSA+PSAwKSB7XG4gICAgICAgICAgY3VycmVudERhdGEuX3RvW2pdID0gbmV3SW5kaWNlc1tjdXJyZW50RGF0YS5fdG9bal1dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVHJ5aW5nIHRvIHVwZGF0ZSBhIHJlbW92ZWQgbm9kZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgb2Zmc2V0ID0gMDtcbiAgICAvLyBkZWxldGUgYWxsIHZhbHVlcyB0aGF0IGFyZSBub3QgYmVpbmcgcmVmZXJlbmNlZFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fYWxsRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gaWYgY3VycmVudCB2YWx1ZSBpcyBuZWl0aGVyIGxpbmtlZCB0byBuZXh0IG5vZGUsIG5vciBhbiBvdXRwdXQgdmFsdWUsIHJlbW92ZSBpdC5cbiAgICAgIGlmICh0aGlzLl9hbGxEYXRhW2ldLmZyb20gPT09IC0yICYmIHRoaXMuX2FsbE91dHB1dEluZGljZXMuaW5kZXhPZihpICsgb2Zmc2V0KSA9PT0gLTEpIHtcbiAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgIHRoaXMuX2FsbERhdGEuc3BsaWNlKGksIDEpO1xuICAgICAgICBpLS07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKG9mZnNldCA+IDApIHtcbiAgICAgICAgbGV0IGluZCA9IC0xO1xuICAgICAgICAvLyBpZiBjdXJyZW50IHZhbHVlIGlzIG5laXRoZXIgYW4gaW5wdXQgdmFsdWUgbm9yIGFuIGluaXRpYWxpemVyLCBmaW5kIHRoZSBub2RlIGl0J3NcbiAgICAgICAgLy8gY29taW5nIGZyb20gYW5kIHVwZGF0ZSB0aGUgY29ycmVzcG9uZGluZyBub2RlIG91dHB1dFxuICAgICAgICBpZiAodGhpcy5fYWxsRGF0YVtpXS5mcm9tICE9PSB1bmRlZmluZWQgJiYgdGhpcy5fYWxsRGF0YVtpXS5mcm9tICE9PSAtMSkge1xuICAgICAgICAgIGluZCA9IHRoaXMuX25vZGVzW3RoaXMuX2FsbERhdGFbaV0uZnJvbV0ub3V0cHV0cy5pbmRleE9mKGkgKyBvZmZzZXQpO1xuICAgICAgICAgIGlmIChpbmQgIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9ub2Rlc1t0aGlzLl9hbGxEYXRhW2ldLmZyb21dLm91dHB1dHNbaW5kXSA9IGk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGlmIGN1cnJlbnQgdmFsdWUgaXMgYW4gaW5wdXQgdmFsdWUsIHVwZGF0ZSBpdHMgcmVmZXJlbmNlIGluIGlucHV0SW5kaWNlc1xuICAgICAgICAgIGluZCA9IHRoaXMuX2FsbElucHV0SW5kaWNlcy5pbmRleE9mKGkgKyBvZmZzZXQpO1xuICAgICAgICAgIGlmIChpbmQgIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9hbGxJbnB1dEluZGljZXNbaW5kXSA9IGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmluZCB0aGUgbm9kZSB0aGF0IHRoZSBjdXJyZW50IHZhbHVlIGlzIGxpbmtpbmcgdG8gYW5kIHVwZGF0ZSBpdHMgaW5wdXQgcmVmZXJlbmNlXG4gICAgICAgIHRoaXMuX2FsbERhdGFbaV0udG8uZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICAgIGluZCA9IHRoaXMuX25vZGVzW25vZGVdLmlucHV0cy5pbmRleE9mKGkgKyBvZmZzZXQpO1xuICAgICAgICAgIGlmIChpbmQgIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9ub2Rlc1tub2RlXS5pbnB1dHNbaW5kXSA9IGk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuX2FsbERhdGFbaV0udG8ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgLy8gaWYgY3VycmVudCB2YWx1ZSBpcyBhIGdyYXBoIG91dHB1dCwgdXBkYXRlIGl0cyByZWZlcmVuY2UgaW4gb3V0cHV0SW5kaWNlc1xuICAgICAgICAgIGluZCA9IHRoaXMuX2FsbE91dHB1dEluZGljZXMuaW5kZXhPZihpICsgb2Zmc2V0KTtcbiAgICAgICAgICBpZiAoaW5kICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5fYWxsT3V0cHV0SW5kaWNlc1tpbmRdID0gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlIHRoZSBzcGVjaWZpZWQgbm9kZS4gQXNzdW1lIHRoZSBub2RlIGhhcyBvbmUgaW5jb21pbmcgaW5wdXQgYW5kIHRoZSBmaXJzdCBvdXRwdXQgY29ubmVjdGVkIHRvIG90aGVyIG5vZGVzLlxuICAgKiBBbiBpbnB1dCB2YWxpZGF0aW9uIG11c3QgYmUgZG9uZSBiZWZvcmUgY2FsbGluZyB0aGlzIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gbm9kZUluZGV4IFRoZSBpbmRleCBvZiBub2RlIHRvIGJlIGRlbGV0ZWRcbiAgICovXG4gIHByaXZhdGUgZGVsZXRlTm9kZShub2RlSW5kZXg6IG51bWJlcikge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLl9ub2Rlc1tub2RlSW5kZXhdO1xuICAgIGlmIChub2RlLm91dHB1dHMubGVuZ3RoID4gMSkge1xuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBub2RlLm91dHB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuX2FsbERhdGFbbm9kZS5vdXRwdXRzW2ldXS50by5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb2RlIGRlbGV0aW9uIHdpdGggbW9yZSB0aGFuIG9uZSBvdXRwdXQgY29ubmVjdGVkIHRvIG90aGVyIG5vZGVzIGlzIG5vdCBzdXBwb3J0ZWQuICcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdGhpcyBub2RlIHdpbCBub3QgYmUgZXhlY3V0ZWRcbiAgICBub2RlLmV4ZWN1dGVOb2RlID0gZmFsc2U7XG4gICAgY29uc3QgaW5wdXRWYWx1ZUluZGV4ID0gbm9kZS5pbnB1dHNbMF07XG4gICAgY29uc3Qgb3V0cHV0VmFsdWVJbmRleCA9IG5vZGUub3V0cHV0c1swXTtcbiAgICBjb25zdCBub2Rlc0NvbnN1bWluZ091dHB1dCA9IHRoaXMuX2FsbERhdGFbb3V0cHV0VmFsdWVJbmRleF0udG87XG5cbiAgICAvLyByZW1vdmUgdGhpcyBub2RlIGZyb20gdGhlIHRvIHByb3BlcnR5IG9mIHRoZSBpbnB1dCBWYWx1ZVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5pbnB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGRlbEluZGV4ID0gdGhpcy5fYWxsRGF0YVtub2RlLmlucHV0c1tpXV0udG8uaW5kZXhPZihub2RlSW5kZXgpO1xuICAgICAgLy8gc2hvdWxkIG5vdCBoYXBwZW5cbiAgICAgIGlmIChkZWxJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIFZhbHVlIG9iamVjdCBkb2Vzbid0IGhhdmUgdGhlIGN1cnJlbnQgTm9kZSBpbiBpdCdzICd0bycgcHJvcGVydHkgXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5fYWxsRGF0YVtub2RlLmlucHV0c1tpXV0udG8uc3BsaWNlKGRlbEluZGV4LCAxKTtcbiAgICB9XG5cbiAgICAvLyBjbGVhciBub2RlIGluZGljZXMgY29uc3VtaW5nIHRoaXMgb3V0cHV0IFZhbHVlXG4gICAgdGhpcy5fYWxsRGF0YVtvdXRwdXRWYWx1ZUluZGV4XS5fdG8gPSBbXTtcblxuICAgIC8vIGlmIHRoZSBvdXRwdXQgb2YgdGhpcyBub2RlIGlzIGEgZ3JhcGggb3V0cHV0LCBhZGp1c3QgdGhlIGluZGV4IGFwcHJvcHJpYXRlbHlcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuX2FsbE91dHB1dEluZGljZXMuaW5kZXhPZihvdXRwdXRWYWx1ZUluZGV4KTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICB0aGlzLl9hbGxPdXRwdXRJbmRpY2VzW2luZGV4XSA9IGlucHV0VmFsdWVJbmRleDtcbiAgICB9XG5cbiAgICAvLyBvdmVycmlkZSB0aGUgaW5wdXRzIGZvciBub2RlcyBjb25zdW1pbmcgdGhpcyBub2RlJ3Mgb3V0cHV0IHdpdGggdGhlIGlucHV0IHRvIHRoaXMgbm9kZVxuICAgIGlmIChub2Rlc0NvbnN1bWluZ091dHB1dCAmJiBub2Rlc0NvbnN1bWluZ091dHB1dC5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKGNvbnN0IG5vZGVJbmRleCBvZiBub2Rlc0NvbnN1bWluZ091dHB1dCkge1xuICAgICAgICBjb25zdCByZXBsYWNlSW5kZXggPSB0aGlzLl9ub2Rlc1tub2RlSW5kZXhdLmlucHV0cy5pbmRleE9mKG91dHB1dFZhbHVlSW5kZXgpO1xuICAgICAgICAvLyBzaG91bGQgbm90IGhhcHBlblxuICAgICAgICBpZiAocmVwbGFjZUluZGV4ID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBOb2RlIG9iamVjdCBkb2Vzbid0IGhhdmUgdGhlIG91dHB1dCBWYWx1ZSBpbiBpdCdzICdpbnB1dHMnIHByb3BlcnR5IFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9ub2Rlc1tub2RlSW5kZXhdLmlucHV0c1tyZXBsYWNlSW5kZXhdID0gaW5wdXRWYWx1ZUluZGV4O1xuICAgICAgICB0aGlzLl9hbGxEYXRhW2lucHV0VmFsdWVJbmRleF0udG8ucHVzaChub2RlSW5kZXgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJlbW92ZUFsbERyb3BvdXROb2RlcygpIHtcbiAgICBsZXQgbm9kZUluZGV4ID0gMDtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgdGhpcy5fbm9kZXMpIHtcbiAgICAgIC8vIHdlZWQgb3V0ICdEcm9wb3V0JyBub2RlcyBzbyB0aGF0IG5vIHRpbWUgaXMgd2FzdGVkIGluIGV4ZWN1dGlvblxuICAgICAgaWYgKG5vZGUub3BUeXBlID09PSAnRHJvcG91dCcpIHtcbiAgICAgICAgLy8gdGhlIG5vZGUgc2hvdWxkIGhhdmUgZXhhY3RseSAxIGlucHV0IGFuZCAxIG9yIDIgb3V0cHV0c1xuICAgICAgICBpZiAobm9kZS5pbnB1dHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEcm9wb3V0IG5vZGVzIHNob3VsZCBvbmx5IGNvbnRhaW4gb25lIGlucHV0LiAnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5vdXRwdXRzLmxlbmd0aCAhPT0gMSAmJiBub2RlLm91dHB1dHMubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEcm9wb3V0IG5vZGVzIHNob3VsZCBjb250YWluIGVpdGhlciAxIG9yIDIgb3V0cHV0KHMpJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhlIHNlY29uZCBvdXRwdXQgc2hvdWxkIG5vdCBiZSByZWZlcmVuY2VkIGJ5IGFueSBvdGhlciBub2RlXG4gICAgICAgIGlmIChub2RlLm91dHB1dHMubGVuZ3RoID09PSAyICYmIHRoaXMuX2FsbERhdGFbbm9kZS5vdXRwdXRzWzFdXS5fdG8ubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHJvcG91dCBub2RlcydzIHNlY29uZCBvdXRwdXQgc2hvdWxkIG5vdCBiZSByZWZlcmVuY2VkIGJ5IG90aGVyIG5vZGVzXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVsZXRlTm9kZShub2RlSW5kZXgpO1xuICAgICAgfVxuICAgICAgbm9kZUluZGV4Kys7XG4gICAgfVxuICB9XG5cbiAgcmVtb3ZlQWxsSWRlbnRpdHlOb2RlcygpIHtcbiAgICBsZXQgbm9kZUluZGV4ID0gMDtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgdGhpcy5fbm9kZXMpIHtcbiAgICAgIC8vIHdlZWQgb3V0ICdJZGVudGl0eScgbm9kZXMgc28gdGhhdCBubyB0aW1lIGlzIHdhc3RlZCBpbiBleGVjdXRpb25cbiAgICAgIGlmIChub2RlLm9wVHlwZSA9PT0gJ0lkZW50aXR5Jykge1xuICAgICAgICB0aGlzLmRlbGV0ZU5vZGUobm9kZUluZGV4KTtcbiAgICAgIH1cbiAgICAgIG5vZGVJbmRleCsrO1xuICAgIH1cbiAgfVxuXG4gIGlzQWN0aXZhdGlvbihuOiBOb2RlKTogYm9vbGVhbiB7XG4gICAgc3dpdGNoIChuLm9wVHlwZSkge1xuICAgICAgLy8gVE9ETzogYWRkIG90aGVyIGFjdGl2YXRpb24gbWV0aG9kc1xuICAgICAgY2FzZSAnUmVsdSc6XG4gICAgICBjYXNlICdTaWdtb2lkJzpcbiAgICAgIGNhc2UgJ0NsaXAnOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdXNlQ29udkFjdGl2YXRpb25Ob2RlcygpIHtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgdGhpcy5fbm9kZXMpIHtcbiAgICAgIGlmIChub2RlLm9wVHlwZSA9PT0gJ0NvbnYnKSB7XG4gICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLl9hbGxEYXRhW25vZGUub3V0cHV0c1swXV0uX3RvO1xuICAgICAgICBpZiAobmV4dC5sZW5ndGggPT09IDEgJiYgdGhpcy5pc0FjdGl2YXRpb24odGhpcy5fbm9kZXNbbmV4dFswXV0pKSB7XG4gICAgICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLl9ub2Rlc1tuZXh0WzBdXTtcbiAgICAgICAgICBpZiAoY2hpbGQub3BUeXBlID09PSAnQ2xpcCcpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC5pbnB1dHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbm9kZS5hdHRyaWJ1dGVzLnNldCgnYWN0aXZhdGlvbl9wYXJhbXMnLCAnZmxvYXRzJywgW1xuICAgICAgICAgICAgICAgICAgY2hpbGQuYXR0cmlidXRlcy5nZXRGbG9hdCgnbWluJyksXG4gICAgICAgICAgICAgICAgICBjaGlsZC5hdHRyaWJ1dGVzLmdldEZsb2F0KCdtYXgnKSxcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIG5vZGUuYXR0cmlidXRlcy5zZXQoJ2FjdGl2YXRpb25fcGFyYW1zJywgJ2Zsb2F0cycsIFtNSU5fQ0xJUCwgTUFYX0NMSVBdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgY2hpbGQuaW5wdXRzLmxlbmd0aCA+PSAzICYmXG4gICAgICAgICAgICAgIHRoaXMuX2FsbERhdGFbY2hpbGQuaW5wdXRzWzFdXS50ZW5zb3IgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICB0aGlzLl9hbGxEYXRhW2NoaWxkLmlucHV0c1syXV0udGVuc29yICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBub2RlLmF0dHJpYnV0ZXMuc2V0KCdhY3RpdmF0aW9uX3BhcmFtcycsICdmbG9hdHMnLCBbXG4gICAgICAgICAgICAgICAgdGhpcy5fYWxsRGF0YVtjaGlsZC5pbnB1dHNbMV1dLnRlbnNvciEuZmxvYXREYXRhWzBdLFxuICAgICAgICAgICAgICAgIHRoaXMuX2FsbERhdGFbY2hpbGQuaW5wdXRzWzJdXS50ZW5zb3IhLmZsb2F0RGF0YVswXSxcbiAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBTa2lwIGZ1c2lvbiB3aXRoIGNsaXAgbm9kZSBzaW5jZSBjbGlwIG1pbiBhbmQgY2xpcCBtYXggYXJlIG5vdCBjb21pbmcgZnJvbSBpbml0aWFsaXplclxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZS5hdHRyaWJ1dGVzLnNldCgnYWN0aXZhdGlvbicsICdzdHJpbmcnLCBjaGlsZC5vcFR5cGUpO1xuICAgICAgICAgIHRoaXMuZGVsZXRlTm9kZShuZXh0WzBdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBmbGF0YnVmZmVycyB9IGZyb20gJ2ZsYXRidWZmZXJzJztcblxuaW1wb3J0IHsgR3JhcGggfSBmcm9tICcuL2dyYXBoJztcbmltcG9ydCB7IE9wU2V0IH0gZnJvbSAnLi9vcHNldCc7XG5pbXBvcnQgeyBvbm54cnVudGltZSB9IGZyb20gJy4vb3J0LXNjaGVtYS9mbGF0YnVmZmVycy9vcnQtZ2VuZXJhdGVkJztcbmltcG9ydCB7IG9ubnggfSBmcm9tICcuL29ydC1zY2hlbWEvcHJvdG9idWYvb25ueCc7XG5pbXBvcnQgeyBMb25nVXRpbCB9IGZyb20gJy4vdXRpbCc7XG5cbmltcG9ydCBvcnRGYnMgPSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzO1xuXG5leHBvcnQgY2xhc3MgTW9kZWwge1xuICAvLyBlbXB0eSBtb2RlbFxuICBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgbG9hZChidWY6IFVpbnQ4QXJyYXksIGdyYXBoSW5pdGlhbGl6ZXI/OiBHcmFwaC5Jbml0aWFsaXplciwgaXNPcnRGb3JtYXQ/OiBib29sZWFuKTogdm9pZCB7XG4gICAgbGV0IG9ubnhFcnJvcjogRXJyb3IgfCB1bmRlZmluZWQ7XG4gICAgaWYgKCFpc09ydEZvcm1hdCkge1xuICAgICAgLy8gaXNPcnRGb3JtYXQgPT09IGZhbHNlIHx8IGlzT3J0Rm9ybWF0ID09PSB1bmRlZmluZWRcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMubG9hZEZyb21Pbm54Rm9ybWF0KGJ1ZiwgZ3JhcGhJbml0aWFsaXplcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGlzT3J0Rm9ybWF0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIG9ubnhFcnJvciA9IGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMubG9hZEZyb21PcnRGb3JtYXQoYnVmLCBncmFwaEluaXRpYWxpemVyKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoaXNPcnRGb3JtYXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgICAgLy8gVHJpZWQgYm90aCBmb3JtYXRzIGFuZCBmYWlsZWQgKHdoZW4gaXNPcnRGb3JtYXQgPT09IHVuZGVmaW5lZClcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgbW9kZWwgYXMgT05OWCBmb3JtYXQ6ICR7b25ueEVycm9yfVxcbmFzIE9SVCBmb3JtYXQ6ICR7ZX1gKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGxvYWRGcm9tT25ueEZvcm1hdChidWY6IFVpbnQ4QXJyYXksIGdyYXBoSW5pdGlhbGl6ZXI/OiBHcmFwaC5Jbml0aWFsaXplcik6IHZvaWQge1xuICAgIGNvbnN0IG1vZGVsUHJvdG8gPSBvbm54Lk1vZGVsUHJvdG8uZGVjb2RlKGJ1Zik7XG4gICAgY29uc3QgaXJWZXJzaW9uID0gTG9uZ1V0aWwubG9uZ1RvTnVtYmVyKG1vZGVsUHJvdG8uaXJWZXJzaW9uKTtcbiAgICBpZiAoaXJWZXJzaW9uIDwgMykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdvbmx5IHN1cHBvcnQgT05OWCBtb2RlbCB3aXRoIElSX1ZFUlNJT04+PTMnKTtcbiAgICB9XG5cbiAgICB0aGlzLl9vcHNldHMgPSBtb2RlbFByb3RvLm9wc2V0SW1wb3J0Lm1hcCgoaSkgPT4gKHtcbiAgICAgIGRvbWFpbjogaS5kb21haW4gYXMgc3RyaW5nLFxuICAgICAgdmVyc2lvbjogTG9uZ1V0aWwubG9uZ1RvTnVtYmVyKGkudmVyc2lvbiEpLFxuICAgIH0pKTtcblxuICAgIHRoaXMuX2dyYXBoID0gR3JhcGguZnJvbShtb2RlbFByb3RvLmdyYXBoISwgZ3JhcGhJbml0aWFsaXplcik7XG4gIH1cblxuICBwcml2YXRlIGxvYWRGcm9tT3J0Rm9ybWF0KGJ1ZjogVWludDhBcnJheSwgZ3JhcGhJbml0aWFsaXplcj86IEdyYXBoLkluaXRpYWxpemVyKTogdm9pZCB7XG4gICAgY29uc3QgZmIgPSBuZXcgZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcihidWYpO1xuICAgIGNvbnN0IG9ydE1vZGVsID0gb3J0RmJzLkluZmVyZW5jZVNlc3Npb24uZ2V0Um9vdEFzSW5mZXJlbmNlU2Vzc2lvbihmYikubW9kZWwoKSE7XG4gICAgY29uc3QgaXJWZXJzaW9uID0gTG9uZ1V0aWwubG9uZ1RvTnVtYmVyKG9ydE1vZGVsLmlyVmVyc2lvbigpKTtcbiAgICBpZiAoaXJWZXJzaW9uIDwgMykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdvbmx5IHN1cHBvcnQgT05OWCBtb2RlbCB3aXRoIElSX1ZFUlNJT04+PTMnKTtcbiAgICB9XG4gICAgdGhpcy5fb3BzZXRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcnRNb2RlbC5vcHNldEltcG9ydExlbmd0aCgpOyBpKyspIHtcbiAgICAgIGNvbnN0IG9wc2V0SWQgPSBvcnRNb2RlbC5vcHNldEltcG9ydChpKSE7XG4gICAgICB0aGlzLl9vcHNldHMucHVzaCh7IGRvbWFpbjogb3BzZXRJZD8uZG9tYWluKCkgYXMgc3RyaW5nLCB2ZXJzaW9uOiBMb25nVXRpbC5sb25nVG9OdW1iZXIob3BzZXRJZC52ZXJzaW9uKCkhKSB9KTtcbiAgICB9XG5cbiAgICB0aGlzLl9ncmFwaCA9IEdyYXBoLmZyb20ob3J0TW9kZWwuZ3JhcGgoKSEsIGdyYXBoSW5pdGlhbGl6ZXIpO1xuICB9XG5cbiAgcHJpdmF0ZSBfZ3JhcGg6IEdyYXBoO1xuICBnZXQgZ3JhcGgoKTogR3JhcGgge1xuICAgIHJldHVybiB0aGlzLl9ncmFwaDtcbiAgfVxuXG4gIHByaXZhdGUgX29wc2V0czogT3BTZXRbXTtcbiAgZ2V0IG9wc2V0cygpOiByZWFkb25seSBPcFNldFtdIHtcbiAgICByZXR1cm4gdGhpcy5fb3BzZXRzO1xuICB9XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IHJlc29sdmVCYWNrZW5kLCBTZXNzaW9uSGFuZGxlclR5cGUgfSBmcm9tICcuL2JhY2tlbmQnO1xuaW1wb3J0IHsgRXhlY3V0aW9uUGxhbiB9IGZyb20gJy4vZXhlY3V0aW9uLXBsYW4nO1xuaW1wb3J0IHsgR3JhcGggfSBmcm9tICcuL2dyYXBoJztcbmltcG9ydCB7IFByb2ZpbGVyIH0gZnJvbSAnLi9pbnN0cnVtZW50JztcbmltcG9ydCB7IE1vZGVsIH0gZnJvbSAnLi9tb2RlbCc7XG5pbXBvcnQgeyBPcGVyYXRvciB9IGZyb20gJy4vb3BlcmF0b3JzJztcbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4vdGVuc29yJztcblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIFNlc3Npb24ge1xuICBleHBvcnQgaW50ZXJmYWNlIENvbmZpZyB7XG4gICAgYmFja2VuZEhpbnQ/OiBzdHJpbmc7XG4gICAgcHJvZmlsZXI/OiBQcm9maWxlci5Db25maWc7XG4gIH1cblxuICBleHBvcnQgaW50ZXJmYWNlIENvbnRleHQge1xuICAgIHByb2ZpbGVyOiBSZWFkb25seTxQcm9maWxlcj47XG4gICAgZ3JhcGhJbnB1dFR5cGVzPzogVGVuc29yLkRhdGFUeXBlW107XG4gICAgZ3JhcGhJbnB1dERpbXM/OiBBcnJheTxyZWFkb25seSBudW1iZXJbXT47XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFNlc3Npb24ge1xuICBjb25zdHJ1Y3Rvcihjb25maWc6IFNlc3Npb24uQ29uZmlnID0ge30pIHtcbiAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIHRoaXMuYmFja2VuZEhpbnQgPSBjb25maWcuYmFja2VuZEhpbnQ7XG4gICAgdGhpcy5wcm9maWxlciA9IFByb2ZpbGVyLmNyZWF0ZShjb25maWcucHJvZmlsZXIpO1xuICAgIHRoaXMuY29udGV4dCA9IHsgcHJvZmlsZXI6IHRoaXMucHJvZmlsZXIsIGdyYXBoSW5wdXRUeXBlczogW10sIGdyYXBoSW5wdXREaW1zOiBbXSB9O1xuICB9XG5cbiAgZ2V0IGlucHV0TmFtZXMoKTogcmVhZG9ubHkgc3RyaW5nW10ge1xuICAgIHJldHVybiB0aGlzLl9tb2RlbC5ncmFwaC5nZXRJbnB1dE5hbWVzKCk7XG4gIH1cbiAgZ2V0IG91dHB1dE5hbWVzKCk6IHJlYWRvbmx5IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gdGhpcy5fbW9kZWwuZ3JhcGguZ2V0T3V0cHV0TmFtZXMoKTtcbiAgfVxuXG4gIHN0YXJ0UHJvZmlsaW5nKCkge1xuICAgIHRoaXMucHJvZmlsZXIuc3RhcnQoKTtcbiAgfVxuXG4gIGVuZFByb2ZpbGluZygpIHtcbiAgICB0aGlzLnByb2ZpbGVyLnN0b3AoKTtcbiAgfVxuXG4gIGFzeW5jIGxvYWRNb2RlbCh1cmk6IHN0cmluZyk6IFByb21pc2U8dm9pZD47XG4gIGFzeW5jIGxvYWRNb2RlbChidWZmZXI6IEFycmF5QnVmZmVyLCBieXRlT2Zmc2V0PzogbnVtYmVyLCBsZW5ndGg/OiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+O1xuICBhc3luYyBsb2FkTW9kZWwoYnVmZmVyOiBVaW50OEFycmF5KTogUHJvbWlzZTx2b2lkPjtcbiAgYXN5bmMgbG9hZE1vZGVsKGFyZzogc3RyaW5nIHwgQXJyYXlCdWZmZXIgfCBVaW50OEFycmF5LCBieXRlT2Zmc2V0PzogbnVtYmVyLCBsZW5ndGg/OiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCB0aGlzLnByb2ZpbGVyLmV2ZW50KCdzZXNzaW9uJywgJ1Nlc3Npb24ubG9hZE1vZGVsJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gcmVzb2x2ZSBiYWNrZW5kIGFuZCBzZXNzaW9uIGhhbmRsZXJcbiAgICAgIGNvbnN0IGJhY2tlbmQgPSBhd2FpdCByZXNvbHZlQmFja2VuZCh0aGlzLmJhY2tlbmRIaW50KTtcbiAgICAgIHRoaXMuc2Vzc2lvbkhhbmRsZXIgPSBiYWNrZW5kLmNyZWF0ZVNlc3Npb25IYW5kbGVyKHRoaXMuY29udGV4dCk7XG5cbiAgICAgIHRoaXMuX21vZGVsID0gbmV3IE1vZGVsKCk7XG4gICAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3QgaXNPcnRGb3JtYXQgPSBhcmcuZW5kc1dpdGgoJy5vcnQnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLnZlcnNpb25zICYmIHByb2Nlc3MudmVyc2lvbnMubm9kZSkge1xuICAgICAgICAgIC8vIG5vZGVcbiAgICAgICAgICBjb25zdCB7IHJlYWRGaWxlIH0gPSByZXF1aXJlKCdub2RlOmZzL3Byb21pc2VzJyk7XG4gICAgICAgICAgY29uc3QgYnVmID0gYXdhaXQgcmVhZEZpbGUoYXJnKTtcbiAgICAgICAgICB0aGlzLmluaXRpYWxpemUoYnVmLCBpc09ydEZvcm1hdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gYnJvd3NlclxuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYXJnKTtcbiAgICAgICAgICBjb25zdCBidWYgPSBhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xuICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZShuZXcgVWludDhBcnJheShidWYpLCBpc09ydEZvcm1hdCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIUFycmF5QnVmZmVyLmlzVmlldyhhcmcpKSB7XG4gICAgICAgIC8vIGxvYWQgbW9kZWwgZnJvbSBBcnJheUJ1ZmZlclxuICAgICAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheShhcmcsIGJ5dGVPZmZzZXQgfHwgMCwgbGVuZ3RoIHx8IGFyZy5ieXRlTGVuZ3RoKTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKGFycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBsb2FkIG1vZGVsIGZyb20gVWludDhhcnJheVxuICAgICAgICB0aGlzLmluaXRpYWxpemUoYXJnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgaW5pdGlhbGl6ZShtb2RlbFByb3RvQmxvYjogVWludDhBcnJheSwgaXNPcnRGb3JtYXQ/OiBib29sZWFuKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FscmVhZHkgaW5pdGlhbGl6ZWQnKTtcbiAgICB9XG5cbiAgICB0aGlzLnByb2ZpbGVyLmV2ZW50KCdzZXNzaW9uJywgJ1Nlc3Npb24uaW5pdGlhbGl6ZScsICgpID0+IHtcbiAgICAgIC8vIGxvYWQgZ3JhcGhcbiAgICAgIGNvbnN0IGdyYXBoSW5pdGlhbGl6ZXIgPSB0aGlzLnNlc3Npb25IYW5kbGVyLnRyYW5zZm9ybUdyYXBoXG4gICAgICAgID8gKHRoaXMuc2Vzc2lvbkhhbmRsZXIgYXMgR3JhcGguSW5pdGlhbGl6ZXIpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fbW9kZWwubG9hZChtb2RlbFByb3RvQmxvYiwgZ3JhcGhJbml0aWFsaXplciwgaXNPcnRGb3JtYXQpO1xuXG4gICAgICAvLyBncmFwaCBpcyBjb21wbGV0ZWx5IGluaXRpYWx6aWVkIGF0IHRoaXMgc3RhZ2UgLCBsZXQgdGhlIGludGVyZXN0ZWQgaGFuZGxlcnMga25vd1xuICAgICAgaWYgKHRoaXMuc2Vzc2lvbkhhbmRsZXIub25HcmFwaEluaXRpYWxpemVkKSB7XG4gICAgICAgIHRoaXMuc2Vzc2lvbkhhbmRsZXIub25HcmFwaEluaXRpYWxpemVkKHRoaXMuX21vZGVsLmdyYXBoKTtcbiAgICAgIH1cbiAgICAgIC8vIGluaXRpYWxpemUgZWFjaCBvcGVyYXRvciBpbiB0aGUgZ3JhcGhcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZU9wcyh0aGlzLl9tb2RlbC5ncmFwaCk7XG5cbiAgICAgIC8vIGluc3RhbnRpYXRlIGFuIEV4ZWN1dGlvblBsYW4gb2JqZWN0IHRvIGJlIHVzZWQgYnkgdGhlIFNlc3Npb24gb2JqZWN0XG4gICAgICB0aGlzLl9leGVjdXRpb25QbGFuID0gbmV3IEV4ZWN1dGlvblBsYW4odGhpcy5fbW9kZWwuZ3JhcGgsIHRoaXMuX29wcywgdGhpcy5wcm9maWxlcik7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG4gIH1cblxuICBhc3luYyBydW4oaW5wdXRzOiBNYXA8c3RyaW5nLCBUZW5zb3I+IHwgVGVuc29yW10pOiBQcm9taXNlPE1hcDxzdHJpbmcsIFRlbnNvcj4+IHtcbiAgICBpZiAoIXRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Nlc3Npb24gbm90IGluaXRpYWxpemVkIHlldCcpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnByb2ZpbGVyLmV2ZW50KCdzZXNzaW9uJywgJ1Nlc3Npb24ucnVuJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW5wdXRUZW5zb3JzID0gdGhpcy5ub3JtYWxpemVBbmRWYWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuXG4gICAgICBjb25zdCBvdXRwdXRUZW5zb3JzID0gYXdhaXQgdGhpcy5fZXhlY3V0aW9uUGxhbi5leGVjdXRlKHRoaXMuc2Vzc2lvbkhhbmRsZXIsIGlucHV0VGVuc29ycyk7XG5cbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZU91dHB1dChvdXRwdXRUZW5zb3JzKTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgbm9ybWFsaXplQW5kVmFsaWRhdGVJbnB1dHMoaW5wdXRzOiBNYXA8c3RyaW5nLCBUZW5zb3I+IHwgVGVuc29yW10pOiBUZW5zb3JbXSB7XG4gICAgY29uc3QgbW9kZWxJbnB1dE5hbWVzID0gdGhpcy5fbW9kZWwuZ3JhcGguZ2V0SW5wdXROYW1lcygpO1xuXG4gICAgLy8gbm9ybWFsaXplIGlucHV0c1xuICAgIC8vIGlucHV0czogVGVuc29yW11cbiAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dHMpKSB7XG4gICAgICBpZiAoaW5wdXRzLmxlbmd0aCAhPT0gbW9kZWxJbnB1dE5hbWVzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGluY29ycmVjdCBpbnB1dCBhcnJheSBsZW5ndGg6IGV4cGVjdGVkICR7bW9kZWxJbnB1dE5hbWVzLmxlbmd0aH0gYnV0IGdvdCAke2lucHV0cy5sZW5ndGh9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGNvbnZlcnQgbWFwIHRvIGFycmF5XG4gICAgLy8gaW5wdXRzOiBNYXA8c3RyaW5nLCBUZW5zb3I+XG4gICAgZWxzZSB7XG4gICAgICBpZiAoaW5wdXRzLnNpemUgIT09IG1vZGVsSW5wdXROYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbmNvcnJlY3QgaW5wdXQgbWFwIHNpemU6IGV4cGVjdGVkICR7bW9kZWxJbnB1dE5hbWVzLmxlbmd0aH0gYnV0IGdvdCAke2lucHV0cy5zaXplfWApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzb3J0ZWRJbnB1dHMgPSBuZXcgQXJyYXk8VGVuc29yPihpbnB1dHMuc2l6ZSk7XG4gICAgICBsZXQgc29ydGVkSW5wdXRzSW5kZXggPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtb2RlbElucHV0TmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgdGVuc29yID0gaW5wdXRzLmdldChtb2RlbElucHV0TmFtZXNbaV0pO1xuICAgICAgICBpZiAoIXRlbnNvcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbWlzc2luZyBpbnB1dCB0ZW5zb3IgZm9yOiAnJHtuYW1lfSdgKTtcbiAgICAgICAgfVxuICAgICAgICBzb3J0ZWRJbnB1dHNbc29ydGVkSW5wdXRzSW5kZXgrK10gPSB0ZW5zb3I7XG4gICAgICB9XG5cbiAgICAgIGlucHV0cyA9IHNvcnRlZElucHV0cztcbiAgICB9XG5cbiAgICAvLyB2YWxpZGF0ZSBkaW1zIHJlcXVpcmVtZW50c1xuICAgIC8vIEZpcnN0IHNlc3Npb24gcnVuIC0gZ3JhcGggaW5wdXQgZGF0YSBpcyBub3QgY2FjaGVkIGZvciB0aGUgc2Vzc2lvblxuICAgIGlmIChcbiAgICAgICF0aGlzLmNvbnRleHQuZ3JhcGhJbnB1dFR5cGVzIHx8XG4gICAgICB0aGlzLmNvbnRleHQuZ3JhcGhJbnB1dFR5cGVzLmxlbmd0aCA9PT0gMCB8fFxuICAgICAgIXRoaXMuY29udGV4dC5ncmFwaElucHV0RGltcyB8fFxuICAgICAgdGhpcy5jb250ZXh0LmdyYXBoSW5wdXREaW1zLmxlbmd0aCA9PT0gMFxuICAgICkge1xuICAgICAgY29uc3QgbW9kZWxJbnB1dEluZGljZXMgPSB0aGlzLl9tb2RlbC5ncmFwaC5nZXRJbnB1dEluZGljZXMoKTtcbiAgICAgIGNvbnN0IG1vZGVsVmFsdWVzID0gdGhpcy5fbW9kZWwuZ3JhcGguZ2V0VmFsdWVzKCk7XG5cbiAgICAgIGNvbnN0IGdyYXBoSW5wdXREaW1zID0gbmV3IEFycmF5PHJlYWRvbmx5IG51bWJlcltdPihtb2RlbElucHV0SW5kaWNlcy5sZW5ndGgpO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vZGVsSW5wdXRJbmRpY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGdyYXBoSW5wdXQgPSBtb2RlbFZhbHVlc1ttb2RlbElucHV0SW5kaWNlc1tpXV07XG4gICAgICAgIGdyYXBoSW5wdXREaW1zW2ldID0gZ3JhcGhJbnB1dC50eXBlIS5zaGFwZS5kaW1zO1xuXG4gICAgICAgIC8vIGNhY2hlZCBmb3Igc2Vjb25kIGFuZCBzdWJzZXF1ZW50IHJ1bnMuXG4gICAgICAgIC8vIFNvbWUgcGFydHMgb2YgdGhlIGZyYW1ld29yayB3b3JrcyBvbiB0aGUgYXNzdW1wdGlvbiB0aGF0IHRoZSBncmFwaCBhbmQgdHlwZXMgYW5kIHNoYXBlcyBhcmUgc3RhdGljXG4gICAgICAgIHRoaXMuY29udGV4dC5ncmFwaElucHV0VHlwZXMhLnB1c2goZ3JhcGhJbnB1dC50eXBlIS50ZW5zb3JUeXBlKTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmdyYXBoSW5wdXREaW1zIS5wdXNoKGlucHV0c1tpXS5kaW1zKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy52YWxpZGF0ZUlucHV0VGVuc29yRGltcyhncmFwaElucHV0RGltcywgaW5wdXRzLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvLyBTZWNvbmQgYW5kIHN1YnNlcXVlbnQgc2Vzc2lvbiBydW5zIC0gZ3JhcGggaW5wdXQgZGF0YSBpcyBjYWNoZWQgZm9yIHRoZSBzZXNzaW9uXG4gICAgZWxzZSB7XG4gICAgICB0aGlzLnZhbGlkYXRlSW5wdXRUZW5zb3JEaW1zKHRoaXMuY29udGV4dC5ncmFwaElucHV0RGltcywgaW5wdXRzLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgLy8gdmFsaWRhdGUgdHlwZXMgcmVxdWlyZW1lbnRcbiAgICB0aGlzLnZhbGlkYXRlSW5wdXRUZW5zb3JUeXBlcyh0aGlzLmNvbnRleHQuZ3JhcGhJbnB1dFR5cGVzISwgaW5wdXRzKTtcblxuICAgIHJldHVybiBpbnB1dHM7XG4gIH1cblxuICBwcml2YXRlIHZhbGlkYXRlSW5wdXRUZW5zb3JUeXBlcyhncmFwaElucHV0VHlwZXM6IFRlbnNvci5EYXRhVHlwZVtdLCBnaXZlbklucHV0czogVGVuc29yW10pIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdpdmVuSW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBleHBlY3RlZFR5cGUgPSBncmFwaElucHV0VHlwZXNbaV07XG4gICAgICBjb25zdCBhY3R1YWxUeXBlID0gZ2l2ZW5JbnB1dHNbaV0udHlwZTtcbiAgICAgIGlmIChleHBlY3RlZFR5cGUgIT09IGFjdHVhbFR5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnB1dCB0ZW5zb3JbJHtpfV0gY2hlY2sgZmFpbGVkOiBleHBlY3RlZCB0eXBlICcke2V4cGVjdGVkVHlwZX0nIGJ1dCBnb3QgJHthY3R1YWxUeXBlfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgdmFsaWRhdGVJbnB1dFRlbnNvckRpbXMoXG4gICAgZ3JhcGhJbnB1dERpbXM6IEFycmF5PHJlYWRvbmx5IG51bWJlcltdPixcbiAgICBnaXZlbklucHV0czogVGVuc29yW10sXG4gICAgbm9uZURpbVN1cHBvcnRlZDogYm9vbGVhbixcbiAgKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnaXZlbklucHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZXhwZWN0ZWREaW1zID0gZ3JhcGhJbnB1dERpbXNbaV07XG4gICAgICBjb25zdCBhY3R1YWxEaW1zID0gZ2l2ZW5JbnB1dHNbaV0uZGltcztcbiAgICAgIGlmICghdGhpcy5jb21wYXJlVGVuc29yRGltcyhleHBlY3RlZERpbXMsIGFjdHVhbERpbXMsIG5vbmVEaW1TdXBwb3J0ZWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgaW5wdXQgdGVuc29yWyR7aX1dIGNoZWNrIGZhaWxlZDogZXhwZWN0ZWQgc2hhcGUgJ1ske2V4cGVjdGVkRGltcy5qb2luKCcsJyl9XScgYnV0IGdvdCBbJHthY3R1YWxEaW1zLmpvaW4oXG4gICAgICAgICAgICAnLCcsXG4gICAgICAgICAgKX1dYCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNvbXBhcmVUZW5zb3JEaW1zKFxuICAgIGV4cGVjdGVkRGltczogcmVhZG9ubHkgbnVtYmVyW10sXG4gICAgYWN0dWFsRGltczogcmVhZG9ubHkgbnVtYmVyW10sXG4gICAgbm9uZURpbVN1cHBvcnRlZDogYm9vbGVhbixcbiAgKTogYm9vbGVhbiB7XG4gICAgaWYgKGV4cGVjdGVkRGltcy5sZW5ndGggIT09IGFjdHVhbERpbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBleHBlY3RlZERpbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmIChleHBlY3RlZERpbXNbaV0gIT09IGFjdHVhbERpbXNbaV0gJiYgKCFub25lRGltU3VwcG9ydGVkIHx8IGV4cGVjdGVkRGltc1tpXSAhPT0gMCkpIHtcbiAgICAgICAgLy8gZGF0YSBzaGFwZSBtaXMtbWF0Y2ggQU5EIG5vdCBhICdOb25lJyBkaW1lbnNpb24uXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlT3V0cHV0KG91dHB1dFRlbnNvcnM6IFRlbnNvcltdKTogTWFwPHN0cmluZywgVGVuc29yPiB7XG4gICAgY29uc3QgbW9kZWxPdXRwdXROYW1lcyA9IHRoaXMuX21vZGVsLmdyYXBoLmdldE91dHB1dE5hbWVzKCk7XG4gICAgaWYgKG91dHB1dFRlbnNvcnMubGVuZ3RoICE9PSBtb2RlbE91dHB1dE5hbWVzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCBudW1iZXIgb2Ygb3V0cHV0cyBkbyBub3QgbWF0Y2ggbnVtYmVyIG9mIGdlbmVyYXRlZCBvdXRwdXRzJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3V0cHV0ID0gbmV3IE1hcDxzdHJpbmcsIFRlbnNvcj4oKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vZGVsT3V0cHV0TmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIG91dHB1dC5zZXQobW9kZWxPdXRwdXROYW1lc1tpXSwgb3V0cHV0VGVuc29yc1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxuXG4gIHByaXZhdGUgaW5pdGlhbGl6ZU9wcyhncmFwaDogR3JhcGgpOiB2b2lkIHtcbiAgICBjb25zdCBub2RlcyA9IGdyYXBoLmdldE5vZGVzKCk7XG4gICAgdGhpcy5fb3BzID0gbmV3IEFycmF5KG5vZGVzLmxlbmd0aCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9vcHNbaV0gPSB0aGlzLnNlc3Npb25IYW5kbGVyLnJlc29sdmUobm9kZXNbaV0sIHRoaXMuX21vZGVsLm9wc2V0cywgZ3JhcGgpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX21vZGVsOiBNb2RlbDtcbiAgcHJpdmF0ZSBfaW5pdGlhbGl6ZWQ6IGJvb2xlYW47XG5cbiAgcHJpdmF0ZSBfb3BzOiBPcGVyYXRvcltdO1xuICBwcml2YXRlIF9leGVjdXRpb25QbGFuOiBFeGVjdXRpb25QbGFuO1xuXG4gIHByaXZhdGUgYmFja2VuZEhpbnQ/OiBzdHJpbmc7XG5cbiAgcHJpdmF0ZSBzZXNzaW9uSGFuZGxlcjogU2Vzc2lvbkhhbmRsZXJUeXBlO1xuICBwcml2YXRlIGNvbnRleHQ6IFNlc3Npb24uQ29udGV4dDtcbiAgcHJpdmF0ZSBwcm9maWxlcjogUmVhZG9ubHk8UHJvZmlsZXI+O1xufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBJbmZlcmVuY2VTZXNzaW9uLCBJbmZlcmVuY2VTZXNzaW9uSGFuZGxlciwgU2Vzc2lvbkhhbmRsZXIsIFRlbnNvciB9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5cbmltcG9ydCB7IFNlc3Npb24gfSBmcm9tICcuL3Nlc3Npb24nO1xuaW1wb3J0IHsgVGVuc29yIGFzIE9ubnhqc1RlbnNvciB9IGZyb20gJy4vdGVuc29yJztcblxuZXhwb3J0IGNsYXNzIE9ubnhqc1Nlc3Npb25IYW5kbGVyIGltcGxlbWVudHMgSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXIge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHNlc3Npb246IFNlc3Npb24pIHtcbiAgICB0aGlzLmlucHV0TmFtZXMgPSB0aGlzLnNlc3Npb24uaW5wdXROYW1lcztcbiAgICB0aGlzLm91dHB1dE5hbWVzID0gdGhpcy5zZXNzaW9uLm91dHB1dE5hbWVzO1xuICB9XG5cbiAgYXN5bmMgZGlzcG9zZSgpOiBQcm9taXNlPHZvaWQ+IHt9XG4gIGlucHV0TmFtZXM6IHJlYWRvbmx5IHN0cmluZ1tdO1xuICBvdXRwdXROYW1lczogcmVhZG9ubHkgc3RyaW5nW107XG4gIGFzeW5jIHJ1bihcbiAgICBmZWVkczogU2Vzc2lvbkhhbmRsZXIuRmVlZHNUeXBlLFxuICAgIF9mZXRjaGVzOiBTZXNzaW9uSGFuZGxlci5GZXRjaGVzVHlwZSxcbiAgICBfb3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zLFxuICApOiBQcm9taXNlPFNlc3Npb25IYW5kbGVyLlJldHVyblR5cGU+IHtcbiAgICBjb25zdCBpbnB1dE1hcCA9IG5ldyBNYXA8c3RyaW5nLCBPbm54anNUZW5zb3I+KCk7XG4gICAgZm9yIChjb25zdCBuYW1lIGluIGZlZWRzKSB7XG4gICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZmVlZHMsIG5hbWUpKSB7XG4gICAgICAgIGNvbnN0IGZlZWQgPSBmZWVkc1tuYW1lXTtcbiAgICAgICAgaW5wdXRNYXAuc2V0KFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgbmV3IE9ubnhqc1RlbnNvcihcbiAgICAgICAgICAgIGZlZWQuZGltcyxcbiAgICAgICAgICAgIGZlZWQudHlwZSBhcyBPbm54anNUZW5zb3IuRGF0YVR5cGUsXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICBmZWVkLmRhdGEgYXMgT25ueGpzVGVuc29yLk51bWJlclR5cGUsXG4gICAgICAgICAgKSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgb3V0cHV0TWFwID0gYXdhaXQgdGhpcy5zZXNzaW9uLnJ1bihpbnB1dE1hcCk7XG4gICAgY29uc3Qgb3V0cHV0OiBTZXNzaW9uSGFuZGxlci5SZXR1cm5UeXBlID0ge307XG4gICAgb3V0cHV0TWFwLmZvckVhY2goKHRlbnNvciwgbmFtZSkgPT4ge1xuICAgICAgb3V0cHV0W25hbWVdID0gbmV3IFRlbnNvcih0ZW5zb3IudHlwZSwgdGVuc29yLmRhdGEsIHRlbnNvci5kaW1zKTtcbiAgICB9KTtcbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG4gIHN0YXJ0UHJvZmlsaW5nKCk6IHZvaWQge1xuICAgIHRoaXMuc2Vzc2lvbi5zdGFydFByb2ZpbGluZygpO1xuICB9XG4gIGVuZFByb2ZpbGluZygpOiB2b2lkIHtcbiAgICB0aGlzLnNlc3Npb24uZW5kUHJvZmlsaW5nKCk7XG4gIH1cbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuLyogZXNsaW50LWRpc2FibGUgaW1wb3J0L25vLWludGVybmFsLW1vZHVsZXMgKi9cbmltcG9ydCB7IEJhY2tlbmQsIEluZmVyZW5jZVNlc3Npb24sIEluZmVyZW5jZVNlc3Npb25IYW5kbGVyIH0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuaW1wb3J0IHsgU2Vzc2lvbiB9IGZyb20gJy4vb25ueGpzL3Nlc3Npb24nO1xuaW1wb3J0IHsgT25ueGpzU2Vzc2lvbkhhbmRsZXIgfSBmcm9tICcuL29ubnhqcy9zZXNzaW9uLWhhbmRsZXItaW5mZXJlbmNlJztcblxuY2xhc3MgT25ueGpzQmFja2VuZCBpbXBsZW1lbnRzIEJhY2tlbmQge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uXG4gIGFzeW5jIGluaXQoKTogUHJvbWlzZTx2b2lkPiB7fVxuXG4gIGFzeW5jIGNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyKFxuICAgIHBhdGhPckJ1ZmZlcjogc3RyaW5nIHwgVWludDhBcnJheSxcbiAgICBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcj4ge1xuICAgIC8vIE5PVEU6IFNlc3Npb24uQ29uZmlnKGZyb20gb25ueC5qcykgaXMgbm90IGNvbXBhdGlibGUgd2l0aCBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zKGZyb21cbiAgICAvLyBvbm54cnVudGltZS1jb21tb24pLlxuICAgIC8vICAgICAgIEluIGZ1dHVyZSB3ZSBzaG91bGQgcmVtb3ZlIFNlc3Npb24uQ29uZmlnIGFuZCB1c2UgSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucy5cbiAgICAvLyAgICAgICBDdXJyZW50bHkgd2UgYWxsb3cgdGhpcyB0byBoYXBwZW4gdG8gbWFrZSB0ZXN0IHJ1bm5lciB3b3JrLlxuICAgIGNvbnN0IHNlc3Npb24gPSBuZXcgU2Vzc2lvbihvcHRpb25zIGFzIHVua25vd24gYXMgU2Vzc2lvbi5Db25maWcpO1xuXG4gICAgLy8gdHlwZXNjcmlwdCBjYW5ub3QgbWVyZ2UgbWV0aG9kIG92ZXJyaWRlIGNvcnJlY3RseSAoc28gZmFyIGluIDQuMi4zKS4gbmVlZCBpZi1lbHNlIHRvIGNhbGwgdGhlIG1ldGhvZC5cbiAgICBpZiAodHlwZW9mIHBhdGhPckJ1ZmZlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGF3YWl0IHNlc3Npb24ubG9hZE1vZGVsKHBhdGhPckJ1ZmZlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF3YWl0IHNlc3Npb24ubG9hZE1vZGVsKHBhdGhPckJ1ZmZlcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBPbm54anNTZXNzaW9uSGFuZGxlcihzZXNzaW9uKTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgb25ueGpzQmFja2VuZCA9IG5ldyBPbm54anNCYWNrZW5kKCk7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmV4cG9ydCBjb25zdCBpc05vZGUgPSAhISh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy52ZXJzaW9ucyAmJiBwcm9jZXNzLnZlcnNpb25zLm5vZGUpO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG4vLy8gPHJlZmVyZW5jZSBsaWI9XCJ3ZWJ3b3JrZXJcIiAvPlxuXG4vL1xuLy8gKiB0eXBlIGhhY2sgZm9yIFwiSFRNTEltYWdlRWxlbWVudFwiXG4vL1xuLy8gaW4gdHlwZXNjcmlwdCwgdGhlIHR5cGUgb2YgXCJIVE1MSW1hZ2VFbGVtZW50XCIgaXMgZGVmaW5lZCBpbiBsaWIuZG9tLmQudHMsIHdoaWNoIGlzIGNvbmZsaWN0IHdpdGggbGliLndlYndvcmtlci5kLnRzLlxuLy8gd2hlbiB3ZSB1c2Ugd2Vid29ya2VyLCB0aGUgbGliLndlYndvcmtlci5kLnRzIHdpbGwgYmUgdXNlZCwgd2hpY2ggZG9lcyBub3QgaGF2ZSBIVE1MSW1hZ2VFbGVtZW50IGRlZmluZWQuXG4vL1xuLy8gd2Ugd2lsbCBnZXQgdGhlIGZvbGxvd2luZyBlcnJvcnMgY29tcGxhaW5pbmcgdGhhdCBIVE1MSW1hZ2VFbGVtZW50IGlzIG5vdCBkZWZpbmVkOlxuLy9cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vL1xuLy8gLi4vY29tbW9uL2Rpc3QvY2pzL3RlbnNvci1mYWN0b3J5LmQudHM6MTg3OjI5IC0gZXJyb3IgVFMyNTUyOiBDYW5ub3QgZmluZCBuYW1lICdIVE1MSW1hZ2VFbGVtZW50Jy4gRGlkIHlvdSBtZWFuXG4vLyAnSFRNTExJRWxlbWVudCc/XG4vL1xuLy8gMTg3ICAgICBmcm9tSW1hZ2UoaW1hZ2VFbGVtZW50OiBIVE1MSW1hZ2VFbGVtZW50LCBvcHRpb25zPzogVGVuc29yRnJvbUltYWdlRWxlbWVudE9wdGlvbnMpOlxuLy8gUHJvbWlzZTxUeXBlZFRlbnNvcjwnZmxvYXQzMic+IHwgVHlwZWRUZW5zb3I8J3VpbnQ4Jz4+O1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB+fn5+fn5+fn5+fn5+fn5+XG4vL1xuLy8gbm9kZV9tb2R1bGVzL0B3ZWJncHUvdHlwZXMvZGlzdC9pbmRleC5kLnRzOjgzOjcgLSBlcnJvciBUUzI1NTI6IENhbm5vdCBmaW5kIG5hbWUgJ0hUTUxJbWFnZUVsZW1lbnQnLiBEaWQgeW91IG1lYW5cbi8vICdIVE1MTElFbGVtZW50Jz9cbi8vXG4vLyA4MyAgICAgfCBIVE1MSW1hZ2VFbGVtZW50XG4vLyAgICAgICAgICB+fn5+fn5+fn5+fn5+fn5+XG4vL1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vXG4vLyBgSFRNTEltYWdlRWxlbWVudGAgaXMgb25seSB1c2VkIGluIHR5cGUgZGVjbGFyYXRpb24gYW5kIG5vdCBpbiByZWFsIGNvZGUuIFNvIHdlIGRlZmluZSBpdCBhcyBgdW5rbm93bmAgaGVyZSB0b1xuLy8gYnlwYXNzIHRoZSB0eXBlIGNoZWNrLlxuXG4vL1xuLy8gKiB0eXBlIGhhY2sgZm9yIFwiZG9jdW1lbnRcIlxuLy9cbi8vIGluIHR5cGVzY3JpcHQsIHRoZSB0eXBlIG9mIFwiZG9jdW1lbnRcIiBpcyBkZWZpbmVkIGluIGxpYi5kb20uZC50cywgc28gaXQncyBub3QgYXZhaWxhYmxlIGluIHdlYndvcmtlci5cbi8vXG4vLyB3ZSB3aWxsIGdldCB0aGUgZm9sbG93aW5nIGVycm9ycyBjb21wbGFpbmluZyB0aGF0IGRvY3VtZW50IGlzIG5vdCBkZWZpbmVkOlxuLy9cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vL1xuLy8gbGliL3dhc20vd2FzbS11dGlscy1pbXBvcnQudHM6NzozMyAtIGVycm9yIFRTMjU4NDogQ2Fubm90IGZpbmQgbmFtZSAnZG9jdW1lbnQnLiBEbyB5b3UgbmVlZCB0byBjaGFuZ2UgeW91ciB0YXJnZXRcbi8vIGxpYnJhcnk/IFRyeSBjaGFuZ2luZyB0aGUgJ2xpYicgY29tcGlsZXIgb3B0aW9uIHRvIGluY2x1ZGUgJ2RvbScuXG4vL1xuLy8gNyBleHBvcnQgY29uc3Qgc2NyaXB0U3JjID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IChkb2N1bWVudD8uY3VycmVudFNjcmlwdCBhcyBIVE1MU2NyaXB0RWxlbWVudCk/LnNyYyA6XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfn5+fn5+fn5cbi8vXG4vLyBsaWIvd2FzbS93YXNtLXV0aWxzLWltcG9ydC50czo3OjYxIC0gZXJyb3IgVFMyNTg0OiBDYW5ub3QgZmluZCBuYW1lICdkb2N1bWVudCcuIERvIHlvdSBuZWVkIHRvIGNoYW5nZSB5b3VyIHRhcmdldFxuLy8gbGlicmFyeT8gVHJ5IGNoYW5naW5nIHRoZSAnbGliJyBjb21waWxlciBvcHRpb24gdG8gaW5jbHVkZSAnZG9tJy5cbi8vXG4vLyA3IGV4cG9ydCBjb25zdCBzY3JpcHRTcmMgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gKGRvY3VtZW50Py5jdXJyZW50U2NyaXB0IGFzIEhUTUxTY3JpcHRFbGVtZW50KT8uc3JjIDpcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfn5+fn5+fn5cbi8vXG4vLyBsaWIvd2FzbS93YXNtLXV0aWxzLWltcG9ydC50czo3Ojg4IC0gZXJyb3IgVFMyNTUyOiBDYW5ub3QgZmluZCBuYW1lICdIVE1MU2NyaXB0RWxlbWVudCcuIERpZCB5b3UgbWVhblxuLy8gJ0hUTUxMSUVsZW1lbnQnP1xuLy9cbi8vIDcgZXhwb3J0IGNvbnN0IHNjcmlwdFNyYyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyAoZG9jdW1lbnQ/LmN1cnJlbnRTY3JpcHQgYXMgSFRNTFNjcmlwdEVsZW1lbnQpPy5zcmMgOlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB+fn5+fn5+fn5+fn5+fn5+flxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vXG4vLyBgZG9jdW1lbnRgIGlzIHVzZWQgdG8gZ2V0IHRoZSBjdXJyZW50IHNjcmlwdCBVUkwsIHdoaWNoIGlzIG5vdCBhdmFpbGFibGUgaW4gd2Vid29ya2VyLiBUaGlzIGZpbGUgaXMgc2VydmVkIGFzIGFcbi8vIFwiZHVhbFwiIGZpbGUgZm9yIGVudHJpZXMgb2YgYm90aCB3ZWJ3b3JrZXIgYW5kIHRoZSBlc20gbW9kdWxlLlxuLy9cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgdHlwZSBIVE1MSW1hZ2VFbGVtZW50ID0gdW5rbm93bjtcbiAgdHlwZSBIVE1MU2NyaXB0RWxlbWVudCA9IHsgc3JjPzogc3RyaW5nIH07XG4gIGNvbnN0IGRvY3VtZW50OiB1bmRlZmluZWQgfCB7IGN1cnJlbnRTY3JpcHQ/OiBIVE1MU2NyaXB0RWxlbWVudCB9O1xufVxuXG4vKipcbiAqIEBzdW1tYXJ5XG4gKlxuICogVGhpcyBmaWxlIGlzIHNlcnZlZCBhcyBhIFwiZHVhbFwiIGZpbGUgZm9yIGJvdGggZW50cmllcyBvZiB0aGUgZm9sbG93aW5nOlxuICogLSBUaGUgcHJveHkgd29ya2VyIGl0c2VsZi5cbiAqICAgLSBXaGVuIHVzZWQgYXMgYSB3b3JrZXIsIGl0IGxpc3RlbnMgdG8gdGhlIG1lc3NhZ2VzIGZyb20gdGhlIG1haW4gdGhyZWFkIGFuZCBwZXJmb3JtcyB0aGUgY29ycmVzcG9uZGluZyBvcGVyYXRpb25zLlxuICogICAtIFNob3VsZCBiZSBpbXBvcnRlZCBkaXJlY3RseSB1c2luZyBgbmV3IFdvcmtlcigpYCBpbiB0aGUgbWFpbiB0aHJlYWQuXG4gKlxuICogLSBUaGUgRVNNIG1vZHVsZSB0aGF0IGNyZWF0ZXMgdGhlIHByb3h5IHdvcmtlciAoYXMgYSB3b3JrZXIgbGF1bmNoZXIpLlxuICogICAtIFdoZW4gdXNlZCBhcyBhIHdvcmtlciBsYXVuY2hlciwgaXQgY3JlYXRlcyB0aGUgcHJveHkgd29ya2VyIGFuZCByZXR1cm5zIGl0LlxuICogICAtIFNob3VsZCBiZSBpbXBvcnRlZCB1c2luZyBgaW1wb3J0KClgIGluIHRoZSBtYWluIHRocmVhZCwgd2l0aCB0aGUgcXVlcnkgcGFyYW1ldGVyIGBpbXBvcnQ9MWAuXG4gKlxuICogVGhpcyBmaWxlIHdpbGwgYmUgYWx3YXlzIGNvbXBpbGluZyBpbnRvIEVTTSBmb3JtYXQuXG4gKi9cblxuaW1wb3J0IHR5cGUgeyBPcnRXYXNtTWVzc2FnZSwgU2VyaWFsaXphYmxlVGVuc29yTWV0YWRhdGEgfSBmcm9tICcuLi9wcm94eS1tZXNzYWdlcy5qcyc7XG5pbXBvcnQge1xuICBjcmVhdGVTZXNzaW9uLFxuICBjb3B5RnJvbUV4dGVybmFsQnVmZmVyLFxuICBlbmRQcm9maWxpbmcsXG4gIGV4dHJhY3RUcmFuc2ZlcmFibGVCdWZmZXJzLFxuICBpbml0RXAsXG4gIGluaXRSdW50aW1lLFxuICByZWxlYXNlU2Vzc2lvbixcbiAgcnVuLFxufSBmcm9tICcuLi93YXNtLWNvcmUtaW1wbC5qcyc7XG5pbXBvcnQgeyBpbml0aWFsaXplV2ViQXNzZW1ibHkgfSBmcm9tICcuLi93YXNtLWZhY3RvcnkuanMnO1xuaW1wb3J0IHsgc2NyaXB0U3JjIH0gZnJvbSAnLi4vd2FzbS11dGlscy1pbXBvcnQuanMnO1xuXG5jb25zdCBXT1JLRVJfTkFNRSA9ICdvcnQtd2FzbS1wcm94eS13b3JrZXInO1xuY29uc3QgaXNQcm94eVdvcmtlciA9IGdsb2JhbFRoaXMuc2VsZj8ubmFtZSA9PT0gV09SS0VSX05BTUU7XG5cbmlmIChpc1Byb3h5V29ya2VyKSB7XG4gIC8vIFdvcmtlciB0aHJlYWRcbiAgc2VsZi5vbm1lc3NhZ2UgPSAoZXY6IE1lc3NhZ2VFdmVudDxPcnRXYXNtTWVzc2FnZT4pOiB2b2lkID0+IHtcbiAgICBjb25zdCB7IHR5cGUsIGluOiBtZXNzYWdlIH0gPSBldi5kYXRhO1xuICAgIHRyeSB7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnaW5pdC13YXNtJzpcbiAgICAgICAgICBpbml0aWFsaXplV2ViQXNzZW1ibHkobWVzc2FnZSEud2FzbSkudGhlbihcbiAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgaW5pdFJ1bnRpbWUobWVzc2FnZSEpLnRoZW4oXG4gICAgICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2UoeyB0eXBlIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2UoeyB0eXBlLCBlcnIgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgIHBvc3RNZXNzYWdlKHsgdHlwZSwgZXJyIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdpbml0LWVwJzoge1xuICAgICAgICAgIGNvbnN0IHsgZXBOYW1lLCBlbnYgfSA9IG1lc3NhZ2UhO1xuICAgICAgICAgIGluaXRFcChlbnYsIGVwTmFtZSkudGhlbihcbiAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgcG9zdE1lc3NhZ2UoeyB0eXBlIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgcG9zdE1lc3NhZ2UoeyB0eXBlLCBlcnIgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnY29weS1mcm9tJzoge1xuICAgICAgICAgIGNvbnN0IHsgYnVmZmVyIH0gPSBtZXNzYWdlITtcbiAgICAgICAgICBjb25zdCBidWZmZXJEYXRhID0gY29weUZyb21FeHRlcm5hbEJ1ZmZlcihidWZmZXIpO1xuICAgICAgICAgIHBvc3RNZXNzYWdlKHsgdHlwZSwgb3V0OiBidWZmZXJEYXRhIH0gYXMgT3J0V2FzbU1lc3NhZ2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2NyZWF0ZSc6IHtcbiAgICAgICAgICBjb25zdCB7IG1vZGVsLCBvcHRpb25zIH0gPSBtZXNzYWdlITtcbiAgICAgICAgICBjcmVhdGVTZXNzaW9uKG1vZGVsLCBvcHRpb25zKS50aGVuKFxuICAgICAgICAgICAgKHNlc3Npb25NZXRhZGF0YSkgPT4ge1xuICAgICAgICAgICAgICBwb3N0TWVzc2FnZSh7IHR5cGUsIG91dDogc2Vzc2lvbk1ldGFkYXRhIH0gYXMgT3J0V2FzbU1lc3NhZ2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgcG9zdE1lc3NhZ2UoeyB0eXBlLCBlcnIgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAncmVsZWFzZSc6XG4gICAgICAgICAgcmVsZWFzZVNlc3Npb24obWVzc2FnZSEpO1xuICAgICAgICAgIHBvc3RNZXNzYWdlKHsgdHlwZSB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncnVuJzoge1xuICAgICAgICAgIGNvbnN0IHsgc2Vzc2lvbklkLCBpbnB1dEluZGljZXMsIGlucHV0cywgb3V0cHV0SW5kaWNlcywgb3B0aW9ucyB9ID0gbWVzc2FnZSE7XG4gICAgICAgICAgcnVuKHNlc3Npb25JZCwgaW5wdXRJbmRpY2VzLCBpbnB1dHMsIG91dHB1dEluZGljZXMsIG5ldyBBcnJheShvdXRwdXRJbmRpY2VzLmxlbmd0aCkuZmlsbChudWxsKSwgb3B0aW9ucykudGhlbihcbiAgICAgICAgICAgIChvdXRwdXRzKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChvdXRwdXRzLnNvbWUoKG8pID0+IG9bM10gIT09ICdjcHUnKSkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlKHsgdHlwZSwgZXJyOiAnUHJveHkgZG9lcyBub3Qgc3VwcG9ydCBub24tY3B1IHRlbnNvciBsb2NhdGlvbi4nIH0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlKFxuICAgICAgICAgICAgICAgICAgeyB0eXBlLCBvdXQ6IG91dHB1dHMgfSBhcyBPcnRXYXNtTWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgIGV4dHJhY3RUcmFuc2ZlcmFibGVCdWZmZXJzKFsuLi5pbnB1dHMsIC4uLm91dHB1dHNdIGFzIFNlcmlhbGl6YWJsZVRlbnNvck1ldGFkYXRhW10pLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgIHBvc3RNZXNzYWdlKHsgdHlwZSwgZXJyIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2VuZC1wcm9maWxpbmcnOlxuICAgICAgICAgIGVuZFByb2ZpbGluZyhtZXNzYWdlISk7XG4gICAgICAgICAgcG9zdE1lc3NhZ2UoeyB0eXBlIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcG9zdE1lc3NhZ2UoeyB0eXBlLCBlcnIgfSBhcyBPcnRXYXNtTWVzc2FnZSk7XG4gICAgfVxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc1Byb3h5V29ya2VyXG4gID8gbnVsbFxuICA6ICh1cmxPdmVycmlkZT86IHN0cmluZykgPT5cbiAgICAgIG5ldyBXb3JrZXIodXJsT3ZlcnJpZGUgPz8gc2NyaXB0U3JjISwgeyB0eXBlOiBCVUlMRF9ERUZTLklTX0VTTSA/ICdtb2R1bGUnIDogJ2NsYXNzaWMnLCBuYW1lOiBXT1JLRVJfTkFNRSB9KTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHR5cGUgeyBPcnRXYXNtTW9kdWxlIH0gZnJvbSAnLi93YXNtLXR5cGVzJztcbmltcG9ydCB7IGlzTm9kZSB9IGZyb20gJy4vd2FzbS11dGlscy1lbnYnO1xuXG4vKipcbiAqIFRoZSBjbGFzc2ljIHNjcmlwdCBzb3VyY2UgVVJMLiBUaGlzIGlzIG5vdCBhbHdheXMgYXZhaWxhYmxlIGluIG5vbiBFU01vZHVsZSBlbnZpcm9ubWVudHMuXG4gKlxuICogSW4gTm9kZS5qcywgdGhpcyBpcyB1bmRlZmluZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBzY3JpcHRTcmMgPVxuICAvLyBpZiBOb2RlanMsIHJldHVybiB1bmRlZmluZWRcbiAgaXNOb2RlXG4gICAgPyB1bmRlZmluZWRcbiAgICA6IC8vIGlmIEl0J3MgRVNNLCB1c2UgaW1wb3J0Lm1ldGEudXJsXG4gICAgICAoQlVJTERfREVGUy5FU01fSU1QT1JUX01FVEFfVVJMID8/XG4gICAgICAvLyB1c2UgYGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjYCBpZiBhdmFpbGFibGVcbiAgICAgICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnXG4gICAgICAgID8gKGRvY3VtZW50LmN1cnJlbnRTY3JpcHQgYXMgSFRNTFNjcmlwdEVsZW1lbnQpPy5zcmNcbiAgICAgICAgOiAvLyB1c2UgYHNlbGYubG9jYXRpb24uaHJlZmAgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgPyBzZWxmLmxvY2F0aW9uPy5ocmVmXG4gICAgICAgICAgOiB1bmRlZmluZWQpKTtcblxuLyoqXG4gKiBUaGUgb3JpZ2luIG9mIHRoZSBjdXJyZW50IGxvY2F0aW9uLlxuICpcbiAqIEluIE5vZGUuanMsIHRoaXMgaXMgdW5kZWZpbmVkLlxuICovXG5jb25zdCBvcmlnaW4gPSBpc05vZGUgfHwgdHlwZW9mIGxvY2F0aW9uID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IGxvY2F0aW9uLm9yaWdpbjtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gZmlsZW5hbWUgd2l0aCBwcmVmaXggaXMgZnJvbSB0aGUgc2FtZSBvcmlnaW4uXG4gKi9cbmNvbnN0IGlzU2FtZU9yaWdpbiA9IChmaWxlbmFtZTogc3RyaW5nLCBwcmVmaXhPdmVycmlkZT86IHN0cmluZykgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IGJhc2VVcmwgPSBwcmVmaXhPdmVycmlkZSA/PyBzY3JpcHRTcmM7XG4gICAgY29uc3QgdXJsID0gYmFzZVVybCA/IG5ldyBVUkwoZmlsZW5hbWUsIGJhc2VVcmwpIDogbmV3IFVSTChmaWxlbmFtZSk7XG4gICAgcmV0dXJuIHVybC5vcmlnaW4gPT09IG9yaWdpbjtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSB0aGUgaW5wdXRzIHRvIGFuIGFic29sdXRlIFVSTCB3aXRoIHRoZSBnaXZlbiBwcmVmaXggb3ZlcnJpZGUuIElmIGZhaWxlZCwgcmV0dXJuIHVuZGVmaW5lZC5cbiAqL1xuY29uc3Qgbm9ybWFsaXplVXJsID0gKGZpbGVuYW1lOiBzdHJpbmcsIHByZWZpeE92ZXJyaWRlPzogc3RyaW5nKSA9PiB7XG4gIGNvbnN0IGJhc2VVcmwgPSBwcmVmaXhPdmVycmlkZSA/PyBzY3JpcHRTcmM7XG4gIHRyeSB7XG4gICAgY29uc3QgdXJsID0gYmFzZVVybCA/IG5ldyBVUkwoZmlsZW5hbWUsIGJhc2VVcmwpIDogbmV3IFVSTChmaWxlbmFtZSk7XG4gICAgcmV0dXJuIHVybC5ocmVmO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIGZhbGxiYWNrIFVSTCBpZiBhbiBhYnNvbHV0ZSBVUkwgY2Fubm90IGJlIGNyZWF0ZWQgYnkgdGhlIG5vcm1hbGl6ZVVybCBmdW5jdGlvbi5cbiAqL1xuY29uc3QgZmFsbGJhY2tVcmwgPSAoZmlsZW5hbWU6IHN0cmluZywgcHJlZml4T3ZlcnJpZGU/OiBzdHJpbmcpID0+IGAke3ByZWZpeE92ZXJyaWRlID8/ICcuLyd9JHtmaWxlbmFtZX1gO1xuXG4vKipcbiAqIFRoaXMgaGVscGVyIGZ1bmN0aW9uIGlzIHVzZWQgdG8gcHJlbG9hZCBhIG1vZHVsZSBmcm9tIGEgVVJMLlxuICpcbiAqIElmIHRoZSBvcmlnaW4gb2YgdGhlIHdvcmtlciBVUkwgaXMgZGlmZmVyZW50IGZyb20gdGhlIGN1cnJlbnQgb3JpZ2luLCB0aGUgd29ya2VyIGNhbm5vdCBiZSBsb2FkZWQgZGlyZWN0bHkuXG4gKiBTZWUgZGlzY3Vzc2lvbnMgaW4gaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi93b3JrZXItbG9hZGVyL2lzc3Vlcy8xNTRcbiAqXG4gKiBJbiB0aGlzIGNhc2UsIHdlIHdpbGwgZmV0Y2ggdGhlIHdvcmtlciBVUkwgYW5kIGNyZWF0ZSBhIG5ldyBCbG9iIFVSTCB3aXRoIHRoZSBzYW1lIG9yaWdpbiBhcyBhIHdvcmthcm91bmQuXG4gKlxuICogQHBhcmFtIGFic29sdXRlVXJsIC0gVGhlIGFic29sdXRlIFVSTCB0byBwcmVsb2FkLlxuICpcbiAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBuZXcgQmxvYiBVUkxcbiAqL1xuY29uc3QgcHJlbG9hZCA9IGFzeW5jIChhYnNvbHV0ZVVybDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+ID0+IHtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChhYnNvbHV0ZVVybCwgeyBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyB9KTtcbiAgY29uc3QgYmxvYiA9IGF3YWl0IHJlc3BvbnNlLmJsb2IoKTtcbiAgcmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG59O1xuXG4vKipcbiAqIFRoaXMgaGVscGVyIGZ1bmN0aW9uIGlzIHVzZWQgdG8gZHluYW1pY2FsbHkgaW1wb3J0IGEgbW9kdWxlIGZyb20gYSBVUkwuXG4gKlxuICogVGhlIGJ1aWxkIHNjcmlwdCBoYXMgc3BlY2lhbCBoYW5kbGluZyBmb3IgdGhpcyBmdW5jdGlvbiB0byBlbnN1cmUgdGhhdCB0aGUgVVJMIGlzIG5vdCBidW5kbGVkIGludG8gdGhlIGZpbmFsIG91dHB1dC5cbiAqXG4gKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCB0byBpbXBvcnQuXG4gKlxuICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgZGVmYXVsdCBleHBvcnQgb2YgdGhlIG1vZHVsZS5cbiAqL1xuY29uc3QgZHluYW1pY0ltcG9ydERlZmF1bHQgPSBhc3luYyA8VD4odXJsOiBzdHJpbmcpOiBQcm9taXNlPFQ+ID0+XG4gIChhd2FpdCBpbXBvcnQoLyogd2VicGFja0lnbm9yZTogdHJ1ZSAqLyB1cmwpKS5kZWZhdWx0O1xuXG4vKipcbiAqIFRoZSBwcm94eSB3b3JrZXIgZmFjdG9yeSBpbXBvcnRlZCBmcm9tIHRoZSBwcm94eSB3b3JrZXIgbW9kdWxlLlxuICpcbiAqIFRoaXMgaXMgb25seSBhdmFpbGFibGUgd2hlbiB0aGUgV2ViQXNzZW1ibHkgcHJveHkgaXMgbm90IGRpc2FibGVkLlxuICovXG5jb25zdCBjcmVhdGVQcm94eVdvcmtlcjogKCh1cmxPdmVycmlkZT86IHN0cmluZykgPT4gV29ya2VyKSB8IHVuZGVmaW5lZCA9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzXG4gIEJVSUxEX0RFRlMuRElTQUJMRV9XQVNNX1BST1hZID8gdW5kZWZpbmVkIDogcmVxdWlyZSgnLi9wcm94eS13b3JrZXIvbWFpbicpLmRlZmF1bHQ7XG5cbi8qKlxuICogSW1wb3J0IHRoZSBwcm94eSB3b3JrZXIuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIHBlcmZvcm0gdGhlIGZvbGxvd2luZyBzdGVwczpcbiAqIDEuIElmIGEgcHJlbG9hZCBpcyBuZWVkZWQsIGl0IHdpbGwgcHJlbG9hZCB0aGUgbW9kdWxlIGFuZCByZXR1cm4gdGhlIG9iamVjdCBVUkwuXG4gKiAyLiBVc2UgdGhlIHByb3h5IHdvcmtlciBmYWN0b3J5IHRvIGNyZWF0ZSB0aGUgcHJveHkgd29ya2VyLlxuICpcbiAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSB0dXBsZSBvZiAyIGVsZW1lbnRzOlxuICogICAgICAgICAgICAtIFRoZSBvYmplY3QgVVJMIG9mIHRoZSBwcmVsb2FkZWQgbW9kdWxlLCBvciB1bmRlZmluZWQgaWYgbm8gcHJlbG9hZCBpcyBuZWVkZWQuXG4gKiAgICAgICAgICAgIC0gVGhlIHByb3h5IHdvcmtlci5cbiAqL1xuZXhwb3J0IGNvbnN0IGltcG9ydFByb3h5V29ya2VyID0gYXN5bmMgKCk6IFByb21pc2U8W3VuZGVmaW5lZCB8IHN0cmluZywgV29ya2VyXT4gPT4ge1xuICBpZiAoIXNjcmlwdFNyYykge1xuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGxvYWQgcHJveHkgd29ya2VyOiBjYW5ub3QgZGV0ZXJtaW5lIHRoZSBzY3JpcHQgc291cmNlIFVSTC4nKTtcbiAgfVxuXG4gIC8vIElmIHRoZSBzY3JpcHQgc291cmNlIGlzIGZyb20gdGhlIHNhbWUgb3JpZ2luLCB3ZSBjYW4gdXNlIHRoZSBlbWJlZGRlZCBwcm94eSBtb2R1bGUgZGlyZWN0bHkuXG4gIGlmIChpc1NhbWVPcmlnaW4oc2NyaXB0U3JjKSkge1xuICAgIHJldHVybiBbdW5kZWZpbmVkLCBjcmVhdGVQcm94eVdvcmtlciEoKV07XG4gIH1cblxuICAvLyBPdGhlcndpc2UsIG5lZWQgdG8gcHJlbG9hZFxuICBjb25zdCB1cmwgPSBhd2FpdCBwcmVsb2FkKHNjcmlwdFNyYyk7XG4gIHJldHVybiBbdXJsLCBjcmVhdGVQcm94eVdvcmtlciEodXJsKV07XG59O1xuXG4vKipcbiAqIFRoZSBlbWJlZGRlZCBXZWJBc3NlbWJseSBtb2R1bGUuXG4gKlxuICogVGhpcyBpcyBvbmx5IGF2YWlsYWJsZSBpbiBFU00gYW5kIHdoZW4gZW1iZWRkaW5nIGlzIG5vdCBkaXNhYmxlZC5cbiAqL1xuY29uc3QgZW1iZWRkZWRXYXNtTW9kdWxlOiBFbXNjcmlwdGVuTW9kdWxlRmFjdG9yeTxPcnRXYXNtTW9kdWxlPiB8IHVuZGVmaW5lZCA9XG4gIEJVSUxEX0RFRlMuSVNfRVNNICYmIEJVSUxEX0RFRlMuRElTQUJMRV9EWU5BTUlDX0lNUE9SVFxuICAgID8gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHMsIEB0eXBlc2NyaXB0LWVzbGludC9uby12YXItcmVxdWlyZXNcbiAgICAgIHJlcXVpcmUoXG4gICAgICAgICFCVUlMRF9ERUZTLkRJU0FCTEVfSlNFUFxuICAgICAgICAgID8gJy4uLy4uL2Rpc3Qvb3J0LXdhc20tc2ltZC10aHJlYWRlZC5qc2VwLm1qcydcbiAgICAgICAgICA6ICcuLi8uLi9kaXN0L29ydC13YXNtLXNpbWQtdGhyZWFkZWQubWpzJyxcbiAgICAgICkuZGVmYXVsdFxuICAgIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEltcG9ydCB0aGUgV2ViQXNzZW1ibHkgbW9kdWxlLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBwZXJmb3JtIHRoZSBmb2xsb3dpbmcgc3RlcHM6XG4gKiAxLiBJZiBCVUlMRF9ERUZTLkRJU0FCTEVfRFlOQU1JQ19JTVBPUlQgaXMgdHJ1ZSwgdXNlIHRoZSBlbWJlZGRlZCBtb2R1bGUuXG4gKiAyLiBJZiBhIHByZWxvYWQgaXMgbmVlZGVkLCBpdCB3aWxsIHByZWxvYWQgdGhlIG1vZHVsZSBhbmQgcmV0dXJuIHRoZSBvYmplY3QgVVJMLlxuICogMy4gT3RoZXJ3aXNlLCBpdCB3aWxsIHBlcmZvcm0gYSBkeW5hbWljIGltcG9ydCBvZiB0aGUgbW9kdWxlLlxuICpcbiAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSB0dXBsZSBvZiAyIGVsZW1lbnRzOlxuICogICAgICAgICAgICAtIFRoZSBvYmplY3QgVVJMIG9mIHRoZSBwcmVsb2FkZWQgbW9kdWxlLCBvciB1bmRlZmluZWQgaWYgbm8gcHJlbG9hZCBpcyBuZWVkZWQuXG4gKiAgICAgICAgICAgIC0gVGhlIGRlZmF1bHQgZXhwb3J0IG9mIHRoZSBtb2R1bGUsIHdoaWNoIGlzIGEgZmFjdG9yeSBmdW5jdGlvbiB0byBjcmVhdGUgdGhlIFdlYkFzc2VtYmx5IG1vZHVsZS5cbiAqL1xuZXhwb3J0IGNvbnN0IGltcG9ydFdhc21Nb2R1bGUgPSBhc3luYyAoXG4gIHVybE92ZXJyaWRlOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gIHByZWZpeE92ZXJyaWRlOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gIGlzTXVsdGlUaHJlYWRlZDogYm9vbGVhbixcbik6IFByb21pc2U8W3VuZGVmaW5lZCB8IHN0cmluZywgRW1zY3JpcHRlbk1vZHVsZUZhY3Rvcnk8T3J0V2FzbU1vZHVsZT5dPiA9PiB7XG4gIGlmIChCVUlMRF9ERUZTLkRJU0FCTEVfRFlOQU1JQ19JTVBPUlQpIHtcbiAgICByZXR1cm4gW3VuZGVmaW5lZCwgZW1iZWRkZWRXYXNtTW9kdWxlIV07XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgd2FzbU1vZHVsZUZpbGVuYW1lID0gIUJVSUxEX0RFRlMuRElTQUJMRV9KU0VQXG4gICAgICA/ICdvcnQtd2FzbS1zaW1kLXRocmVhZGVkLmpzZXAubWpzJ1xuICAgICAgOiAnb3J0LXdhc20tc2ltZC10aHJlYWRlZC5tanMnO1xuICAgIGNvbnN0IHdhc21Nb2R1bGVVcmwgPSB1cmxPdmVycmlkZSA/PyBub3JtYWxpemVVcmwod2FzbU1vZHVsZUZpbGVuYW1lLCBwcmVmaXhPdmVycmlkZSk7XG4gICAgLy8gbmVlZCB0byBwcmVsb2FkIGlmIGFsbCBvZiB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAgICAvLyAxLiBub3QgaW4gTm9kZS5qcy5cbiAgICAvLyAgICAtIE5vZGUuanMgZG9lcyBub3QgaGF2ZSB0aGUgc2FtZSBvcmlnaW4gcG9saWN5IGZvciBjcmVhdGluZyB3b3JrZXJzLlxuICAgIC8vIDIuIG11bHRpLXRocmVhZGVkIGlzIGVuYWJsZWQuXG4gICAgLy8gICAgLSBJZiBtdWx0aS10aHJlYWRlZCBpcyBkaXNhYmxlZCwgbm8gd29ya2VyIHdpbGwgYmUgY3JlYXRlZC4gU28gd2UgZG9uJ3QgbmVlZCB0byBwcmVsb2FkIHRoZSBtb2R1bGUuXG4gICAgLy8gMy4gdGhlIGFic29sdXRlIFVSTCBpcyBhdmFpbGFibGUuXG4gICAgLy8gICAgLSBJZiB0aGUgYWJzb2x1dGUgVVJMIGlzIGZhaWxlZCB0byBiZSBjcmVhdGVkLCB0aGUgb3JpZ2luIGNhbm5vdCBiZSBkZXRlcm1pbmVkLiBJbiB0aGlzIGNhc2UsIHdlIHdpbGwgbm90XG4gICAgLy8gICAgcHJlbG9hZCB0aGUgbW9kdWxlLlxuICAgIC8vIDQuIHRoZSB3b3JrZXIgVVJMIGlzIG5vdCBmcm9tIHRoZSBzYW1lIG9yaWdpbi5cbiAgICAvLyAgICAtIElmIHRoZSB3b3JrZXIgVVJMIGlzIGZyb20gdGhlIHNhbWUgb3JpZ2luLCB3ZSBjYW4gY3JlYXRlIHRoZSB3b3JrZXIgZGlyZWN0bHkuXG4gICAgY29uc3QgbmVlZFByZWxvYWQgPSAhaXNOb2RlICYmIGlzTXVsdGlUaHJlYWRlZCAmJiB3YXNtTW9kdWxlVXJsICYmICFpc1NhbWVPcmlnaW4od2FzbU1vZHVsZVVybCwgcHJlZml4T3ZlcnJpZGUpO1xuICAgIGNvbnN0IHVybCA9IG5lZWRQcmVsb2FkXG4gICAgICA/IGF3YWl0IHByZWxvYWQod2FzbU1vZHVsZVVybClcbiAgICAgIDogKHdhc21Nb2R1bGVVcmwgPz8gZmFsbGJhY2tVcmwod2FzbU1vZHVsZUZpbGVuYW1lLCBwcmVmaXhPdmVycmlkZSkpO1xuICAgIHJldHVybiBbbmVlZFByZWxvYWQgPyB1cmwgOiB1bmRlZmluZWQsIGF3YWl0IGR5bmFtaWNJbXBvcnREZWZhdWx0PEVtc2NyaXB0ZW5Nb2R1bGVGYWN0b3J5PE9ydFdhc21Nb2R1bGU+Pih1cmwpXTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRW52IH0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuaW1wb3J0IHR5cGUgeyBPcnRXYXNtTW9kdWxlIH0gZnJvbSAnLi93YXNtLXR5cGVzJztcbmltcG9ydCB7IGltcG9ydFdhc21Nb2R1bGUgfSBmcm9tICcuL3dhc20tdXRpbHMtaW1wb3J0JztcblxubGV0IHdhc206IE9ydFdhc21Nb2R1bGUgfCB1bmRlZmluZWQ7XG5sZXQgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbmxldCBpbml0aWFsaXppbmcgPSBmYWxzZTtcbmxldCBhYm9ydGVkID0gZmFsc2U7XG5cbmNvbnN0IGlzTXVsdGlUaHJlYWRTdXBwb3J0ZWQgPSAoKTogYm9vbGVhbiA9PiB7XG4gIC8vIElmICdTaGFyZWRBcnJheUJ1ZmZlcicgaXMgbm90IGF2YWlsYWJsZSwgV2ViQXNzZW1ibHkgdGhyZWFkcyB3aWxsIG5vdCB3b3JrLlxuICBpZiAodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gVGVzdCBmb3IgdHJhbnNmZXJhYmlsaXR5IG9mIFNBQnMgKGZvciBicm93c2Vycy4gbmVlZGVkIGZvciBGaXJlZm94KVxuICAgIC8vIGh0dHBzOi8vZ3JvdXBzLmdvb2dsZS5jb20vZm9ydW0vIyFtc2cvbW96aWxsYS5kZXYucGxhdGZvcm0vSUhrQlpsSEVUcEEvZHdzTU5jaFdFUUFKXG4gICAgaWYgKHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG5ldyBNZXNzYWdlQ2hhbm5lbCgpLnBvcnQxLnBvc3RNZXNzYWdlKG5ldyBTaGFyZWRBcnJheUJ1ZmZlcigxKSk7XG4gICAgfVxuXG4gICAgLy8gVGVzdCBmb3IgV2ViQXNzZW1ibHkgdGhyZWFkcyBjYXBhYmlsaXR5IChmb3IgYm90aCBicm93c2VycyBhbmQgTm9kZS5qcylcbiAgICAvLyBUaGlzIHR5cGVkIGFycmF5IGlzIGEgV2ViQXNzZW1ibHkgcHJvZ3JhbSBjb250YWluaW5nIHRocmVhZGVkIGluc3RydWN0aW9ucy5cbiAgICByZXR1cm4gV2ViQXNzZW1ibHkudmFsaWRhdGUoXG4gICAgICBuZXcgVWludDhBcnJheShbXG4gICAgICAgIDAsIDk3LCAxMTUsIDEwOSwgMSwgMCwgMCwgMCwgMSwgNCwgMSwgOTYsIDAsIDAsIDMsIDIsIDEsIDAsIDUsIDQsIDEsIDMsIDEsIDEsIDEwLCAxMSwgMSwgOSwgMCwgNjUsIDAsIDI1NCwgMTYsXG4gICAgICAgIDIsIDAsIDI2LCAxMSxcbiAgICAgIF0pLFxuICAgICk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbmNvbnN0IGlzU2ltZFN1cHBvcnRlZCA9ICgpOiBib29sZWFuID0+IHtcbiAgdHJ5IHtcbiAgICAvLyBUZXN0IGZvciBXZWJBc3NlbWJseSBTSU1EIGNhcGFiaWxpdHkgKGZvciBib3RoIGJyb3dzZXJzIGFuZCBOb2RlLmpzKVxuICAgIC8vIFRoaXMgdHlwZWQgYXJyYXkgaXMgYSBXZWJBc3NlbWJseSBwcm9ncmFtIGNvbnRhaW5pbmcgU0lNRCBpbnN0cnVjdGlvbnMuXG5cbiAgICAvLyBUaGUgYmluYXJ5IGRhdGEgaXMgZ2VuZXJhdGVkIGZyb20gdGhlIGZvbGxvd2luZyBjb2RlIGJ5IHdhdDJ3YXNtOlxuICAgIC8vXG4gICAgLy8gKG1vZHVsZVxuICAgIC8vICAgKHR5cGUgJHQwIChmdW5jKSlcbiAgICAvLyAgIChmdW5jICRmMCAodHlwZSAkdDApXG4gICAgLy8gICAgIChkcm9wXG4gICAgLy8gICAgICAgKGkzMng0LmRvdF9pMTZ4OF9zXG4gICAgLy8gICAgICAgICAoaTh4MTYuc3BsYXRcbiAgICAvLyAgICAgICAgICAgKGkzMi5jb25zdCAwKSlcbiAgICAvLyAgICAgICAgICh2MTI4LmNvbnN0IGkzMng0IDB4MDAwMDAwMDAgMHgwMDAwMDAwMCAweDAwMDAwMDAwIDB4MDAwMDAwMDApKSkpKVxuXG4gICAgcmV0dXJuIFdlYkFzc2VtYmx5LnZhbGlkYXRlKFxuICAgICAgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAwLCA5NywgMTE1LCAxMDksIDEsIDAsIDAsIDAsIDEsIDQsIDEsIDk2LCAwLCAwLCAzLCAyLCAxLCAwLCAxMCwgMzAsIDEsIDI4LCAwLCA2NSwgMCwgMjUzLCAxNSwgMjUzLCAxMiwgMCwgMCwgMCxcbiAgICAgICAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMjUzLCAxODYsIDEsIDI2LCAxMSxcbiAgICAgIF0pLFxuICAgICk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBpbml0aWFsaXplV2ViQXNzZW1ibHkgPSBhc3luYyAoZmxhZ3M6IEVudi5XZWJBc3NlbWJseUZsYWdzKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIGlmIChpbml0aWFsaXplZCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuICBpZiAoaW5pdGlhbGl6aW5nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibXVsdGlwbGUgY2FsbHMgdG8gJ2luaXRpYWxpemVXZWJBc3NlbWJseSgpJyBkZXRlY3RlZC5cIik7XG4gIH1cbiAgaWYgKGFib3J0ZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJwcmV2aW91cyBjYWxsIHRvICdpbml0aWFsaXplV2ViQXNzZW1ibHkoKScgZmFpbGVkLlwiKTtcbiAgfVxuXG4gIGluaXRpYWxpemluZyA9IHRydWU7XG5cbiAgLy8gd2FzbSBmbGFncyBhcmUgYWxyZWFkeSBpbml0aWFsaXplZFxuICBjb25zdCB0aW1lb3V0ID0gZmxhZ3MuaW5pdFRpbWVvdXQhO1xuICBsZXQgbnVtVGhyZWFkcyA9IGZsYWdzLm51bVRocmVhZHMhO1xuXG4gIC8vIGVuc3VyZSBTSU1EIGlzIHN1cHBvcnRlZFxuICBpZiAoIWlzU2ltZFN1cHBvcnRlZCgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdXZWJBc3NlbWJseSBTSU1EIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuJyk7XG4gIH1cblxuICAvLyBjaGVjayBpZiBtdWx0aS10aHJlYWRpbmcgaXMgc3VwcG9ydGVkXG4gIGNvbnN0IG11bHRpVGhyZWFkU3VwcG9ydGVkID0gaXNNdWx0aVRocmVhZFN1cHBvcnRlZCgpO1xuICBpZiAobnVtVGhyZWFkcyA+IDEgJiYgIW11bHRpVGhyZWFkU3VwcG9ydGVkKSB7XG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiAhc2VsZi5jcm9zc09yaWdpbklzb2xhdGVkKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAnZW52Lndhc20ubnVtVGhyZWFkcyBpcyBzZXQgdG8gJyArXG4gICAgICAgICAgbnVtVGhyZWFkcyArXG4gICAgICAgICAgJywgYnV0IHRoaXMgd2lsbCBub3Qgd29yayB1bmxlc3MgeW91IGVuYWJsZSBjcm9zc09yaWdpbklzb2xhdGVkIG1vZGUuICcgK1xuICAgICAgICAgICdTZWUgaHR0cHM6Ly93ZWIuZGV2L2Nyb3NzLW9yaWdpbi1pc29sYXRpb24tZ3VpZGUvIGZvciBtb3JlIGluZm8uJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICAnV2ViQXNzZW1ibHkgbXVsdGktdGhyZWFkaW5nIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuICcgKyAnRmFsbGluZyBiYWNrIHRvIHNpbmdsZS10aHJlYWRpbmcuJyxcbiAgICApO1xuXG4gICAgLy8gc2V0IGZsYWdzLm51bVRocmVhZHMgdG8gMSBzbyB0aGF0IE9ydEluaXQoKSB3aWxsIG5vdCBjcmVhdGUgYSBnbG9iYWwgdGhyZWFkIHBvb2wuXG4gICAgZmxhZ3MubnVtVGhyZWFkcyA9IG51bVRocmVhZHMgPSAxO1xuICB9XG5cbiAgY29uc3Qgd2FzbVBhdGhzID0gZmxhZ3Mud2FzbVBhdGhzO1xuICBjb25zdCB3YXNtUHJlZml4T3ZlcnJpZGUgPSB0eXBlb2Ygd2FzbVBhdGhzID09PSAnc3RyaW5nJyA/IHdhc21QYXRocyA6IHVuZGVmaW5lZDtcbiAgY29uc3QgbWpzUGF0aE92ZXJyaWRlRmxhZyA9ICh3YXNtUGF0aHMgYXMgRW52Lldhc21GaWxlUGF0aHMpPy5tanM7XG4gIGNvbnN0IG1qc1BhdGhPdmVycmlkZSA9IChtanNQYXRoT3ZlcnJpZGVGbGFnIGFzIFVSTCk/LmhyZWYgPz8gbWpzUGF0aE92ZXJyaWRlRmxhZztcbiAgY29uc3Qgd2FzbVBhdGhPdmVycmlkZUZsYWcgPSAod2FzbVBhdGhzIGFzIEVudi5XYXNtRmlsZVBhdGhzKT8ud2FzbTtcbiAgY29uc3Qgd2FzbVBhdGhPdmVycmlkZSA9ICh3YXNtUGF0aE92ZXJyaWRlRmxhZyBhcyBVUkwpPy5ocmVmID8/IHdhc21QYXRoT3ZlcnJpZGVGbGFnO1xuICBjb25zdCB3YXNtQmluYXJ5T3ZlcnJpZGUgPSBmbGFncy53YXNtQmluYXJ5O1xuXG4gIGNvbnN0IFtvYmplY3RVcmwsIG9ydFdhc21GYWN0b3J5XSA9IGF3YWl0IGltcG9ydFdhc21Nb2R1bGUobWpzUGF0aE92ZXJyaWRlLCB3YXNtUHJlZml4T3ZlcnJpZGUsIG51bVRocmVhZHMgPiAxKTtcblxuICBsZXQgaXNUaW1lb3V0ID0gZmFsc2U7XG5cbiAgY29uc3QgdGFza3M6IEFycmF5PFByb21pc2U8dm9pZD4+ID0gW107XG5cbiAgLy8gcHJvbWlzZSBmb3IgdGltZW91dFxuICBpZiAodGltZW91dCA+IDApIHtcbiAgICB0YXNrcy5wdXNoKFxuICAgICAgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaXNUaW1lb3V0ID0gdHJ1ZTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgfSksXG4gICAgKTtcbiAgfVxuXG4gIC8vIHByb21pc2UgZm9yIG1vZHVsZSBpbml0aWFsaXphdGlvblxuICB0YXNrcy5wdXNoKFxuICAgIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGNvbmZpZzogUGFydGlhbDxPcnRXYXNtTW9kdWxlPiA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBudW1iZXIgb2YgdGhyZWFkcy4gV2ViQXNzZW1ibHkgd2lsbCBjcmVhdGUgKE1vZHVsZS5udW1UaHJlYWRzIC0gMSkgd29ya2Vycy4gSWYgaXQgaXMgMSwgbm8gd29ya2VyIHdpbGwgYmVcbiAgICAgICAgICogY3JlYXRlZC5cbiAgICAgICAgICovXG4gICAgICAgIG51bVRocmVhZHMsXG4gICAgICB9O1xuXG4gICAgICBpZiAod2FzbUJpbmFyeU92ZXJyaWRlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgYSBjdXN0b20gYnVmZmVyIHdoaWNoIGNvbnRhaW5zIHRoZSBXZWJBc3NlbWJseSBiaW5hcnkuIFRoaXMgd2lsbCBza2lwIHRoZSB3YXNtIGZpbGUgZmV0Y2hpbmcuXG4gICAgICAgICAqL1xuICAgICAgICBjb25maWcud2FzbUJpbmFyeSA9IHdhc21CaW5hcnlPdmVycmlkZTtcbiAgICAgIH0gZWxzZSBpZiAod2FzbVBhdGhPdmVycmlkZSB8fCB3YXNtUHJlZml4T3ZlcnJpZGUpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gbG9jYXRlIHRoZSBXZWJBc3NlbWJseSBmaWxlLiBUaGUgZnVuY3Rpb24gc2hvdWxkIHJldHVybiB0aGUgZnVsbCBwYXRoIG9mIHRoZSBmaWxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTaW5jZSBFbXNjcmlwdGVuIDMuMS41OCwgdGhpcyBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZCBmb3IgdGhlIC53YXNtIGZpbGUuXG4gICAgICAgICAqL1xuICAgICAgICBjb25maWcubG9jYXRlRmlsZSA9IChmaWxlTmFtZSwgc2NyaXB0RGlyZWN0b3J5KSA9PlxuICAgICAgICAgIHdhc21QYXRoT3ZlcnJpZGUgPz8gKHdhc21QcmVmaXhPdmVycmlkZSA/PyBzY3JpcHREaXJlY3RvcnkpICsgZmlsZU5hbWU7XG4gICAgICB9XG5cbiAgICAgIG9ydFdhc21GYWN0b3J5KGNvbmZpZykudGhlbihcbiAgICAgICAgLy8gd2FzbSBtb2R1bGUgaW5pdGlhbGl6ZWQgc3VjY2Vzc2Z1bGx5XG4gICAgICAgIChtb2R1bGUpID0+IHtcbiAgICAgICAgICBpbml0aWFsaXppbmcgPSBmYWxzZTtcbiAgICAgICAgICBpbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgd2FzbSA9IG1vZHVsZTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgaWYgKG9iamVjdFVybCkge1xuICAgICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChvYmplY3RVcmwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gd2FzbSBtb2R1bGUgZmFpbGVkIHRvIGluaXRpYWxpemVcbiAgICAgICAgKHdoYXQpID0+IHtcbiAgICAgICAgICBpbml0aWFsaXppbmcgPSBmYWxzZTtcbiAgICAgICAgICBhYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICByZWplY3Qod2hhdCk7XG4gICAgICAgIH0sXG4gICAgICApO1xuICAgIH0pLFxuICApO1xuXG4gIGF3YWl0IFByb21pc2UucmFjZSh0YXNrcyk7XG5cbiAgaWYgKGlzVGltZW91dCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgV2ViQXNzZW1ibHkgYmFja2VuZCBpbml0aWFsaXppbmcgZmFpbGVkIGR1ZSB0byB0aW1lb3V0OiAke3RpbWVvdXR9bXNgKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGdldEluc3RhbmNlID0gKCk6IE9ydFdhc21Nb2R1bGUgPT4ge1xuICBpZiAoaW5pdGlhbGl6ZWQgJiYgd2FzbSkge1xuICAgIHJldHVybiB3YXNtO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdXZWJBc3NlbWJseSBpcyBub3QgaW5pdGlhbGl6ZWQgeWV0LicpO1xufTtcblxuZXhwb3J0IGNvbnN0IGRpc3Bvc2UgPSAoKTogdm9pZCA9PiB7XG4gIGlmIChpbml0aWFsaXplZCAmJiAhaW5pdGlhbGl6aW5nICYmICFhYm9ydGVkKSB7XG4gICAgLy8gVE9ETzogY3VycmVudGx5IFwiUFRocmVhZC50ZXJtaW5hdGVBbGxUaHJlYWRzKClcIiBpcyBub3QgZXhwb3NlZCBpbiB0aGUgd2FzbSBtb2R1bGUuXG4gICAgLy8gICAgICAgQW5kIHRoaXMgZnVuY3Rpb24gaXMgbm90IHlldCBjYWxsZWQgYnkgYW55IGNvZGUuXG4gICAgLy8gICAgICAgSWYgaXQgaXMgbmVlZGVkIGluIHRoZSBmdXR1cmUsIHdlIHNob3VsZCBleHBvc2UgaXQgaW4gdGhlIHdhc20gbW9kdWxlIGFuZCB1bmNvbW1lbnQgdGhlIGZvbGxvd2luZyBsaW5lLlxuXG4gICAgLy8gd2FzbT8uUFRocmVhZD8udGVybWluYXRlQWxsVGhyZWFkcygpO1xuICAgIHdhc20gPSB1bmRlZmluZWQ7XG5cbiAgICBpbml0aWFsaXppbmcgPSBmYWxzZTtcbiAgICBpbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIGFib3J0ZWQgPSB0cnVlO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBnZXRJbnN0YW5jZSB9IGZyb20gJy4vd2FzbS1mYWN0b3J5JztcblxuZXhwb3J0IGNvbnN0IGFsbG9jV2FzbVN0cmluZyA9IChkYXRhOiBzdHJpbmcsIGFsbG9jczogbnVtYmVyW10pOiBudW1iZXIgPT4ge1xuICBjb25zdCB3YXNtID0gZ2V0SW5zdGFuY2UoKTtcblxuICBjb25zdCBkYXRhTGVuZ3RoID0gd2FzbS5sZW5ndGhCeXRlc1VURjgoZGF0YSkgKyAxO1xuICBjb25zdCBkYXRhT2Zmc2V0ID0gd2FzbS5fbWFsbG9jKGRhdGFMZW5ndGgpO1xuICB3YXNtLnN0cmluZ1RvVVRGOChkYXRhLCBkYXRhT2Zmc2V0LCBkYXRhTGVuZ3RoKTtcbiAgYWxsb2NzLnB1c2goZGF0YU9mZnNldCk7XG5cbiAgcmV0dXJuIGRhdGFPZmZzZXQ7XG59O1xuXG5pbnRlcmZhY2UgRXh0cmFPcHRpb25zSGFuZGxlciB7XG4gIChuYW1lOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpOiB2b2lkO1xufVxuXG5leHBvcnQgY29uc3QgaXRlcmF0ZUV4dHJhT3B0aW9ucyA9IChcbiAgb3B0aW9uczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4gIHByZWZpeDogc3RyaW5nLFxuICBzZWVuOiBXZWFrU2V0PFJlY29yZDxzdHJpbmcsIHVua25vd24+PixcbiAgaGFuZGxlcjogRXh0cmFPcHRpb25zSGFuZGxlcixcbik6IHZvaWQgPT4ge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT0gJ29iamVjdCcgJiYgb3B0aW9ucyAhPT0gbnVsbCkge1xuICAgIGlmIChzZWVuLmhhcyhvcHRpb25zKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaXJjdWxhciByZWZlcmVuY2UgaW4gb3B0aW9ucycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWVuLmFkZChvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICBPYmplY3QuZW50cmllcyhvcHRpb25zKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICBjb25zdCBuYW1lID0gcHJlZml4ID8gcHJlZml4ICsga2V5IDoga2V5O1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpdGVyYXRlRXh0cmFPcHRpb25zKHZhbHVlIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+LCBuYW1lICsgJy4nLCBzZWVuLCBoYW5kbGVyKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgaGFuZGxlcihuYW1lLCB2YWx1ZS50b1N0cmluZygpKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICBoYW5kbGVyKG5hbWUsIHZhbHVlID8gJzEnIDogJzAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBoYW5kbGUgZXh0cmEgY29uZmlnIHR5cGU6ICR7dHlwZW9mIHZhbHVlfWApO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIGNoZWNrIHdlYiBhc3NlbWJseSBBUEkncyBsYXN0IGVycm9yIGFuZCB0aHJvdyBlcnJvciBpZiBhbnkgZXJyb3Igb2NjdXJyZWQuXG4gKiBAcGFyYW0gbWVzc2FnZSBhIG1lc3NhZ2UgdXNlZCB3aGVuIGFuIGVycm9yIG9jY3VycmVkLlxuICovXG5leHBvcnQgY29uc3QgY2hlY2tMYXN0RXJyb3IgPSAobWVzc2FnZTogc3RyaW5nKTogdm9pZCA9PiB7XG4gIGNvbnN0IHdhc20gPSBnZXRJbnN0YW5jZSgpO1xuXG4gIGNvbnN0IHN0YWNrID0gd2FzbS5zdGFja1NhdmUoKTtcbiAgdHJ5IHtcbiAgICBjb25zdCBwYXJhbXNPZmZzZXQgPSB3YXNtLnN0YWNrQWxsb2MoOCk7XG4gICAgd2FzbS5fT3J0R2V0TGFzdEVycm9yKHBhcmFtc09mZnNldCwgcGFyYW1zT2Zmc2V0ICsgNCk7XG4gICAgY29uc3QgZXJyb3JDb2RlID0gd2FzbS5IRUFQMzJbcGFyYW1zT2Zmc2V0IC8gNF07XG4gICAgY29uc3QgZXJyb3JNZXNzYWdlUG9pbnRlciA9IHdhc20uSEVBUFUzMltwYXJhbXNPZmZzZXQgLyA0ICsgMV07XG4gICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3JNZXNzYWdlUG9pbnRlciA/IHdhc20uVVRGOFRvU3RyaW5nKGVycm9yTWVzc2FnZVBvaW50ZXIpIDogJyc7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAke21lc3NhZ2V9IEVSUk9SX0NPREU6ICR7ZXJyb3JDb2RlfSwgRVJST1JfTUVTU0FHRTogJHtlcnJvck1lc3NhZ2V9YCk7XG4gIH0gZmluYWxseSB7XG4gICAgd2FzbS5zdGFja1Jlc3RvcmUoc3RhY2spO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBJbmZlcmVuY2VTZXNzaW9uIH0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuaW1wb3J0IHsgZ2V0SW5zdGFuY2UgfSBmcm9tICcuL3dhc20tZmFjdG9yeSc7XG5pbXBvcnQgeyBhbGxvY1dhc21TdHJpbmcsIGNoZWNrTGFzdEVycm9yLCBpdGVyYXRlRXh0cmFPcHRpb25zIH0gZnJvbSAnLi93YXNtLXV0aWxzJztcblxuZXhwb3J0IGNvbnN0IHNldFJ1bk9wdGlvbnMgPSAob3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zKTogW251bWJlciwgbnVtYmVyW11dID0+IHtcbiAgY29uc3Qgd2FzbSA9IGdldEluc3RhbmNlKCk7XG4gIGxldCBydW5PcHRpb25zSGFuZGxlID0gMDtcbiAgY29uc3QgYWxsb2NzOiBudW1iZXJbXSA9IFtdO1xuXG4gIGNvbnN0IHJ1bk9wdGlvbnM6IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdHJ5IHtcbiAgICBpZiAob3B0aW9ucz8ubG9nU2V2ZXJpdHlMZXZlbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBydW5PcHRpb25zLmxvZ1NldmVyaXR5TGV2ZWwgPSAyOyAvLyBEZWZhdWx0IHRvIHdhcm5pbmdcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgdHlwZW9mIG9wdGlvbnMubG9nU2V2ZXJpdHlMZXZlbCAhPT0gJ251bWJlcicgfHxcbiAgICAgICFOdW1iZXIuaXNJbnRlZ2VyKG9wdGlvbnMubG9nU2V2ZXJpdHlMZXZlbCkgfHxcbiAgICAgIG9wdGlvbnMubG9nU2V2ZXJpdHlMZXZlbCA8IDAgfHxcbiAgICAgIG9wdGlvbnMubG9nU2V2ZXJpdHlMZXZlbCA+IDRcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgbG9nIHNlcnZlcml0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7b3B0aW9ucy5sb2dTZXZlcml0eUxldmVsfWApO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zPy5sb2dWZXJib3NpdHlMZXZlbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBydW5PcHRpb25zLmxvZ1ZlcmJvc2l0eUxldmVsID0gMDsgLy8gRGVmYXVsdCB0byAwXG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5sb2dWZXJib3NpdHlMZXZlbCAhPT0gJ251bWJlcicgfHwgIU51bWJlci5pc0ludGVnZXIob3B0aW9ucy5sb2dWZXJib3NpdHlMZXZlbCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgbG9nIHZlcmJvc2l0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7b3B0aW9ucy5sb2dWZXJib3NpdHlMZXZlbH1gKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucz8udGVybWluYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJ1bk9wdGlvbnMudGVybWluYXRlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IHRhZ0RhdGFPZmZzZXQgPSAwO1xuICAgIGlmIChvcHRpb25zPy50YWcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFnRGF0YU9mZnNldCA9IGFsbG9jV2FzbVN0cmluZyhvcHRpb25zLnRhZywgYWxsb2NzKTtcbiAgICB9XG5cbiAgICBydW5PcHRpb25zSGFuZGxlID0gd2FzbS5fT3J0Q3JlYXRlUnVuT3B0aW9ucyhcbiAgICAgIHJ1bk9wdGlvbnMubG9nU2V2ZXJpdHlMZXZlbCEsXG4gICAgICBydW5PcHRpb25zLmxvZ1ZlcmJvc2l0eUxldmVsISxcbiAgICAgICEhcnVuT3B0aW9ucy50ZXJtaW5hdGUhLFxuICAgICAgdGFnRGF0YU9mZnNldCxcbiAgICApO1xuICAgIGlmIChydW5PcHRpb25zSGFuZGxlID09PSAwKSB7XG4gICAgICBjaGVja0xhc3RFcnJvcihcIkNhbid0IGNyZWF0ZSBydW4gb3B0aW9ucy5cIik7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnM/LmV4dHJhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGl0ZXJhdGVFeHRyYU9wdGlvbnMob3B0aW9ucy5leHRyYSwgJycsIG5ldyBXZWFrU2V0PFJlY29yZDxzdHJpbmcsIHVua25vd24+PigpLCAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCBrZXlEYXRhT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKGtleSwgYWxsb2NzKTtcbiAgICAgICAgY29uc3QgdmFsdWVEYXRhT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKHZhbHVlLCBhbGxvY3MpO1xuXG4gICAgICAgIGlmICh3YXNtLl9PcnRBZGRSdW5Db25maWdFbnRyeShydW5PcHRpb25zSGFuZGxlLCBrZXlEYXRhT2Zmc2V0LCB2YWx1ZURhdGFPZmZzZXQpICE9PSAwKSB7XG4gICAgICAgICAgY2hlY2tMYXN0RXJyb3IoYENhbid0IHNldCBhIHJ1biBjb25maWcgZW50cnk6ICR7a2V5fSAtICR7dmFsdWV9LmApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gW3J1bk9wdGlvbnNIYW5kbGUsIGFsbG9jc107XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAocnVuT3B0aW9uc0hhbmRsZSAhPT0gMCkge1xuICAgICAgd2FzbS5fT3J0UmVsZWFzZVJ1bk9wdGlvbnMocnVuT3B0aW9uc0hhbmRsZSk7XG4gICAgfVxuICAgIGFsbG9jcy5mb3JFYWNoKChhbGxvYykgPT4gd2FzbS5fZnJlZShhbGxvYykpO1xuICAgIHRocm93IGU7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEluZmVyZW5jZVNlc3Npb24gfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG5pbXBvcnQgeyBnZXRJbnN0YW5jZSB9IGZyb20gJy4vd2FzbS1mYWN0b3J5JztcbmltcG9ydCB7IGFsbG9jV2FzbVN0cmluZywgY2hlY2tMYXN0RXJyb3IsIGl0ZXJhdGVFeHRyYU9wdGlvbnMgfSBmcm9tICcuL3dhc20tdXRpbHMnO1xuXG5jb25zdCBnZXRHcmFwaE9wdGltemF0aW9uTGV2ZWwgPSAoZ3JhcGhPcHRpbWl6YXRpb25MZXZlbDogc3RyaW5nIHwgdW5rbm93bik6IG51bWJlciA9PiB7XG4gIHN3aXRjaCAoZ3JhcGhPcHRpbWl6YXRpb25MZXZlbCkge1xuICAgIGNhc2UgJ2Rpc2FibGVkJzpcbiAgICAgIHJldHVybiAwO1xuICAgIGNhc2UgJ2Jhc2ljJzpcbiAgICAgIHJldHVybiAxO1xuICAgIGNhc2UgJ2V4dGVuZGVkJzpcbiAgICAgIHJldHVybiAyO1xuICAgIGNhc2UgJ2FsbCc6XG4gICAgICByZXR1cm4gOTk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZ3JhcGggb3B0aW1pemF0aW9uIGxldmVsOiAke2dyYXBoT3B0aW1pemF0aW9uTGV2ZWx9YCk7XG4gIH1cbn07XG5cbmNvbnN0IGdldEV4ZWN1dGlvbk1vZGUgPSAoZXhlY3V0aW9uTW9kZTogJ3NlcXVlbnRpYWwnIHwgJ3BhcmFsbGVsJyk6IG51bWJlciA9PiB7XG4gIHN3aXRjaCAoZXhlY3V0aW9uTW9kZSkge1xuICAgIGNhc2UgJ3NlcXVlbnRpYWwnOlxuICAgICAgcmV0dXJuIDA7XG4gICAgY2FzZSAncGFyYWxsZWwnOlxuICAgICAgcmV0dXJuIDE7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZXhlY3V0aW9uIG1vZGU6ICR7ZXhlY3V0aW9uTW9kZX1gKTtcbiAgfVxufTtcblxuY29uc3QgYXBwZW5kRGVmYXVsdE9wdGlvbnMgPSAob3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyk6IHZvaWQgPT4ge1xuICBpZiAoIW9wdGlvbnMuZXh0cmEpIHtcbiAgICBvcHRpb25zLmV4dHJhID0ge307XG4gIH1cbiAgaWYgKCFvcHRpb25zLmV4dHJhLnNlc3Npb24pIHtcbiAgICBvcHRpb25zLmV4dHJhLnNlc3Npb24gPSB7fTtcbiAgfVxuICBjb25zdCBzZXNzaW9uID0gb3B0aW9ucy5leHRyYS5zZXNzaW9uIGFzIFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gIGlmICghc2Vzc2lvbi51c2Vfb3J0X21vZGVsX2J5dGVzX2RpcmVjdGx5KSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNhbWVsY2FzZVxuICAgIHNlc3Npb24udXNlX29ydF9tb2RlbF9ieXRlc19kaXJlY3RseSA9ICcxJztcbiAgfVxuXG4gIC8vIGlmIHVzaW5nIEpTRVAgd2l0aCBXZWJHUFUsIGFsd2F5cyBkaXNhYmxlIG1lbW9yeSBwYXR0ZXJuXG4gIGlmIChcbiAgICBvcHRpb25zLmV4ZWN1dGlvblByb3ZpZGVycyAmJlxuICAgIG9wdGlvbnMuZXhlY3V0aW9uUHJvdmlkZXJzLnNvbWUoKGVwKSA9PiAodHlwZW9mIGVwID09PSAnc3RyaW5nJyA/IGVwIDogZXAubmFtZSkgPT09ICd3ZWJncHUnKVxuICApIHtcbiAgICBvcHRpb25zLmVuYWJsZU1lbVBhdHRlcm4gPSBmYWxzZTtcbiAgfVxufTtcblxuY29uc3Qgc2V0RXhlY3V0aW9uUHJvdmlkZXJzID0gKFxuICBzZXNzaW9uT3B0aW9uc0hhbmRsZTogbnVtYmVyLFxuICBleGVjdXRpb25Qcm92aWRlcnM6IHJlYWRvbmx5IEluZmVyZW5jZVNlc3Npb24uRXhlY3V0aW9uUHJvdmlkZXJDb25maWdbXSxcbiAgYWxsb2NzOiBudW1iZXJbXSxcbik6IHZvaWQgPT4ge1xuICBmb3IgKGNvbnN0IGVwIG9mIGV4ZWN1dGlvblByb3ZpZGVycykge1xuICAgIGxldCBlcE5hbWUgPSB0eXBlb2YgZXAgPT09ICdzdHJpbmcnID8gZXAgOiBlcC5uYW1lO1xuXG4gICAgLy8gY2hlY2sgRVAgbmFtZVxuICAgIHN3aXRjaCAoZXBOYW1lKSB7XG4gICAgICBjYXNlICd3ZWJubic6XG4gICAgICAgIGVwTmFtZSA9ICdXRUJOTic7XG4gICAgICAgIGlmICh0eXBlb2YgZXAgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgY29uc3Qgd2Vibm5PcHRpb25zID0gZXAgYXMgSW5mZXJlbmNlU2Vzc2lvbi5XZWJOTkV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgICAgICAgIC8vIGNvbnN0IGNvbnRleHQgPSAod2Vibm5PcHRpb25zIGFzIEluZmVyZW5jZVNlc3Npb24uV2ViTk5PcHRpb25zV2l0aE1MQ29udGV4dCk/LmNvbnRleHQ7XG4gICAgICAgICAgY29uc3QgZGV2aWNlVHlwZSA9ICh3ZWJubk9wdGlvbnMgYXMgSW5mZXJlbmNlU2Vzc2lvbi5XZWJOTkNvbnRleHRPcHRpb25zKT8uZGV2aWNlVHlwZTtcbiAgICAgICAgICBpZiAoZGV2aWNlVHlwZSkge1xuICAgICAgICAgICAgY29uc3Qga2V5RGF0YU9mZnNldCA9IGFsbG9jV2FzbVN0cmluZygnZGV2aWNlVHlwZScsIGFsbG9jcyk7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZURhdGFPZmZzZXQgPSBhbGxvY1dhc21TdHJpbmcoZGV2aWNlVHlwZSwgYWxsb2NzKTtcbiAgICAgICAgICAgIGlmIChnZXRJbnN0YW5jZSgpLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkoc2Vzc2lvbk9wdGlvbnNIYW5kbGUsIGtleURhdGFPZmZzZXQsIHZhbHVlRGF0YU9mZnNldCkgIT09IDApIHtcbiAgICAgICAgICAgICAgY2hlY2tMYXN0RXJyb3IoYENhbid0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiAnZGV2aWNlVHlwZScgLSAke2RldmljZVR5cGV9LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3dlYmdwdSc6XG4gICAgICAgIGVwTmFtZSA9ICdKUyc7XG4gICAgICAgIGlmICh0eXBlb2YgZXAgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgY29uc3Qgd2ViZ3B1T3B0aW9ucyA9IGVwIGFzIEluZmVyZW5jZVNlc3Npb24uV2ViR3B1RXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XG4gICAgICAgICAgaWYgKHdlYmdwdU9wdGlvbnM/LnByZWZlcnJlZExheW91dCkge1xuICAgICAgICAgICAgaWYgKHdlYmdwdU9wdGlvbnMucHJlZmVycmVkTGF5b3V0ICE9PSAnTkNIVycgJiYgd2ViZ3B1T3B0aW9ucy5wcmVmZXJyZWRMYXlvdXQgIT09ICdOSFdDJykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHByZWZlcnJlZExheW91dCBtdXN0IGJlIGVpdGhlciAnTkNIVycgb3IgJ05IV0MnOiAke3dlYmdwdU9wdGlvbnMucHJlZmVycmVkTGF5b3V0fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qga2V5RGF0YU9mZnNldCA9IGFsbG9jV2FzbVN0cmluZygncHJlZmVycmVkTGF5b3V0JywgYWxsb2NzKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlRGF0YU9mZnNldCA9IGFsbG9jV2FzbVN0cmluZyh3ZWJncHVPcHRpb25zLnByZWZlcnJlZExheW91dCwgYWxsb2NzKTtcbiAgICAgICAgICAgIGlmIChnZXRJbnN0YW5jZSgpLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkoc2Vzc2lvbk9wdGlvbnNIYW5kbGUsIGtleURhdGFPZmZzZXQsIHZhbHVlRGF0YU9mZnNldCkgIT09IDApIHtcbiAgICAgICAgICAgICAgY2hlY2tMYXN0RXJyb3IoYENhbid0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiAncHJlZmVycmVkTGF5b3V0JyAtICR7d2ViZ3B1T3B0aW9ucy5wcmVmZXJyZWRMYXlvdXR9LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3dhc20nOlxuICAgICAgY2FzZSAnY3B1JzpcbiAgICAgICAgY29udGludWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG5vdCBzdXBwb3J0ZWQgZXhlY3V0aW9uIHByb3ZpZGVyOiAke2VwTmFtZX1gKTtcbiAgICB9XG5cbiAgICBjb25zdCBlcE5hbWVEYXRhT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKGVwTmFtZSwgYWxsb2NzKTtcbiAgICBpZiAoZ2V0SW5zdGFuY2UoKS5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXIoc2Vzc2lvbk9wdGlvbnNIYW5kbGUsIGVwTmFtZURhdGFPZmZzZXQpICE9PSAwKSB7XG4gICAgICBjaGVja0xhc3RFcnJvcihgQ2FuJ3QgYXBwZW5kIGV4ZWN1dGlvbiBwcm92aWRlcjogJHtlcE5hbWV9LmApO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHNldFNlc3Npb25PcHRpb25zID0gKG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zKTogW251bWJlciwgbnVtYmVyW11dID0+IHtcbiAgY29uc3Qgd2FzbSA9IGdldEluc3RhbmNlKCk7XG4gIGxldCBzZXNzaW9uT3B0aW9uc0hhbmRsZSA9IDA7XG4gIGNvbnN0IGFsbG9jczogbnVtYmVyW10gPSBbXTtcblxuICBjb25zdCBzZXNzaW9uT3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGFwcGVuZERlZmF1bHRPcHRpb25zKHNlc3Npb25PcHRpb25zKTtcblxuICB0cnkge1xuICAgIGNvbnN0IGdyYXBoT3B0aW1pemF0aW9uTGV2ZWwgPSBnZXRHcmFwaE9wdGltemF0aW9uTGV2ZWwoc2Vzc2lvbk9wdGlvbnMuZ3JhcGhPcHRpbWl6YXRpb25MZXZlbCA/PyAnYWxsJyk7XG4gICAgY29uc3QgZXhlY3V0aW9uTW9kZSA9IGdldEV4ZWN1dGlvbk1vZGUoc2Vzc2lvbk9wdGlvbnMuZXhlY3V0aW9uTW9kZSA/PyAnc2VxdWVudGlhbCcpO1xuICAgIGNvbnN0IGxvZ0lkRGF0YU9mZnNldCA9XG4gICAgICB0eXBlb2Ygc2Vzc2lvbk9wdGlvbnMubG9nSWQgPT09ICdzdHJpbmcnID8gYWxsb2NXYXNtU3RyaW5nKHNlc3Npb25PcHRpb25zLmxvZ0lkLCBhbGxvY3MpIDogMDtcblxuICAgIGNvbnN0IGxvZ1NldmVyaXR5TGV2ZWwgPSBzZXNzaW9uT3B0aW9ucy5sb2dTZXZlcml0eUxldmVsID8/IDI7IC8vIERlZmF1bHQgdG8gMiAtIHdhcm5pbmdcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobG9nU2V2ZXJpdHlMZXZlbCkgfHwgbG9nU2V2ZXJpdHlMZXZlbCA8IDAgfHwgbG9nU2V2ZXJpdHlMZXZlbCA+IDQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgbG9nIHNlcnZlcml0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7bG9nU2V2ZXJpdHlMZXZlbH1gKTtcbiAgICB9XG5cbiAgICBjb25zdCBsb2dWZXJib3NpdHlMZXZlbCA9IHNlc3Npb25PcHRpb25zLmxvZ1ZlcmJvc2l0eUxldmVsID8/IDA7IC8vIERlZmF1bHQgdG8gMCAtIHZlcmJvc2VcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobG9nVmVyYm9zaXR5TGV2ZWwpIHx8IGxvZ1ZlcmJvc2l0eUxldmVsIDwgMCB8fCBsb2dWZXJib3NpdHlMZXZlbCA+IDQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgbG9nIHZlcmJvc2l0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7bG9nVmVyYm9zaXR5TGV2ZWx9YCk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3B0aW1pemVkTW9kZWxGaWxlUGF0aE9mZnNldCA9XG4gICAgICB0eXBlb2Ygc2Vzc2lvbk9wdGlvbnMub3B0aW1pemVkTW9kZWxGaWxlUGF0aCA9PT0gJ3N0cmluZydcbiAgICAgICAgPyBhbGxvY1dhc21TdHJpbmcoc2Vzc2lvbk9wdGlvbnMub3B0aW1pemVkTW9kZWxGaWxlUGF0aCwgYWxsb2NzKVxuICAgICAgICA6IDA7XG5cbiAgICBzZXNzaW9uT3B0aW9uc0hhbmRsZSA9IHdhc20uX09ydENyZWF0ZVNlc3Npb25PcHRpb25zKFxuICAgICAgZ3JhcGhPcHRpbWl6YXRpb25MZXZlbCxcbiAgICAgICEhc2Vzc2lvbk9wdGlvbnMuZW5hYmxlQ3B1TWVtQXJlbmEsXG4gICAgICAhIXNlc3Npb25PcHRpb25zLmVuYWJsZU1lbVBhdHRlcm4sXG4gICAgICBleGVjdXRpb25Nb2RlLFxuICAgICAgISFzZXNzaW9uT3B0aW9ucy5lbmFibGVQcm9maWxpbmcsXG4gICAgICAwLFxuICAgICAgbG9nSWREYXRhT2Zmc2V0LFxuICAgICAgbG9nU2V2ZXJpdHlMZXZlbCxcbiAgICAgIGxvZ1ZlcmJvc2l0eUxldmVsLFxuICAgICAgb3B0aW1pemVkTW9kZWxGaWxlUGF0aE9mZnNldCxcbiAgICApO1xuICAgIGlmIChzZXNzaW9uT3B0aW9uc0hhbmRsZSA9PT0gMCkge1xuICAgICAgY2hlY2tMYXN0RXJyb3IoXCJDYW4ndCBjcmVhdGUgc2Vzc2lvbiBvcHRpb25zLlwiKTtcbiAgICB9XG5cbiAgICBpZiAoc2Vzc2lvbk9wdGlvbnMuZXhlY3V0aW9uUHJvdmlkZXJzKSB7XG4gICAgICBzZXRFeGVjdXRpb25Qcm92aWRlcnMoc2Vzc2lvbk9wdGlvbnNIYW5kbGUsIHNlc3Npb25PcHRpb25zLmV4ZWN1dGlvblByb3ZpZGVycywgYWxsb2NzKTtcbiAgICB9XG5cbiAgICBpZiAoc2Vzc2lvbk9wdGlvbnMuZW5hYmxlR3JhcGhDYXB0dXJlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlb2Ygc2Vzc2lvbk9wdGlvbnMuZW5hYmxlR3JhcGhDYXB0dXJlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBlbmFibGVHcmFwaENhcHR1cmUgbXVzdCBiZSBhIGJvb2xlYW4gdmFsdWU6ICR7c2Vzc2lvbk9wdGlvbnMuZW5hYmxlR3JhcGhDYXB0dXJlfWApO1xuICAgICAgfVxuICAgICAgY29uc3Qga2V5RGF0YU9mZnNldCA9IGFsbG9jV2FzbVN0cmluZygnZW5hYmxlR3JhcGhDYXB0dXJlJywgYWxsb2NzKTtcbiAgICAgIGNvbnN0IHZhbHVlRGF0YU9mZnNldCA9IGFsbG9jV2FzbVN0cmluZyhzZXNzaW9uT3B0aW9ucy5lbmFibGVHcmFwaENhcHR1cmUudG9TdHJpbmcoKSwgYWxsb2NzKTtcbiAgICAgIGlmICh3YXNtLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkoc2Vzc2lvbk9wdGlvbnNIYW5kbGUsIGtleURhdGFPZmZzZXQsIHZhbHVlRGF0YU9mZnNldCkgIT09IDApIHtcbiAgICAgICAgY2hlY2tMYXN0RXJyb3IoXG4gICAgICAgICAgYENhbid0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiAnZW5hYmxlR3JhcGhDYXB0dXJlJyAtICR7c2Vzc2lvbk9wdGlvbnMuZW5hYmxlR3JhcGhDYXB0dXJlfS5gLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzZXNzaW9uT3B0aW9ucy5mcmVlRGltZW5zaW9uT3ZlcnJpZGVzKSB7XG4gICAgICBmb3IgKGNvbnN0IFtuYW1lLCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoc2Vzc2lvbk9wdGlvbnMuZnJlZURpbWVuc2lvbk92ZXJyaWRlcykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZnJlZSBkaW1lbnNpb24gb3ZlcnJpZGUgbmFtZSBtdXN0IGJlIGEgc3RyaW5nOiAke25hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgIU51bWJlci5pc0ludGVnZXIodmFsdWUpIHx8IHZhbHVlIDwgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZnJlZSBkaW1lbnNpb24gb3ZlcnJpZGUgdmFsdWUgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyOiAke3ZhbHVlfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5hbWVPZmZzZXQgPSBhbGxvY1dhc21TdHJpbmcobmFtZSwgYWxsb2NzKTtcbiAgICAgICAgaWYgKHdhc20uX09ydEFkZEZyZWVEaW1lbnNpb25PdmVycmlkZShzZXNzaW9uT3B0aW9uc0hhbmRsZSwgbmFtZU9mZnNldCwgdmFsdWUpICE9PSAwKSB7XG4gICAgICAgICAgY2hlY2tMYXN0RXJyb3IoYENhbid0IHNldCBhIGZyZWUgZGltZW5zaW9uIG92ZXJyaWRlOiAke25hbWV9IC0gJHt2YWx1ZX0uYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2Vzc2lvbk9wdGlvbnMuZXh0cmEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaXRlcmF0ZUV4dHJhT3B0aW9ucyhzZXNzaW9uT3B0aW9ucy5leHRyYSwgJycsIG5ldyBXZWFrU2V0PFJlY29yZDxzdHJpbmcsIHVua25vd24+PigpLCAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCBrZXlEYXRhT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKGtleSwgYWxsb2NzKTtcbiAgICAgICAgY29uc3QgdmFsdWVEYXRhT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKHZhbHVlLCBhbGxvY3MpO1xuXG4gICAgICAgIGlmICh3YXNtLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkoc2Vzc2lvbk9wdGlvbnNIYW5kbGUsIGtleURhdGFPZmZzZXQsIHZhbHVlRGF0YU9mZnNldCkgIT09IDApIHtcbiAgICAgICAgICBjaGVja0xhc3RFcnJvcihgQ2FuJ3Qgc2V0IGEgc2Vzc2lvbiBjb25maWcgZW50cnk6ICR7a2V5fSAtICR7dmFsdWV9LmApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gW3Nlc3Npb25PcHRpb25zSGFuZGxlLCBhbGxvY3NdO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHNlc3Npb25PcHRpb25zSGFuZGxlICE9PSAwKSB7XG4gICAgICB3YXNtLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnMoc2Vzc2lvbk9wdGlvbnNIYW5kbGUpO1xuICAgIH1cbiAgICBhbGxvY3MuZm9yRWFjaCgoYWxsb2MpID0+IHdhc20uX2ZyZWUoYWxsb2MpKTtcbiAgICB0aHJvdyBlO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBUZW5zb3IgfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG4vLyBhIGR1bW15IHR5cGUgZGVjbGFyYXRpb24gZm9yIEZsb2F0MTZBcnJheSBpbiBjYXNlIGFueSBwb2x5ZmlsbCBpcyBhdmFpbGFibGUuXG5kZWNsYXJlIGdsb2JhbCB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb24sIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgY29uc3QgRmxvYXQxNkFycmF5OiBhbnk7XG59XG5cbi8vIFRoaXMgZmlsZSBpbmNsdWRlcyBjb21tb24gZGVmaW5pdGlvbnMuIFRoZXkgZG8gTk9UIGhhdmUgZGVwZW5kZW5jeSBvbiB0aGUgV2ViQXNzZW1ibHkgaW5zdGFuY2UuXG5cbi8qKlxuICogQ29waWVkIGZyb20gT05OWCBkZWZpbml0aW9uLiBVc2UgdGhpcyB0byBkcm9wIGRlcGVuZGVuY3kgJ29ubnhfcHJvdG8nIHRvIGRlY3JlYXNlIGNvbXBpbGVkIC5qcyBmaWxlIHNpemUuXG4gKi9cbmV4cG9ydCBjb25zdCBlbnVtIERhdGFUeXBlIHtcbiAgdW5kZWZpbmVkID0gMCxcbiAgZmxvYXQgPSAxLFxuICB1aW50OCA9IDIsXG4gIGludDggPSAzLFxuICB1aW50MTYgPSA0LFxuICBpbnQxNiA9IDUsXG4gIGludDMyID0gNixcbiAgaW50NjQgPSA3LFxuICBzdHJpbmcgPSA4LFxuICBib29sID0gOSxcbiAgZmxvYXQxNiA9IDEwLFxuICBkb3VibGUgPSAxMSxcbiAgdWludDMyID0gMTIsXG4gIHVpbnQ2NCA9IDEzLFxuICBjb21wbGV4NjQgPSAxNCxcbiAgY29tcGxleDEyOCA9IDE1LFxuICBiZmxvYXQxNiA9IDE2LFxuXG4gIC8vIDQtYml0IGRhdGEtdHlwZXNcbiAgdWludDQgPSAyMSxcbiAgaW50NCA9IDIyLFxufVxuXG4vKipcbiAqIE1hcCBzdHJpbmcgdGVuc29yIGRhdGEgdG8gZW51bSB2YWx1ZVxuICovXG5leHBvcnQgY29uc3QgdGVuc29yRGF0YVR5cGVTdHJpbmdUb0VudW0gPSAodHlwZTogc3RyaW5nKTogRGF0YVR5cGUgPT4ge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdpbnQ4JzpcbiAgICAgIHJldHVybiBEYXRhVHlwZS5pbnQ4O1xuICAgIGNhc2UgJ3VpbnQ4JzpcbiAgICAgIHJldHVybiBEYXRhVHlwZS51aW50ODtcbiAgICBjYXNlICdib29sJzpcbiAgICAgIHJldHVybiBEYXRhVHlwZS5ib29sO1xuICAgIGNhc2UgJ2ludDE2JzpcbiAgICAgIHJldHVybiBEYXRhVHlwZS5pbnQxNjtcbiAgICBjYXNlICd1aW50MTYnOlxuICAgICAgcmV0dXJuIERhdGFUeXBlLnVpbnQxNjtcbiAgICBjYXNlICdpbnQzMic6XG4gICAgICByZXR1cm4gRGF0YVR5cGUuaW50MzI7XG4gICAgY2FzZSAndWludDMyJzpcbiAgICAgIHJldHVybiBEYXRhVHlwZS51aW50MzI7XG4gICAgY2FzZSAnZmxvYXQxNic6XG4gICAgICByZXR1cm4gRGF0YVR5cGUuZmxvYXQxNjtcbiAgICBjYXNlICdmbG9hdDMyJzpcbiAgICAgIHJldHVybiBEYXRhVHlwZS5mbG9hdDtcbiAgICBjYXNlICdmbG9hdDY0JzpcbiAgICAgIHJldHVybiBEYXRhVHlwZS5kb3VibGU7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiBEYXRhVHlwZS5zdHJpbmc7XG4gICAgY2FzZSAnaW50NjQnOlxuICAgICAgcmV0dXJuIERhdGFUeXBlLmludDY0O1xuICAgIGNhc2UgJ3VpbnQ2NCc6XG4gICAgICByZXR1cm4gRGF0YVR5cGUudWludDY0O1xuICAgIGNhc2UgJ2ludDQnOlxuICAgICAgcmV0dXJuIERhdGFUeXBlLmludDQ7XG4gICAgY2FzZSAndWludDQnOlxuICAgICAgcmV0dXJuIERhdGFUeXBlLnVpbnQ0O1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke3R5cGV9YCk7XG4gIH1cbn07XG5cbi8qKlxuICogTWFwIGVudW0gdmFsdWUgdG8gc3RyaW5nIHRlbnNvciBkYXRhXG4gKi9cbmV4cG9ydCBjb25zdCB0ZW5zb3JEYXRhVHlwZUVudW1Ub1N0cmluZyA9ICh0eXBlUHJvdG86IERhdGFUeXBlKTogVGVuc29yLlR5cGUgPT4ge1xuICBzd2l0Y2ggKHR5cGVQcm90bykge1xuICAgIGNhc2UgRGF0YVR5cGUuaW50ODpcbiAgICAgIHJldHVybiAnaW50OCc7XG4gICAgY2FzZSBEYXRhVHlwZS51aW50ODpcbiAgICAgIHJldHVybiAndWludDgnO1xuICAgIGNhc2UgRGF0YVR5cGUuYm9vbDpcbiAgICAgIHJldHVybiAnYm9vbCc7XG4gICAgY2FzZSBEYXRhVHlwZS5pbnQxNjpcbiAgICAgIHJldHVybiAnaW50MTYnO1xuICAgIGNhc2UgRGF0YVR5cGUudWludDE2OlxuICAgICAgcmV0dXJuICd1aW50MTYnO1xuICAgIGNhc2UgRGF0YVR5cGUuaW50MzI6XG4gICAgICByZXR1cm4gJ2ludDMyJztcbiAgICBjYXNlIERhdGFUeXBlLnVpbnQzMjpcbiAgICAgIHJldHVybiAndWludDMyJztcbiAgICBjYXNlIERhdGFUeXBlLmZsb2F0MTY6XG4gICAgICByZXR1cm4gJ2Zsb2F0MTYnO1xuICAgIGNhc2UgRGF0YVR5cGUuZmxvYXQ6XG4gICAgICByZXR1cm4gJ2Zsb2F0MzInO1xuICAgIGNhc2UgRGF0YVR5cGUuZG91YmxlOlxuICAgICAgcmV0dXJuICdmbG9hdDY0JztcbiAgICBjYXNlIERhdGFUeXBlLnN0cmluZzpcbiAgICAgIHJldHVybiAnc3RyaW5nJztcbiAgICBjYXNlIERhdGFUeXBlLmludDY0OlxuICAgICAgcmV0dXJuICdpbnQ2NCc7XG4gICAgY2FzZSBEYXRhVHlwZS51aW50NjQ6XG4gICAgICByZXR1cm4gJ3VpbnQ2NCc7XG4gICAgY2FzZSBEYXRhVHlwZS5pbnQ0OlxuICAgICAgcmV0dXJuICdpbnQ0JztcbiAgICBjYXNlIERhdGFUeXBlLnVpbnQ0OlxuICAgICAgcmV0dXJuICd1aW50NCc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7dHlwZVByb3RvfWApO1xuICB9XG59O1xuXG4vKipcbiAqIGdldCB0ZW5zb3Igc2l6ZSBpbiBieXRlcyBieSB0aGUgZ2l2ZW4gZGF0YSB0eXBlIGFuZCBkaW1lbnNpb25zXG4gKiBAcmV0dXJucyBzaXplIGluIGludGVnZXIgb3IgdW5kZWZpbmVkIGlmIHRoZSBkYXRhIHR5cGUgaXMgbm90IHN1cHBvcnRlZFxuICovXG5leHBvcnQgY29uc3QgY2FsY3VsYXRlVGVuc29yU2l6ZUluQnl0ZXMgPSAoXG4gIGRhdGVUeXBlOiBudW1iZXIsXG4gIGRpbXNPclNpemU6IHJlYWRvbmx5IG51bWJlcltdIHwgbnVtYmVyLFxuKTogbnVtYmVyIHwgdW5kZWZpbmVkID0+IHtcbiAgY29uc3QgZWxlbWVudFNpemUgPSBbXG4gICAgLTEsIC8vIHVuZGVmaW5lZCA9IDBcbiAgICA0LCAvLyBmbG9hdCA9IDFcbiAgICAxLCAvLyB1aW50OCA9IDJcbiAgICAxLCAvLyBpbnQ4ID0gM1xuICAgIDIsIC8vIHVpbnQxNiA9IDRcbiAgICAyLCAvLyBpbnQxNiA9IDVcbiAgICA0LCAvLyBpbnQzMiA9IDZcbiAgICA4LCAvLyBpbnQ2NCA9IDdcbiAgICAtMSwgLy8gc3RyaW5nID0gOFxuICAgIDEsIC8vIGJvb2wgPSA5XG4gICAgMiwgLy8gZmxvYXQxNiA9IDEwXG4gICAgOCwgLy8gZG91YmxlID0gMTFcbiAgICA0LCAvLyB1aW50MzIgPSAxMlxuICAgIDgsIC8vIHVpbnQ2NCA9IDEzXG4gICAgLTEsIC8vIGNvbXBsZXg2NCA9IDE0XG4gICAgLTEsIC8vIGNvbXBsZXgxMjggPSAxNVxuICAgIC0xLCAvLyBiZmxvYXQxNiA9IDE2XG4gICAgLTEsIC8vIEZMT0FUOEU0TTNGTiA9IDE3XG4gICAgLTEsIC8vIEZMT0FUOEU0TTNGTlVaID0gMThcbiAgICAtMSwgLy8gRkxPQVQ4RTVNMiA9IDE5XG4gICAgLTEsIC8vIEZMT0FUOEU1TTJGTlVaID0gMjBcbiAgICAwLjUsIC8vIHVpbnQ0ID0gMjFcbiAgICAwLjUsIC8vIGludDQgPSAyMlxuICBdW2RhdGVUeXBlXTtcblxuICBjb25zdCBzaXplID0gdHlwZW9mIGRpbXNPclNpemUgPT09ICdudW1iZXInID8gZGltc09yU2l6ZSA6IGRpbXNPclNpemUucmVkdWNlKChhLCBiKSA9PiBhICogYiwgMSk7XG4gIHJldHVybiBlbGVtZW50U2l6ZSA+IDAgPyBNYXRoLmNlaWwoc2l6ZSAqIGVsZW1lbnRTaXplKSA6IHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogZ2V0IHR5cGVkIGFycmF5IGNvbnN0cnVjdG9yIGJ5IHRoZSBnaXZlbiB0ZW5zb3IgdHlwZVxuICovXG5leHBvcnQgY29uc3QgdGVuc29yVHlwZVRvVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gKFxuICB0eXBlOiBUZW5zb3IuVHlwZSxcbik6XG4gIHwgRmxvYXQzMkFycmF5Q29uc3RydWN0b3JcbiAgfCBVaW50OEFycmF5Q29uc3RydWN0b3JcbiAgfCBJbnQ4QXJyYXlDb25zdHJ1Y3RvclxuICB8IFVpbnQxNkFycmF5Q29uc3RydWN0b3JcbiAgfCBJbnQxNkFycmF5Q29uc3RydWN0b3JcbiAgfCBJbnQzMkFycmF5Q29uc3RydWN0b3JcbiAgfCBCaWdJbnQ2NEFycmF5Q29uc3RydWN0b3JcbiAgfCBVaW50OEFycmF5Q29uc3RydWN0b3JcbiAgfCBGbG9hdDY0QXJyYXlDb25zdHJ1Y3RvclxuICB8IFVpbnQzMkFycmF5Q29uc3RydWN0b3JcbiAgfCBCaWdVaW50NjRBcnJheUNvbnN0cnVjdG9yID0+IHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnZmxvYXQxNic6XG4gICAgICAvLyBhbGxvdyBGbG9hdDE2QXJyYXkgcG9seWZpbGwuXG4gICAgICByZXR1cm4gdHlwZW9mIEZsb2F0MTZBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgRmxvYXQxNkFycmF5LmZyb20gPyBGbG9hdDE2QXJyYXkgOiBVaW50MTZBcnJheTtcbiAgICBjYXNlICdmbG9hdDMyJzpcbiAgICAgIHJldHVybiBGbG9hdDMyQXJyYXk7XG4gICAgY2FzZSAndWludDgnOlxuICAgICAgcmV0dXJuIFVpbnQ4QXJyYXk7XG4gICAgY2FzZSAnaW50OCc6XG4gICAgICByZXR1cm4gSW50OEFycmF5O1xuICAgIGNhc2UgJ3VpbnQxNic6XG4gICAgICByZXR1cm4gVWludDE2QXJyYXk7XG4gICAgY2FzZSAnaW50MTYnOlxuICAgICAgcmV0dXJuIEludDE2QXJyYXk7XG4gICAgY2FzZSAnaW50MzInOlxuICAgICAgcmV0dXJuIEludDMyQXJyYXk7XG4gICAgY2FzZSAnYm9vbCc6XG4gICAgICByZXR1cm4gVWludDhBcnJheTtcbiAgICBjYXNlICdmbG9hdDY0JzpcbiAgICAgIHJldHVybiBGbG9hdDY0QXJyYXk7XG4gICAgY2FzZSAndWludDMyJzpcbiAgICAgIHJldHVybiBVaW50MzJBcnJheTtcbiAgICBjYXNlICdpbnQ2NCc6XG4gICAgICByZXR1cm4gQmlnSW50NjRBcnJheTtcbiAgICBjYXNlICd1aW50NjQnOlxuICAgICAgcmV0dXJuIEJpZ1VpbnQ2NEFycmF5O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIHR5cGU6ICR7dHlwZX1gKTtcbiAgfVxufTtcblxuLyoqXG4gKiBNYXAgc3RyaW5nIGxvZyBsZXZlbCB0byBpbnRlZ2VyIHZhbHVlXG4gKi9cbmV4cG9ydCBjb25zdCBsb2dMZXZlbFN0cmluZ1RvRW51bSA9IChsb2dMZXZlbD86ICd2ZXJib3NlJyB8ICdpbmZvJyB8ICd3YXJuaW5nJyB8ICdlcnJvcicgfCAnZmF0YWwnKTogbnVtYmVyID0+IHtcbiAgc3dpdGNoIChsb2dMZXZlbCkge1xuICAgIGNhc2UgJ3ZlcmJvc2UnOlxuICAgICAgcmV0dXJuIDA7XG4gICAgY2FzZSAnaW5mbyc6XG4gICAgICByZXR1cm4gMTtcbiAgICBjYXNlICd3YXJuaW5nJzpcbiAgICAgIHJldHVybiAyO1xuICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgIHJldHVybiAzO1xuICAgIGNhc2UgJ2ZhdGFsJzpcbiAgICAgIHJldHVybiA0O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGxvZ2dpbmcgbGV2ZWw6ICR7bG9nTGV2ZWx9YCk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdGVuc29yIHR5cGUgaXMgc3VwcG9ydGVkIGJ5IEdQVSBidWZmZXJcbiAqL1xuZXhwb3J0IGNvbnN0IGlzR3B1QnVmZmVyU3VwcG9ydGVkVHlwZSA9ICh0eXBlOiBUZW5zb3IuVHlwZSk6IHR5cGUgaXMgVGVuc29yLkdwdUJ1ZmZlckRhdGFUeXBlcyA9PlxuICB0eXBlID09PSAnZmxvYXQzMicgfHxcbiAgdHlwZSA9PT0gJ2Zsb2F0MTYnIHx8XG4gIHR5cGUgPT09ICdpbnQzMicgfHxcbiAgdHlwZSA9PT0gJ2ludDY0JyB8fFxuICB0eXBlID09PSAndWludDMyJyB8fFxuICB0eXBlID09PSAndWludDgnIHx8XG4gIHR5cGUgPT09ICdib29sJyB8fFxuICB0eXBlID09PSAndWludDQnIHx8XG4gIHR5cGUgPT09ICdpbnQ0JztcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB0ZW5zb3IgdHlwZSBpcyBzdXBwb3J0ZWQgYnkgV2ViTk4gTUxUZW5zb3JcbiAqL1xuZXhwb3J0IGNvbnN0IGlzTUxUZW5zb3JTdXBwb3J0ZWRUeXBlID0gKHR5cGU6IFRlbnNvci5UeXBlKTogdHlwZSBpcyBUZW5zb3IuTUxUZW5zb3JEYXRhVHlwZXMgPT5cbiAgdHlwZSA9PT0gJ2Zsb2F0MzInIHx8XG4gIHR5cGUgPT09ICdmbG9hdDE2JyB8fFxuICB0eXBlID09PSAnaW50MzInIHx8XG4gIHR5cGUgPT09ICdpbnQ2NCcgfHxcbiAgdHlwZSA9PT0gJ3VpbnQzMicgfHxcbiAgdHlwZSA9PT0gJ3VpbnQ2NCcgfHxcbiAgdHlwZSA9PT0gJ2ludDgnIHx8XG4gIHR5cGUgPT09ICd1aW50OCcgfHxcbiAgdHlwZSA9PT0gJ2Jvb2wnIHx8XG4gIHR5cGUgPT09ICd1aW50NCcgfHxcbiAgdHlwZSA9PT0gJ2ludDQnO1xuXG4vKipcbiAqIE1hcCBzdHJpbmcgZGF0YSBsb2NhdGlvbiB0byBpbnRlZ2VyIHZhbHVlXG4gKi9cbmV4cG9ydCBjb25zdCBkYXRhTG9jYXRpb25TdHJpbmdUb0VudW0gPSAobG9jYXRpb246IFRlbnNvci5EYXRhTG9jYXRpb24pOiBudW1iZXIgPT4ge1xuICBzd2l0Y2ggKGxvY2F0aW9uKSB7XG4gICAgY2FzZSAnbm9uZSc6XG4gICAgICByZXR1cm4gMDtcbiAgICBjYXNlICdjcHUnOlxuICAgICAgcmV0dXJuIDE7XG4gICAgY2FzZSAnY3B1LXBpbm5lZCc6XG4gICAgICByZXR1cm4gMjtcbiAgICBjYXNlICd0ZXh0dXJlJzpcbiAgICAgIHJldHVybiAzO1xuICAgIGNhc2UgJ2dwdS1idWZmZXInOlxuICAgICAgcmV0dXJuIDQ7XG4gICAgY2FzZSAnbWwtdGVuc29yJzpcbiAgICAgIHJldHVybiA1O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgbG9jYXRpb246ICR7bG9jYXRpb259YCk7XG4gIH1cbn07XG5cbi8qKlxuICogTWFwIGludGVnZXIgZGF0YSBsb2NhdGlvbiB0byBzdHJpbmcgdmFsdWVcbiAqL1xuZXhwb3J0IGNvbnN0IGRhdGFMb2NhdGlvbkVudW1Ub1N0cmluZyA9IChsb2NhdGlvbjogbnVtYmVyKTogVGVuc29yLkRhdGFMb2NhdGlvbiB8IHVuZGVmaW5lZCA9PlxuICAoWydub25lJywgJ2NwdScsICdjcHUtcGlubmVkJywgJ3RleHR1cmUnLCAnZ3B1LWJ1ZmZlcicsICdtbC10ZW5zb3InXSBhcyBjb25zdClbbG9jYXRpb25dO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBpc05vZGUgfSBmcm9tICcuL3dhc20tdXRpbHMtZW52JztcblxuLyoqXG4gKiBMb2FkIGEgZmlsZSBpbnRvIGEgVWludDhBcnJheS5cbiAqXG4gKiBAcGFyYW0gZmlsZSAtIHRoZSBmaWxlIHRvIGxvYWQuIENhbiBiZSBhIFVSTC9wYXRoLCBhIEJsb2IsIGFuIEFycmF5QnVmZmVyLCBvciBhIFVpbnQ4QXJyYXkuXG4gKiBAcmV0dXJucyBhIFVpbnQ4QXJyYXkgY29udGFpbmluZyB0aGUgZmlsZSBkYXRhLlxuICovXG5leHBvcnQgY29uc3QgbG9hZEZpbGUgPSBhc3luYyAoZmlsZTogc3RyaW5nIHwgQmxvYiB8IEFycmF5QnVmZmVyTGlrZSB8IFVpbnQ4QXJyYXkpOiBQcm9taXNlPFVpbnQ4QXJyYXk+ID0+IHtcbiAgaWYgKHR5cGVvZiBmaWxlID09PSAnc3RyaW5nJykge1xuICAgIGlmIChpc05vZGUpIHtcbiAgICAgIC8vIGxvYWQgZmlsZSBpbnRvIEFycmF5QnVmZmVyIGluIE5vZGUuanNcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgcmVhZEZpbGUgfSA9IHJlcXVpcmUoJ25vZGU6ZnMvcHJvbWlzZXMnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGF3YWl0IHJlYWRGaWxlKGZpbGUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUuY29kZSA9PT0gJ0VSUl9GU19GSUxFX1RPT19MQVJHRScpIHtcbiAgICAgICAgICAvLyBmaWxlIGlzIHRvbyBsYXJnZSwgdXNlIGZzLmNyZWF0ZVJlYWRTdHJlYW0gaW5zdGVhZFxuICAgICAgICAgIGNvbnN0IHsgY3JlYXRlUmVhZFN0cmVhbSB9ID0gcmVxdWlyZSgnbm9kZTpmcycpO1xuICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IGNyZWF0ZVJlYWRTdHJlYW0oZmlsZSk7XG4gICAgICAgICAgY29uc3QgY2h1bmtzOiBVaW50OEFycmF5W10gPSBbXTtcbiAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgICAgICAgICAgY2h1bmtzLnB1c2goY2h1bmspO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoQnVmZmVyLmNvbmNhdChjaHVua3MpKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBsb2FkIGZpbGUgaW50byBBcnJheUJ1ZmZlciBpbiBicm93c2Vyc1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChmaWxlKTtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBmYWlsZWQgdG8gbG9hZCBleHRlcm5hbCBkYXRhIGZpbGU6ICR7ZmlsZX1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbnRlbnRMZW5ndGhIZWFkZXIgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnQ29udGVudC1MZW5ndGgnKTtcbiAgICAgIGNvbnN0IGZpbGVTaXplID0gY29udGVudExlbmd0aEhlYWRlciA/IHBhcnNlSW50KGNvbnRlbnRMZW5ndGhIZWFkZXIsIDEwKSA6IDA7XG4gICAgICBpZiAoZmlsZVNpemUgPCAxMDczNzQxODI0IC8qIDFHQiAqLykge1xuICAgICAgICAvLyB3aGVuIENvbnRlbnQtTGVuZ3RoIGhlYWRlciBpcyBub3Qgc2V0LCB3ZSBjYW5ub3QgZGV0ZXJtaW5lIHRoZSBmaWxlIHNpemUuIFdlIGFzc3VtZSBpdCBpcyBzbWFsbCBlbm91Z2ggdG9cbiAgICAgICAgLy8gbG9hZCBpbnRvIG1lbW9yeS5cbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZmlsZSBpcyB0b28gbGFyZ2UsIHVzZSBzdHJlYW0gaW5zdGVhZFxuICAgICAgICBpZiAoIXJlc3BvbnNlLmJvZHkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGZhaWxlZCB0byBsb2FkIGV4dGVybmFsIGRhdGEgZmlsZTogJHtmaWxlfSwgbm8gcmVzcG9uc2UgYm9keS5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuXG4gICAgICAgIGxldCBidWZmZXI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gdHJ5IHRvIGNyZWF0ZSBBcnJheUJ1ZmZlciBkaXJlY3RseVxuICAgICAgICAgIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihmaWxlU2l6ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFJhbmdlRXJyb3IpIHtcbiAgICAgICAgICAgIC8vIHVzZSBXZWJBc3NlbWJseSBNZW1vcnkgdG8gYWxsb2NhdGUgbGFyZ2VyIEFycmF5QnVmZmVyXG4gICAgICAgICAgICBjb25zdCBwYWdlcyA9IE1hdGguY2VpbChmaWxlU2l6ZSAvIDY1NTM2KTtcbiAgICAgICAgICAgIGJ1ZmZlciA9IG5ldyBXZWJBc3NlbWJseS5NZW1vcnkoeyBpbml0aWFsOiBwYWdlcywgbWF4aW11bTogcGFnZXMgfSkuYnVmZmVyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGNodW5rU2l6ZSA9IHZhbHVlLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgY29uc3QgY2h1bmsgPSBuZXcgVWludDhBcnJheShidWZmZXIsIG9mZnNldCwgY2h1bmtTaXplKTtcbiAgICAgICAgICBjaHVuay5zZXQodmFsdWUpO1xuICAgICAgICAgIG9mZnNldCArPSBjaHVua1NpemU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmZlciwgMCwgZmlsZVNpemUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChmaWxlIGluc3RhbmNlb2YgQmxvYikge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShhd2FpdCBmaWxlLmFycmF5QnVmZmVyKCkpO1xuICB9IGVsc2UgaWYgKGZpbGUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgcmV0dXJuIGZpbGU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGZpbGUpO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG4vLyBXZWJOTiBBUEkgY3VycmVudGx5IGRvZXMgbm90IGhhdmUgYSBUeXBlU2NyaXB0IGRlZmluaXRpb24gZmlsZS4gVGhpcyBmaWxlIGlzIGEgd29ya2Fyb3VuZCB3aXRoIHR5cGVzIGdlbmVyYXRlZCBmcm9tXG4vLyBXZWJOTiBBUEkgc3BlY2lmaWNhdGlvbi5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJtYWNoaW5lbGVhcm5pbmcvd2Vibm4vaXNzdWVzLzY3N1xuLy8vIDxyZWZlcmVuY2UgcGF0aD1cImpzZXAvd2Vibm4vd2Vibm4uZC50c1wiIC8+XG5cbmltcG9ydCB7IEVudiwgSW5mZXJlbmNlU2Vzc2lvbiwgVGVuc29yIH0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuaW1wb3J0IHtcbiAgU2VyaWFsaXphYmxlSW50ZXJuYWxCdWZmZXIsXG4gIFNlcmlhbGl6YWJsZVNlc3Npb25NZXRhZGF0YSxcbiAgU2VyaWFsaXphYmxlVGVuc29yTWV0YWRhdGEsXG4gIFRlbnNvck1ldGFkYXRhLFxufSBmcm9tICcuL3Byb3h5LW1lc3NhZ2VzJztcbmltcG9ydCB7IHNldFJ1bk9wdGlvbnMgfSBmcm9tICcuL3J1bi1vcHRpb25zJztcbmltcG9ydCB7IHNldFNlc3Npb25PcHRpb25zIH0gZnJvbSAnLi9zZXNzaW9uLW9wdGlvbnMnO1xuaW1wb3J0IHtcbiAgY2FsY3VsYXRlVGVuc29yU2l6ZUluQnl0ZXMsXG4gIGRhdGFMb2NhdGlvblN0cmluZ1RvRW51bSxcbiAgaXNHcHVCdWZmZXJTdXBwb3J0ZWRUeXBlLFxuICBpc01MVGVuc29yU3VwcG9ydGVkVHlwZSxcbiAgbG9nTGV2ZWxTdHJpbmdUb0VudW0sXG4gIHRlbnNvckRhdGFUeXBlRW51bVRvU3RyaW5nLFxuICB0ZW5zb3JEYXRhVHlwZVN0cmluZ1RvRW51bSxcbiAgdGVuc29yVHlwZVRvVHlwZWRBcnJheUNvbnN0cnVjdG9yLFxufSBmcm9tICcuL3dhc20tY29tbW9uJztcbmltcG9ydCB7IGdldEluc3RhbmNlIH0gZnJvbSAnLi93YXNtLWZhY3RvcnknO1xuaW1wb3J0IHsgYWxsb2NXYXNtU3RyaW5nLCBjaGVja0xhc3RFcnJvciB9IGZyb20gJy4vd2FzbS11dGlscyc7XG5pbXBvcnQgeyBsb2FkRmlsZSB9IGZyb20gJy4vd2FzbS11dGlscy1sb2FkLWZpbGUnO1xuXG4vLyAjcmVnaW9uIEluaXRpYWxpemF0aW9uc1xuXG4vKipcbiAqIFRoZXJlIGFyZSA0IGRpZmZlcmVudCBcImluaXRpYWxpemF0aW9uXCIgc3RlcHMgZm9yIE9SVC4gVGhleSBoYXBwZW4gaW4gZGlmZmVyZW50IHBsYWNlcyBhbmQgZGlmZmVyZW50IHRpbWUuXG4gKlxuICogMS4gSmF2YVNjcmlwdCBpbml0aWFsaXphdGlvbiBmb3Igb25ueHJ1bnRpbWUtY29tbW9uIGFuZCBvbm54cnVudGltZS13ZWIuXG4gKiAgICBUaGlzIGlzIHRoZSBmaXJzdCBpbml0aWFsaXphdGlvbiBzdGVwLiBJbiB0aGlzIHN0ZXAsIG9ubnhydW50aW1lLXdlYiBjYWxscyBvbm54cnVudGltZS1jb21tb24ncyByZWdpc3RlckJhY2tlbmQoKVxuICogZnVuY3Rpb24gbXVsdGlwbGUgdGltZXMgdG8gcmVnaXN0ZXIgYWxsIHRoZSBhdmFpbGFibGUgYmFja2VuZHMuIFRoZSBiYWNrZW5kIHJlZ2lzdHJhdGlvbiBpcyB2ZXJ5IGZhc3QuIEl0IG9ubHlcbiAqIHJlZ2lzdGVycyB0aGUgYmFja2VuZCBuYW1lIHdpdGggdGhlIHVuaW5pdGlhbGl6ZWQgYmFja2VuZCBvYmplY3QuIE5vIGhlYXZ5IGluaXRpYWxpemF0aW9uIGlzIGRvbmUgaW4gdGhpcyBzdGVwLlxuICogICAgUmVmZXIgdG8gd2ViL2xpYi9pbmRleC50cyBmb3IgdGhlIGJhY2tlbmQgcmVnaXN0cmF0aW9uLlxuICpcbiAqIDIuIFdlYkFzc2VtYmx5IGFydGlmYWN0IGluaXRpYWxpemF0aW9uLlxuICogICAgVGhpcyBoYXBwZW5zIHdoZW4gYW55IHJlZ2lzdGVyZWQgd2FzbSBiYWNrZW5kIGlzIHVzZWQgZm9yIHRoZSBmaXJzdCB0aW1lIChpZS4gYG9ydC5JbmZlcmVuY2VTZXNzaW9uLmNyZWF0ZSgpYCBpc1xuICogY2FsbGVkKS4gSW4gdGhpcyBzdGVwLCBvbm54cnVudGltZS13ZWIgZG9lcyB0aGUgZm9sbG93aW5nczpcbiAqICAgICAtIGNyZWF0ZSBhIHByb3h5IHdvcmtlciBhbmQgbWFrZSBzdXJlIHRoZSBwcm94eSB3b3JrZXIgaXMgcmVhZHkgdG8gcmVjZWl2ZSBtZXNzYWdlcywgaWYgcHJveHkgaXMgZW5hYmxlZC5cbiAqICAgICAtIHBlcmZvcm0gZmVhdHVyZSBkZXRlY3Rpb24sIGxvY2F0ZSBjb3JyZWN0IFdlYkFzc2VtYmx5IGFydGlmYWN0IHBhdGggYW5kIGNhbGwgdGhlIEVtc2NyaXB0ZW4gZ2VuZXJhdGVkXG4gKiBKYXZhU2NyaXB0IGNvZGUgdG8gaW5pdGlhbGl6ZSB0aGUgV2ViQXNzZW1ibHkgcnVudGltZS5cbiAqICAgICAgICAgLSBpZiBwcm94eSBpcyBlbmFibGVkLCB0aGlzIHN0ZXAgaGFwcGVucyBpbiB0aGUgcHJveHkgd29ya2VyIHVzaW5nIG1lc3NhZ2UgJ2luaXQtd2FzbScuXG4gKiAgICAgICAgIC0gZG93bmxvYWRpbmcgdGhlICdvcnQtd2FzbXsuLi59Lndhc20nIGZpbGUgaXMgZG9uZSBpbiB0aGlzIHN0ZXAuXG4gKiAgICAgICAgIC0gaWYgbXVsdGktdGhyZWFkIGlzIGVuYWJsZWQsIG9uZSBvciBtb3JlIHdlYndvcmtlciB3aWxsIGJlIGNyZWF0ZWQgdG8gaW5pdGlhbGl6ZSB0aGUgUFRocmVhZCB0aHJlYWRwb29sLlxuICpcbiAqIDMuIE9SVCBlbnZpcm9ubWVudCBpbml0aWFsaXphdGlvbi5cbiAqICAgIFRoaXMgaGFwcGVucyBhZnRlciBzdGVwIDIuIEluIHRoaXMgc3RlcCwgb25ueHJ1bnRpbWUtd2ViIHBlcmZvcm1zIE9OTlggUnVudGltZSBlbnZpcm9ubWVudCBpbml0aWFsaXphdGlvbi5cbiAqIEZ1bmN0aW9uIGBfT3J0SW5pdCgpYCBpcyBjYWxsZWQgaW4gdGhpcyBzdGVwLlxuICogICAgIC0gaWYgcHJveHkgaXMgZW5hYmxlZCwgdGhpcyBzdGVwIGhhcHBlbnMgaW4gdGhlIHByb3h5IHdvcmtlciB1c2luZyBtZXNzYWdlICdpbml0LW9ydCcuXG4gKiAgICAgLSBsb2dnaW5nIGxldmVsIChvcnQuZW52LmxvZ0xldmVsKSBhbmQgdGhyZWFkIG51bWJlciAob3J0LmVudi53YXNtLm51bVRocmVhZHMpIGFyZSBzZXQgaW4gdGhpcyBzdGVwLlxuICpcbiAqIDQuIFNlc3Npb24gaW5pdGlhbGl6YXRpb24uXG4gKiAgICBUaGlzIGhhcHBlbnMgd2hlbiBgb3J0LkluZmVyZW5jZVNlc3Npb24uY3JlYXRlKClgIGlzIGNhbGxlZC4gVW5saWtlIHRoZSBmaXJzdCAzIHN0ZXBzICh0aGV5IG9ubHkgY2FsbGVkIG9uY2UpLFxuICogdGhpcyBzdGVwIHdpbGwgYmUgZG9uZSBmb3IgZWFjaCBzZXNzaW9uLiBJbiB0aGlzIHN0ZXAsIG9ubnhydW50aW1lLXdlYiBkb2VzIHRoZSBmb2xsb3dpbmdzOlxuICogICAgSWYgdGhlIHBhcmFtZXRlciBpcyBhIFVSTDpcbiAqICAgIC0gZG93bmxvYWQgdGhlIG1vZGVsIGRhdGEgZnJvbSB0aGUgVVJMLlxuICogICAgLSBjb3B5IHRoZSBtb2RlbCBkYXRhIHRvIHRoZSBXQVNNIGhlYXAuIChwcm94eTogJ2NvcHktZnJvbScpXG4gKiAgICAtIGRlcmVmZXJlbmNlIHRoZSBtb2RlbCBidWZmZXIuIFRoaXMgc3RlcCBhbGxvd3MgdGhlIG9yaWdpbmFsIEFycmF5QnVmZmVyIHRvIGJlIGdhcmJhZ2UgY29sbGVjdGVkLlxuICogICAgLSBjYWxsIGBfT3J0Q3JlYXRlU2Vzc2lvbigpYCB0byBjcmVhdGUgdGhlIHNlc3Npb24uIChwcm94eTogJ2NyZWF0ZScpXG4gKlxuICogICAgSWYgdGhlIHBhcmFtZXRlciBpcyBhIFVpbnQ4QXJyYXkgb2JqZWN0OlxuICogICAgLSBjb3B5IHRoZSBtb2RlbCBkYXRhIHRvIHRoZSBXQVNNIGhlYXAuIChwcm94eTogJ2NvcHktZnJvbScpXG4gKiAgICAtIGNhbGwgYF9PcnRDcmVhdGVTZXNzaW9uKClgIHRvIGNyZWF0ZSB0aGUgc2Vzc2lvbi4gKHByb3h5OiAnY3JlYXRlJylcbiAqXG4gKlxuICovXG5cbi8qKlxuICogaW5pdGlhbGl6ZSBPUlQgZW52aXJvbm1lbnQuXG4gKlxuICogQHBhcmFtIG51bVRocmVhZHMgU2V0R2xvYmFsSW50cmFPcE51bVRocmVhZHMobnVtVGhyZWFkcylcbiAqIEBwYXJhbSBsb2dnaW5nTGV2ZWwgQ3JlYXRlRW52KHN0YXRpY19jYXN0PE9ydExvZ2dpbmdMZXZlbD4obG9nZ2luZ19sZXZlbCkpXG4gKi9cbmNvbnN0IGluaXRPcnQgPSAobnVtVGhyZWFkczogbnVtYmVyLCBsb2dnaW5nTGV2ZWw6IG51bWJlcik6IHZvaWQgPT4ge1xuICBjb25zdCBlcnJvckNvZGUgPSBnZXRJbnN0YW5jZSgpLl9PcnRJbml0KG51bVRocmVhZHMsIGxvZ2dpbmdMZXZlbCk7XG4gIGlmIChlcnJvckNvZGUgIT09IDApIHtcbiAgICBjaGVja0xhc3RFcnJvcihcIkNhbid0IGluaXRpYWxpemUgb25ueHJ1bnRpbWUuXCIpO1xuICB9XG59O1xuXG4vKipcbiAqIGluaXRpYWxpemUgcnVudGltZSBlbnZpcm9ubWVudC5cbiAqIEBwYXJhbSBlbnYgcGFzc2VkIGluIHRoZSBlbnZpcm9ubWVudCBjb25maWcgb2JqZWN0LlxuICovXG5leHBvcnQgY29uc3QgaW5pdFJ1bnRpbWUgPSBhc3luYyAoZW52OiBFbnYpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgLy8gaW5pdCBPUlRcbiAgaW5pdE9ydChlbnYud2FzbS5udW1UaHJlYWRzISwgbG9nTGV2ZWxTdHJpbmdUb0VudW0oZW52LmxvZ0xldmVsKSk7XG59O1xuXG4vKipcbiAqIHBlcmZvcm0gRVAgc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24uXG4gKlxuICogQHBhcmFtIGVudlxuICogQHBhcmFtIGVwTmFtZVxuICovXG5leHBvcnQgY29uc3QgaW5pdEVwID0gYXN5bmMgKGVudjogRW52LCBlcE5hbWU6IHN0cmluZyk6IFByb21pc2U8dm9pZD4gPT4ge1xuICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9KU0VQKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHMsIEB0eXBlc2NyaXB0LWVzbGludC9uby12YXItcmVxdWlyZXNcbiAgICBjb25zdCBpbml0SnNlcCA9IHJlcXVpcmUoJy4vanNlcC9pbml0JykuaW5pdDtcblxuICAgIGlmIChlcE5hbWUgPT09ICd3ZWJncHUnKSB7XG4gICAgICAvLyBwZXJmb3JtIFdlYkdQVSBhdmFpbGFiaWxpdHkgY2hlY2tcbiAgICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJyB8fCAhbmF2aWdhdG9yLmdwdSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYkdQVSBpcyBub3Qgc3VwcG9ydGVkIGluIGN1cnJlbnQgZW52aXJvbm1lbnQnKTtcbiAgICAgIH1cblxuICAgICAgbGV0IGFkYXB0ZXIgPSBlbnYud2ViZ3B1LmFkYXB0ZXIgYXMgR1BVQWRhcHRlciB8IG51bGw7XG4gICAgICBpZiAoIWFkYXB0ZXIpIHtcbiAgICAgICAgLy8gaWYgYWRhcHRlciBpcyBub3Qgc2V0LCByZXF1ZXN0IGEgbmV3IGFkYXB0ZXIuXG4gICAgICAgIGNvbnN0IHBvd2VyUHJlZmVyZW5jZSA9IGVudi53ZWJncHUucG93ZXJQcmVmZXJlbmNlO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgcG93ZXJQcmVmZXJlbmNlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICBwb3dlclByZWZlcmVuY2UgIT09ICdsb3ctcG93ZXInICYmXG4gICAgICAgICAgcG93ZXJQcmVmZXJlbmNlICE9PSAnaGlnaC1wZXJmb3JtYW5jZSdcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHBvd2VyUHJlZmVyZW5jZSBzZXR0aW5nOiBcIiR7cG93ZXJQcmVmZXJlbmNlfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZm9yY2VGYWxsYmFja0FkYXB0ZXIgPSBlbnYud2ViZ3B1LmZvcmNlRmFsbGJhY2tBZGFwdGVyO1xuICAgICAgICBpZiAoZm9yY2VGYWxsYmFja0FkYXB0ZXIgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZm9yY2VGYWxsYmFja0FkYXB0ZXIgIT09ICdib29sZWFuJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBmb3JjZUZhbGxiYWNrQWRhcHRlciBzZXR0aW5nOiBcIiR7Zm9yY2VGYWxsYmFja0FkYXB0ZXJ9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICBhZGFwdGVyID0gYXdhaXQgbmF2aWdhdG9yLmdwdS5yZXF1ZXN0QWRhcHRlcih7IHBvd2VyUHJlZmVyZW5jZSwgZm9yY2VGYWxsYmFja0FkYXB0ZXIgfSk7XG4gICAgICAgIGlmICghYWRhcHRlcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdGYWlsZWQgdG8gZ2V0IEdQVSBhZGFwdGVyLiAnICtcbiAgICAgICAgICAgICAgJ1lvdSBtYXkgbmVlZCB0byBlbmFibGUgZmxhZyBcIi0tZW5hYmxlLXVuc2FmZS13ZWJncHVcIiBpZiB5b3UgYXJlIHVzaW5nIENocm9tZS4nLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIGFkYXB0ZXIgaXMgc2V0LCB2YWxpZGF0ZSBpdC5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIHR5cGVvZiBhZGFwdGVyLmxpbWl0cyAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgICB0eXBlb2YgYWRhcHRlci5mZWF0dXJlcyAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgICB0eXBlb2YgYWRhcHRlci5yZXF1ZXN0RGV2aWNlICE9PSAnZnVuY3Rpb24nXG4gICAgICAgICkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBHUFUgYWRhcHRlciBzZXQgaW4gYGVudi53ZWJncHUuYWRhcHRlcmAuIEl0IG11c3QgYmUgYSBHUFVBZGFwdGVyIG9iamVjdC4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBhd2FpdCBpbml0SnNlcCgnd2ViZ3B1JywgZ2V0SW5zdGFuY2UoKSwgZW52LCBhZGFwdGVyKTtcbiAgICB9XG4gICAgaWYgKGVwTmFtZSA9PT0gJ3dlYm5uJykge1xuICAgICAgLy8gcGVyZm9ybSBXZWJOTiBhdmFpbGFiaWxpdHkgY2hlY2tcbiAgICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJyB8fCAhKG5hdmlnYXRvciBhcyB1bmtub3duIGFzIHsgbWw6IHVua25vd24gfSkubWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJOTiBpcyBub3Qgc3VwcG9ydGVkIGluIGN1cnJlbnQgZW52aXJvbm1lbnQnKTtcbiAgICAgIH1cblxuICAgICAgYXdhaXQgaW5pdEpzZXAoJ3dlYm5uJywgZ2V0SW5zdGFuY2UoKSwgZW52KTtcbiAgICB9XG4gIH1cbn07XG5cbi8vICNlbmRyZWdpb24gSW5pdGlhbGl6YXRpb25zXG5cbi8qKlxuICogdmFsaWQgZGF0YSBsb2NhdGlvbnMgZm9yIGlucHV0L291dHB1dCB0ZW5zb3JzLlxuICovXG50eXBlIFN1cHBvcnRlZFRlbnNvckRhdGFMb2NhdGlvbkZvcklucHV0T3V0cHV0ID0gJ2NwdScgfCAnY3B1LXBpbm5lZCcgfCAnZ3B1LWJ1ZmZlcicgfCAnbWwtdGVuc29yJztcblxudHlwZSBJT0JpbmRpbmdTdGF0ZSA9IHtcbiAgLyoqXG4gICAqIHRoZSBoYW5kbGUgb2YgSU8gYmluZGluZy5cbiAgICovXG4gIHJlYWRvbmx5IGhhbmRsZTogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiB0aGUgcHJlZmVycmVkIGxvY2F0aW9uIGZvciBlYWNoIG91dHB1dCB0ZW5zb3IuXG4gICAqXG4gICAqIHZhbHVlIGlzIG9uZSBvZiAnY3B1JywgJ2NwdS1waW5uZWQnLCAnZ3B1LWJ1ZmZlcicsICdtbC10ZW5zb3InLlxuICAgKi9cbiAgcmVhZG9ubHkgb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zOiByZWFkb25seSBTdXBwb3J0ZWRUZW5zb3JEYXRhTG9jYXRpb25Gb3JJbnB1dE91dHB1dFtdO1xuXG4gIC8qKlxuICAgKiBlbnVtIHZhbHVlIG9mIHRoZSBwcmVmZXJyZWQgbG9jYXRpb24gZm9yIGVhY2ggb3V0cHV0IHRlbnNvci5cbiAgICovXG4gIHJlYWRvbmx5IG91dHB1dFByZWZlcnJlZExvY2F0aW9uc0VuY29kZWQ6IHJlYWRvbmx5IG51bWJlcltdO1xufTtcblxuLyoqXG4gKiAgdHVwbGUgZWxlbWVudHMgYXJlOiBJbmZlcmVuY2VTZXNzaW9uIElEOyBpbnB1dE5hbWVzVVRGOEVuY29kZWQ7IG91dHB1dE5hbWVzVVRGOEVuY29kZWQ7IGJpbmRpbmdTdGF0ZVxuICovXG50eXBlIFNlc3Npb25NZXRhZGF0YSA9IFtcbiAgaW5mZXJlbmNlU2Vzc2lvbklkOiBudW1iZXIsXG4gIGlucHV0TmFtZXNVVEY4RW5jb2RlZDogbnVtYmVyW10sXG4gIG91dHB1dE5hbWVzVVRGOEVuY29kZWQ6IG51bWJlcltdLFxuICBiaW5kaW5nU3RhdGU6IElPQmluZGluZ1N0YXRlIHwgbnVsbCxcbiAgZW5hYmxlR3JhcGhDYXB0dXJlOiBib29sZWFuLFxuICBpbnB1dE91dHB1dEJvdW5kOiBib29sZWFuLFxuXTtcblxuY29uc3QgYWN0aXZlU2Vzc2lvbnMgPSBuZXcgTWFwPG51bWJlciwgU2Vzc2lvbk1ldGFkYXRhPigpO1xuXG4vKipcbiAqIGdldCB0aGUgaW5wdXQvb3V0cHV0IGNvdW50IG9mIHRoZSBzZXNzaW9uLlxuICogQHBhcmFtIHNlc3Npb25IYW5kbGUgdGhlIGhhbmRsZSByZXByZXNlbnRpbmcgdGhlIHNlc3Npb24uIHNob3VsZCBiZSBub24temVyby5cbiAqIEByZXR1cm5zIGEgdHVwbGUgaW5jbHVkaW5nIDIgbnVtYmVycywgcmVwcmVzZW50aW5nIHRoZSBpbnB1dCBjb3VudCBhbmQgb3V0cHV0IGNvdW50LlxuICovXG5jb25zdCBnZXRTZXNzaW9uSW5wdXRPdXRwdXRDb3VudCA9IChzZXNzaW9uSGFuZGxlOiBudW1iZXIpOiBbbnVtYmVyLCBudW1iZXJdID0+IHtcbiAgY29uc3Qgd2FzbSA9IGdldEluc3RhbmNlKCk7XG4gIGNvbnN0IHN0YWNrID0gd2FzbS5zdGFja1NhdmUoKTtcbiAgdHJ5IHtcbiAgICBjb25zdCBkYXRhT2Zmc2V0ID0gd2FzbS5zdGFja0FsbG9jKDgpO1xuICAgIGNvbnN0IGVycm9yQ29kZSA9IHdhc20uX09ydEdldElucHV0T3V0cHV0Q291bnQoc2Vzc2lvbkhhbmRsZSwgZGF0YU9mZnNldCwgZGF0YU9mZnNldCArIDQpO1xuICAgIGlmIChlcnJvckNvZGUgIT09IDApIHtcbiAgICAgIGNoZWNrTGFzdEVycm9yKFwiQ2FuJ3QgZ2V0IHNlc3Npb24gaW5wdXQvb3V0cHV0IGNvdW50LlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIFt3YXNtLkhFQVAzMltkYXRhT2Zmc2V0IC8gNF0sIHdhc20uSEVBUDMyW2RhdGFPZmZzZXQgLyA0ICsgMV1dO1xuICB9IGZpbmFsbHkge1xuICAgIHdhc20uc3RhY2tSZXN0b3JlKHN0YWNrKTtcbiAgfVxufTtcblxuLyoqXG4gKiBhbGxvY2F0ZSB0aGUgbWVtb3J5IGFuZCBtZW1jcHkgdGhlIGV4dGVybmFsIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gbW9kZWwgLSB0aGUgZXh0ZXJuYWwgYnVmZmVyIGNvbnRhaW5pbmcgdGhlIG1vZGVsIGRhdGEuIE11c3Qgbm90IGJlIHRoZSBzYW1lIGJ1ZmZlciBhcyB0aGUgV0FTTSBoZWFwLlxuICogQHJldHVybnMgYSAyLWVsZW1lbnRzIHR1cGxlIC0gdGhlIHBvaW50ZXIgYW5kIHNpemUgb2YgdGhlIGFsbG9jYXRlZCBidWZmZXJcbiAqL1xuZXhwb3J0IGNvbnN0IGNvcHlGcm9tRXh0ZXJuYWxCdWZmZXIgPSAobW9kZWw6IFVpbnQ4QXJyYXkpOiBbbnVtYmVyLCBudW1iZXJdID0+IHtcbiAgY29uc3Qgd2FzbSA9IGdldEluc3RhbmNlKCk7XG4gIGNvbnN0IG1vZGVsRGF0YU9mZnNldCA9IHdhc20uX21hbGxvYyhtb2RlbC5ieXRlTGVuZ3RoKTtcbiAgaWYgKG1vZGVsRGF0YU9mZnNldCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgY3JlYXRlIGEgc2Vzc2lvbi4gZmFpbGVkIHRvIGFsbG9jYXRlIGEgYnVmZmVyIG9mIHNpemUgJHttb2RlbC5ieXRlTGVuZ3RofS5gKTtcbiAgfVxuICB3YXNtLkhFQVBVOC5zZXQobW9kZWwsIG1vZGVsRGF0YU9mZnNldCk7XG4gIHJldHVybiBbbW9kZWxEYXRhT2Zmc2V0LCBtb2RlbC5ieXRlTGVuZ3RoXTtcbn07XG5cbi8qKlxuICogY3JlYXRlIGFuIGluZmVyZW5jZSBzZXNzaW9uIGZyb20gYSBtb2RlbCBkYXRhIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gbW9kZWxEYXRhIC0gZWl0aGVyIGEgVWludDhBcnJheSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBtb2RlbCBkYXRhLCBvciBhIDItZWxlbWVudHMgdHVwbGUgY29udGFpbmluZyB0aGVcbiAqICAgICBwb2ludGVyIGFuZCBzaXplIG9mIHRoZSBtb2RlbCBkYXRhIGJ1ZmZlci5cbiAqIEBwYXJhbSBvcHRpb25zIGFuIG9wdGlvbmFsIHNlc3Npb24gb3B0aW9ucyBvYmplY3QuXG4gKiBAcmV0dXJucyBhIDMtZWxlbWVudHMgdHVwbGUgY29udGFpbmluZyBbc2Vzc2lvbiBoYW5kbGUsIGlucHV0IG5hbWVzLCBvdXRwdXQgbmFtZXNdXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVTZXNzaW9uID0gYXN5bmMgKFxuICBtb2RlbERhdGE6IFVpbnQ4QXJyYXkgfCBTZXJpYWxpemFibGVJbnRlcm5hbEJ1ZmZlcixcbiAgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMsXG4pOiBQcm9taXNlPFNlcmlhbGl6YWJsZVNlc3Npb25NZXRhZGF0YT4gPT4ge1xuICBsZXQgbW9kZWxEYXRhT2Zmc2V0OiBudW1iZXIsIG1vZGVsRGF0YUxlbmd0aDogbnVtYmVyO1xuICBjb25zdCB3YXNtID0gZ2V0SW5zdGFuY2UoKTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShtb2RlbERhdGEpKSB7XG4gICAgLy8gaWYgbW9kZWwgZGF0YSBpcyBhbiBhcnJheSwgaXQgbXVzdCBiZSBhIDItZWxlbWVudHMgdHVwbGUgY29udGFpbmluZyB0aGUgcG9pbnRlciBhbmQgc2l6ZSBvZiB0aGUgbW9kZWwgZGF0YVxuICAgIFttb2RlbERhdGFPZmZzZXQsIG1vZGVsRGF0YUxlbmd0aF0gPSBtb2RlbERhdGE7XG4gIH0gZWxzZSBpZiAobW9kZWxEYXRhLmJ1ZmZlciA9PT0gd2FzbS5IRUFQVTguYnVmZmVyKSB7XG4gICAgLy8gaWYgbW9kZWwgZGF0YSB1c2VzIHRoZSBzYW1lIGJ1ZmZlciBhcyB0aGUgV0FTTSBoZWFwLCB3ZSBkb24ndCBuZWVkIHRvIGNvcHkgaXQuXG4gICAgW21vZGVsRGF0YU9mZnNldCwgbW9kZWxEYXRhTGVuZ3RoXSA9IFttb2RlbERhdGEuYnl0ZU9mZnNldCwgbW9kZWxEYXRhLmJ5dGVMZW5ndGhdO1xuICB9IGVsc2Uge1xuICAgIC8vIG90aGVyd2lzZSwgY29weSB0aGUgbW9kZWwgZGF0YSB0byB0aGUgV0FTTSBoZWFwLlxuICAgIFttb2RlbERhdGFPZmZzZXQsIG1vZGVsRGF0YUxlbmd0aF0gPSBjb3B5RnJvbUV4dGVybmFsQnVmZmVyKG1vZGVsRGF0YSk7XG4gIH1cblxuICBsZXQgc2Vzc2lvbkhhbmRsZSA9IDA7XG4gIGxldCBzZXNzaW9uT3B0aW9uc0hhbmRsZSA9IDA7XG4gIGxldCBpb0JpbmRpbmdIYW5kbGUgPSAwO1xuICBsZXQgYWxsb2NzOiBudW1iZXJbXSA9IFtdO1xuICBjb25zdCBpbnB1dE5hbWVzVVRGOEVuY29kZWQgPSBbXTtcbiAgY29uc3Qgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZCA9IFtdO1xuXG4gIHRyeSB7XG4gICAgW3Nlc3Npb25PcHRpb25zSGFuZGxlLCBhbGxvY3NdID0gc2V0U2Vzc2lvbk9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICBpZiAob3B0aW9ucz8uZXh0ZXJuYWxEYXRhICYmIHdhc20ubW91bnRFeHRlcm5hbERhdGEpIHtcbiAgICAgIGNvbnN0IGxvYWRpbmdQcm9taXNlcyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBmaWxlIG9mIG9wdGlvbnMuZXh0ZXJuYWxEYXRhKSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSB0eXBlb2YgZmlsZSA9PT0gJ3N0cmluZycgPyBmaWxlIDogZmlsZS5wYXRoO1xuICAgICAgICBsb2FkaW5nUHJvbWlzZXMucHVzaChcbiAgICAgICAgICBsb2FkRmlsZSh0eXBlb2YgZmlsZSA9PT0gJ3N0cmluZycgPyBmaWxlIDogZmlsZS5kYXRhKS50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICB3YXNtLm1vdW50RXh0ZXJuYWxEYXRhIShwYXRoLCBkYXRhKTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gd2FpdCBmb3IgYWxsIGV4dGVybmFsIGRhdGEgZmlsZXMgdG8gYmUgbG9hZGVkXG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChsb2FkaW5nUHJvbWlzZXMpO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgcHJvdmlkZXIgb2Ygb3B0aW9ucz8uZXhlY3V0aW9uUHJvdmlkZXJzID8/IFtdKSB7XG4gICAgICBjb25zdCBwcm92aWRlck5hbWUgPSB0eXBlb2YgcHJvdmlkZXIgPT09ICdzdHJpbmcnID8gcHJvdmlkZXIgOiBwcm92aWRlci5uYW1lO1xuICAgICAgaWYgKHByb3ZpZGVyTmFtZSA9PT0gJ3dlYm5uJykge1xuICAgICAgICB3YXNtLnNob3VsZFRyYW5zZmVyVG9NTFRlbnNvciA9IGZhbHNlO1xuICAgICAgICBpZiAod2FzbS5jdXJyZW50Q29udGV4dCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2ViTk4gZXhlY3V0aW9uIHByb3ZpZGVyIGlzIGFscmVhZHkgc2V0LicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcHJvdmlkZXIgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgY29uc3Qgd2Vibm5PcHRpb25zID0gcHJvdmlkZXIgYXMgSW5mZXJlbmNlU2Vzc2lvbi5XZWJOTkV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSAod2Vibm5PcHRpb25zIGFzIEluZmVyZW5jZVNlc3Npb24uV2ViTk5PcHRpb25zV2l0aE1MQ29udGV4dCk/LmNvbnRleHQ7XG4gICAgICAgICAgY29uc3QgZ3B1RGV2aWNlID0gKHdlYm5uT3B0aW9ucyBhcyBJbmZlcmVuY2VTZXNzaW9uLldlYk5OT3B0aW9uc1dlYkdwdSk/LmdwdURldmljZTtcbiAgICAgICAgICBjb25zdCBkZXZpY2VUeXBlID0gKHdlYm5uT3B0aW9ucyBhcyBJbmZlcmVuY2VTZXNzaW9uLldlYk5OQ29udGV4dE9wdGlvbnMpPy5kZXZpY2VUeXBlO1xuICAgICAgICAgIGNvbnN0IG51bVRocmVhZHMgPSAod2Vibm5PcHRpb25zIGFzIEluZmVyZW5jZVNlc3Npb24uV2ViTk5Db250ZXh0T3B0aW9ucyk/Lm51bVRocmVhZHM7XG4gICAgICAgICAgY29uc3QgcG93ZXJQcmVmZXJlbmNlID0gKHdlYm5uT3B0aW9ucyBhcyBJbmZlcmVuY2VTZXNzaW9uLldlYk5OQ29udGV4dE9wdGlvbnMpPy5wb3dlclByZWZlcmVuY2U7XG4gICAgICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgICAgIHdhc20uY3VycmVudENvbnRleHQgPSBjb250ZXh0IGFzIE1MQ29udGV4dDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGdwdURldmljZSkge1xuICAgICAgICAgICAgd2FzbS5jdXJyZW50Q29udGV4dCA9IGF3YWl0IG5hdmlnYXRvci5tbC5jcmVhdGVDb250ZXh0KGdwdURldmljZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdhc20uY3VycmVudENvbnRleHQgPSBhd2FpdCBuYXZpZ2F0b3IubWwuY3JlYXRlQ29udGV4dCh7IGRldmljZVR5cGUsIG51bVRocmVhZHMsIHBvd2VyUHJlZmVyZW5jZSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FzbS5jdXJyZW50Q29udGV4dCA9IGF3YWl0IG5hdmlnYXRvci5tbC5jcmVhdGVDb250ZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2Vzc2lvbkhhbmRsZSA9IGF3YWl0IHdhc20uX09ydENyZWF0ZVNlc3Npb24obW9kZWxEYXRhT2Zmc2V0LCBtb2RlbERhdGFMZW5ndGgsIHNlc3Npb25PcHRpb25zSGFuZGxlKTtcbiAgICBpZiAoc2Vzc2lvbkhhbmRsZSA9PT0gMCkge1xuICAgICAgY2hlY2tMYXN0RXJyb3IoXCJDYW4ndCBjcmVhdGUgYSBzZXNzaW9uLlwiKTtcbiAgICB9XG5cbiAgICAvLyBjbGVhciBjdXJyZW50IE1MQ29udGV4dCBhZnRlciBzZXNzaW9uIGNyZWF0aW9uXG4gICAgaWYgKHdhc20uY3VycmVudENvbnRleHQpIHtcbiAgICAgIHdhc20uanNlcFJlZ2lzdGVyTUxDb250ZXh0IShzZXNzaW9uSGFuZGxlLCB3YXNtLmN1cnJlbnRDb250ZXh0KTtcbiAgICAgIHdhc20uY3VycmVudENvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgICB3YXNtLnNob3VsZFRyYW5zZmVyVG9NTFRlbnNvciA9IHRydWU7XG4gICAgfVxuXG4gICAgY29uc3QgW2lucHV0Q291bnQsIG91dHB1dENvdW50XSA9IGdldFNlc3Npb25JbnB1dE91dHB1dENvdW50KHNlc3Npb25IYW5kbGUpO1xuXG4gICAgY29uc3QgZW5hYmxlR3JhcGhDYXB0dXJlID0gISFvcHRpb25zPy5lbmFibGVHcmFwaENhcHR1cmU7XG5cbiAgICBjb25zdCBpbnB1dE5hbWVzID0gW107XG4gICAgY29uc3Qgb3V0cHV0TmFtZXMgPSBbXTtcbiAgICBjb25zdCBvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnM6IFN1cHBvcnRlZFRlbnNvckRhdGFMb2NhdGlvbkZvcklucHV0T3V0cHV0W10gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Q291bnQ7IGkrKykge1xuICAgICAgY29uc3QgbmFtZSA9IHdhc20uX09ydEdldElucHV0TmFtZShzZXNzaW9uSGFuZGxlLCBpKTtcbiAgICAgIGlmIChuYW1lID09PSAwKSB7XG4gICAgICAgIGNoZWNrTGFzdEVycm9yKFwiQ2FuJ3QgZ2V0IGFuIGlucHV0IG5hbWUuXCIpO1xuICAgICAgfVxuICAgICAgaW5wdXROYW1lc1VURjhFbmNvZGVkLnB1c2gobmFtZSk7XG4gICAgICBpbnB1dE5hbWVzLnB1c2god2FzbS5VVEY4VG9TdHJpbmcobmFtZSkpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dENvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IG5hbWUgPSB3YXNtLl9PcnRHZXRPdXRwdXROYW1lKHNlc3Npb25IYW5kbGUsIGkpO1xuICAgICAgaWYgKG5hbWUgPT09IDApIHtcbiAgICAgICAgY2hlY2tMYXN0RXJyb3IoXCJDYW4ndCBnZXQgYW4gb3V0cHV0IG5hbWUuXCIpO1xuICAgICAgfVxuICAgICAgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZC5wdXNoKG5hbWUpO1xuICAgICAgY29uc3QgbmFtZVN0cmluZyA9IHdhc20uVVRGOFRvU3RyaW5nKG5hbWUpO1xuICAgICAgb3V0cHV0TmFtZXMucHVzaChuYW1lU3RyaW5nKTtcblxuICAgICAgaWYgKCFCVUlMRF9ERUZTLkRJU0FCTEVfSlNFUCkge1xuICAgICAgICBpZiAoZW5hYmxlR3JhcGhDYXB0dXJlICYmIG9wdGlvbnM/LnByZWZlcnJlZE91dHB1dExvY2F0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnMucHVzaCgnZ3B1LWJ1ZmZlcicpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxvY2F0aW9uID1cbiAgICAgICAgICB0eXBlb2Ygb3B0aW9ucz8ucHJlZmVycmVkT3V0cHV0TG9jYXRpb24gPT09ICdzdHJpbmcnXG4gICAgICAgICAgICA/IG9wdGlvbnMucHJlZmVycmVkT3V0cHV0TG9jYXRpb25cbiAgICAgICAgICAgIDogKG9wdGlvbnM/LnByZWZlcnJlZE91dHB1dExvY2F0aW9uPy5bbmFtZVN0cmluZ10gPz8gJ2NwdScpO1xuICAgICAgICBpZiAobG9jYXRpb24gIT09ICdjcHUnICYmIGxvY2F0aW9uICE9PSAnY3B1LXBpbm5lZCcgJiYgbG9jYXRpb24gIT09ICdncHUtYnVmZmVyJyAmJiBsb2NhdGlvbiAhPT0gJ21sLXRlbnNvcicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vdCBzdXBwb3J0ZWQgcHJlZmVycmVkIG91dHB1dCBsb2NhdGlvbjogJHtsb2NhdGlvbn0uYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuYWJsZUdyYXBoQ2FwdHVyZSAmJiBsb2NhdGlvbiAhPT0gJ2dwdS1idWZmZXInKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYE5vdCBzdXBwb3J0ZWQgcHJlZmVycmVkIG91dHB1dCBsb2NhdGlvbjogJHtsb2NhdGlvbn0uIE9ubHkgJ2dwdS1idWZmZXInIGxvY2F0aW9uIGlzIHN1cHBvcnRlZCB3aGVuIGVuYWJsZUdyYXBoQ2FwdHVyZSBpcyB0cnVlLmAsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnMucHVzaChsb2NhdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdXNlIElPIGJpbmRpbmcgb25seSB3aGVuIGF0IGxlYXN0IG9uZSBvdXRwdXQgaXMgcHJlZmVycmVkIHRvIGJlIG9uIEdQVS5cbiAgICBsZXQgYmluZGluZ1N0YXRlOiBJT0JpbmRpbmdTdGF0ZSB8IG51bGwgPSBudWxsO1xuICAgIGlmICghQlVJTERfREVGUy5ESVNBQkxFX0pTRVAgJiYgb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zLnNvbWUoKGwpID0+IGwgPT09ICdncHUtYnVmZmVyJyB8fCBsID09PSAnbWwtdGVuc29yJykpIHtcbiAgICAgIGlvQmluZGluZ0hhbmRsZSA9IHdhc20uX09ydENyZWF0ZUJpbmRpbmcoc2Vzc2lvbkhhbmRsZSk7XG4gICAgICBpZiAoaW9CaW5kaW5nSGFuZGxlID09PSAwKSB7XG4gICAgICAgIGNoZWNrTGFzdEVycm9yKFwiQ2FuJ3QgY3JlYXRlIElPIGJpbmRpbmcuXCIpO1xuICAgICAgfVxuXG4gICAgICBiaW5kaW5nU3RhdGUgPSB7XG4gICAgICAgIGhhbmRsZTogaW9CaW5kaW5nSGFuZGxlLFxuICAgICAgICBvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnMsXG4gICAgICAgIG91dHB1dFByZWZlcnJlZExvY2F0aW9uc0VuY29kZWQ6IG91dHB1dFByZWZlcnJlZExvY2F0aW9ucy5tYXAoKGwpID0+IGRhdGFMb2NhdGlvblN0cmluZ1RvRW51bShsKSksXG4gICAgICB9O1xuICAgIH1cblxuICAgIGFjdGl2ZVNlc3Npb25zLnNldChzZXNzaW9uSGFuZGxlLCBbXG4gICAgICBzZXNzaW9uSGFuZGxlLFxuICAgICAgaW5wdXROYW1lc1VURjhFbmNvZGVkLFxuICAgICAgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZCxcbiAgICAgIGJpbmRpbmdTdGF0ZSxcbiAgICAgIGVuYWJsZUdyYXBoQ2FwdHVyZSxcbiAgICAgIGZhbHNlLFxuICAgIF0pO1xuICAgIHJldHVybiBbc2Vzc2lvbkhhbmRsZSwgaW5wdXROYW1lcywgb3V0cHV0TmFtZXNdO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaW5wdXROYW1lc1VURjhFbmNvZGVkLmZvckVhY2goKGJ1ZikgPT4gd2FzbS5fT3J0RnJlZShidWYpKTtcbiAgICBvdXRwdXROYW1lc1VURjhFbmNvZGVkLmZvckVhY2goKGJ1ZikgPT4gd2FzbS5fT3J0RnJlZShidWYpKTtcblxuICAgIGlmIChpb0JpbmRpbmdIYW5kbGUgIT09IDApIHtcbiAgICAgIHdhc20uX09ydFJlbGVhc2VCaW5kaW5nKGlvQmluZGluZ0hhbmRsZSk7XG4gICAgfVxuXG4gICAgaWYgKHNlc3Npb25IYW5kbGUgIT09IDApIHtcbiAgICAgIHdhc20uX09ydFJlbGVhc2VTZXNzaW9uKHNlc3Npb25IYW5kbGUpO1xuICAgIH1cbiAgICB0aHJvdyBlO1xuICB9IGZpbmFsbHkge1xuICAgIHdhc20uX2ZyZWUobW9kZWxEYXRhT2Zmc2V0KTtcbiAgICBpZiAoc2Vzc2lvbk9wdGlvbnNIYW5kbGUgIT09IDApIHtcbiAgICAgIHdhc20uX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucyhzZXNzaW9uT3B0aW9uc0hhbmRsZSk7XG4gICAgfVxuICAgIGFsbG9jcy5mb3JFYWNoKChhbGxvYykgPT4gd2FzbS5fZnJlZShhbGxvYykpO1xuXG4gICAgLy8gdW5tb3VudCBleHRlcm5hbCBkYXRhIGlmIG5lY2Vzc2FyeVxuICAgIHdhc20udW5tb3VudEV4dGVybmFsRGF0YT8uKCk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCByZWxlYXNlU2Vzc2lvbiA9IChzZXNzaW9uSWQ6IG51bWJlcik6IHZvaWQgPT4ge1xuICBjb25zdCB3YXNtID0gZ2V0SW5zdGFuY2UoKTtcbiAgY29uc3Qgc2Vzc2lvbiA9IGFjdGl2ZVNlc3Npb25zLmdldChzZXNzaW9uSWQpO1xuICBpZiAoIXNlc3Npb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCByZWxlYXNlIHNlc3Npb24uIGludmFsaWQgc2Vzc2lvbiBpZDogJHtzZXNzaW9uSWR9YCk7XG4gIH1cbiAgY29uc3QgW3Nlc3Npb25IYW5kbGUsIGlucHV0TmFtZXNVVEY4RW5jb2RlZCwgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZCwgaW9CaW5kaW5nU3RhdGUsIGVuYWJsZUdyYXBoQ2FwdHVyZV0gPSBzZXNzaW9uO1xuXG4gIGlmIChpb0JpbmRpbmdTdGF0ZSkge1xuICAgIGlmIChlbmFibGVHcmFwaENhcHR1cmUpIHtcbiAgICAgIHdhc20uX09ydENsZWFyQm91bmRPdXRwdXRzKGlvQmluZGluZ1N0YXRlLmhhbmRsZSk7XG4gICAgfVxuICAgIHdhc20uX09ydFJlbGVhc2VCaW5kaW5nKGlvQmluZGluZ1N0YXRlLmhhbmRsZSk7XG4gIH1cblxuICB3YXNtLmpzZXBPblJlbGVhc2VTZXNzaW9uPy4oc2Vzc2lvbklkKTtcblxuICBpbnB1dE5hbWVzVVRGOEVuY29kZWQuZm9yRWFjaCgoYnVmKSA9PiB3YXNtLl9PcnRGcmVlKGJ1ZikpO1xuICBvdXRwdXROYW1lc1VURjhFbmNvZGVkLmZvckVhY2goKGJ1ZikgPT4gd2FzbS5fT3J0RnJlZShidWYpKTtcbiAgd2FzbS5fT3J0UmVsZWFzZVNlc3Npb24oc2Vzc2lvbkhhbmRsZSk7XG4gIGFjdGl2ZVNlc3Npb25zLmRlbGV0ZShzZXNzaW9uSWQpO1xufTtcblxuZXhwb3J0IGNvbnN0IHByZXBhcmVJbnB1dE91dHB1dFRlbnNvciA9IChcbiAgdGVuc29yOiBUZW5zb3JNZXRhZGF0YSB8IG51bGwsXG4gIHRlbnNvckhhbmRsZXM6IG51bWJlcltdLFxuICBhbGxvY3M6IG51bWJlcltdLFxuICBzZXNzaW9uSWQ6IG51bWJlcixcbiAgaW5kZXg6IG51bWJlcixcbiAgZW5hYmxlR3JhcGhDYXB0dXJlID0gZmFsc2UsXG4pOiB2b2lkID0+IHtcbiAgaWYgKCF0ZW5zb3IpIHtcbiAgICB0ZW5zb3JIYW5kbGVzLnB1c2goMCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgd2FzbSA9IGdldEluc3RhbmNlKCk7XG5cbiAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JbMF07XG4gIGNvbnN0IGRpbXMgPSB0ZW5zb3JbMV07XG4gIGNvbnN0IGxvY2F0aW9uID0gdGVuc29yWzNdO1xuXG4gIGxldCByYXdEYXRhOiBudW1iZXI7XG4gIGxldCBkYXRhQnl0ZUxlbmd0aDogbnVtYmVyO1xuXG4gIGlmIChkYXRhVHlwZSA9PT0gJ3N0cmluZycgJiYgKGxvY2F0aW9uID09PSAnZ3B1LWJ1ZmZlcicgfHwgbG9jYXRpb24gPT09ICdtbC10ZW5zb3InKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignU3RyaW5nIHRlbnNvciBpcyBub3Qgc3VwcG9ydGVkIG9uIEdQVS4nKTtcbiAgfVxuXG4gIGlmIChlbmFibGVHcmFwaENhcHR1cmUgJiYgbG9jYXRpb24gIT09ICdncHUtYnVmZmVyJykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBFeHRlcm5hbCBidWZmZXIgbXVzdCBiZSBwcm92aWRlZCBmb3IgaW5wdXQvb3V0cHV0IGluZGV4ICR7aW5kZXh9IHdoZW4gZW5hYmxlR3JhcGhDYXB0dXJlIGlzIHRydWUuYCxcbiAgICApO1xuICB9XG5cbiAgaWYgKGxvY2F0aW9uID09PSAnZ3B1LWJ1ZmZlcicpIHtcbiAgICBjb25zdCBncHVCdWZmZXIgPSB0ZW5zb3JbMl0uZ3B1QnVmZmVyIGFzIEdQVUJ1ZmZlcjtcbiAgICBkYXRhQnl0ZUxlbmd0aCA9IGNhbGN1bGF0ZVRlbnNvclNpemVJbkJ5dGVzKHRlbnNvckRhdGFUeXBlU3RyaW5nVG9FbnVtKGRhdGFUeXBlKSwgZGltcykhO1xuXG4gICAgY29uc3QgcmVnaXN0ZXJCdWZmZXIgPSB3YXNtLmpzZXBSZWdpc3RlckJ1ZmZlcjtcbiAgICBpZiAoIXJlZ2lzdGVyQnVmZmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RlbnNvciBsb2NhdGlvbiBcImdwdS1idWZmZXJcIiBpcyBub3Qgc3VwcG9ydGVkIHdpdGhvdXQgdXNpbmcgV2ViR1BVLicpO1xuICAgIH1cbiAgICByYXdEYXRhID0gcmVnaXN0ZXJCdWZmZXIoc2Vzc2lvbklkLCBpbmRleCwgZ3B1QnVmZmVyLCBkYXRhQnl0ZUxlbmd0aCk7XG4gIH0gZWxzZSBpZiAobG9jYXRpb24gPT09ICdtbC10ZW5zb3InKSB7XG4gICAgY29uc3QgbWxUZW5zb3IgPSB0ZW5zb3JbMl0ubWxUZW5zb3IgYXMgTUxUZW5zb3I7XG4gICAgZGF0YUJ5dGVMZW5ndGggPSBjYWxjdWxhdGVUZW5zb3JTaXplSW5CeXRlcyh0ZW5zb3JEYXRhVHlwZVN0cmluZ1RvRW51bShkYXRhVHlwZSksIGRpbXMpITtcblxuICAgIGNvbnN0IHJlZ2lzdGVyTUxUZW5zb3IgPSB3YXNtLmpzZXBSZWdpc3Rlck1MVGVuc29yO1xuICAgIGlmICghcmVnaXN0ZXJNTFRlbnNvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZW5zb3IgbG9jYXRpb24gXCJtbC10ZW5zb3JcIiBpcyBub3Qgc3VwcG9ydGVkIHdpdGhvdXQgdXNpbmcgV2ViTk4uJyk7XG4gICAgfVxuICAgIHJhd0RhdGEgPSByZWdpc3Rlck1MVGVuc29yKG1sVGVuc29yLCB0ZW5zb3JEYXRhVHlwZVN0cmluZ1RvRW51bShkYXRhVHlwZSksIGRpbXMpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGRhdGEgPSB0ZW5zb3JbMl07XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgLy8gc3RyaW5nIHRlbnNvclxuICAgICAgZGF0YUJ5dGVMZW5ndGggPSA0ICogZGF0YS5sZW5ndGg7XG4gICAgICByYXdEYXRhID0gd2FzbS5fbWFsbG9jKGRhdGFCeXRlTGVuZ3RoKTtcbiAgICAgIGFsbG9jcy5wdXNoKHJhd0RhdGEpO1xuICAgICAgbGV0IGRhdGFJbmRleCA9IHJhd0RhdGEgLyA0O1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YVtpXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB0ZW5zb3IgZGF0YSBhdCBpbmRleCAke2l9IGlzIG5vdCBhIHN0cmluZ2ApO1xuICAgICAgICB9XG4gICAgICAgIHdhc20uSEVBUFUzMltkYXRhSW5kZXgrK10gPSBhbGxvY1dhc21TdHJpbmcoZGF0YVtpXSwgYWxsb2NzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YUJ5dGVMZW5ndGggPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICByYXdEYXRhID0gd2FzbS5fbWFsbG9jKGRhdGFCeXRlTGVuZ3RoKTtcbiAgICAgIGFsbG9jcy5wdXNoKHJhd0RhdGEpO1xuICAgICAgd2FzbS5IRUFQVTguc2V0KG5ldyBVaW50OEFycmF5KGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGRhdGFCeXRlTGVuZ3RoKSwgcmF3RGF0YSk7XG4gICAgfVxuICB9XG5cbiAgY29uc3Qgc3RhY2sgPSB3YXNtLnN0YWNrU2F2ZSgpO1xuICBjb25zdCBkaW1zT2Zmc2V0ID0gd2FzbS5zdGFja0FsbG9jKDQgKiBkaW1zLmxlbmd0aCk7XG4gIHRyeSB7XG4gICAgbGV0IGRpbUluZGV4ID0gZGltc09mZnNldCAvIDQ7XG4gICAgZGltcy5mb3JFYWNoKChkKSA9PiAod2FzbS5IRUFQMzJbZGltSW5kZXgrK10gPSBkKSk7XG4gICAgY29uc3QgdGVuc29yID0gd2FzbS5fT3J0Q3JlYXRlVGVuc29yKFxuICAgICAgdGVuc29yRGF0YVR5cGVTdHJpbmdUb0VudW0oZGF0YVR5cGUpLFxuICAgICAgcmF3RGF0YSxcbiAgICAgIGRhdGFCeXRlTGVuZ3RoLFxuICAgICAgZGltc09mZnNldCxcbiAgICAgIGRpbXMubGVuZ3RoLFxuICAgICAgZGF0YUxvY2F0aW9uU3RyaW5nVG9FbnVtKGxvY2F0aW9uKSxcbiAgICApO1xuICAgIGlmICh0ZW5zb3IgPT09IDApIHtcbiAgICAgIGNoZWNrTGFzdEVycm9yKGBDYW4ndCBjcmVhdGUgdGVuc29yIGZvciBpbnB1dC9vdXRwdXQuIHNlc3Npb249JHtzZXNzaW9uSWR9LCBpbmRleD0ke2luZGV4fS5gKTtcbiAgICB9XG4gICAgdGVuc29ySGFuZGxlcy5wdXNoKHRlbnNvcik7XG4gIH0gZmluYWxseSB7XG4gICAgd2FzbS5zdGFja1Jlc3RvcmUoc3RhY2spO1xuICB9XG59O1xuXG4vKipcbiAqIHBlcmZvcm0gaW5mZXJlbmNlIHJ1blxuICovXG5leHBvcnQgY29uc3QgcnVuID0gYXN5bmMgKFxuICBzZXNzaW9uSWQ6IG51bWJlcixcbiAgaW5wdXRJbmRpY2VzOiBudW1iZXJbXSxcbiAgaW5wdXRUZW5zb3JzOiBUZW5zb3JNZXRhZGF0YVtdLFxuICBvdXRwdXRJbmRpY2VzOiBudW1iZXJbXSxcbiAgb3V0cHV0VGVuc29yczogQXJyYXk8VGVuc29yTWV0YWRhdGEgfCBudWxsPixcbiAgb3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zLFxuKTogUHJvbWlzZTxUZW5zb3JNZXRhZGF0YVtdPiA9PiB7XG4gIGNvbnN0IHdhc20gPSBnZXRJbnN0YW5jZSgpO1xuICBjb25zdCBzZXNzaW9uID0gYWN0aXZlU2Vzc2lvbnMuZ2V0KHNlc3Npb25JZCk7XG4gIGlmICghc2Vzc2lvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IHJ1biBpbmZlcmVuY2UuIGludmFsaWQgc2Vzc2lvbiBpZDogJHtzZXNzaW9uSWR9YCk7XG4gIH1cbiAgY29uc3Qgc2Vzc2lvbkhhbmRsZSA9IHNlc3Npb25bMF07XG4gIGNvbnN0IGlucHV0TmFtZXNVVEY4RW5jb2RlZCA9IHNlc3Npb25bMV07XG4gIGNvbnN0IG91dHB1dE5hbWVzVVRGOEVuY29kZWQgPSBzZXNzaW9uWzJdO1xuICBjb25zdCBpb0JpbmRpbmdTdGF0ZSA9IHNlc3Npb25bM107XG4gIGNvbnN0IGVuYWJsZUdyYXBoQ2FwdHVyZSA9IHNlc3Npb25bNF07XG4gIGNvbnN0IGlucHV0T3V0cHV0Qm91bmQgPSBzZXNzaW9uWzVdO1xuXG4gIGNvbnN0IGlucHV0Q291bnQgPSBpbnB1dEluZGljZXMubGVuZ3RoO1xuICBjb25zdCBvdXRwdXRDb3VudCA9IG91dHB1dEluZGljZXMubGVuZ3RoO1xuXG4gIGxldCBydW5PcHRpb25zSGFuZGxlID0gMDtcbiAgbGV0IHJ1bk9wdGlvbnNBbGxvY3M6IG51bWJlcltdID0gW107XG5cbiAgY29uc3QgaW5wdXRUZW5zb3JIYW5kbGVzOiBudW1iZXJbXSA9IFtdO1xuICBjb25zdCBvdXRwdXRUZW5zb3JIYW5kbGVzOiBudW1iZXJbXSA9IFtdO1xuICBjb25zdCBpbnB1dE91dHB1dEFsbG9jczogbnVtYmVyW10gPSBbXTtcblxuICBjb25zdCBiZWZvcmVSdW5TdGFjayA9IHdhc20uc3RhY2tTYXZlKCk7XG4gIGNvbnN0IGlucHV0VmFsdWVzT2Zmc2V0ID0gd2FzbS5zdGFja0FsbG9jKGlucHV0Q291bnQgKiA0KTtcbiAgY29uc3QgaW5wdXROYW1lc09mZnNldCA9IHdhc20uc3RhY2tBbGxvYyhpbnB1dENvdW50ICogNCk7XG4gIGNvbnN0IG91dHB1dFZhbHVlc09mZnNldCA9IHdhc20uc3RhY2tBbGxvYyhvdXRwdXRDb3VudCAqIDQpO1xuICBjb25zdCBvdXRwdXROYW1lc09mZnNldCA9IHdhc20uc3RhY2tBbGxvYyhvdXRwdXRDb3VudCAqIDQpO1xuXG4gIHRyeSB7XG4gICAgLy8gV2ViTk4gYmFja2VuZCBuZWVkcyB0aGUgYWN0aXZlIHNlc3Npb24gdG8gY2hlY2sgTUxUZW5zb3JzIHdpdGggdGhlIGN1cnJlbnQgY29udGV4dC5cbiAgICB3YXNtLmpzZXBPblJ1blN0YXJ0Py4oc2Vzc2lvbkhhbmRsZSk7XG5cbiAgICBbcnVuT3B0aW9uc0hhbmRsZSwgcnVuT3B0aW9uc0FsbG9jc10gPSBzZXRSdW5PcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgLy8gY3JlYXRlIGlucHV0IHRlbnNvcnNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Q291bnQ7IGkrKykge1xuICAgICAgcHJlcGFyZUlucHV0T3V0cHV0VGVuc29yKFxuICAgICAgICBpbnB1dFRlbnNvcnNbaV0sXG4gICAgICAgIGlucHV0VGVuc29ySGFuZGxlcyxcbiAgICAgICAgaW5wdXRPdXRwdXRBbGxvY3MsXG4gICAgICAgIHNlc3Npb25JZCxcbiAgICAgICAgaW5wdXRJbmRpY2VzW2ldLFxuICAgICAgICBlbmFibGVHcmFwaENhcHR1cmUsXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBvdXRwdXQgdGVuc29yc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0cHV0Q291bnQ7IGkrKykge1xuICAgICAgcHJlcGFyZUlucHV0T3V0cHV0VGVuc29yKFxuICAgICAgICBvdXRwdXRUZW5zb3JzW2ldLFxuICAgICAgICBvdXRwdXRUZW5zb3JIYW5kbGVzLFxuICAgICAgICBpbnB1dE91dHB1dEFsbG9jcyxcbiAgICAgICAgc2Vzc2lvbklkLFxuICAgICAgICBpbnB1dENvdW50ICsgb3V0cHV0SW5kaWNlc1tpXSxcbiAgICAgICAgZW5hYmxlR3JhcGhDYXB0dXJlLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBsZXQgaW5wdXRWYWx1ZXNJbmRleCA9IGlucHV0VmFsdWVzT2Zmc2V0IC8gNDtcbiAgICBsZXQgaW5wdXROYW1lc0luZGV4ID0gaW5wdXROYW1lc09mZnNldCAvIDQ7XG4gICAgbGV0IG91dHB1dFZhbHVlc0luZGV4ID0gb3V0cHV0VmFsdWVzT2Zmc2V0IC8gNDtcbiAgICBsZXQgb3V0cHV0TmFtZXNJbmRleCA9IG91dHB1dE5hbWVzT2Zmc2V0IC8gNDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Q291bnQ7IGkrKykge1xuICAgICAgd2FzbS5IRUFQVTMyW2lucHV0VmFsdWVzSW5kZXgrK10gPSBpbnB1dFRlbnNvckhhbmRsZXNbaV07XG4gICAgICB3YXNtLkhFQVBVMzJbaW5wdXROYW1lc0luZGV4KytdID0gaW5wdXROYW1lc1VURjhFbmNvZGVkW2lucHV0SW5kaWNlc1tpXV07XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0cHV0Q291bnQ7IGkrKykge1xuICAgICAgd2FzbS5IRUFQVTMyW291dHB1dFZhbHVlc0luZGV4KytdID0gb3V0cHV0VGVuc29ySGFuZGxlc1tpXTtcbiAgICAgIHdhc20uSEVBUFUzMltvdXRwdXROYW1lc0luZGV4KytdID0gb3V0cHV0TmFtZXNVVEY4RW5jb2RlZFtvdXRwdXRJbmRpY2VzW2ldXTtcbiAgICB9XG5cbiAgICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9KU0VQICYmIGlvQmluZGluZ1N0YXRlICYmICFpbnB1dE91dHB1dEJvdW5kKSB7XG4gICAgICBjb25zdCB7IGhhbmRsZSwgb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zLCBvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnNFbmNvZGVkIH0gPSBpb0JpbmRpbmdTdGF0ZTtcblxuICAgICAgaWYgKGlucHV0TmFtZXNVVEY4RW5jb2RlZC5sZW5ndGggIT09IGlucHV0Q291bnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBpbnB1dCBjb3VudCBmcm9tIGZlZWRzICgke2lucHV0Q291bnR9KSBpcyBleHBlY3RlZCB0byBiZSBhbHdheXMgZXF1YWwgdG8gbW9kZWwncyBpbnB1dCBjb3VudCAoJHtpbnB1dE5hbWVzVVRGOEVuY29kZWQubGVuZ3RofSkuYCxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gcHJvY2VzcyBpbnB1dHNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRDb3VudDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gaW5wdXRJbmRpY2VzW2ldO1xuICAgICAgICBjb25zdCBlcnJvckNvZGUgPSBhd2FpdCB3YXNtLl9PcnRCaW5kSW5wdXQoaGFuZGxlLCBpbnB1dE5hbWVzVVRGOEVuY29kZWRbaW5kZXhdLCBpbnB1dFRlbnNvckhhbmRsZXNbaV0pO1xuICAgICAgICBpZiAoZXJyb3JDb2RlICE9PSAwKSB7XG4gICAgICAgICAgY2hlY2tMYXN0RXJyb3IoYENhbid0IGJpbmQgaW5wdXRbJHtpfV0gZm9yIHNlc3Npb249JHtzZXNzaW9uSWR9LmApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHByb2Nlc3MgcHJlLWFsbG9jYXRlZCBvdXRwdXRzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dENvdW50OyBpKyspIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBvdXRwdXRJbmRpY2VzW2ldO1xuICAgICAgICBjb25zdCBsb2NhdGlvbiA9IG91dHB1dFRlbnNvcnNbaV0/LlszXTsgLy8gdW5kZWZpbmVkIG1lYW5zIG91dHB1dCBpcyBub3QgcHJlLWFsbG9jYXRlZC5cblxuICAgICAgICBpZiAobG9jYXRpb24pIHtcbiAgICAgICAgICAvLyBvdXRwdXQgaXMgcHJlLWFsbG9jYXRlZC4gYmluZCB0aGUgdGVuc29yLlxuICAgICAgICAgIGNvbnN0IGVycm9yQ29kZSA9IHdhc20uX09ydEJpbmRPdXRwdXQoaGFuZGxlLCBvdXRwdXROYW1lc1VURjhFbmNvZGVkW2luZGV4XSwgb3V0cHV0VGVuc29ySGFuZGxlc1tpXSwgMCk7XG4gICAgICAgICAgaWYgKGVycm9yQ29kZSAhPT0gMCkge1xuICAgICAgICAgICAgY2hlY2tMYXN0RXJyb3IoYENhbid0IGJpbmQgcHJlLWFsbG9jYXRlZCBvdXRwdXRbJHtpfV0gZm9yIHNlc3Npb249JHtzZXNzaW9uSWR9LmApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBvdXRwdXQgaXMgbm90IHByZS1hbGxvY2F0ZWQuIHJlc2V0IHByZWZlcnJlZCBsb2NhdGlvbi5cbiAgICAgICAgICBjb25zdCBlcnJvckNvZGUgPSB3YXNtLl9PcnRCaW5kT3V0cHV0KFxuICAgICAgICAgICAgaGFuZGxlLFxuICAgICAgICAgICAgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZFtpbmRleF0sXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zRW5jb2RlZFtpbmRleF0sXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoZXJyb3JDb2RlICE9PSAwKSB7XG4gICAgICAgICAgICBjaGVja0xhc3RFcnJvcihgQ2FuJ3QgYmluZCBvdXRwdXRbJHtpfV0gdG8gJHtvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnNbaV19IGZvciBzZXNzaW9uPSR7c2Vzc2lvbklkfS5gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFjdGl2ZVNlc3Npb25zLnNldChzZXNzaW9uSWQsIFtcbiAgICAgICAgc2Vzc2lvbkhhbmRsZSxcbiAgICAgICAgaW5wdXROYW1lc1VURjhFbmNvZGVkLFxuICAgICAgICBvdXRwdXROYW1lc1VURjhFbmNvZGVkLFxuICAgICAgICBpb0JpbmRpbmdTdGF0ZSxcbiAgICAgICAgZW5hYmxlR3JhcGhDYXB0dXJlLFxuICAgICAgICB0cnVlLFxuICAgICAgXSk7XG4gICAgfVxuXG4gICAgbGV0IGVycm9yQ29kZTogbnVtYmVyO1xuICAgIGlmICghQlVJTERfREVGUy5ESVNBQkxFX0pTRVAgJiYgaW9CaW5kaW5nU3RhdGUpIHtcbiAgICAgIGVycm9yQ29kZSA9IGF3YWl0IHdhc20uX09ydFJ1bldpdGhCaW5kaW5nKFxuICAgICAgICBzZXNzaW9uSGFuZGxlLFxuICAgICAgICBpb0JpbmRpbmdTdGF0ZS5oYW5kbGUsXG4gICAgICAgIG91dHB1dENvdW50LFxuICAgICAgICBvdXRwdXRWYWx1ZXNPZmZzZXQsXG4gICAgICAgIHJ1bk9wdGlvbnNIYW5kbGUsXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvckNvZGUgPSBhd2FpdCB3YXNtLl9PcnRSdW4oXG4gICAgICAgIHNlc3Npb25IYW5kbGUsXG4gICAgICAgIGlucHV0TmFtZXNPZmZzZXQsXG4gICAgICAgIGlucHV0VmFsdWVzT2Zmc2V0LFxuICAgICAgICBpbnB1dENvdW50LFxuICAgICAgICBvdXRwdXROYW1lc09mZnNldCxcbiAgICAgICAgb3V0cHV0Q291bnQsXG4gICAgICAgIG91dHB1dFZhbHVlc09mZnNldCxcbiAgICAgICAgcnVuT3B0aW9uc0hhbmRsZSxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGVycm9yQ29kZSAhPT0gMCkge1xuICAgICAgY2hlY2tMYXN0RXJyb3IoJ2ZhaWxlZCB0byBjYWxsIE9ydFJ1bigpLicpO1xuICAgIH1cblxuICAgIGNvbnN0IG91dHB1dDogVGVuc29yTWV0YWRhdGFbXSA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXRDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCB0ZW5zb3IgPSB3YXNtLkhFQVBVMzJbb3V0cHV0VmFsdWVzT2Zmc2V0IC8gNCArIGldO1xuICAgICAgaWYgKHRlbnNvciA9PT0gb3V0cHV0VGVuc29ySGFuZGxlc1tpXSkge1xuICAgICAgICAvLyBvdXRwdXQgdGVuc29yIGlzIHByZS1hbGxvY2F0ZWQuIG5vIG5lZWQgdG8gY29weSBkYXRhLlxuICAgICAgICBvdXRwdXQucHVzaChvdXRwdXRUZW5zb3JzW2ldISk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBiZWZvcmVHZXRUZW5zb3JEYXRhU3RhY2sgPSB3YXNtLnN0YWNrU2F2ZSgpO1xuICAgICAgLy8gc3RhY2sgYWxsb2NhdGUgNCBwb2ludGVyIHZhbHVlXG4gICAgICBjb25zdCB0ZW5zb3JEYXRhT2Zmc2V0ID0gd2FzbS5zdGFja0FsbG9jKDQgKiA0KTtcblxuICAgICAgbGV0IGtlZXBPdXRwdXRUZW5zb3IgPSBmYWxzZTtcbiAgICAgIGxldCB0eXBlOiBUZW5zb3IuVHlwZSB8IHVuZGVmaW5lZCxcbiAgICAgICAgZGF0YU9mZnNldCA9IDA7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBlcnJvckNvZGUgPSB3YXNtLl9PcnRHZXRUZW5zb3JEYXRhKFxuICAgICAgICAgIHRlbnNvcixcbiAgICAgICAgICB0ZW5zb3JEYXRhT2Zmc2V0LFxuICAgICAgICAgIHRlbnNvckRhdGFPZmZzZXQgKyA0LFxuICAgICAgICAgIHRlbnNvckRhdGFPZmZzZXQgKyA4LFxuICAgICAgICAgIHRlbnNvckRhdGFPZmZzZXQgKyAxMixcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGVycm9yQ29kZSAhPT0gMCkge1xuICAgICAgICAgIGNoZWNrTGFzdEVycm9yKGBDYW4ndCBhY2Nlc3Mgb3V0cHV0IHRlbnNvciBkYXRhIG9uIGluZGV4ICR7aX0uYCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRlbnNvckRhdGFJbmRleCA9IHRlbnNvckRhdGFPZmZzZXQgLyA0O1xuICAgICAgICBjb25zdCBkYXRhVHlwZSA9IHdhc20uSEVBUFUzMlt0ZW5zb3JEYXRhSW5kZXgrK107XG4gICAgICAgIGRhdGFPZmZzZXQgPSB3YXNtLkhFQVBVMzJbdGVuc29yRGF0YUluZGV4KytdO1xuICAgICAgICBjb25zdCBkaW1zT2Zmc2V0ID0gd2FzbS5IRUFQVTMyW3RlbnNvckRhdGFJbmRleCsrXTtcbiAgICAgICAgY29uc3QgZGltc0xlbmd0aCA9IHdhc20uSEVBUFUzMlt0ZW5zb3JEYXRhSW5kZXgrK107XG4gICAgICAgIGNvbnN0IGRpbXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaW1zTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBkaW1zLnB1c2god2FzbS5IRUFQVTMyW2RpbXNPZmZzZXQgLyA0ICsgaV0pO1xuICAgICAgICB9XG4gICAgICAgIHdhc20uX09ydEZyZWUoZGltc09mZnNldCk7XG5cbiAgICAgICAgY29uc3Qgc2l6ZSA9IGRpbXMucmVkdWNlKChhLCBiKSA9PiBhICogYiwgMSk7XG4gICAgICAgIHR5cGUgPSB0ZW5zb3JEYXRhVHlwZUVudW1Ub1N0cmluZyhkYXRhVHlwZSk7XG5cbiAgICAgICAgY29uc3QgcHJlZmVycmVkTG9jYXRpb24gPSBpb0JpbmRpbmdTdGF0ZT8ub3V0cHV0UHJlZmVycmVkTG9jYXRpb25zW291dHB1dEluZGljZXNbaV1dO1xuXG4gICAgICAgIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlmIChwcmVmZXJyZWRMb2NhdGlvbiA9PT0gJ2dwdS1idWZmZXInIHx8IHByZWZlcnJlZExvY2F0aW9uID09PSAnbWwtdGVuc29yJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdHJpbmcgdGVuc29yIGlzIG5vdCBzdXBwb3J0ZWQgb24gR1BVLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBzdHJpbmdEYXRhOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICAgIGxldCBkYXRhSW5kZXggPSBkYXRhT2Zmc2V0IC8gNDtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gd2FzbS5IRUFQVTMyW2RhdGFJbmRleCsrXTtcbiAgICAgICAgICAgIGNvbnN0IG1heEJ5dGVzVG9SZWFkID0gaSA9PT0gc2l6ZSAtIDEgPyB1bmRlZmluZWQgOiB3YXNtLkhFQVBVMzJbZGF0YUluZGV4XSAtIG9mZnNldDtcbiAgICAgICAgICAgIHN0cmluZ0RhdGEucHVzaCh3YXNtLlVURjhUb1N0cmluZyhvZmZzZXQsIG1heEJ5dGVzVG9SZWFkKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dHB1dC5wdXNoKFt0eXBlLCBkaW1zLCBzdHJpbmdEYXRhLCAnY3B1J10pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElmIGEgY2VydGFpbiBvdXRwdXQncyBwcmVmZXJyZWQgbG9jYXRpb24gaXMgR1BVIGJ1dCB0aGUgdGVuc29yIGlzIGVtcHR5LCB3ZSBzdGlsbCBuZWVkIHRvIGNyZWF0ZSBhIENQVVxuICAgICAgICAgIC8vIHRlbnNvciBmb3IgaXQuIFRoZXJlIGlzIG5vIG1hcHBpbmcgR1BVIGJ1ZmZlciBmb3IgYW4gZW1wdHkgdGVuc29yLlxuICAgICAgICAgIGlmIChwcmVmZXJyZWRMb2NhdGlvbiA9PT0gJ2dwdS1idWZmZXInICYmIHNpemUgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBnZXRCdWZmZXIgPSB3YXNtLmpzZXBHZXRCdWZmZXI7XG4gICAgICAgICAgICBpZiAoIWdldEJ1ZmZlcikge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ByZWZlcnJlZExvY2F0aW9uIFwiZ3B1LWJ1ZmZlclwiIGlzIG5vdCBzdXBwb3J0ZWQgd2l0aG91dCB1c2luZyBXZWJHUFUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBncHVCdWZmZXIgPSBnZXRCdWZmZXIoZGF0YU9mZnNldCk7XG4gICAgICAgICAgICBjb25zdCBidWZmZXJTaXplID0gY2FsY3VsYXRlVGVuc29yU2l6ZUluQnl0ZXMoZGF0YVR5cGUsIHNpemUpO1xuICAgICAgICAgICAgaWYgKGJ1ZmZlclNpemUgPT09IHVuZGVmaW5lZCB8fCAhaXNHcHVCdWZmZXJTdXBwb3J0ZWRUeXBlKHR5cGUpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke3R5cGV9YCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGRvIG5vdCByZWxlYXNlIHRoZSB0ZW5zb3IgcmlnaHQgbm93LiBpdCB3aWxsIGJlIHJlbGVhc2VkIHdoZW4gdXNlciBjYWxscyB0ZW5zb3IuZGlzcG9zZSgpLlxuICAgICAgICAgICAga2VlcE91dHB1dFRlbnNvciA9IHRydWU7XG5cbiAgICAgICAgICAgIG91dHB1dC5wdXNoKFtcbiAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgZGltcyxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGdwdUJ1ZmZlcixcbiAgICAgICAgICAgICAgICBkb3dubG9hZDogd2FzbS5qc2VwQ3JlYXRlRG93bmxvYWRlciEoZ3B1QnVmZmVyLCBidWZmZXJTaXplLCB0eXBlKSxcbiAgICAgICAgICAgICAgICBkaXNwb3NlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICB3YXNtLl9PcnRSZWxlYXNlVGVuc29yKHRlbnNvcik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgJ2dwdS1idWZmZXInLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChwcmVmZXJyZWRMb2NhdGlvbiA9PT0gJ21sLXRlbnNvcicgJiYgc2l6ZSA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGVuc3VyZVRlbnNvciA9IHdhc20uanNlcEVuc3VyZVRlbnNvcjtcbiAgICAgICAgICAgIGlmICghZW5zdXJlVGVuc29yKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncHJlZmVycmVkTG9jYXRpb24gXCJtbC10ZW5zb3JcIiBpcyBub3Qgc3VwcG9ydGVkIHdpdGhvdXQgdXNpbmcgV2ViTk4uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0ZW5zb3JTaXplID0gY2FsY3VsYXRlVGVuc29yU2l6ZUluQnl0ZXMoZGF0YVR5cGUsIHNpemUpO1xuICAgICAgICAgICAgaWYgKHRlbnNvclNpemUgPT09IHVuZGVmaW5lZCB8fCAhaXNNTFRlbnNvclN1cHBvcnRlZFR5cGUodHlwZSkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7dHlwZX1gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgdGhlIGdyYXBoIGhhcyBiZWVuIHBhcnRpdGlvbmVkLCB0aGUgb3V0cHV0IHRlbnNvciBtYXkgaGF2ZSBub3QgYmVlbiBjcmVhdGVkLiBGb3IgdGhpcyByZWFzb24sIHdlIHVzZVxuICAgICAgICAgICAgLy8gZW5zdXJlVGVuc29yIHRvIGdldC9jcmVhdGUgdGhlIE1MVGVuc29yLiBJbiB3aGljaCBjYXNlLCB3ZSBkb24ndCBuZWVkIHRvIGNvcHkgdGhlIGRhdGEgaWYgYSBuZXcgdGVuc29yXG4gICAgICAgICAgICAvLyBoYXMgYmVlbiBjcmVhdGVkLlxuICAgICAgICAgICAgY29uc3QgbWxUZW5zb3IgPSBhd2FpdCBlbnN1cmVUZW5zb3IoZGF0YU9mZnNldCwgZGF0YVR5cGUsIGRpbXMsIGZhbHNlKTtcblxuICAgICAgICAgICAgLy8gZG8gbm90IHJlbGVhc2UgdGhlIHRlbnNvciByaWdodCBub3cuIGl0IHdpbGwgYmUgcmVsZWFzZWQgd2hlbiB1c2VyIGNhbGxzIHRlbnNvci5kaXNwb3NlKCkuXG4gICAgICAgICAgICBrZWVwT3V0cHV0VGVuc29yID0gdHJ1ZTtcblxuICAgICAgICAgICAgb3V0cHV0LnB1c2goW1xuICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICBkaW1zLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbWxUZW5zb3IsXG4gICAgICAgICAgICAgICAgZG93bmxvYWQ6IHdhc20uanNlcENyZWF0ZU1MVGVuc29yRG93bmxvYWRlciEoZGF0YU9mZnNldCwgdHlwZSksXG4gICAgICAgICAgICAgICAgZGlzcG9zZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgd2FzbS5qc2VwUmVsZWFzZVRlbnNvcklkIShkYXRhT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgIHdhc20uX09ydFJlbGVhc2VUZW5zb3IodGVuc29yKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAnbWwtdGVuc29yJyxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB0eXBlZEFycmF5Q29uc3RydWN0b3IgPSB0ZW5zb3JUeXBlVG9UeXBlZEFycmF5Q29uc3RydWN0b3IodHlwZSk7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gbmV3IHR5cGVkQXJyYXlDb25zdHJ1Y3RvcihzaXplKTtcbiAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGRhdGEuYnl0ZUxlbmd0aCkuc2V0KFxuICAgICAgICAgICAgICB3YXNtLkhFQVBVOC5zdWJhcnJheShkYXRhT2Zmc2V0LCBkYXRhT2Zmc2V0ICsgZGF0YS5ieXRlTGVuZ3RoKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBvdXRwdXQucHVzaChbdHlwZSwgZGltcywgZGF0YSwgJ2NwdSddKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHdhc20uc3RhY2tSZXN0b3JlKGJlZm9yZUdldFRlbnNvckRhdGFTdGFjayk7XG4gICAgICAgIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiBkYXRhT2Zmc2V0KSB7XG4gICAgICAgICAgd2FzbS5fZnJlZShkYXRhT2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWtlZXBPdXRwdXRUZW5zb3IpIHtcbiAgICAgICAgICB3YXNtLl9PcnRSZWxlYXNlVGVuc29yKHRlbnNvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaW9CaW5kaW5nU3RhdGUgJiYgIWVuYWJsZUdyYXBoQ2FwdHVyZSkge1xuICAgICAgd2FzbS5fT3J0Q2xlYXJCb3VuZE91dHB1dHMoaW9CaW5kaW5nU3RhdGUuaGFuZGxlKTtcbiAgICAgIGFjdGl2ZVNlc3Npb25zLnNldChzZXNzaW9uSWQsIFtcbiAgICAgICAgc2Vzc2lvbkhhbmRsZSxcbiAgICAgICAgaW5wdXROYW1lc1VURjhFbmNvZGVkLFxuICAgICAgICBvdXRwdXROYW1lc1VURjhFbmNvZGVkLFxuICAgICAgICBpb0JpbmRpbmdTdGF0ZSxcbiAgICAgICAgZW5hYmxlR3JhcGhDYXB0dXJlLFxuICAgICAgICBmYWxzZSxcbiAgICAgIF0pO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9IGZpbmFsbHkge1xuICAgIHdhc20uc3RhY2tSZXN0b3JlKGJlZm9yZVJ1blN0YWNrKTtcblxuICAgIGlucHV0VGVuc29ySGFuZGxlcy5mb3JFYWNoKCh2KSA9PiB3YXNtLl9PcnRSZWxlYXNlVGVuc29yKHYpKTtcbiAgICBvdXRwdXRUZW5zb3JIYW5kbGVzLmZvckVhY2goKHYpID0+IHdhc20uX09ydFJlbGVhc2VUZW5zb3IodikpO1xuICAgIGlucHV0T3V0cHV0QWxsb2NzLmZvckVhY2goKHApID0+IHdhc20uX2ZyZWUocCkpO1xuXG4gICAgaWYgKHJ1bk9wdGlvbnNIYW5kbGUgIT09IDApIHtcbiAgICAgIHdhc20uX09ydFJlbGVhc2VSdW5PcHRpb25zKHJ1bk9wdGlvbnNIYW5kbGUpO1xuICAgIH1cbiAgICBydW5PcHRpb25zQWxsb2NzLmZvckVhY2goKHApID0+IHdhc20uX2ZyZWUocCkpO1xuICB9XG59O1xuXG4vKipcbiAqIGVuZCBwcm9maWxpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IGVuZFByb2ZpbGluZyA9IChzZXNzaW9uSWQ6IG51bWJlcik6IHZvaWQgPT4ge1xuICBjb25zdCB3YXNtID0gZ2V0SW5zdGFuY2UoKTtcbiAgY29uc3Qgc2Vzc2lvbiA9IGFjdGl2ZVNlc3Npb25zLmdldChzZXNzaW9uSWQpO1xuICBpZiAoIXNlc3Npb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2Vzc2lvbiBpZCcpO1xuICB9XG4gIGNvbnN0IHNlc3Npb25IYW5kbGUgPSBzZXNzaW9uWzBdO1xuXG4gIC8vIHByb2ZpbGUgZmlsZSBuYW1lIGlzIG5vdCB1c2VkIHlldCwgYnV0IGl0IG11c3QgYmUgZnJlZWQuXG4gIGNvbnN0IHByb2ZpbGVGaWxlTmFtZSA9IHdhc20uX09ydEVuZFByb2ZpbGluZyhzZXNzaW9uSGFuZGxlKTtcbiAgaWYgKHByb2ZpbGVGaWxlTmFtZSA9PT0gMCkge1xuICAgIGNoZWNrTGFzdEVycm9yKFwiQ2FuJ3QgZ2V0IGFuIHByb2ZpbGUgZmlsZSBuYW1lLlwiKTtcbiAgfVxuICB3YXNtLl9PcnRGcmVlKHByb2ZpbGVGaWxlTmFtZSk7XG59O1xuXG5leHBvcnQgY29uc3QgZXh0cmFjdFRyYW5zZmVyYWJsZUJ1ZmZlcnMgPSAodGVuc29yczogcmVhZG9ubHkgU2VyaWFsaXphYmxlVGVuc29yTWV0YWRhdGFbXSk6IEFycmF5QnVmZmVyTGlrZVtdID0+IHtcbiAgY29uc3QgYnVmZmVyczogQXJyYXlCdWZmZXJMaWtlW10gPSBbXTtcbiAgZm9yIChjb25zdCB0ZW5zb3Igb2YgdGVuc29ycykge1xuICAgIGNvbnN0IGRhdGEgPSB0ZW5zb3JbMl07XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpICYmICdidWZmZXInIGluIGRhdGEpIHtcbiAgICAgIGJ1ZmZlcnMucHVzaChkYXRhLmJ1ZmZlcik7XG4gICAgfVxuICB9XG4gIHJldHVybiBidWZmZXJzO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgZW52LCBJbmZlcmVuY2VTZXNzaW9uIH0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuaW1wb3J0IHtcbiAgT3J0V2FzbU1lc3NhZ2UsXG4gIFNlcmlhbGl6YWJsZUludGVybmFsQnVmZmVyLFxuICBTZXJpYWxpemFibGVTZXNzaW9uTWV0YWRhdGEsXG4gIFNlcmlhbGl6YWJsZVRlbnNvck1ldGFkYXRhLFxuICBUZW5zb3JNZXRhZGF0YSxcbn0gZnJvbSAnLi9wcm94eS1tZXNzYWdlcyc7XG5pbXBvcnQgKiBhcyBjb3JlIGZyb20gJy4vd2FzbS1jb3JlLWltcGwnO1xuaW1wb3J0IHsgaW5pdGlhbGl6ZVdlYkFzc2VtYmx5IH0gZnJvbSAnLi93YXNtLWZhY3RvcnknO1xuaW1wb3J0IHsgaW1wb3J0UHJveHlXb3JrZXIgfSBmcm9tICcuL3dhc20tdXRpbHMtaW1wb3J0JztcblxuY29uc3QgaXNQcm94eSA9ICgpOiBib29sZWFuID0+ICEhZW52Lndhc20ucHJveHkgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcbmxldCBwcm94eVdvcmtlcjogV29ya2VyIHwgdW5kZWZpbmVkO1xubGV0IGluaXRpYWxpemluZyA9IGZhbHNlO1xubGV0IGluaXRpYWxpemVkID0gZmFsc2U7XG5sZXQgYWJvcnRlZCA9IGZhbHNlO1xubGV0IHRlbXBvcmFyeU9iamVjdFVybDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuXG50eXBlIFByb21pc2VDYWxsYmFja3M8VCA9IHZvaWQ+ID0gW3Jlc29sdmU6IChyZXN1bHQ6IFQpID0+IHZvaWQsIHJlamVjdDogKHJlYXNvbjogdW5rbm93bikgPT4gdm9pZF07XG5sZXQgaW5pdFdhc21DYWxsYmFja3M6IFByb21pc2VDYWxsYmFja3M7XG5jb25zdCBxdWV1ZWRDYWxsYmFja3M6IE1hcDxPcnRXYXNtTWVzc2FnZVsndHlwZSddLCBBcnJheTxQcm9taXNlQ2FsbGJhY2tzPHVua25vd24+Pj4gPSBuZXcgTWFwKCk7XG5cbmNvbnN0IGVucXVldWVDYWxsYmFja3MgPSAodHlwZTogT3J0V2FzbU1lc3NhZ2VbJ3R5cGUnXSwgY2FsbGJhY2tzOiBQcm9taXNlQ2FsbGJhY2tzPHVua25vd24+KTogdm9pZCA9PiB7XG4gIGNvbnN0IHF1ZXVlID0gcXVldWVkQ2FsbGJhY2tzLmdldCh0eXBlKTtcbiAgaWYgKHF1ZXVlKSB7XG4gICAgcXVldWUucHVzaChjYWxsYmFja3MpO1xuICB9IGVsc2Uge1xuICAgIHF1ZXVlZENhbGxiYWNrcy5zZXQodHlwZSwgW2NhbGxiYWNrc10pO1xuICB9XG59O1xuXG5jb25zdCBlbnN1cmVXb3JrZXIgPSAoKTogdm9pZCA9PiB7XG4gIGlmIChpbml0aWFsaXppbmcgfHwgIWluaXRpYWxpemVkIHx8IGFib3J0ZWQgfHwgIXByb3h5V29ya2VyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd3b3JrZXIgbm90IHJlYWR5Jyk7XG4gIH1cbn07XG5cbmNvbnN0IG9uUHJveHlXb3JrZXJNZXNzYWdlID0gKGV2OiBNZXNzYWdlRXZlbnQ8T3J0V2FzbU1lc3NhZ2U+KTogdm9pZCA9PiB7XG4gIHN3aXRjaCAoZXYuZGF0YS50eXBlKSB7XG4gICAgY2FzZSAnaW5pdC13YXNtJzpcbiAgICAgIGluaXRpYWxpemluZyA9IGZhbHNlO1xuICAgICAgaWYgKGV2LmRhdGEuZXJyKSB7XG4gICAgICAgIGFib3J0ZWQgPSB0cnVlO1xuICAgICAgICBpbml0V2FzbUNhbGxiYWNrc1sxXShldi5kYXRhLmVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIGluaXRXYXNtQ2FsbGJhY2tzWzBdKCk7XG4gICAgICB9XG4gICAgICBpZiAodGVtcG9yYXJ5T2JqZWN0VXJsKSB7XG4gICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwodGVtcG9yYXJ5T2JqZWN0VXJsKTtcbiAgICAgICAgdGVtcG9yYXJ5T2JqZWN0VXJsID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaW5pdC1lcCc6XG4gICAgY2FzZSAnY29weS1mcm9tJzpcbiAgICBjYXNlICdjcmVhdGUnOlxuICAgIGNhc2UgJ3JlbGVhc2UnOlxuICAgIGNhc2UgJ3J1bic6XG4gICAgY2FzZSAnZW5kLXByb2ZpbGluZyc6IHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHF1ZXVlZENhbGxiYWNrcy5nZXQoZXYuZGF0YS50eXBlKSE7XG4gICAgICBpZiAoZXYuZGF0YS5lcnIpIHtcbiAgICAgICAgY2FsbGJhY2tzLnNoaWZ0KCkhWzFdKGV2LmRhdGEuZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrcy5zaGlmdCgpIVswXShldi5kYXRhLm91dCEpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBpbml0aWFsaXplV2ViQXNzZW1ibHlBbmRPcnRSdW50aW1lID0gYXN5bmMgKCk6IFByb21pc2U8dm9pZD4gPT4ge1xuICBpZiAoaW5pdGlhbGl6ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGluaXRpYWxpemluZykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIm11bHRpcGxlIGNhbGxzIHRvICdpbml0V2FzbSgpJyBkZXRlY3RlZC5cIik7XG4gIH1cbiAgaWYgKGFib3J0ZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJwcmV2aW91cyBjYWxsIHRvICdpbml0V2FzbSgpJyBmYWlsZWQuXCIpO1xuICB9XG5cbiAgaW5pdGlhbGl6aW5nID0gdHJ1ZTtcblxuICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9XQVNNX1BST1hZICYmIGlzUHJveHkoKSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBwcm94eVdvcmtlcj8udGVybWluYXRlKCk7XG5cbiAgICAgIHZvaWQgaW1wb3J0UHJveHlXb3JrZXIoKS50aGVuKChbb2JqZWN0VXJsLCB3b3JrZXJdKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcHJveHlXb3JrZXIgPSB3b3JrZXI7XG4gICAgICAgICAgcHJveHlXb3JrZXIub25lcnJvciA9IChldjogRXJyb3JFdmVudCkgPT4gcmVqZWN0KGV2KTtcbiAgICAgICAgICBwcm94eVdvcmtlci5vbm1lc3NhZ2UgPSBvblByb3h5V29ya2VyTWVzc2FnZTtcbiAgICAgICAgICBpbml0V2FzbUNhbGxiYWNrcyA9IFtyZXNvbHZlLCByZWplY3RdO1xuICAgICAgICAgIGNvbnN0IG1lc3NhZ2U6IE9ydFdhc21NZXNzYWdlID0geyB0eXBlOiAnaW5pdC13YXNtJywgaW46IGVudiB9O1xuICAgICAgICAgIHByb3h5V29ya2VyLnBvc3RNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgIHRlbXBvcmFyeU9iamVjdFVybCA9IG9iamVjdFVybDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfVxuICAgICAgfSwgcmVqZWN0KTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgaW5pdGlhbGl6ZVdlYkFzc2VtYmx5KGVudi53YXNtKTtcbiAgICAgIGF3YWl0IGNvcmUuaW5pdFJ1bnRpbWUoZW52KTtcbiAgICAgIGluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBhYm9ydGVkID0gdHJ1ZTtcbiAgICAgIHRocm93IGU7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGluaXRpYWxpemluZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGluaXRpYWxpemVPcnRFcCA9IGFzeW5jIChlcE5hbWU6IHN0cmluZyk6IFByb21pc2U8dm9pZD4gPT4ge1xuICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9XQVNNX1BST1hZICYmIGlzUHJveHkoKSkge1xuICAgIGVuc3VyZVdvcmtlcigpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBlbnF1ZXVlQ2FsbGJhY2tzKCdpbml0LWVwJywgW3Jlc29sdmUsIHJlamVjdF0pO1xuICAgICAgY29uc3QgbWVzc2FnZTogT3J0V2FzbU1lc3NhZ2UgPSB7IHR5cGU6ICdpbml0LWVwJywgaW46IHsgZXBOYW1lLCBlbnYgfSB9O1xuICAgICAgcHJveHlXb3JrZXIhLnBvc3RNZXNzYWdlKG1lc3NhZ2UpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGF3YWl0IGNvcmUuaW5pdEVwKGVudiwgZXBOYW1lKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGNvcHlGcm9tRXh0ZXJuYWxCdWZmZXIgPSBhc3luYyAoYnVmZmVyOiBVaW50OEFycmF5KTogUHJvbWlzZTxTZXJpYWxpemFibGVJbnRlcm5hbEJ1ZmZlcj4gPT4ge1xuICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9XQVNNX1BST1hZICYmIGlzUHJveHkoKSkge1xuICAgIGVuc3VyZVdvcmtlcigpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZTxTZXJpYWxpemFibGVJbnRlcm5hbEJ1ZmZlcj4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgZW5xdWV1ZUNhbGxiYWNrcygnY29weS1mcm9tJywgW3Jlc29sdmUsIHJlamVjdF0pO1xuICAgICAgY29uc3QgbWVzc2FnZTogT3J0V2FzbU1lc3NhZ2UgPSB7IHR5cGU6ICdjb3B5LWZyb20nLCBpbjogeyBidWZmZXIgfSB9O1xuICAgICAgcHJveHlXb3JrZXIhLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIFtidWZmZXIuYnVmZmVyXSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvcmUuY29weUZyb21FeHRlcm5hbEJ1ZmZlcihidWZmZXIpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlU2Vzc2lvbiA9IGFzeW5jIChcbiAgbW9kZWw6IFNlcmlhbGl6YWJsZUludGVybmFsQnVmZmVyIHwgVWludDhBcnJheSxcbiAgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMsXG4pOiBQcm9taXNlPFNlcmlhbGl6YWJsZVNlc3Npb25NZXRhZGF0YT4gPT4ge1xuICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9XQVNNX1BST1hZICYmIGlzUHJveHkoKSkge1xuICAgIC8vIGNoZWNrIHVuc3VwcG9ydGVkIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucz8ucHJlZmVycmVkT3V0cHV0TG9jYXRpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc2Vzc2lvbiBvcHRpb24gXCJwcmVmZXJyZWRPdXRwdXRMb2NhdGlvblwiIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHByb3h5LicpO1xuICAgIH1cbiAgICBlbnN1cmVXb3JrZXIoKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2U8U2VyaWFsaXphYmxlU2Vzc2lvbk1ldGFkYXRhPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBlbnF1ZXVlQ2FsbGJhY2tzKCdjcmVhdGUnLCBbcmVzb2x2ZSwgcmVqZWN0XSk7XG4gICAgICBjb25zdCBtZXNzYWdlOiBPcnRXYXNtTWVzc2FnZSA9IHsgdHlwZTogJ2NyZWF0ZScsIGluOiB7IG1vZGVsLCBvcHRpb25zOiB7IC4uLm9wdGlvbnMgfSB9IH07XG4gICAgICBjb25zdCB0cmFuc2ZlcmFibGU6IFRyYW5zZmVyYWJsZVtdID0gW107XG4gICAgICBpZiAobW9kZWwgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIHRyYW5zZmVyYWJsZS5wdXNoKG1vZGVsLmJ1ZmZlcik7XG4gICAgICB9XG4gICAgICBwcm94eVdvcmtlciEucG9zdE1lc3NhZ2UobWVzc2FnZSwgdHJhbnNmZXJhYmxlKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29yZS5jcmVhdGVTZXNzaW9uKG1vZGVsLCBvcHRpb25zKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHJlbGVhc2VTZXNzaW9uID0gYXN5bmMgKHNlc3Npb25JZDogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIGlmICghQlVJTERfREVGUy5ESVNBQkxFX1dBU01fUFJPWFkgJiYgaXNQcm94eSgpKSB7XG4gICAgZW5zdXJlV29ya2VyKCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGVucXVldWVDYWxsYmFja3MoJ3JlbGVhc2UnLCBbcmVzb2x2ZSwgcmVqZWN0XSk7XG4gICAgICBjb25zdCBtZXNzYWdlOiBPcnRXYXNtTWVzc2FnZSA9IHsgdHlwZTogJ3JlbGVhc2UnLCBpbjogc2Vzc2lvbklkIH07XG4gICAgICBwcm94eVdvcmtlciEucG9zdE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgY29yZS5yZWxlYXNlU2Vzc2lvbihzZXNzaW9uSWQpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgcnVuID0gYXN5bmMgKFxuICBzZXNzaW9uSWQ6IG51bWJlcixcbiAgaW5wdXRJbmRpY2VzOiBudW1iZXJbXSxcbiAgaW5wdXRzOiBUZW5zb3JNZXRhZGF0YVtdLFxuICBvdXRwdXRJbmRpY2VzOiBudW1iZXJbXSxcbiAgb3V0cHV0czogQXJyYXk8VGVuc29yTWV0YWRhdGEgfCBudWxsPixcbiAgb3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zLFxuKTogUHJvbWlzZTxUZW5zb3JNZXRhZGF0YVtdPiA9PiB7XG4gIGlmICghQlVJTERfREVGUy5ESVNBQkxFX1dBU01fUFJPWFkgJiYgaXNQcm94eSgpKSB7XG4gICAgLy8gY2hlY2sgaW5wdXRzIGxvY2F0aW9uXG4gICAgaWYgKGlucHV0cy5zb21lKCh0KSA9PiB0WzNdICE9PSAnY3B1JykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW5wdXQgdGVuc29yIG9uIEdQVSBpcyBub3Qgc3VwcG9ydGVkIGZvciBwcm94eS4nKTtcbiAgICB9XG4gICAgLy8gY2hlY2sgb3V0cHV0cyBsb2NhdGlvblxuICAgIGlmIChvdXRwdXRzLnNvbWUoKHQpID0+IHQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ByZS1hbGxvY2F0ZWQgb3V0cHV0IHRlbnNvciBpcyBub3Qgc3VwcG9ydGVkIGZvciBwcm94eS4nKTtcbiAgICB9XG4gICAgZW5zdXJlV29ya2VyKCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPFNlcmlhbGl6YWJsZVRlbnNvck1ldGFkYXRhW10+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGVucXVldWVDYWxsYmFja3MoJ3J1bicsIFtyZXNvbHZlLCByZWplY3RdKTtcbiAgICAgIGNvbnN0IHNlcmlhbGl6YWJsZUlucHV0cyA9IGlucHV0cyBhcyBTZXJpYWxpemFibGVUZW5zb3JNZXRhZGF0YVtdOyAvLyBldmVyeSBpbnB1dCBpcyBvbiBDUFUuXG4gICAgICBjb25zdCBtZXNzYWdlOiBPcnRXYXNtTWVzc2FnZSA9IHtcbiAgICAgICAgdHlwZTogJ3J1bicsXG4gICAgICAgIGluOiB7IHNlc3Npb25JZCwgaW5wdXRJbmRpY2VzLCBpbnB1dHM6IHNlcmlhbGl6YWJsZUlucHV0cywgb3V0cHV0SW5kaWNlcywgb3B0aW9ucyB9LFxuICAgICAgfTtcbiAgICAgIHByb3h5V29ya2VyIS5wb3N0TWVzc2FnZShtZXNzYWdlLCBjb3JlLmV4dHJhY3RUcmFuc2ZlcmFibGVCdWZmZXJzKHNlcmlhbGl6YWJsZUlucHV0cykpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjb3JlLnJ1bihzZXNzaW9uSWQsIGlucHV0SW5kaWNlcywgaW5wdXRzLCBvdXRwdXRJbmRpY2VzLCBvdXRwdXRzLCBvcHRpb25zKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGVuZFByb2ZpbGluZyA9IGFzeW5jIChzZXNzaW9uSWQ6IG51bWJlcik6IFByb21pc2U8dm9pZD4gPT4ge1xuICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9XQVNNX1BST1hZICYmIGlzUHJveHkoKSkge1xuICAgIGVuc3VyZVdvcmtlcigpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBlbnF1ZXVlQ2FsbGJhY2tzKCdlbmQtcHJvZmlsaW5nJywgW3Jlc29sdmUsIHJlamVjdF0pO1xuICAgICAgY29uc3QgbWVzc2FnZTogT3J0V2FzbU1lc3NhZ2UgPSB7IHR5cGU6ICdlbmQtcHJvZmlsaW5nJywgaW46IHNlc3Npb25JZCB9O1xuICAgICAgcHJveHlXb3JrZXIhLnBvc3RNZXNzYWdlKG1lc3NhZ2UpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNvcmUuZW5kUHJvZmlsaW5nKHNlc3Npb25JZCk7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7XG4gIEluZmVyZW5jZVNlc3Npb24sXG4gIEluZmVyZW5jZVNlc3Npb25IYW5kbGVyLFxuICBTZXNzaW9uSGFuZGxlcixcbiAgVGVuc29yLFxuICBUUkFDRV9GVU5DX0JFR0lOLFxuICBUUkFDRV9GVU5DX0VORCxcbn0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuaW1wb3J0IHsgU2VyaWFsaXphYmxlSW50ZXJuYWxCdWZmZXIsIFRlbnNvck1ldGFkYXRhIH0gZnJvbSAnLi9wcm94eS1tZXNzYWdlcyc7XG5pbXBvcnQgeyBjb3B5RnJvbUV4dGVybmFsQnVmZmVyLCBjcmVhdGVTZXNzaW9uLCBlbmRQcm9maWxpbmcsIHJlbGVhc2VTZXNzaW9uLCBydW4gfSBmcm9tICcuL3Byb3h5LXdyYXBwZXInO1xuaW1wb3J0IHsgaXNHcHVCdWZmZXJTdXBwb3J0ZWRUeXBlLCBpc01MVGVuc29yU3VwcG9ydGVkVHlwZSB9IGZyb20gJy4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgaXNOb2RlIH0gZnJvbSAnLi93YXNtLXV0aWxzLWVudic7XG5pbXBvcnQgeyBsb2FkRmlsZSB9IGZyb20gJy4vd2FzbS11dGlscy1sb2FkLWZpbGUnO1xuXG5leHBvcnQgY29uc3QgZW5jb2RlVGVuc29yTWV0YWRhdGEgPSAodGVuc29yOiBUZW5zb3IsIGdldE5hbWU6ICgpID0+IHN0cmluZyk6IFRlbnNvck1ldGFkYXRhID0+IHtcbiAgc3dpdGNoICh0ZW5zb3IubG9jYXRpb24pIHtcbiAgICBjYXNlICdjcHUnOlxuICAgICAgcmV0dXJuIFt0ZW5zb3IudHlwZSwgdGVuc29yLmRpbXMsIHRlbnNvci5kYXRhLCAnY3B1J107XG4gICAgY2FzZSAnZ3B1LWJ1ZmZlcic6XG4gICAgICByZXR1cm4gW3RlbnNvci50eXBlLCB0ZW5zb3IuZGltcywgeyBncHVCdWZmZXI6IHRlbnNvci5ncHVCdWZmZXIgfSwgJ2dwdS1idWZmZXInXTtcbiAgICBjYXNlICdtbC10ZW5zb3InOlxuICAgICAgcmV0dXJuIFt0ZW5zb3IudHlwZSwgdGVuc29yLmRpbXMsIHsgbWxUZW5zb3I6IHRlbnNvci5tbFRlbnNvciB9LCAnbWwtdGVuc29yJ107XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBkYXRhIGxvY2F0aW9uOiAke3RlbnNvci5sb2NhdGlvbn0gZm9yICR7Z2V0TmFtZSgpfWApO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgZGVjb2RlVGVuc29yTWV0YWRhdGEgPSAodGVuc29yOiBUZW5zb3JNZXRhZGF0YSk6IFRlbnNvciA9PiB7XG4gIHN3aXRjaCAodGVuc29yWzNdKSB7XG4gICAgY2FzZSAnY3B1JzpcbiAgICAgIHJldHVybiBuZXcgVGVuc29yKHRlbnNvclswXSwgdGVuc29yWzJdLCB0ZW5zb3JbMV0pO1xuICAgIGNhc2UgJ2dwdS1idWZmZXInOiB7XG4gICAgICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclswXTtcbiAgICAgIGlmICghaXNHcHVCdWZmZXJTdXBwb3J0ZWRUeXBlKGRhdGFUeXBlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG5vdCBzdXBwb3J0ZWQgZGF0YSB0eXBlOiAke2RhdGFUeXBlfSBmb3IgZGVzZXJpYWxpemluZyBHUFUgdGVuc29yYCk7XG4gICAgICB9XG4gICAgICBjb25zdCB7IGdwdUJ1ZmZlciwgZG93bmxvYWQsIGRpc3Bvc2UgfSA9IHRlbnNvclsyXTtcbiAgICAgIHJldHVybiBUZW5zb3IuZnJvbUdwdUJ1ZmZlcihncHVCdWZmZXIsIHsgZGF0YVR5cGUsIGRpbXM6IHRlbnNvclsxXSwgZG93bmxvYWQsIGRpc3Bvc2UgfSk7XG4gICAgfVxuICAgIGNhc2UgJ21sLXRlbnNvcic6IHtcbiAgICAgIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yWzBdO1xuICAgICAgaWYgKCFpc01MVGVuc29yU3VwcG9ydGVkVHlwZShkYXRhVHlwZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtkYXRhVHlwZX0gZm9yIGRlc2VyaWFsaXppbmcgTUxUZW5zb3IgdGVuc29yYCk7XG4gICAgICB9XG4gICAgICBjb25zdCB7IG1sVGVuc29yLCBkb3dubG9hZCwgZGlzcG9zZSB9ID0gdGVuc29yWzJdO1xuICAgICAgcmV0dXJuIFRlbnNvci5mcm9tTUxUZW5zb3IobWxUZW5zb3IsIHsgZGF0YVR5cGUsIGRpbXM6IHRlbnNvclsxXSwgZG93bmxvYWQsIGRpc3Bvc2UgfSk7XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGF0YSBsb2NhdGlvbjogJHt0ZW5zb3JbM119YCk7XG4gIH1cbn07XG5cbmV4cG9ydCBjbGFzcyBPbm54cnVudGltZVdlYkFzc2VtYmx5U2Vzc2lvbkhhbmRsZXIgaW1wbGVtZW50cyBJbmZlcmVuY2VTZXNzaW9uSGFuZGxlciB7XG4gIHByaXZhdGUgc2Vzc2lvbklkOiBudW1iZXI7XG5cbiAgaW5wdXROYW1lczogc3RyaW5nW107XG4gIG91dHB1dE5hbWVzOiBzdHJpbmdbXTtcblxuICBhc3luYyBmZXRjaE1vZGVsQW5kQ29weVRvV2FzbU1lbW9yeShwYXRoOiBzdHJpbmcpOiBQcm9taXNlPFNlcmlhbGl6YWJsZUludGVybmFsQnVmZmVyPiB7XG4gICAgLy8gZmV0Y2ggbW9kZWwgZnJvbSB1cmwgYW5kIG1vdmUgdG8gd2FzbSBoZWFwLlxuICAgIHJldHVybiBjb3B5RnJvbUV4dGVybmFsQnVmZmVyKGF3YWl0IGxvYWRGaWxlKHBhdGgpKTtcbiAgfVxuXG4gIGFzeW5jIGxvYWRNb2RlbChwYXRoT3JCdWZmZXI6IHN0cmluZyB8IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgVFJBQ0VfRlVOQ19CRUdJTigpO1xuICAgIGxldCBtb2RlbDogUGFyYW1ldGVyczx0eXBlb2YgY3JlYXRlU2Vzc2lvbj5bMF07XG5cbiAgICBpZiAodHlwZW9mIHBhdGhPckJ1ZmZlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChpc05vZGUpIHtcbiAgICAgICAgLy8gbm9kZVxuICAgICAgICBtb2RlbCA9IGF3YWl0IGxvYWRGaWxlKHBhdGhPckJ1ZmZlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBicm93c2VyXG4gICAgICAgIC8vIGZldGNoIG1vZGVsIGFuZCBjb3B5IHRvIHdhc20gaGVhcC5cbiAgICAgICAgbW9kZWwgPSBhd2FpdCB0aGlzLmZldGNoTW9kZWxBbmRDb3B5VG9XYXNtTWVtb3J5KHBhdGhPckJ1ZmZlcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vZGVsID0gcGF0aE9yQnVmZmVyO1xuICAgIH1cblxuICAgIFt0aGlzLnNlc3Npb25JZCwgdGhpcy5pbnB1dE5hbWVzLCB0aGlzLm91dHB1dE5hbWVzXSA9IGF3YWl0IGNyZWF0ZVNlc3Npb24obW9kZWwsIG9wdGlvbnMpO1xuICAgIFRSQUNFX0ZVTkNfRU5EKCk7XG4gIH1cblxuICBhc3luYyBkaXNwb3NlKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiByZWxlYXNlU2Vzc2lvbih0aGlzLnNlc3Npb25JZCk7XG4gIH1cblxuICBhc3luYyBydW4oXG4gICAgZmVlZHM6IFNlc3Npb25IYW5kbGVyLkZlZWRzVHlwZSxcbiAgICBmZXRjaGVzOiBTZXNzaW9uSGFuZGxlci5GZXRjaGVzVHlwZSxcbiAgICBvcHRpb25zOiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMsXG4gICk6IFByb21pc2U8U2Vzc2lvbkhhbmRsZXIuUmV0dXJuVHlwZT4ge1xuICAgIFRSQUNFX0ZVTkNfQkVHSU4oKTtcbiAgICBjb25zdCBpbnB1dEFycmF5OiBUZW5zb3JbXSA9IFtdO1xuICAgIGNvbnN0IGlucHV0SW5kaWNlczogbnVtYmVyW10gPSBbXTtcbiAgICBPYmplY3QuZW50cmllcyhmZWVkcykuZm9yRWFjaCgoa3ZwKSA9PiB7XG4gICAgICBjb25zdCBuYW1lID0ga3ZwWzBdO1xuICAgICAgY29uc3QgdGVuc29yID0ga3ZwWzFdO1xuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmlucHV0TmFtZXMuaW5kZXhPZihuYW1lKTtcbiAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGlucHV0ICcke25hbWV9J2ApO1xuICAgICAgfVxuICAgICAgaW5wdXRBcnJheS5wdXNoKHRlbnNvcik7XG4gICAgICBpbnB1dEluZGljZXMucHVzaChpbmRleCk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBvdXRwdXRBcnJheTogQXJyYXk8VGVuc29yIHwgbnVsbD4gPSBbXTtcbiAgICBjb25zdCBvdXRwdXRJbmRpY2VzOiBudW1iZXJbXSA9IFtdO1xuICAgIE9iamVjdC5lbnRyaWVzKGZldGNoZXMpLmZvckVhY2goKGt2cCkgPT4ge1xuICAgICAgY29uc3QgbmFtZSA9IGt2cFswXTtcbiAgICAgIGNvbnN0IHRlbnNvciA9IGt2cFsxXTtcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5vdXRwdXROYW1lcy5pbmRleE9mKG5hbWUpO1xuICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgb3V0cHV0ICcke25hbWV9J2ApO1xuICAgICAgfVxuICAgICAgb3V0cHV0QXJyYXkucHVzaCh0ZW5zb3IpO1xuICAgICAgb3V0cHV0SW5kaWNlcy5wdXNoKGluZGV4KTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGlucHV0cyA9IGlucHV0QXJyYXkubWFwKCh0LCBpKSA9PlxuICAgICAgZW5jb2RlVGVuc29yTWV0YWRhdGEodCwgKCkgPT4gYGlucHV0IFwiJHt0aGlzLmlucHV0TmFtZXNbaW5wdXRJbmRpY2VzW2ldXX1cImApLFxuICAgICk7XG4gICAgY29uc3Qgb3V0cHV0cyA9IG91dHB1dEFycmF5Lm1hcCgodCwgaSkgPT5cbiAgICAgIHQgPyBlbmNvZGVUZW5zb3JNZXRhZGF0YSh0LCAoKSA9PiBgb3V0cHV0IFwiJHt0aGlzLm91dHB1dE5hbWVzW291dHB1dEluZGljZXNbaV1dfVwiYCkgOiBudWxsLFxuICAgICk7XG5cbiAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgcnVuKHRoaXMuc2Vzc2lvbklkLCBpbnB1dEluZGljZXMsIGlucHV0cywgb3V0cHV0SW5kaWNlcywgb3V0cHV0cywgb3B0aW9ucyk7XG5cbiAgICBjb25zdCByZXN1bHRNYXA6IFNlc3Npb25IYW5kbGVyLlJldHVyblR5cGUgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdE1hcFt0aGlzLm91dHB1dE5hbWVzW291dHB1dEluZGljZXNbaV1dXSA9IG91dHB1dEFycmF5W2ldID8/IGRlY29kZVRlbnNvck1ldGFkYXRhKHJlc3VsdHNbaV0pO1xuICAgIH1cbiAgICBUUkFDRV9GVU5DX0VORCgpO1xuICAgIHJldHVybiByZXN1bHRNYXA7XG4gIH1cblxuICBzdGFydFByb2ZpbGluZygpOiB2b2lkIHtcbiAgICAvLyBUT0RPOiBpbXBsZW1lbnQgcHJvZmlsaW5nXG4gIH1cblxuICBlbmRQcm9maWxpbmcoKTogdm9pZCB7XG4gICAgdm9pZCBlbmRQcm9maWxpbmcodGhpcy5zZXNzaW9uSWQpO1xuICB9XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEJhY2tlbmQsIGVudiwgSW5mZXJlbmNlU2Vzc2lvbiwgSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXIgfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG5pbXBvcnQgeyBpbml0aWFsaXplT3J0RXAsIGluaXRpYWxpemVXZWJBc3NlbWJseUFuZE9ydFJ1bnRpbWUgfSBmcm9tICcuL3dhc20vcHJveHktd3JhcHBlcic7XG5pbXBvcnQgeyBPbm54cnVudGltZVdlYkFzc2VtYmx5U2Vzc2lvbkhhbmRsZXIgfSBmcm9tICcuL3dhc20vc2Vzc2lvbi1oYW5kbGVyLWluZmVyZW5jZSc7XG5pbXBvcnQgeyBzY3JpcHRTcmMgfSBmcm9tICcuL3dhc20vd2FzbS11dGlscy1pbXBvcnQnO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaW5pdGlhbGl6ZXMgYWxsIGZsYWdzIGZvciBXZWJBc3NlbWJseS5cbiAqXG4gKiBUaG9zZSBmbGFncyBhcmUgYWNjZXNzaWJsZSBmcm9tIGBvcnQuZW52Lndhc21gLiBVc2VycyBhcmUgYWxsb3cgdG8gc2V0IHRob3NlIGZsYWdzIGJlZm9yZSB0aGUgZmlyc3QgaW5mZXJlbmNlIHNlc3Npb25cbiAqIGJlaW5nIGNyZWF0ZWQsIHRvIG92ZXJyaWRlIGRlZmF1bHQgdmFsdWUuXG4gKi9cbmV4cG9ydCBjb25zdCBpbml0aWFsaXplRmxhZ3MgPSAoKTogdm9pZCA9PiB7XG4gIGlmICh0eXBlb2YgZW52Lndhc20uaW5pdFRpbWVvdXQgIT09ICdudW1iZXInIHx8IGVudi53YXNtLmluaXRUaW1lb3V0IDwgMCkge1xuICAgIGVudi53YXNtLmluaXRUaW1lb3V0ID0gMDtcbiAgfVxuXG4gIGlmIChlbnYud2FzbS5zaW1kID09PSBmYWxzZSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgY29uc29sZS53YXJuKFxuICAgICAgJ0RlcHJlY2F0ZWQgcHJvcGVydHkgXCJlbnYud2FzbS5zaW1kXCIgaXMgc2V0IHRvIGZhbHNlLiAnICtcbiAgICAgICAgJ25vbi1TSU1EIGJ1aWxkIGlzIG5vIGxvbmdlciBwcm92aWRlZCwgYW5kIHRoaXMgc2V0dGluZyB3aWxsIGJlIGlnbm9yZWQuJyxcbiAgICApO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlbnYud2FzbS5wcm94eSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgZW52Lndhc20ucHJveHkgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW52Lndhc20udHJhY2UgIT09ICdib29sZWFuJykge1xuICAgIGVudi53YXNtLnRyYWNlID0gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIGVudi53YXNtLm51bVRocmVhZHMgIT09ICdudW1iZXInIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKGVudi53YXNtLm51bVRocmVhZHMpIHx8IGVudi53YXNtLm51bVRocmVhZHMgPD0gMCkge1xuICAgIC8vIFRoZSBmb2xsb3dpbmcgbG9naWMgb25seSBhcHBsaWVzIHdoZW4gYG9ydC5lbnYud2FzbS5udW1UaHJlYWRzYCBpcyBub3Qgc2V0IGJ5IHVzZXIuIFdlIHdpbGwgYWx3YXlzIGhvbm9yIHVzZXInc1xuICAgIC8vIHNldHRpbmcgaWYgaXQgaXMgcHJvdmlkZWQuXG5cbiAgICAvLyBCcm93c2VyOiB3aGVuIGNyb3NzT3JpZ2luSXNvbGF0ZWQgaXMgZmFsc2UsIFNoYXJlZEFycmF5QnVmZmVyIGlzIG5vdCBhdmFpbGFibGUgc28gV2ViQXNzZW1ibHkgdGhyZWFkcyB3aWxsIG5vdFxuICAgIC8vIHdvcmsuIEluIHRoaXMgY2FzZSwgd2Ugd2lsbCBzZXQgbnVtVGhyZWFkcyB0byAxLlxuICAgIC8vXG4gICAgLy8gVGhlcmUgaXMgYW4gZXhjZXB0aW9uOiB3aGVuIHRoZSBicm93c2VyIGlzIGNvbmZpZ3VyZWQgdG8gZm9yY2UtZW5hYmxlIFNoYXJlZEFycmF5QnVmZmVyIChlLmcuIENocm9tdWltIHdpdGhcbiAgICAvLyAtLWVuYWJsZS1mZWF0dXJlcz1TaGFyZWRBcnJheUJ1ZmZlciksIGl0IGlzIHBvc3NpYmxlIHRoYXQgYHNlbGYuY3Jvc3NPcmlnaW5Jc29sYXRlZGAgaXMgZmFsc2UgYW5kXG4gICAgLy8gU2hhcmVkQXJyYXlCdWZmZXIgaXMgYXZhaWxhYmxlIGF0IHRoZSBzYW1lIHRpbWUuIFRoaXMgaXMgdXN1YWxseSBmb3IgdGVzdGluZy4gSW4gdGhpcyBjYXNlLCAgd2Ugd2lsbCBzdGlsbCBzZXRcbiAgICAvLyBudW1UaHJlYWRzIHRvIDEgaGVyZS4gSWYgd2Ugd2FudCB0byBlbmFibGUgbXVsdGktdGhyZWFkaW5nIGluIHRlc3QsIHdlIHNob3VsZCBzZXQgYG9ydC5lbnYud2FzbS5udW1UaHJlYWRzYCB0byBhXG4gICAgLy8gdmFsdWUgZ3JlYXRlciB0aGFuIDEuXG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiAhc2VsZi5jcm9zc09yaWdpbklzb2xhdGVkKSB7XG4gICAgICBlbnYud2FzbS5udW1UaHJlYWRzID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbnVtQ3B1TG9naWNhbENvcmVzID1cbiAgICAgICAgdHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcgPyByZXF1aXJlKCdub2RlOm9zJykuY3B1cygpLmxlbmd0aCA6IG5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5O1xuICAgICAgZW52Lndhc20ubnVtVGhyZWFkcyA9IE1hdGgubWluKDQsIE1hdGguY2VpbCgobnVtQ3B1TG9naWNhbENvcmVzIHx8IDEpIC8gMikpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghQlVJTERfREVGUy5ESVNBQkxFX0RZTkFNSUNfSU1QT1JUKSB7XG4gICAgLy8gb3ZlcndyaXRlIHdhc20gcGF0aHMgb3ZlcnJpZGUgaWYgbm90IHNldFxuICAgIGlmIChlbnYud2FzbS53YXNtUGF0aHMgPT09IHVuZGVmaW5lZCAmJiBzY3JpcHRTcmMgJiYgc2NyaXB0U3JjLmluZGV4T2YoJ2Jsb2I6JykgIT09IDApIHtcbiAgICAgIGVudi53YXNtLndhc21QYXRocyA9IHNjcmlwdFNyYy5zdWJzdHJpbmcoMCwgc2NyaXB0U3JjLmxhc3RJbmRleE9mKCcvJykgKyAxKTtcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCBjbGFzcyBPbm54cnVudGltZVdlYkFzc2VtYmx5QmFja2VuZCBpbXBsZW1lbnRzIEJhY2tlbmQge1xuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBpbml0aWFsaXplcyB0aGUgV2ViQXNzZW1ibHkgYmFja2VuZC5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBvbmx5IG9uY2UgZm9yIGVhY2ggYmFja2VuZCBuYW1lLiBJdCB3aWxsIGJlIGNhbGxlZCB0aGUgZmlyc3QgdGltZSB3aGVuXG4gICAqIGBvcnQuSW5mZXJlbmNlU2Vzc2lvbi5jcmVhdGUoKWAgaXMgY2FsbGVkIHdpdGggYSByZWdpc3RlcmVkIGJhY2tlbmQgbmFtZS5cbiAgICpcbiAgICogQHBhcmFtIGJhY2tlbmROYW1lIC0gdGhlIHJlZ2lzdGVyZWQgYmFja2VuZCBuYW1lLlxuICAgKi9cbiAgYXN5bmMgaW5pdChiYWNrZW5kTmFtZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gcG9wdWxhdGUgd2FzbSBmbGFnc1xuICAgIGluaXRpYWxpemVGbGFncygpO1xuXG4gICAgLy8gaW5pdCB3YXNtXG4gICAgYXdhaXQgaW5pdGlhbGl6ZVdlYkFzc2VtYmx5QW5kT3J0UnVudGltZSgpO1xuXG4gICAgLy8gcGVyZm9ybWUgRVAgc3BlY2lmaWMgaW5pdGlhbGl6YXRpb25cbiAgICBhd2FpdCBpbml0aWFsaXplT3J0RXAoYmFja2VuZE5hbWUpO1xuICB9XG4gIGNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyKFxuICAgIHBhdGg6IHN0cmluZyxcbiAgICBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcj47XG4gIGNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyKFxuICAgIGJ1ZmZlcjogVWludDhBcnJheSxcbiAgICBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcj47XG4gIGFzeW5jIGNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyKFxuICAgIHBhdGhPckJ1ZmZlcjogc3RyaW5nIHwgVWludDhBcnJheSxcbiAgICBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcj4ge1xuICAgIGNvbnN0IGhhbmRsZXIgPSBuZXcgT25ueHJ1bnRpbWVXZWJBc3NlbWJseVNlc3Npb25IYW5kbGVyKCk7XG4gICAgYXdhaXQgaGFuZGxlci5sb2FkTW9kZWwocGF0aE9yQnVmZmVyLCBvcHRpb25zKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGhhbmRsZXIpO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCB3YXNtQmFja2VuZCA9IG5ldyBPbm54cnVudGltZVdlYkFzc2VtYmx5QmFja2VuZCgpO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzICovXG5cbi8vIFdlIHVzZSBcInJlcXVpcmVcIiBpbnN0ZWFkIG9mIFwiaW1wb3J0XCIgaGVyZSBiZWNhdXNlIGltcG9ydCBzdGF0ZW1lbnQgbXVzdCBiZSBwdXQgaW4gdG9wIGxldmVsLiBPdXIgY3VycmVudCBjb2RlIGRvZXNcbi8vIG5vdCBhbGxvdyBidW5kbGVyIHRvIHRyZWUtc2hha2luZyBjb2RlIGFzIGV4cGVjdGVkIGJlY2F1c2Ugc29tZSBjb2RlcyBhcmUgdHJlYXRlZCBhcyBoYXZpbmcgc2lkZSBlZmZlY3RzLlxuLy8gU28gd2UgaW1wb3J0IGNvZGUgaW5zaWRlIHRoZSBpZi1jbGF1c2UgdG8gYWxsb3cgYnVuZGxlciByZW1vdmUgdGhlIGNvZGUgc2FmZWx5LlxuXG5leHBvcnQgKiBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuaW1wb3J0ICogYXMgb3J0IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5leHBvcnQgZGVmYXVsdCBvcnQ7XG5cbmltcG9ydCB7IHJlZ2lzdGVyQmFja2VuZCwgZW52IH0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuL3ZlcnNpb24nO1xuXG5pZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9XRUJHTCkge1xuICBjb25zdCBvbm54anNCYWNrZW5kID0gcmVxdWlyZSgnLi9iYWNrZW5kLW9ubnhqcycpLm9ubnhqc0JhY2tlbmQ7XG4gIHJlZ2lzdGVyQmFja2VuZCgnd2ViZ2wnLCBvbm54anNCYWNrZW5kLCAtMTApO1xufVxuXG5pZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9XQVNNKSB7XG4gIGNvbnN0IHdhc21CYWNrZW5kID0gcmVxdWlyZSgnLi9iYWNrZW5kLXdhc20nKS53YXNtQmFja2VuZDtcbiAgaWYgKCFCVUlMRF9ERUZTLkRJU0FCTEVfSlNFUCkge1xuICAgIHJlZ2lzdGVyQmFja2VuZCgnd2ViZ3B1Jywgd2FzbUJhY2tlbmQsIDUpO1xuICAgIHJlZ2lzdGVyQmFja2VuZCgnd2Vibm4nLCB3YXNtQmFja2VuZCwgNSk7XG4gIH1cbiAgcmVnaXN0ZXJCYWNrZW5kKCdjcHUnLCB3YXNtQmFja2VuZCwgMTApO1xuICByZWdpc3RlckJhY2tlbmQoJ3dhc20nLCB3YXNtQmFja2VuZCwgMTApO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZW52LnZlcnNpb25zLCAnd2ViJywgeyB2YWx1ZTogdmVyc2lvbiwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuLy8gVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBieSAvanMvc2NyaXB0cy91cGRhdGUtdmVyc2lvbi50c1xuLy8gRG8gbm90IG1vZGlmeSBmaWxlIGNvbnRlbnQgbWFudWFsbHkuXG5cbmV4cG9ydCBjb25zdCB2ZXJzaW9uID0gJzEuMjAuMCc7XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsTUFnQk0sVUFDQSwwQkFZTyxpQkF3Q1AsZ0NBd0NPO0FBN0diOzs7QUFnQkEsTUFBTSxXQUFxQyxvQkFBSSxJQUFHO0FBQ2xELE1BQU0sMkJBQXFDLENBQUE7QUFZcEMsTUFBTSxrQkFBa0IsQ0FBQ0EsT0FBY0MsVUFBa0IsYUFBMEI7QUFDeEYsWUFBSUEsWUFBVyxPQUFPQSxTQUFRLFNBQVMsY0FBYyxPQUFPQSxTQUFRLGtDQUFrQyxZQUFZO0FBQ2hILGdCQUFNLGlCQUFpQixTQUFTLElBQUlELEtBQUk7QUFDeEMsY0FBSSxtQkFBbUIsUUFBVztBQUNoQyxxQkFBUyxJQUFJQSxPQUFNLEVBQUUsU0FBQUMsVUFBUyxTQUFRLENBQUU7cUJBQy9CLGVBQWUsV0FBVyxVQUFVO0FBRTdDO3FCQUNTLGVBQWUsYUFBYSxVQUFVO0FBQy9DLGdCQUFJLGVBQWUsWUFBWUEsVUFBUztBQUN0QyxvQkFBTSxJQUFJLE1BQU0sNEJBQTRCRCxLQUFJLG9CQUFvQixRQUFRLEVBQUU7OztBQUlsRixjQUFJLFlBQVksR0FBRztBQUNqQixrQkFBTSxJQUFJLHlCQUF5QixRQUFRQSxLQUFJO0FBQy9DLGdCQUFJLE1BQU0sSUFBSTtBQUNaLHVDQUF5QixPQUFPLEdBQUcsQ0FBQzs7QUFHdEMscUJBQVNFLEtBQUksR0FBR0EsS0FBSSx5QkFBeUIsUUFBUUEsTUFBSztBQUN4RCxrQkFBSSxTQUFTLElBQUkseUJBQXlCQSxFQUFDLENBQUMsRUFBRyxZQUFZLFVBQVU7QUFDbkUseUNBQXlCLE9BQU9BLElBQUcsR0FBR0YsS0FBSTtB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SSxNQXFHQSxXQU9BLFlBMkdBLFNBK0ZBLGdCQU9BLGdCQU9BLGdCQU9BLGdCQU9BLGdCQU9BLFlBTUEsTUFZQSxPQVlBLEtBWUEsTUFZQSxTQVlBLFdBWUEsb0JBWUEsV0FZQSxlQXMrQkc7QUExN0NQO0FBQUE7QUFxQkEsTUFBSSxPQUFPO0FBQ1gsVUFBSTtBQUNGLGVBQU8sSUFBSSxZQUFZLFNBQVMsSUFBSSxZQUFZLE9BQU8sSUFBSSxXQUFXO0FBQUEsVUFDcEU7QUFBQSxVQUFHO0FBQUEsVUFBSTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBRztBQUFBLFVBQUc7QUFBQSxVQUFHO0FBQUEsVUFBRztBQUFBLFVBQUc7QUFBQSxVQUFJO0FBQUEsVUFBRztBQUFBLFVBQUk7QUFBQSxVQUFHO0FBQUEsVUFBRztBQUFBLFVBQUs7QUFBQSxVQUFJO0FBQUEsVUFBRztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFHO0FBQUEsVUFBSztBQUFBLFVBQUc7QUFBQSxVQUFHO0FBQUEsVUFBRztBQUFBLFVBQUc7QUFBQSxVQUFHO0FBQUEsVUFBRztBQUFBLFVBQUc7QUFBQSxVQUFHO0FBQUEsVUFBRztBQUFBLFVBQUc7QUFBQSxVQUFHO0FBQUEsVUFBRztBQUFBLFVBQUs7QUFBQSxVQUFHO0FBQUEsVUFBSTtBQUFBLFVBQUc7QUFBQSxVQUFJO0FBQUEsVUFBRztBQUFBLFVBQUk7QUFBQSxVQUFHO0FBQUEsVUFBRztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUc7QUFBQSxVQUFHO0FBQUEsVUFBRztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUk7QUFBQSxVQUFLO0FBQUEsVUFBRztBQUFBLFVBQUc7QUFBQSxVQUFHO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSTtBQUFBLFVBQUs7QUFBQSxVQUFHO0FBQUEsVUFBRztBQUFBLFVBQUc7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFJO0FBQUEsVUFBSztBQUFBLFVBQUc7QUFBQSxVQUFHO0FBQUEsVUFBRztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUk7QUFBQSxVQUFLO0FBQUEsVUFBRztBQUFBLFVBQUc7QUFBQSxVQUFHO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFHO0FBQUEsVUFBRztBQUFBLFVBQUk7QUFBQSxVQUFLO0FBQUEsVUFBRztBQUFBLFVBQUc7QUFBQSxVQUFHO0FBQUEsVUFBRztBQUFBLFVBQUk7QUFBQSxVQUFHO0FBQUEsVUFBSTtBQUFBLFVBQUk7QUFBQSxVQUFHO0FBQUEsVUFBRztBQUFBLFVBQUs7QUFBQSxVQUFJO0FBQUEsVUFBRztBQUFBLFVBQUs7QUFBQSxVQUFJO0FBQUEsVUFBRztBQUFBLFVBQUs7QUFBQSxVQUFJO0FBQUEsVUFBSTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSTtBQUFBLFVBQUc7QUFBQSxVQUFLO0FBQUEsVUFBSTtBQUFBLFVBQUc7QUFBQSxVQUFLO0FBQUEsVUFBSTtBQUFBLFVBQUk7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFJO0FBQUEsVUFBRztBQUFBLFVBQUk7QUFBQSxVQUFJO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFJO0FBQUEsVUFBRztBQUFBLFVBQUk7QUFBQSxVQUFHO0FBQUEsVUFBSztBQUFBLFVBQUk7QUFBQSxVQUFJO0FBQUEsVUFBRztBQUFBLFVBQUc7QUFBQSxVQUFLO0FBQUEsVUFBSTtBQUFBLFVBQUc7QUFBQSxVQUFLO0FBQUEsVUFBSTtBQUFBLFVBQUc7QUFBQSxVQUFLO0FBQUEsVUFBSTtBQUFBLFVBQUk7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUk7QUFBQSxVQUFHO0FBQUEsVUFBSztBQUFBLFVBQUk7QUFBQSxVQUFHO0FBQUEsVUFBSztBQUFBLFVBQUk7QUFBQSxVQUFJO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSTtBQUFBLFVBQUc7QUFBQSxVQUFJO0FBQUEsVUFBSTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSTtBQUFBLFVBQUc7QUFBQSxVQUFJO0FBQUEsVUFBRztBQUFBLFVBQUs7QUFBQSxVQUFJO0FBQUEsVUFBSTtBQUFBLFVBQUc7QUFBQSxVQUFHO0FBQUEsVUFBSztBQUFBLFVBQUk7QUFBQSxVQUFHO0FBQUEsVUFBSztBQUFBLFVBQUk7QUFBQSxVQUFHO0FBQUEsVUFBSztBQUFBLFVBQUk7QUFBQSxVQUFJO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFJO0FBQUEsVUFBRztBQUFBLFVBQUs7QUFBQSxVQUFJO0FBQUEsVUFBRztBQUFBLFVBQUs7QUFBQSxVQUFJO0FBQUEsVUFBSTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUk7QUFBQSxVQUFHO0FBQUEsVUFBSTtBQUFBLFVBQUk7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUk7QUFBQSxVQUFHO0FBQUEsVUFBSTtBQUFBLFVBQUc7QUFBQSxVQUFLO0FBQUEsVUFBSTtBQUFBLFVBQUk7QUFBQSxVQUFHO0FBQUEsVUFBRztBQUFBLFVBQUs7QUFBQSxVQUFJO0FBQUEsVUFBRztBQUFBLFVBQUs7QUFBQSxVQUFJO0FBQUEsVUFBRztBQUFBLFVBQUs7QUFBQSxVQUFJO0FBQUEsVUFBSTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSTtBQUFBLFVBQUc7QUFBQSxVQUFLO0FBQUEsVUFBSTtBQUFBLFVBQUc7QUFBQSxVQUFLO0FBQUEsVUFBSTtBQUFBLFVBQUk7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFJO0FBQUEsVUFBRztBQUFBLFVBQUk7QUFBQSxVQUFJO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFJO0FBQUEsVUFBRztBQUFBLFVBQUk7QUFBQSxVQUFHO0FBQUEsVUFBSztBQUFBLFVBQUk7QUFB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QkFBQUM7QUFBQSxJQUFBO0FBQUEsZUFBQUM7QUFBQSxJQUFBO0FBQUE7QUFTQTtBQUNBO0FBR0E7OztBQ1BPLE1BQU1DLFdBQVU7OztBREt2QixNQUFPLGNBQVE7QUFLZixNQUFJLE1BQTJCO0FBQzdCLFVBQU1DLGlCQUFnQiw4REFBNEI7QUFDbEQsb0JBQWdCLFNBQVNBLGdCQUFlLEdBQUc7QUFBQSxFQUM3QztBQUVBLE1BQUksTUFBMEI7QUFDNUIsVUFBTUMsZUFBYywwREFBMEI7QUFDOUMsUUFBSSxPQUEwQjtBQUM1QixzQkFBZ0IsVUFBVUEsY0FBYSxDQUFDO0FBQ3hDLHNCQUFnQixTQUFTQSxjQUFhLENBQUM7QUFBQSxJQUN6QztBQUNBLG9CQUFnQixPQUFPQSxjQUFhLEVBQUU7QUFDdEMsb0JBQWdCLFFBQVFBLGNBQWEsRUFBRTtBQUFBLEVBQ3pDO0FBRUEsU0FBTyxlQUFlQyxLQUFJLFVBQVUsT0FBTyxFQUFFLE9BQU9DLFVBQVMsWUFBWSxLQUFLLENBQUM7IiwKICAibmFtZXMiOiBbIm5hbWUiLCAiYmFja2VuZCIsICJpIiwgImVudiIsICJjcmVhdGVDYW52YXMiLCAiVGVuc29yIiwgIlRlbnNvciIsICJuYW1lIiwgImJhY2tlbmQiLCAiSW5mZXJlbmNlU2Vzc2lvbiIsICJiYWNrZW5kIiwgIlRlbnNvciIsICJuYW1lIiwgIlRyYWluaW5nU2Vzc2lvbiIsICJJbmZlcmVuY2VTZXNzaW9uIiwgIlRlbnNvciIsICJUcmFpbmluZ1Nlc3Npb24iLCAiZW52IiwgImxvZyIsICJlbnYiLCAibmFtZSIsICJ2ZXJzaW9uIiwgImV4cG9ydHMiLCAiR3VpZCIsICJjYWNoZSIsICJkaXYiLCAibG9nMiIsICJvbm54cnVudGltZSIsICJleHBlcmltZW50YWwiLCAiZmJzIiwgIkF0dHJpYnV0ZVR5cGUiLCAiRGltZW5zaW9uVmFsdWVUeXBlIiwgIlRlbnNvckRhdGFUeXBlIiwgIk5vZGVUeXBlIiwgIlR5cGVJbmZvVmFsdWUiLCAiTm9kZSIsICJ2ZXJzaW9uIiwgIlRlbnNvciIsICJBdHRyaWJ1dGUiLCAiR3JhcGgiLCAiTW9kZWwiLCAiSW5mZXJlbmNlU2Vzc2lvbiIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJwYXJhbXMiLCAib2Zmc2V0IiwgImV4cG9ydHMiLCAiaSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgInNsaWNlIiwgInNpemUiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZnJvbU51bWJlciIsICJ0b051bWJlciIsICJleHBvcnRzIiwgIkJ1ZmZlciIsICJuYW1lIiwgImkiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiY3JlYXRlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImNyZWF0ZV9hcnJheSIsICJjcmVhdGUiLCAiYnVmZmVyIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgInNlbGYiLCAiZXJyIiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZXhwb3J0cyIsICJyZXF1aXJlX21pbmltYWwiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAib25ueCIsICJUZW5zb3IiLCAiTWFwIiwgImluaXRfdGVuc29yIiwgIlRlbnNvciIsICJzaGFwZSIsICJzcGxpdCIsICJpbXBvcnRfb25ueCIsICJUZW5zb3IiLCAiaW5pdF90ZW5zb3IiLCAiY2FjaGUiLCAidmVyc2lvbiIsICJuYW1lIiwgInNoYXBlIiwgInNoYXBlIiwgInNoYXBlIiwgImluaXRfdGVuc29yIiwgInNoYXBlIiwgIlRlbnNvciIsICJuYW1lIiwgIm5hbWUiLCAibmFtZSIsICJhZGQiLCAiYW5kIiwgIm9yIiwgInhvciIsICJnbHNsIiwgInNoYWRlclNvdXJjZSIsICJ2YWxpZGF0ZUlucHV0cyIsICJzaGlmdCIsICJ2YWxpZGF0ZUlucHV0cyIsICJuYW1lIiwgImxvZyIsICJub3QiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAibmFtZSIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJzaGFwZSIsICJ2YWxpZGF0ZUlucHV0cyIsICJzdW0iLCAidmFsaWRhdGVJbnB1dHMiLCAibmFtZSIsICJpbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAiZGltIiwgInZhbGlkYXRlSW5wdXRzIiwgInZhbGlkYXRlSW5wdXRzIiwgImluaXRfdGVuc29yIiwgIlRlbnNvciIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJzcGxpdCIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0c1YxMyIsICJhZGQiLCAiYW5kIiwgImxvZyIsICJub3QiLCAib3IiLCAieG9yIiwgIm5hbWUiLCAic2hhcGUiLCAic2hhcGUiLCAibmFtZSIsICJzb3VyY2UiLCAicGFja2VkU2FtcGxlciIsICJ0ZXhOdW1SIiwgInRleE51bUMiLCAidHJhbnNwb3NlIiwgIm5hbWUiLCAic2hhcGUiLCAiaSIsICJuYW1lIiwgIm5hbWUiLCAiZW52IiwgIm5hbWUiLCAibG9jYXRpb24iLCAidGV4dHVyZSIsICJiYWNrZW5kIiwgInZlcnNpb24iLCAiZW52IiwgImVudiIsICJjYWNoZSIsICJiYWNrZW5kIiwgImluaXRfYmFja2VuZCIsICJvdXRwdXQiLCAiaW1wb3J0X29ubngiLCAib3J0RmJzIiwgImluaXRfdGVuc29yIiwgIlRlbnNvciIsICJ2YWx1ZSIsICJpbXBvcnRfb25ueCIsICJvcnRGYnMiLCAiaW5pdF90ZW5zb3IiLCAibmFtZSIsICJUZW5zb3IiLCAic2hhcGUiLCAibm9kZUluZGV4IiwgImltcG9ydF9vbm54IiwgIm9ydEZicyIsICJpbml0X2JhY2tlbmQiLCAiYmFja2VuZCIsICJpbml0X3RlbnNvciIsICJuYW1lIiwgIlRlbnNvciIsICJlbnYiLCAid2FzbSIsICJtb2R1bGUiLCAid2FzbSIsICJuYW1lIiwgIndhc20iLCAid2FzbSIsICJuYW1lIiwgImxvY2F0aW9uIiwgImVudiIsICJ3YXNtIiwgIm5hbWUiLCAibG9jYXRpb24iLCAidGVuc29yIiwgImVycm9yQ29kZSIsICJpIiwgImluaXRpYWxpemluZyIsICJpbml0aWFsaXplZCIsICJhYm9ydGVkIiwgImNvcHlGcm9tRXh0ZXJuYWxCdWZmZXIiLCAiY3JlYXRlU2Vzc2lvbiIsICJyZWxlYXNlU2Vzc2lvbiIsICJydW4iLCAiZW5kUHJvZmlsaW5nIiwgImVudiIsICJpbml0X3Nlc3Npb25faGFuZGxlcl9pbmZlcmVuY2UiLCAiVGVuc29yIiwgImNvcHlGcm9tRXh0ZXJuYWxCdWZmZXIiLCAiY3JlYXRlU2Vzc2lvbiIsICJyZWxlYXNlU2Vzc2lvbiIsICJuYW1lIiwgInJ1biIsICJlbmRQcm9maWxpbmciLCAiaW5pdF9zZXNzaW9uX2hhbmRsZXJfaW5mZXJlbmNlIiwgImVudiIsICJJbmZlcmVuY2VTZXNzaW9uIiwgIlRlbnNvciIsICJUcmFpbmluZ1Nlc3Npb24iLCAiZW52IiwgInZlcnNpb24iLCAib25ueGpzQmFja2VuZCIsICJ3YXNtQmFja2VuZCIsICJlbnYiLCAidmVyc2lvbiJdCn0K
