/*!
 * ONNX Runtime Web v1.19.0
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
"use strict";var ort=(()=>{var et=Object.defineProperty;var Gn=Object.getOwnPropertyDescriptor;var jn=Object.getOwnPropertyNames;var Vn=Object.prototype.hasOwnProperty;var tt=(t=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(t,{get:(e,n)=>(typeof require<"u"?require:e)[n]}):t)(function(t){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+t+'" is not supported')});var b=(t,e)=>()=>(t&&(e=t(t=0)),e);var Oe=(t,e)=>{for(var n in e)et(t,n,{get:e[n],enumerable:!0})},Yn=(t,e,n,o)=>{if(e&&typeof e=="object"||typeof e=="function")for(let r of jn(e))!Vn.call(t,r)&&r!==n&&et(t,r,{get:()=>e[r],enumerable:!(o=Gn(e,r))||o.enumerable});return t};var nt=t=>Yn(et({},"__esModule",{value:!0}),t);var Ae,j,ee,qn,Ie,ve=b(()=>{"use strict";Ae=new Map,j=[],ee=(t,e,n)=>{if(e&&typeof e.init=="function"&&typeof e.createInferenceSessionHandler=="function"){let o=Ae.get(t);if(o===void 0)Ae.set(t,{backend:e,priority:n});else{if(o.priority>n)return;if(o.priority===n&&o.backend!==e)throw new Error(`cannot register backend "${t}" using priority ${n}`)}if(n>=0){let r=j.indexOf(t);r!==-1&&j.splice(r,1);for(let a=0;a<j.length;a++)if(Ae.get(j[a]).priority<=n){j.splice(a,0,t);return}j.push(t)}return}throw new TypeError("not a valid backend")},qn=async t=>{let e=Ae.get(t);if(!e)return"backend not found.";if(e.initialized)return e.backend;if(e.aborted)return e.error;{let n=!!e.initPromise;try{return n||(e.initPromise=e.backend.init(t)),await e.initPromise,e.initialized=!0,e.backend}catch(o){return n||(e.error=`${o}`,e.aborted=!0),e.error}finally{delete e.initPromise}}},Ie=async t=>{let e=t.executionProviders||[],n=e.map(c=>typeof c=="string"?c:c.name),o=n.length===0?j:n,r,a=[],s=new Set;for(let c of o){let u=await qn(c);typeof u=="string"?a.push({name:c,err:u}):(r||(r=u),r===u&&s.add(c))}if(!r)throw new Error(`no available backend found. ERR: ${a.map(c=>`[${c.name}] ${c.err}`).join(", ")}`);for(let{name:c,err:u}of a)n.includes(c)&&console.warn(`removing requested execution provider "${c}" from session options because it is not available: ${u}`);let i=e.filter(c=>s.has(typeof c=="string"?c:c.name));return[r,new Proxy(t,{get:(c,u)=>u==="executionProviders"?i:Reflect.get(c,u)})]}});var Pt=b(()=>{"use strict";ve()});var xt,Ct=b(()=>{"use strict";xt="1.19.0"});var Bt,L,rt=b(()=>{"use strict";Ct();Bt="warning",L={wasm:{},webgl:{},webgpu:{},versions:{common:xt},set logLevel(t){if(t!==void 0){if(typeof t!="string"||["verbose","info","warning","error","fatal"].indexOf(t)===-1)throw new Error(`Unsupported logging level: ${t}`);Bt=t}},get logLevel(){return Bt}};Object.defineProperty(L,"logLevel",{enumerable:!0})});var A,_t=b(()=>{"use strict";rt();A=L});var Rt,Lt,Mt=b(()=>{"use strict";Rt=(t,e)=>{let n=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);n.width=t.dims[3],n.height=t.dims[2];let o=n.getContext("2d");if(o!=null){let r,a;e?.tensorLayout!==void 0&&e.tensorLayout==="NHWC"?(r=t.dims[2],a=t.dims[3]):(r=t.dims[3],a=t.dims[2]);let s=e?.format!==void 0?e.format:"RGB",i=e?.norm,c,u;i===void 0||i.mean===void 0?c=[255,255,255,255]:typeof i.mean=="number"?c=[i.mean,i.mean,i.mean,i.mean]:(c=[i.mean[0],i.mean[1],i.mean[2],0],i.mean[3]!==void 0&&(c[3]=i.mean[3])),i===void 0||i.bias===void 0?u=[0,0,0,0]:typeof i.bias=="number"?u=[i.bias,i.bias,i.bias,i.bias]:(u=[i.bias[0],i.bias[1],i.bias[2],0],i.bias[3]!==void 0&&(u[3]=i.bias[3]));let f=a*r,l=0,d=f,p=f*2,h=-1;s==="RGBA"?(l=0,d=f,p=f*2,h=f*3):s==="RGB"?(l=0,d=f,p=f*2):s==="RBG"&&(l=0,p=f,d=f*2);for(let m=0;m<a;m++)for(let g=0;g<r;g++){let T=(t.data[l++]-u[0])*c[0],w=(t.data[d++]-u[1])*c[1],y=(t.data[p++]-u[2])*c[2],S=h===-1?255:(t.data[h++]-u[3])*c[3];o.fillStyle="rgba("+T+","+w+","+y+","+S+")",o.fillRect(g,m,1,1)}if("toDataURL"in n)return n.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},Lt=(t,e)=>{let n=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d"),o;if(n!=null){let r,a,s;e?.tensorLayout!==void 0&&e.tensorLayout==="NHWC"?(r=t.dims[2],a=t.dims[1],s=t.dims[3]):(r=t.dims[3],a=t.dims[2],s=t.dims[1]);let i=e!==void 0&&e.format!==void 0?e.format:"RGB",c=e?.norm,u,f;c===void 0||c.mean===void 0?u=[255,255,255,255]:typeof c.mean=="number"?u=[c.mean,c.mean,c.mean,c.mean]:(u=[c.mean[0],c.mean[1],c.mean[2],255],c.mean[3]!==void 0&&(u[3]=c.mean[3])),c===void 0||c.bias===void 0?f=[0,0,0,0]:typeof c.bias=="number"?f=[c.bias,c.bias,c.bias,c.bias]:(f=[c.bias[0],c.bias[1],c.bias[2],0],c.bias[3]!==void 0&&(f[3]=c.bias[3]));let l=a*r;if(e!==void 0&&(e.format!==void 0&&s===4&&e.format!=="RGBA"||s===3&&e.format!=="RGB"&&e.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let d=4,p=0,h=1,m=2,g=3,T=0,w=l,y=l*2,S=-1;i==="RGBA"?(T=0,w=l,y=l*2,S=l*3):i==="RGB"?(T=0,w=l,y=l*2):i==="RBG"&&(T=0,y=l,w=l*2),o=n.createImageData(r,a);for(let P=0;P<a*r;p+=d,h+=d,m+=d,g+=d,P++)o.data[p]=(t.data[T++]-f[0])*u[0],o.data[h]=(t.data[w++]-f[1])*u[1],o.data[m]=(t.data[y++]-f[2])*u[2],o.data[g]=S===-1?255:(t.data[S++]-f[3])*u[3]}else throw new Error("Can not access image data");return o}});var ot,Ut,kt,Dt,Nt,Ft=b(()=>{"use strict";Pe();ot=(t,e)=>{if(t===void 0)throw new Error("Image buffer must be defined");if(e.height===void 0||e.width===void 0)throw new Error("Image height and width must be defined");if(e.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:n,width:o}=e,r=e.norm??{mean:255,bias:0},a,s;typeof r.mean=="number"?a=[r.mean,r.mean,r.mean,r.mean]:a=[r.mean[0],r.mean[1],r.mean[2],r.mean[3]??255],typeof r.bias=="number"?s=[r.bias,r.bias,r.bias,r.bias]:s=[r.bias[0],r.bias[1],r.bias[2],r.bias[3]??0];let i=e.format!==void 0?e.format:"RGBA",c=e.tensorFormat!==void 0&&e.tensorFormat!==void 0?e.tensorFormat:"RGB",u=n*o,f=c==="RGBA"?new Float32Array(u*4):new Float32Array(u*3),l=4,d=0,p=1,h=2,m=3,g=0,T=u,w=u*2,y=-1;i==="RGB"&&(l=3,d=0,p=1,h=2,m=-1),c==="RGBA"?y=u*3:c==="RBG"?(g=0,w=u,T=u*2):c==="BGR"&&(w=0,T=u,g=u*2);for(let P=0;P<u;P++,d+=l,h+=l,p+=l,m+=l)f[g++]=(t[d]+s[0])/a[0],f[T++]=(t[p]+s[1])/a[1],f[w++]=(t[h]+s[2])/a[2],y!==-1&&m!==-1&&(f[y++]=(t[m]+s[3])/a[3]);return c==="RGBA"?new C("float32",f,[1,4,n,o]):new C("float32",f,[1,3,n,o])},Ut=async(t,e)=>{let n=typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement,o=typeof ImageData<"u"&&t instanceof ImageData,r=typeof ImageBitmap<"u"&&t instanceof ImageBitmap,a=typeof t=="string",s,i=e??{},c=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},u=f=>f instanceof HTMLCanvasElement||f instanceof OffscreenCanvas?f.getContext("2d"):null;if(n){let f=c();f.width=t.width,f.height=t.height;let l=u(f);if(l!=null){let d=t.height,p=t.width;if(e!==void 0&&e.resizedHeight!==void 0&&e.resizedWidth!==void 0&&(d=e.resizedHeight,p=e.resizedWidth),e!==void 0){if(i=e,e.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");i.tensorFormat="RGBA",i.height=d,i.width=p}else i.tensorFormat="RGBA",i.height=d,i.width=p;l.drawImage(t,0,0),s=l.getImageData(0,0,p,d).data}else throw new Error("Can not access image data")}else if(o){let f,l;if(e!==void 0&&e.resizedWidth!==void 0&&e.resizedHeight!==void 0?(f=e.resizedHeight,l=e.resizedWidth):(f=t.height,l=t.width),e!==void 0&&(i=e),i.format="RGBA",i.height=f,i.width=l,e!==void 0){let d=c();d.width=l,d.height=f;let p=u(d);if(p!=null)p.putImageData(t,0,0),s=p.getImageData(0,0,l,f).data;else throw new Error("Can not access image data")}else s=t.data}else if(r){if(e===void 0)throw new Error("Please provide image config with format for Imagebitmap");let f=c();f.width=t.width,f.height=t.height;let l=u(f);if(l!=null){let d=t.height,p=t.width;return l.drawImage(t,0,0,p,d),s=l.getImageData(0,0,p,d).data,i.height=d,i.width=p,ot(s,i)}else throw new Error("Can not access image data")}else{if(a)return new Promise((f,l)=>{let d=c(),p=u(d);if(!t||!p)return l();let h=new Image;h.crossOrigin="Anonymous",h.src=t,h.onload=()=>{d.width=h.width,d.height=h.height,p.drawImage(h,0,0,d.width,d.height);let m=p.getImageData(0,0,d.width,d.height);i.height=d.height,i.width=d.width,f(ot(m.data,i))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(s!==void 0)return ot(s,i);throw new Error("Input data provided is not supported - aborted tensor creation")},kt=(t,e)=>{let{width:n,height:o,download:r,dispose:a}=e,s=[1,o,n,4];return new C({location:"texture",type:"float32",texture:t,dims:s,download:r,dispose:a})},Dt=(t,e)=>{let{dataType:n,dims:o,download:r,dispose:a}=e;return new C({location:"gpu-buffer",type:n??"float32",gpuBuffer:t,dims:o,download:r,dispose:a})},Nt=(t,e,n)=>new C({location:"cpu-pinned",type:t,data:e,dims:n??[e.length]})});var V,le,Ht,zt,Wt=b(()=>{"use strict";V=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),le=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),Ht=!1,zt=()=>{if(!Ht){Ht=!0;let t=typeof BigInt64Array<"u"&&BigInt64Array.from,e=typeof BigUint64Array<"u"&&BigUint64Array.from,n=typeof Float16Array<"u"&&Float16Array.from;t&&(V.set("int64",BigInt64Array),le.set(BigInt64Array,"int64")),e&&(V.set("uint64",BigUint64Array),le.set(BigUint64Array,"uint64")),n?(V.set("float16",Float16Array),le.set(Float16Array,"float16")):V.set("float16",Uint16Array)}}});var $t,Gt,jt=b(()=>{"use strict";Pe();$t=t=>{let e=1;for(let n=0;n<t.length;n++){let o=t[n];if(typeof o!="number"||!Number.isSafeInteger(o))throw new TypeError(`dims[${n}] must be an integer, got: ${o}`);if(o<0)throw new RangeError(`dims[${n}] must be a non-negative integer, got: ${o}`);e*=o}return e},Gt=(t,e)=>{switch(t.location){case"cpu":return new C(t.type,t.data,e);case"cpu-pinned":return new C({location:"cpu-pinned",data:t.data,type:t.type,dims:e});case"texture":return new C({location:"texture",texture:t.texture,type:t.type,dims:e});case"gpu-buffer":return new C({location:"gpu-buffer",gpuBuffer:t.gpuBuffer,type:t.type,dims:e});default:throw new Error(`tensorReshape: tensor location ${t.location} is not supported`)}}});var C,Pe=b(()=>{"use strict";Mt();Ft();Wt();jt();C=class{constructor(e,n,o){zt();let r,a;if(typeof e=="object"&&"location"in e)switch(this.dataLocation=e.location,r=e.type,a=e.dims,e.location){case"cpu-pinned":{let i=V.get(r);if(!i)throw new TypeError(`unsupported type "${r}" to create tensor from pinned buffer`);if(!(e.data instanceof i))throw new TypeError(`buffer should be of type ${i.name}`);this.cpuData=e.data;break}case"texture":{if(r!=="float32")throw new TypeError(`unsupported type "${r}" to create tensor from texture`);this.gpuTextureData=e.texture,this.downloader=e.download,this.disposer=e.dispose;break}case"gpu-buffer":{if(r!=="float32"&&r!=="float16"&&r!=="int32"&&r!=="int64"&&r!=="uint32"&&r!=="uint8"&&r!=="bool")throw new TypeError(`unsupported type "${r}" to create tensor from gpu buffer`);this.gpuBufferData=e.gpuBuffer,this.downloader=e.download,this.disposer=e.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let i,c;if(typeof e=="string")if(r=e,c=o,e==="string"){if(!Array.isArray(n))throw new TypeError("A string tensor's data must be a string array.");i=n}else{let u=V.get(e);if(u===void 0)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(n)){if(e==="float16"&&u===Uint16Array)throw new TypeError("Creating a float16 tensor from number array is not supported. Please use Uint16Array as data.");e==="uint64"||e==="int64"?i=u.from(n,BigInt):i=u.from(n)}else if(n instanceof u)i=n;else throw new TypeError(`A ${r} tensor's data must be type of ${u}`)}else if(c=n,Array.isArray(e)){if(e.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let u=typeof e[0];if(u==="string")r="string",i=e;else if(u==="boolean")r="bool",i=Uint8Array.from(e);else throw new TypeError(`Invalid element type of data array: ${u}.`)}else{let u=le.get(e.constructor);if(u===void 0)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);r=u,i=e}if(c===void 0)c=[i.length];else if(!Array.isArray(c))throw new TypeError("A tensor's dims must be a number array");a=c,this.cpuData=i,this.dataLocation="cpu"}let s=$t(a);if(this.cpuData&&s!==this.cpuData.length)throw new Error(`Tensor's size(${s}) does not match data length(${this.cpuData.length}).`);this.type=r,this.dims=a,this.size=s}static async fromImage(e,n){return Ut(e,n)}static fromTexture(e,n){return kt(e,n)}static fromGpuBuffer(e,n){return Dt(e,n)}static fromPinnedBuffer(e,n,o){return Nt(e,n,o)}toDataURL(e){return Rt(this,e)}toImageData(e){return Lt(this,e)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}async getData(e){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let n=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=n,e&&this.disposer&&(this.disposer(),this.disposer=void 0),n}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(e){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return Gt(this,e)}}});var x,xe=b(()=>{"use strict";Pe();x=C});var st,Vt,z,W,at=b(()=>{"use strict";rt();st=(t,e)=>{(typeof L.trace>"u"?!L.wasm.trace:!L.trace)||console.timeStamp(`${t}::ORT::${e}`)},Vt=(t,e)=>{let n=new Error().stack?.split(/\r\n|\r|\n/g)||[],o=!1;for(let r=0;r<n.length;r++){if(o&&!n[r].includes("TRACE_FUNC")){let a=`FUNC_${t}::${n[r].trim().split(" ")[1]}`;e&&(a+=`::${e}`),st("CPU",a);return}n[r].includes("TRACE_FUNC")&&(o=!0)}},z=t=>{(typeof L.trace>"u"?!L.wasm.trace:!L.trace)||Vt("BEGIN",t)},W=t=>{(typeof L.trace>"u"?!L.wasm.trace:!L.trace)||Vt("END",t)}});var Ce,Yt=b(()=>{"use strict";ve();xe();at();Ce=class t{constructor(e){this.handler=e}async run(e,n,o){z();let r={},a={};if(typeof e!="object"||e===null||e instanceof x||Array.isArray(e))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let s=!0;if(typeof n=="object"){if(n===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(n instanceof x)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(n)){if(n.length===0)throw new TypeError("'fetches' cannot be an empty array.");s=!1;for(let u of n){if(typeof u!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(u)===-1)throw new RangeError(`'fetches' contains invalid output name: ${u}.`);r[u]=null}if(typeof o=="object"&&o!==null)a=o;else if(typeof o<"u")throw new TypeError("'options' must be an object.")}else{let u=!1,f=Object.getOwnPropertyNames(n);for(let l of this.outputNames)if(f.indexOf(l)!==-1){let d=n[l];(d===null||d instanceof x)&&(u=!0,s=!1,r[l]=d)}if(u){if(typeof o=="object"&&o!==null)a=o;else if(typeof o<"u")throw new TypeError("'options' must be an object.")}else a=n}}else if(typeof n<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let u of this.inputNames)if(typeof e[u]>"u")throw new Error(`input '${u}' is missing in 'feeds'.`);if(s)for(let u of this.outputNames)r[u]=null;let i=await this.handler.run(e,r,a),c={};for(let u in i)if(Object.hasOwnProperty.call(i,u)){let f=i[u];f instanceof x?c[u]=f:c[u]=new x(f.type,f.data,f.dims)}return W(),c}async release(){return this.handler.dispose()}static async create(e,n,o,r){z();let a,s={};if(typeof e=="string"){if(a=e,typeof n=="object"&&n!==null)s=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof Uint8Array){if(a=e,typeof n=="object"&&n!==null)s=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&e instanceof SharedArrayBuffer){let f=e,l=0,d=e.byteLength;if(typeof n=="object"&&n!==null)s=n;else if(typeof n=="number"){if(l=n,!Number.isSafeInteger(l))throw new RangeError("'byteOffset' must be an integer.");if(l<0||l>=f.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${f.byteLength}).`);if(d=e.byteLength-l,typeof o=="number"){if(d=o,!Number.isSafeInteger(d))throw new RangeError("'byteLength' must be an integer.");if(d<=0||l+d>f.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${f.byteLength-l}].`);if(typeof r=="object"&&r!==null)s=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else if(typeof o<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof n<"u")throw new TypeError("'options' must be an object.");a=new Uint8Array(f,l,d)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let[i,c]=await Ie(s),u=await i.createInferenceSessionHandler(a,c);return W(),new t(u)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}});var qt,Jt=b(()=>{"use strict";Yt();qt=Ce});var Xt=b(()=>{"use strict"});var Kt=b(()=>{"use strict"});var Qt=b(()=>{"use strict"});var Zt=b(()=>{"use strict"});var Jn,Be,en=b(()=>{"use strict";ve();xe();Jn="Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.",Be=class t{constructor(e,n,o){this.handler=e,this.hasOptimizerModel=n,this.hasEvalModel=o}get trainingInputNames(){return this.handler.inputNames}get trainingOutputNames(){return this.handler.outputNames}get evalInputNames(){if(this.hasEvalModel)return this.handler.evalInputNames;throw new Error("This training session has no evalModel loaded.")}get evalOutputNames(){if(this.hasEvalModel)return this.handler.evalOutputNames;throw new Error("This training session has no evalModel loaded.")}static async create(e,n){let o=e.evalModel||"",r=e.optimizerModel||"",a=n||{},[s,i]=await Ie(a);if(s.createTrainingSessionHandler){let c=await s.createTrainingSessionHandler(e.checkpointState,e.trainModel,o,r,i);return new t(c,!!e.optimizerModel,!!e.evalModel)}else throw new Error(Jn)}typeNarrowingForRunStep(e,n,o,r,a){let s={},i={};if(typeof o!="object"||o===null||o instanceof x||Array.isArray(o))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let c=!0;if(typeof r=="object"){if(r===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(r instanceof x)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(r)){if(r.length===0)throw new TypeError("'fetches' cannot be an empty array.");c=!1;for(let u of r){if(typeof u!="string")throw new TypeError("'fetches' must be a string array or an object.");if(n.indexOf(u)===-1)throw new RangeError(`'fetches' contains invalid output name: ${u}.`);s[u]=null}if(typeof a=="object"&&a!==null)i=a;else if(typeof a<"u")throw new TypeError("'options' must be an object.")}else{let u=!1,f=Object.getOwnPropertyNames(r);for(let l of n)if(f.indexOf(l)!==-1){let d=r[l];(d===null||d instanceof x)&&(u=!0,c=!1,s[l]=d)}if(u){if(typeof a=="object"&&a!==null)i=a;else if(typeof a<"u")throw new TypeError("'options' must be an object.")}else i=r}}else if(typeof r<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let u of e)if(typeof o[u]>"u")throw new Error(`input '${u}' is missing in 'feeds'.`);if(c)for(let u of n)s[u]=null;return[s,i]}convertHandlerReturnTypeToMapOfTensors(e){let n={};for(let o in e)if(Object.hasOwnProperty.call(e,o)){let r=e[o];r instanceof x?n[o]=r:n[o]=new x(r.type,r.data,r.dims)}return n}async lazyResetGrad(){await this.handler.lazyResetGrad()}async runTrainStep(e,n,o){let[r,a]=this.typeNarrowingForRunStep(this.trainingInputNames,this.trainingOutputNames,e,n,o),s=await this.handler.runTrainStep(e,r,a);return this.convertHandlerReturnTypeToMapOfTensors(s)}async runOptimizerStep(e){if(this.hasOptimizerModel)await this.handler.runOptimizerStep(e||{});else throw new Error("This TrainingSession has no OptimizerModel loaded.")}async runEvalStep(e,n,o){if(this.hasEvalModel){let[r,a]=this.typeNarrowingForRunStep(this.evalInputNames,this.evalOutputNames,e,n,o),s=await this.handler.runEvalStep(e,r,a);return this.convertHandlerReturnTypeToMapOfTensors(s)}else throw new Error("This TrainingSession has no EvalModel loaded.")}async getParametersSize(e=!0){return this.handler.getParametersSize(e)}async loadParametersBuffer(e,n=!0){let o=await this.getParametersSize(n);if(e.length!==4*o)throw new Error("Size of the buffer passed into loadParametersBuffer must match the number of parameters in the model. Please use getParametersSize method to check.");return this.handler.loadParametersBuffer(e,n)}async getContiguousParameters(e=!0){return this.handler.getContiguousParameters(e)}async release(){return this.handler.dispose()}}});var tn,nn=b(()=>{"use strict";en();tn=Be});var it={};Oe(it,{InferenceSession:()=>qt,TRACE:()=>st,TRACE_FUNC_BEGIN:()=>z,TRACE_FUNC_END:()=>W,Tensor:()=>x,TrainingSession:()=>tn,env:()=>A,registerBackend:()=>ee});var Y=b(()=>{"use strict";Pt();_t();Jt();xe();Xt();Kt();at();Qt();Zt();nn()});var _e=b(()=>{"use strict"});var an={};Oe(an,{default:()=>Xn});var on,sn,Xn,un=b(()=>{"use strict";pe();$();de();on="ort-wasm-proxy-worker",sn=globalThis.self?.name===on;sn&&(self.onmessage=t=>{let{type:e,in:n}=t.data;try{switch(e){case"init-wasm":Re(n.wasm).then(()=>{Le(n).then(()=>{postMessage({type:e})},o=>{postMessage({type:e,err:o})})},o=>{postMessage({type:e,err:o})});break;case"init-ep":{let{epName:o,env:r}=n;Me(r,o).then(()=>{postMessage({type:e})},a=>{postMessage({type:e,err:a})});break}case"copy-from":{let{buffer:o}=n,r=q(o);postMessage({type:e,out:r});break}case"create":{let{model:o,options:r}=n;Ue(o,r).then(a=>{postMessage({type:e,out:a})},a=>{postMessage({type:e,err:a})});break}case"release":ke(n),postMessage({type:e});break;case"run":{let{sessionId:o,inputIndices:r,inputs:a,outputIndices:s,options:i}=n;De(o,r,a,s,new Array(s.length).fill(null),i).then(c=>{c.some(u=>u[3]!=="cpu")?postMessage({type:e,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:e,out:c},Fe([...a,...c]))},c=>{postMessage({type:e,err:c})});break}case"end-profiling":Ne(n),postMessage({type:e});break;default:}}catch(o){postMessage({type:e,err:o})}});Xn=sn?null:t=>new Worker(t??U,{type:"classic",name:on})});var U,Kn,fn,Qn,Zn,ln,er,cn,dn,pn,de=b(()=>{"use strict";_e();U=!1?void 0:typeof document<"u"?document.currentScript?.src:typeof self<"u"?self.location?.href:void 0,Kn=!1||typeof location>"u"?void 0:location.origin,fn=(t,e)=>{try{let n=e??U;return(n?new URL(t,n):new URL(t)).origin===Kn}catch{return!1}},Qn=(t,e)=>{let n=e??U;try{return(n?new URL(t,n):new URL(t)).href}catch{return}},Zn=(t,e)=>`${e??"./"}${t}`,ln=async t=>{let n=await(await fetch(t,{credentials:"same-origin"})).blob();return URL.createObjectURL(n)},er=async t=>(await import(/*webpackIgnore:true*/t)).default,cn=(un(),nt(an)).default,dn=async()=>{if(!U)throw new Error("Failed to load proxy worker: cannot determine the script source URL.");if(fn(U))return[void 0,cn()];let t=await ln(U);return[t,cn(t)]},pn=async(t,e,n)=>{{let o="ort-training-wasm-simd-threaded.mjs",r=t??Qn(o,e),a=!!1&&n&&r&&!fn(r,e),s=a?await ln(r):r??Zn(o,e);return[a?s:void 0,await er(s)]}}});var ut,ct,He,mn,tr,nr,Re,E,$=b(()=>{"use strict";de();ct=!1,He=!1,mn=!1,tr=()=>{if(typeof SharedArrayBuffer>"u")return!1;try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},nr=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},Re=async t=>{if(ct)return Promise.resolve();if(He)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(mn)throw new Error("previous call to 'initializeWebAssembly()' failed.");He=!0;let e=t.initTimeout,n=t.numThreads;if(!nr())throw new Error("WebAssembly SIMD is not supported in the current environment.");let o=tr();n>1&&!o&&(typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+n+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),t.numThreads=n=1);let r=t.wasmPaths,a=typeof r=="string"?r:void 0,s=r?.mjs,i=s?.href??s,c=r?.wasm,u=c?.href??c,[f,l]=await pn(i,a,n>1),d=!1,p=[];if(e>0&&p.push(new Promise(h=>{setTimeout(()=>{d=!0,h()},e)})),p.push(new Promise((h,m)=>{let g={numThreads:n};(u||a)&&(g.locateFile=(T,w)=>u??(a??w)+T),l(g).then(T=>{He=!1,ct=!0,ut=T,h(),f&&URL.revokeObjectURL(f)},T=>{He=!1,mn=!0,m(T)})})),await Promise.race(p),d)throw new Error(`WebAssembly backend initializing failed due to timeout: ${e}ms`)},E=()=>{if(ct&&ut)return ut;throw new Error("WebAssembly is not initialized yet.")}});var v,me,I,he=b(()=>{"use strict";$();v=(t,e)=>{let n=E(),o=n.lengthBytesUTF8(t)+1,r=n._malloc(o);return n.stringToUTF8(t,r,o),e.push(r),r},me=(t,e,n,o)=>{if(typeof t=="object"&&t!==null){if(n.has(t))throw new Error("Circular reference in options");n.add(t)}Object.entries(t).forEach(([r,a])=>{let s=e?e+r:r;if(typeof a=="object")me(a,s+".",n,o);else if(typeof a=="string"||typeof a=="number")o(s,a.toString());else if(typeof a=="boolean")o(s,a?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof a}`)})},I=t=>{let e=E(),n=e.stackSave();try{let o=e.stackAlloc(8);e._OrtGetLastError(o,o+4);let r=e.HEAP32[o/4],a=e.HEAPU32[o/4+1],s=a?e.UTF8ToString(a):"";throw new Error(`${t} ERROR_CODE: ${r}, ERROR_MESSAGE: ${s}`)}finally{e.stackRestore(n)}}});var te,ft=b(()=>{"use strict";$();he();te=t=>{let e=E(),n=0,o=[],r=t||{};try{if(t?.logSeverityLevel===void 0)r.logSeverityLevel=2;else if(typeof t.logSeverityLevel!="number"||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(t?.logVerbosityLevel===void 0)r.logVerbosityLevel=0;else if(typeof t.logVerbosityLevel!="number"||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);t?.terminate===void 0&&(r.terminate=!1);let a=0;return t?.tag!==void 0&&(a=v(t.tag,o)),n=e._OrtCreateRunOptions(r.logSeverityLevel,r.logVerbosityLevel,!!r.terminate,a),n===0&&I("Can't create run options."),t?.extra!==void 0&&me(t.extra,"",new WeakSet,(s,i)=>{let c=v(s,o),u=v(i,o);e._OrtAddRunConfigEntry(n,c,u)!==0&&I(`Can't set a run config entry: ${s} - ${i}.`)}),[n,o]}catch(a){throw n!==0&&e._OrtReleaseRunOptions(n),o.forEach(s=>e._free(s)),a}}});var rr,or,sr,ar,ze,lt=b(()=>{"use strict";$();he();rr=t=>{switch(t){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${t}`)}},or=t=>{switch(t){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${t}`)}},sr=t=>{t.extra||(t.extra={}),t.extra.session||(t.extra.session={});let e=t.extra.session;e.use_ort_model_bytes_directly||(e.use_ort_model_bytes_directly="1"),t.executionProviders&&t.executionProviders.some(n=>(typeof n=="string"?n:n.name)==="webgpu")&&(t.enableMemPattern=!1)},ar=(t,e,n)=>{for(let o of e){let r=typeof o=="string"?o:o.name;switch(r){case"webnn":if(r="WEBNN",typeof o!="string"){let i=o?.deviceType;if(i){let c=v("deviceType",n),u=v(i,n);E()._OrtAddSessionConfigEntry(t,c,u)!==0&&I(`Can't set a session config entry: 'deviceType' - ${i}.`)}}break;case"webgpu":if(r="JS",typeof o!="string"){let s=o;if(s?.preferredLayout){if(s.preferredLayout!=="NCHW"&&s.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${s.preferredLayout}`);let i=v("preferredLayout",n),c=v(s.preferredLayout,n);E()._OrtAddSessionConfigEntry(t,i,c)!==0&&I(`Can't set a session config entry: 'preferredLayout' - ${s.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${r}`)}let a=v(r,n);E()._OrtAppendExecutionProvider(t,a)!==0&&I(`Can't append execution provider: ${r}.`)}},ze=t=>{let e=E(),n=0,o=[],r=t||{};sr(r);try{let a=rr(r.graphOptimizationLevel??"all"),s=or(r.executionMode??"sequential"),i=typeof r.logId=="string"?v(r.logId,o):0,c=r.logSeverityLevel??2;if(!Number.isInteger(c)||c<0||c>4)throw new Error(`log serverity level is not valid: ${c}`);let u=r.logVerbosityLevel??0;if(!Number.isInteger(u)||u<0||u>4)throw new Error(`log verbosity level is not valid: ${u}`);let f=typeof r.optimizedModelFilePath=="string"?v(r.optimizedModelFilePath,o):0;if(n=e._OrtCreateSessionOptions(a,!!r.enableCpuMemArena,!!r.enableMemPattern,s,!!r.enableProfiling,0,i,c,u,f),n===0&&I("Can't create session options."),r.executionProviders&&ar(n,r.executionProviders,o),r.enableGraphCapture!==void 0){if(typeof r.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${r.enableGraphCapture}`);let l=v("enableGraphCapture",o),d=v(r.enableGraphCapture.toString(),o);e._OrtAddSessionConfigEntry(n,l,d)!==0&&I(`Can't set a session config entry: 'enableGraphCapture' - ${r.enableGraphCapture}.`)}if(r.freeDimensionOverrides)for(let[l,d]of Object.entries(r.freeDimensionOverrides)){if(typeof l!="string")throw new Error(`free dimension override name must be a string: ${l}`);if(typeof d!="number"||!Number.isInteger(d)||d<0)throw new Error(`free dimension override value must be a non-negative integer: ${d}`);let p=v(l,o);e._OrtAddFreeDimensionOverride(n,p,d)!==0&&I(`Can't set a free dimension override: ${l} - ${d}.`)}return r.extra!==void 0&&me(r.extra,"",new WeakSet,(l,d)=>{let p=v(l,o),h=v(d,o);e._OrtAddSessionConfigEntry(n,p,h)!==0&&I(`Can't set a session config entry: ${l} - ${d}.`)}),[n,o]}catch(a){throw n!==0&&e._OrtReleaseSessionOptions(n),o.forEach(s=>e._free(s)),a}}});var ne,We,dt,ye,hn,$e,we,Ge=b(()=>{"use strict";ne=t=>{switch(t){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${t}`)}},We=t=>{switch(t){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${t}`)}},dt=t=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][t],ye=t=>{switch(t){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${t}`)}},hn=t=>{switch(t){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${t}`)}},$e=t=>t==="float32"||t==="float16"||t==="int32"||t==="int64"||t==="uint32"||t==="uint8"||t==="bool",we=t=>{switch(t){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${t}`)}}});var ge,pt=b(()=>{"use strict";_e();ge=async t=>{if(typeof t=="string")if(!1)try{let{readFile:e}=tt("node:fs/promises");return new Uint8Array(await e(t))}catch(e){if(e.code==="ERR_FS_FILE_TOO_LARGE"){let{createReadStream:n}=tt("node:fs"),o=n(t),r=[];for await(let a of o)r.push(a);return new Uint8Array(Buffer.concat(r))}throw e}else{let e=await fetch(t);if(!e.ok)throw new Error(`failed to load external data file: ${t}`);let n=e.headers.get("Content-Length"),o=n?parseInt(n,10):0;if(o<1073741824)return new Uint8Array(await e.arrayBuffer());{if(!e.body)throw new Error(`failed to load external data file: ${t}, no response body.`);let r=e.body.getReader(),a;try{a=new ArrayBuffer(o)}catch(i){if(i instanceof RangeError){let c=Math.ceil(o/65536);a=new WebAssembly.Memory({initial:c,maximum:c}).buffer}else throw i}let s=0;for(;;){let{done:i,value:c}=await r.read();if(i)break;let u=c.byteLength;new Uint8Array(a,s,u).set(c),s+=u}return new Uint8Array(a,0,o)}}else return t instanceof Blob?new Uint8Array(await t.arrayBuffer()):t instanceof Uint8Array?t:new Uint8Array(t)}});var ir,Le,Me,re,ur,q,Ue,ke,je,De,Ne,Fe,pe=b(()=>{"use strict";ft();lt();Ge();$();he();pt();ir=(t,e)=>{E()._OrtInit(t,e)!==0&&I("Can't initialize onnxruntime.")},Le=async t=>{ir(t.wasm.numThreads,hn(t.logLevel))},Me=async(t,e)=>{},re=new Map,ur=t=>{let e=E(),n=e.stackSave();try{let o=e.stackAlloc(8);return e._OrtGetInputOutputCount(t,o,o+4)!==0&&I("Can't get session input/output count."),[e.HEAP32[o/4],e.HEAP32[o/4+1]]}finally{e.stackRestore(n)}},q=t=>{let e=E(),n=e._malloc(t.byteLength);if(n===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${t.byteLength}.`);return e.HEAPU8.set(t,n),[n,t.byteLength]},Ue=async(t,e)=>{let n,o,r=E();Array.isArray(t)?[n,o]=t:t.buffer===r.HEAPU8.buffer?[n,o]=[t.byteOffset,t.byteLength]:[n,o]=q(t);let a=0,s=0,i=0,c=[],u=[],f=[];try{if([s,c]=ze(e),e?.externalData&&r.mountExternalData){let w=[];for(let y of e.externalData){let S=typeof y=="string"?y:y.path;w.push(ge(typeof y=="string"?y:y.data).then(P=>{r.mountExternalData(S,P)}))}await Promise.all(w)}for(let w of e?.executionProviders??[])if((typeof w=="string"?w:w.name)==="webnn"){if(r.currentContext)throw new Error("WebNN execution provider is already set.");if(typeof w!="string"){let S=w,P=S?.context,H=S?.gpuDevice,Q=S?.deviceType,ae=S?.numThreads,Ee=S?.powerPreference;P?r.currentContext=P:H?r.currentContext=await navigator.ml.createContext(H):r.currentContext=await navigator.ml.createContext({deviceType:Q,numThreads:ae,powerPreference:Ee})}else r.currentContext=await navigator.ml.createContext();break}a=await r._OrtCreateSession(n,o,s),a===0&&I("Can't create a session."),r.currentContext&&(r.currentContext=void 0);let[l,d]=ur(a),p=!!e?.enableGraphCapture,h=[],m=[],g=[];for(let w=0;w<l;w++){let y=r._OrtGetInputName(a,w);y===0&&I("Can't get an input name."),u.push(y),h.push(r.UTF8ToString(y))}for(let w=0;w<d;w++){let y=r._OrtGetOutputName(a,w);y===0&&I("Can't get an output name."),f.push(y);let S=r.UTF8ToString(y);m.push(S)}let T=null;return re.set(a,[a,u,f,T,p,!1]),[a,h,m]}catch(l){throw u.forEach(d=>r._OrtFree(d)),f.forEach(d=>r._OrtFree(d)),i!==0&&r._OrtReleaseBinding(i),a!==0&&r._OrtReleaseSession(a),l}finally{r._free(n),s!==0&&r._OrtReleaseSessionOptions(s),c.forEach(l=>r._free(l)),r.unmountExternalData?.()}},ke=t=>{let e=E(),n=re.get(t);if(!n)throw new Error(`cannot release session. invalid session id: ${t}`);let[o,r,a,s,i]=n;s&&(i&&e._OrtClearBoundOutputs(s.handle),e._OrtReleaseBinding(s.handle)),e.jsepOnReleaseSession?.(t),r.forEach(c=>e._OrtFree(c)),a.forEach(c=>e._OrtFree(c)),e._OrtReleaseSession(o),re.delete(t)},je=(t,e,n,o,r,a=!1)=>{if(!t){e.push(0);return}let s=E(),i=t[0],c=t[1],u=t[3],f,l;if(i==="string"&&u==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");if(a&&u!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${r} when enableGraphCapture is true.`);if(u==="gpu-buffer"){let h=t[2].gpuBuffer,m=dt(ne(i));l=c.reduce((T,w)=>T*w,1)*m;let g=s.jsepRegisterBuffer;if(!g)throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');f=g(o,r,h,l)}else{let h=t[2];if(Array.isArray(h)){l=4*h.length,f=s._malloc(l),n.push(f);let m=f/4;for(let g=0;g<h.length;g++){if(typeof h[g]!="string")throw new TypeError(`tensor data at index ${g} is not a string`);s.HEAPU32[m++]=v(h[g],n)}}else l=h.byteLength,f=s._malloc(l),n.push(f),s.HEAPU8.set(new Uint8Array(h.buffer,h.byteOffset,l),f)}let d=s.stackSave(),p=s.stackAlloc(4*c.length);try{let h=p/4;c.forEach(g=>s.HEAP32[h++]=g);let m=s._OrtCreateTensor(ne(i),f,l,p,c.length,we(u));m===0&&I(`Can't create tensor for input/output. session=${o}, index=${r}.`),e.push(m)}finally{s.stackRestore(d)}},De=async(t,e,n,o,r,a)=>{let s=E(),i=re.get(t);if(!i)throw new Error(`cannot run inference. invalid session id: ${t}`);let c=i[0],u=i[1],f=i[2],l=i[3],d=i[4],p=i[5],h=e.length,m=o.length,g=0,T=[],w=[],y=[],S=[],P=s.stackSave(),H=s.stackAlloc(h*4),Q=s.stackAlloc(h*4),ae=s.stackAlloc(m*4),Ee=s.stackAlloc(m*4);try{[g,T]=te(a);for(let O=0;O<h;O++)je(n[O],w,S,t,e[O],d);for(let O=0;O<m;O++)je(r[O],y,S,t,h+o[O],d);let N=H/4,Fn=Q/4,Hn=ae/4,zn=Ee/4;for(let O=0;O<h;O++)s.HEAPU32[N++]=w[O],s.HEAPU32[Fn++]=u[e[O]];for(let O=0;O<m;O++)s.HEAPU32[Hn++]=y[O],s.HEAPU32[zn++]=f[o[O]];s.jsepOnRunStart?.(c);let Tt;Tt=await s._OrtRun(c,Q,H,h,Ee,m,ae,g),Tt!==0&&I("failed to call OrtRun().");let ie=[];for(let O=0;O<m;O++){let ue=s.HEAPU32[ae/4+O];if(ue===y[O]){ie.push(r[O]);continue}let St=s.stackSave(),G=s.stackAlloc(4*4),Te=!1,M,F=0;try{s._OrtGetTensorData(ue,G,G+4,G+8,G+12)!==0&&I(`Can't access output tensor data on index ${O}.`);let Se=G/4,Ot=s.HEAPU32[Se++];F=s.HEAPU32[Se++];let At=s.HEAPU32[Se++],Wn=s.HEAPU32[Se++],ce=[];for(let _=0;_<Wn;_++)ce.push(s.HEAPU32[At/4+_]);s._OrtFree(At);let fe=ce.reduce((_,R)=>_*R,1);M=We(Ot);let It=l?.outputPreferredLocations[o[O]];if(M==="string"){if(It==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");let _=[],R=F/4;for(let Z=0;Z<fe;Z++){let vt=s.HEAPU32[R++],$n=Z===fe-1?void 0:s.HEAPU32[R]-vt;_.push(s.UTF8ToString(vt,$n))}ie.push([M,ce,_,"cpu"])}else if(It==="gpu-buffer"&&fe>0){let _=s.jsepGetBuffer;if(!_)throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let R=_(F),Z=dt(Ot);if(Z===void 0||!$e(M))throw new Error(`Unsupported data type: ${M}`);Te=!0,ie.push([M,ce,{gpuBuffer:R,download:s.jsepCreateDownloader(R,fe*Z,M),dispose:()=>{s._OrtReleaseTensor(ue)}},"gpu-buffer"])}else{let _=ye(M),R=new _(fe);new Uint8Array(R.buffer,R.byteOffset,R.byteLength).set(s.HEAPU8.subarray(F,F+R.byteLength)),ie.push([M,ce,R,"cpu"])}}finally{s.stackRestore(St),M==="string"&&F&&s._free(F),Te||s._OrtReleaseTensor(ue)}}return l&&!d&&(s._OrtClearBoundOutputs(l.handle),re.set(t,[c,u,f,l,d,!1])),ie}finally{s.stackRestore(P),w.forEach(N=>s._OrtReleaseTensor(N)),y.forEach(N=>s._OrtReleaseTensor(N)),S.forEach(N=>s._free(N)),g!==0&&s._OrtReleaseRunOptions(g),T.forEach(N=>s._free(N))}},Ne=t=>{let e=E(),n=re.get(t);if(!n)throw new Error("invalid session id");let o=n[0],r=e._OrtEndProfiling(o);r===0&&I("Can't get an profile file name."),e._OrtFree(r)},Fe=t=>{let e=[];for(let n of t){let o=n[2];!Array.isArray(o)&&"buffer"in o&&e.push(o.buffer)}return e}});var X,k,be,Ye,qe,Ve,mt,ht,oe,se,fr,yn,wn,gn,bn,En,Tn,Sn,yt=b(()=>{"use strict";Y();pe();$();de();X=()=>!!A.wasm.proxy&&typeof document<"u",be=!1,Ye=!1,qe=!1,ht=new Map,oe=(t,e)=>{let n=ht.get(t);n?n.push(e):ht.set(t,[e])},se=()=>{if(be||!Ye||qe||!k)throw new Error("worker not ready")},fr=t=>{switch(t.data.type){case"init-wasm":be=!1,t.data.err?(qe=!0,mt[1](t.data.err)):(Ye=!0,mt[0]()),Ve&&(URL.revokeObjectURL(Ve),Ve=void 0);break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let e=ht.get(t.data.type);t.data.err?e.shift()[1](t.data.err):e.shift()[0](t.data.out);break}default:}},yn=async()=>{if(!Ye){if(be)throw new Error("multiple calls to 'initWasm()' detected.");if(qe)throw new Error("previous call to 'initWasm()' failed.");if(be=!0,X())return new Promise((t,e)=>{k?.terminate(),dn().then(([n,o])=>{try{k=o,k.onerror=a=>e(a),k.onmessage=fr,mt=[t,e];let r={type:"init-wasm",in:A};k.postMessage(r),Ve=n}catch(r){e(r)}},e)});try{await Re(A.wasm),await Le(A),Ye=!0}catch(t){throw qe=!0,t}finally{be=!1}}},wn=async t=>{if(X())return se(),new Promise((e,n)=>{oe("init-ep",[e,n]);let o={type:"init-ep",in:{epName:t,env:A}};k.postMessage(o)});await Me(A,t)},gn=async t=>X()?(se(),new Promise((e,n)=>{oe("copy-from",[e,n]);let o={type:"copy-from",in:{buffer:t}};k.postMessage(o,[t.buffer])})):q(t),bn=async(t,e)=>{if(X()){if(e?.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return se(),new Promise((n,o)=>{oe("create",[n,o]);let r={type:"create",in:{model:t,options:{...e}}},a=[];t instanceof Uint8Array&&a.push(t.buffer),k.postMessage(r,a)})}else return Ue(t,e)},En=async t=>{if(X())return se(),new Promise((e,n)=>{oe("release",[e,n]);let o={type:"release",in:t};k.postMessage(o)});ke(t)},Tn=async(t,e,n,o,r,a)=>{if(X()){if(n.some(s=>s[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if(r.some(s=>s))throw new Error("pre-allocated output tensor is not supported for proxy.");return se(),new Promise((s,i)=>{oe("run",[s,i]);let c=n,u={type:"run",in:{sessionId:t,inputIndices:e,inputs:c,outputIndices:o,options:a}};k.postMessage(u,Fe(c))})}else return De(t,e,n,o,r,a)},Sn=async t=>{if(X())return se(),new Promise((e,n)=>{oe("end-profiling",[e,n]);let o={type:"end-profiling",in:t};k.postMessage(o)});Ne(t)}});var K,Xe,Je,wt=b(()=>{"use strict";Y();yt();Ge();_e();pt();K=(t,e)=>{switch(t.location){case"cpu":return[t.type,t.dims,t.data,"cpu"];case"gpu-buffer":return[t.type,t.dims,{gpuBuffer:t.gpuBuffer},"gpu-buffer"];default:throw new Error(`invalid data location: ${t.location} for ${e()}`)}},Xe=t=>{switch(t[3]){case"cpu":return new x(t[0],t[2],t[1]);case"gpu-buffer":{let e=t[0];if(!$e(e))throw new Error(`not supported data type: ${e} for deserializing GPU tensor`);let{gpuBuffer:n,download:o,dispose:r}=t[2];return x.fromGpuBuffer(n,{dataType:e,dims:t[1],download:o,dispose:r})}default:throw new Error(`invalid data location: ${t[3]}`)}},Je=class{async fetchModelAndCopyToWasmMemory(e){return gn(await ge(e))}async loadModel(e,n){z();let o;typeof e=="string"?!1?o=await ge(e):o=await this.fetchModelAndCopyToWasmMemory(e):o=e,[this.sessionId,this.inputNames,this.outputNames]=await bn(o,n),W()}async dispose(){return En(this.sessionId)}async run(e,n,o){z();let r=[],a=[];Object.entries(e).forEach(d=>{let p=d[0],h=d[1],m=this.inputNames.indexOf(p);if(m===-1)throw new Error(`invalid input '${p}'`);r.push(h),a.push(m)});let s=[],i=[];Object.entries(n).forEach(d=>{let p=d[0],h=d[1],m=this.outputNames.indexOf(p);if(m===-1)throw new Error(`invalid output '${p}'`);s.push(h),i.push(m)});let c=r.map((d,p)=>K(d,()=>`input "${this.inputNames[a[p]]}"`)),u=s.map((d,p)=>d?K(d,()=>`output "${this.outputNames[i[p]]}"`):null),f=await Tn(this.sessionId,a,c,i,u,o),l={};for(let d=0;d<f.length;d++)l[this.outputNames[i[d]]]=s[d]??Xe(f[d]);return W(),l}startProfiling(){}endProfiling(){Sn(this.sessionId)}}});var lr,Ke,On=b(()=>{"use strict";Y();yt();wt();de();lr=()=>{if((typeof A.wasm.initTimeout!="number"||A.wasm.initTimeout<0)&&(A.wasm.initTimeout=0),A.wasm.simd===!1&&console.warn('Deprecated property "env.wasm.simd" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'),typeof A.wasm.proxy!="boolean"&&(A.wasm.proxy=!1),typeof A.wasm.trace!="boolean"&&(A.wasm.trace=!1),typeof A.wasm.numThreads!="number"||!Number.isInteger(A.wasm.numThreads)||A.wasm.numThreads<=0)if(typeof self<"u"&&!self.crossOriginIsolated)A.wasm.numThreads=1;else{let t=typeof navigator>"u"?tt("node:os").cpus().length:navigator.hardwareConcurrency;A.wasm.numThreads=Math.min(4,Math.ceil((t||1)/2))}A.wasm.wasmPaths===void 0&&U&&U.indexOf("blob:")!==0&&(A.wasm.wasmPaths=U.substring(0,U.lastIndexOf("/")+1))},Ke=class{async init(e){lr(),await yn(),await wn(e)}async createInferenceSessionHandler(e,n){let o=new Je;return await o.loadModel(e,n),Promise.resolve(o)}}});var D,B,In,dr,An,gt,vn,Qe,Pn,xn,Cn,Bn,_n,bt,Rn,Ln,Mn,Un=b(()=>{"use strict";ft();lt();Ge();pe();$();he();D="Built without training API's enabled. Use the onnxruntime-web/training import for training functionality, and make sure that all the correct artifacts are built & moved to the correct folder if using a custom build. Check https://onnxruntime.ai/docs/build/web.html for more information.",B=(t,e,n=!0)=>{n&&t!==0?I(e):!n&&t===0&&I(e)},In=t=>{let e=E(),[n,o]=t,r=0;try{if(e._OrtTrainingLoadCheckpoint)r=e._OrtTrainingLoadCheckpoint(n,o);else throw new Error(D);return B(r,"Error occurred when trying to create a CheckpointState",!1),r}catch(a){throw e._OrtTrainingReleaseCheckpoint&&r!==0&&e._OrtTrainingReleaseCheckpoint(r),a}finally{e._OrtFree(t[0])}},dr=(t,e)=>{let n=E(),o=n.stackSave();try{let r=n.stackAlloc(8);if(n._OrtTrainingGetModelInputOutputCount){let a=n._OrtTrainingGetModelInputOutputCount(t,r,r+4,e);return B(a,"Can't get session input/output count."),[n.HEAP32[r/4],n.HEAP32[r/4+1]]}else throw new Error(D)}finally{n.stackRestore(o)}},An=(t,e,n,o)=>{let r=[],a=E();for(let s=0;s<e;s++)if(a._OrtTrainingGetModelInputOutputName){let i=a._OrtTrainingGetModelInputOutputName(t,s,n,o);B(i,`Can't get input or output name -- is input: ${n}, index ${s}`,!1),r.push(a.UTF8ToString(i)),a._free(i)}else throw new Error(D);return r},gt=(t,e)=>{let n=[],o=[],[r,a]=dr(t,e);return n=An(t,r,!0,e),o=An(t,a,!1,e),[n,o]},vn=(t,e,n,o,r)=>{let a=E(),s=0,i=0,c=[];try{if([i,c]=ze(r),a._OrtTrainingCreateSession)s=a._OrtTrainingCreateSession(i,t,e[0],e[1],n[0],n[1],o[0],o[1]);else throw new Error(D);return B(s,"Error occurred when trying to create a TrainingSession",!1),s}catch(u){throw a._OrtTrainingReleaseSession&&s!==0&&a._OrtTrainingReleaseSession(s),u}finally{a._free(e[0]),a._free(n[0]),a._free(o[0]),i!==0&&a._OrtReleaseSessionOptions(i),c.forEach(u=>a._free(u))}},Qe=(t,e,n,o,r,a)=>{let s=e.length;for(let f=0;f<s;f++)je(n[f],o,r,t,a+e[f]);let i=E(),c=i.stackAlloc(s*4),u=c/4;for(let f=0;f<s;f++)i.HEAPU32[u++]=o[f];return c},Pn=(t,e,n,o)=>{let r=E(),a=[];for(let s=0;s<e;s++){let i=r.HEAPU32[t/4+s];if(i===n[s]){a.push(o[s]);continue}let c=r.stackSave(),u=r.stackAlloc(4*4),f,l=0;try{let d=r._OrtGetTensorData(i,u,u+4,u+8,u+12);B(d,`Can't access output tensor data on index ${s}.`);let p=u/4,h=r.HEAPU32[p++];l=r.HEAPU32[p++];let m=r.HEAPU32[p++],g=r.HEAPU32[p++],T=[];for(let y=0;y<g;y++)T.push(r.HEAPU32[m/4+y]);r._OrtFree(m);let w=T.reduce((y,S)=>y*S,1);if(f=We(h),f==="string"){let y=[],S=l/4;for(let P=0;P<w;P++){let H=r.HEAPU32[S++],Q=P===w-1?void 0:r.HEAPU32[S]-H;y.push(r.UTF8ToString(H,Q))}a.push([f,T,y,"cpu"])}else{let y=ye(f),S=new y(w);new Uint8Array(S.buffer,S.byteOffset,S.byteLength).set(r.HEAPU8.subarray(l,l+S.byteLength)),a.push([f,T,S,"cpu"])}}finally{r.stackRestore(c),f==="string"&&l&&r._free(l),r._OrtReleaseTensor(i)}}return a},xn=async t=>{let e=E();if(e._OrtTrainingLazyResetGrad){let n=e._OrtTrainingLazyResetGrad(t);B(n,"Can't call lazyResetGrad.")}else throw new Error(D)},Cn=async(t,e,n,o,r,a)=>{let s=E(),i=e.length,c=o.length,u=0,f=[],l=[],d=[],p=[],h=s.stackSave();try{[u,f]=te(a);let m=Qe(t,e,n,l,p,0),g=Qe(t,o,r,d,p,i);if(s._OrtTrainingRunTrainStep){let T=s._OrtTrainingRunTrainStep(t,m,i,g,c,u);B(T,"failed to call OrtTrainingRunTrainStep in the WebAssembly layer")}else throw new Error(D);return Pn(g,c,d,r)}finally{s.stackRestore(h),l.forEach(m=>s._OrtReleaseTensor(m)),d.forEach(m=>s._OrtReleaseTensor(m)),p.forEach(m=>s._free(m)),u!==0&&s._OrtReleaseRunOptions(u),f.forEach(m=>s._free(m))}},Bn=async(t,e)=>{let n=E(),o=0,r=[];try{if([o,r]=te(e),n._OrtTrainingOptimizerStep){let a=n._OrtTrainingOptimizerStep(t,o);B(a,"Failed to call OrtTrainingOptimizerStep in the WebAssembly layer")}else throw new Error(D)}finally{o!==0&&n._OrtReleaseRunOptions(o),r.forEach(a=>n._free(a))}},_n=async(t,e,n,o,r,a)=>{let s=E(),i=e.length,c=o.length,u=0,f=[],l=[],d=[],p=[],h=s.stackSave();try{[u,f]=te(a);let m=Qe(t,e,n,l,p,0),g=Qe(t,o,r,d,p,i);if(s._OrtTrainingEvalStep){let T=s._OrtTrainingEvalStep(t,m,i,g,c,u);B(T,"failed to call OrtTrainingEvalStep in the WebAssembly layer")}else throw new Error(D);return Pn(g,c,d,r)}finally{s.stackRestore(h),l.forEach(m=>s._OrtReleaseTensor(m)),d.forEach(m=>s._OrtReleaseTensor(m)),p.forEach(m=>s._free(m)),u!==0&&s._OrtReleaseRunOptions(u),f.forEach(m=>s._free(m))}},bt=(t,e)=>{let n=E(),o=n.stackSave();try{let r=n.stackAlloc(4);if(n._OrtTrainingGetParametersSize){let a=n._OrtTrainingGetParametersSize(t,r,e);return B(a,"Can't get parameters size"),n.HEAP32[r/4]}else throw new Error(D)}finally{n.stackRestore(o)}},Rn=async(t,e)=>{let n=E(),o=n.stackSave(),r="float32",a="cpu",s=bt(t,e),i=0,c=4*s,u=n._malloc(c),f=[s],l=n.stackAlloc(4),d=l/4;n.HEAP32[d]=s;try{if(i=n._OrtCreateTensor(ne(r),u,c,l,f.length,we(a)),B(i,`Can't create tensor for getContiguousParameters. session=${t}.`,!1),n._OrtTrainingCopyParametersToBuffer){let g=n._OrtTrainingCopyParametersToBuffer(t,i,s,e);B(g,"Can't get contiguous parameters.")}else throw new Error(D);let p=ye(r),h=new p(s),m=[];if(new Uint8Array(h.buffer,h.byteOffset,h.byteLength).set(n.HEAPU8.subarray(u,u+c)),m.push([r,f,h,a]),m.length!==1)throw new Error(`something unexpected happened in the getContiguousParameters function. Expected output length of
     one, got ${m.length}`);return m[0]}finally{i!==0&&n._OrtReleaseTensor(i),n._free(u),n._free(l),n.stackRestore(o)}},Ln=async(t,e,n)=>{let o=E(),r=o.stackSave(),a="float32",s="cpu",i=e.length,c=i/4,u=o._malloc(i);o.HEAPU8.set(e,u);let f=o.stackAlloc(4);o.HEAP32[f/4]=c;let l=1,d=0;try{if(d=o._OrtCreateTensor(ne(a),u,i,f,l,we(s)),B(d,`Can't create tensor for input/output. session=${t}`,!1),o._OrtTrainingCopyParametersFromBuffer){let p=o._OrtTrainingCopyParametersFromBuffer(t,d,c,n);B(p,"Can't copy buffer to parameters.")}else throw new Error(D)}finally{d!==0&&o._OrtReleaseTensor(d),o.stackRestore(r),o._free(u),o._free(f)}},Mn=(t,e)=>{let n=E();n._OrtTrainingReleaseSession&&n._OrtTrainingReleaseSession(e),n._OrtTrainingReleaseCheckpoint&&n._OrtTrainingReleaseCheckpoint(t)}});var Ze,kn=b(()=>{"use strict";wt();pe();Un();Ze=class{constructor(){this.evalInputNames=[];this.evalOutputNames=[]}async uriOrBufferToHeap(e){let n;if(typeof e=="string"){let r=await(await fetch(e)).arrayBuffer();n=new Uint8Array(r)}else n=e;return q(n)}async createTrainingSession(e,n,o,r,a){let s=await this.uriOrBufferToHeap(e),i=await this.uriOrBufferToHeap(n),c=[0,0],u=[0,0];o!==""&&(c=await this.uriOrBufferToHeap(o)),r!==""&&(u=await this.uriOrBufferToHeap(r)),this.checkpointId=In(s),this.sessionId=vn(this.checkpointId,i,c,u,a),[this.inputNames,this.outputNames]=gt(this.sessionId,!1),o!==""&&([this.evalInputNames,this.evalOutputNames]=gt(this.sessionId,!0))}convertMapIntoValuesArrayAndIndicesArray(e,n,o){let r=[],a=[];Object.entries(e).forEach(i=>{let c=i[0],u=i[1],f=n.indexOf(c);if(f===-1)throw new Error(`invalid input '${c}`);r.push(u),a.push(f)});let s=r.map(o);return[r,a,s]}convertTensorMetadataToReturnType(e,n,o){let r={};for(let a=0;a<e.length;a++)r[this.outputNames[o[a]]]=n[a]??Xe(e[a]);return r}async lazyResetGrad(){await xn(this.sessionId)}async runTrainStep(e,n,o){let[,r,a]=this.convertMapIntoValuesArrayAndIndicesArray(e,this.inputNames,(f,l)=>K(f,()=>`input "${this.inputNames[r[l]]}"`)),[s,i,c]=this.convertMapIntoValuesArrayAndIndicesArray(n,this.outputNames,(f,l)=>f?K(f,()=>`output "${this.outputNames[i[l]]}"`):null),u=await Cn(this.sessionId,r,a,i,c,o);return this.convertTensorMetadataToReturnType(u,s,i)}async runOptimizerStep(e){await Bn(this.sessionId,e)}async runEvalStep(e,n,o){let[,r,a]=this.convertMapIntoValuesArrayAndIndicesArray(e,this.evalInputNames,(f,l)=>K(f,()=>`input "${this.evalInputNames[r[l]]}"`)),[s,i,c]=this.convertMapIntoValuesArrayAndIndicesArray(n,this.evalOutputNames,(f,l)=>f?K(f,()=>`output "${this.evalOutputNames[i[l]]}"`):null),u=await _n(this.sessionId,r,a,i,c,o);return this.convertTensorMetadataToReturnType(u,s,i)}async getParametersSize(e){return bt(this.sessionId,e)}async loadParametersBuffer(e,n){await Ln(this.sessionId,e,n)}async getContiguousParameters(e){let n=await Rn(this.sessionId,e);return Xe(n)}async dispose(){return Mn(this.checkpointId,this.sessionId)}}});var Dn={};Oe(Dn,{wasmBackend:()=>pr});var Et,pr,Nn=b(()=>{"use strict";On();kn();Et=class extends Ke{async createTrainingSessionHandler(e,n,o,r,a){let s=new Ze;return await s.createTrainingSession(e,n,o,r,a),Promise.resolve(s)}},pr=new Et});var hr={};Oe(hr,{InferenceSession:()=>qt,TRACE:()=>st,TRACE_FUNC_BEGIN:()=>z,TRACE_FUNC_END:()=>W,Tensor:()=>x,TrainingSession:()=>tn,default:()=>mr,env:()=>A,registerBackend:()=>ee});Y();Y();Y();var rn="1.19.0";var mr=it;{let t=(Nn(),nt(Dn)).wasmBackend;ee("cpu",t,10),ee("wasm",t,10)}Object.defineProperty(A.versions,"web",{value:rn,enumerable:!0});return nt(hr);})();
typeof exports=="object"&&typeof module=="object"&&(module.exports=ort);
//# sourceMappingURL=ort.training.wasm.min.js.map
