/*!
 * ONNX Runtime Web v1.23.0-dev.20250912-f418a44c40
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
"use strict";var Et=Object.create;var ue=Object.defineProperty;var St=Object.getOwnPropertyDescriptor;var ht=Object.getOwnPropertyNames;var Tt=Object.getPrototypeOf,It=Object.prototype.hasOwnProperty;var M=(e,t)=>()=>(e&&(t=e(e=0)),t);var xe=(e,t)=>{for(var n in t)ue(e,n,{get:t[n],enumerable:!0})},ie=(e,t,n,o)=>{if(t&&typeof t=="object"||typeof t=="function")for(let r of ht(t))!It.call(e,r)&&r!==n&&ue(e,r,{get:()=>t[r],enumerable:!(o=St(t,r))||o.enumerable});return e},G=(e,t,n)=>(ie(e,t,"default"),n&&ie(n,t,"default")),Ot=(e,t,n)=>(n=e!=null?Et(Tt(e)):{},ie(t||!e||!e.__esModule?ue(n,"default",{value:e,enumerable:!0}):n,e)),Me=e=>ie(ue({},"__esModule",{value:!0}),e);var H,ce=M(()=>{"use strict";H=!!(typeof process<"u"&&process.versions&&process.versions.node)});var Lt,Bt,V,Fe,We,Pt,_t,vt,Ut,ke,Re,Se=M(()=>{"use strict";ce();Lt=H||typeof location>"u"?void 0:location.origin,Bt=()=>{if(!H)return typeof document<"u"?document.currentScript?.src:typeof self<"u"?self.location?.href:void 0},V=Bt(),Fe=()=>{if(V&&!V.startsWith("blob:"))return V.substring(0,V.lastIndexOf("/")+1)},We=(e,t)=>{try{let n=t??V;return(n?new URL(e,n):new URL(e)).origin===Lt}catch{return!1}},Pt=(e,t)=>{let n=t??V;try{return(n?new URL(e,n):new URL(e)).href}catch{return}},_t=(e,t)=>`${t??"./"}${e}`,vt=async e=>{let n=await(await fetch(e,{credentials:"same-origin"})).blob();return URL.createObjectURL(n)},Ut=async e=>(await import(/*webpackIgnore:true*/e)).default,ke=void 0,Re=async(e,t,n,o)=>{let r=ke&&!(e||t);if(r)if(V)r=We(V);else if(o&&!n)r=!0;else throw new Error("cannot determine the script source URL.");if(r)return[void 0,ke];{let a="ort-wasm-simd-threaded.mjs",s=e??Pt(a,t),i=!H&&n&&s&&!We(s,t),u=i?await vt(s):s??_t(a,t);return[i?u:void 0,await Ut(u)]}}});var he,Te,le,Ne,Dt,At,xt,Ge,E,Y=M(()=>{"use strict";Se();Te=!1,le=!1,Ne=!1,Dt=()=>{if(typeof SharedArrayBuffer>"u")return!1;try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},At=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},xt=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,5,1,96,0,1,123,3,2,1,0,10,19,1,17,0,65,1,253,15,65,2,253,15,65,3,253,15,253,147,2,11]))}catch{return!1}},Ge=async e=>{if(Te)return Promise.resolve();if(le)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(Ne)throw new Error("previous call to 'initializeWebAssembly()' failed.");le=!0;let t=e.initTimeout,n=e.numThreads;if(e.simd!==!1){if(e.simd==="relaxed"){if(!xt())throw new Error("Relaxed WebAssembly SIMD is not supported in the current environment.")}else if(!At())throw new Error("WebAssembly SIMD is not supported in the current environment.")}let o=Dt();n>1&&!o&&(typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+n+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),e.numThreads=n=1);let r=e.wasmPaths,a=typeof r=="string"?r:void 0,s=r?.mjs,i=s?.href??s,u=r?.wasm,f=u?.href??u,l=e.wasmBinary,[d,c]=await Re(i,a,n>1,!!l||!!f),p=!1,S=[];if(t>0&&S.push(new Promise(T=>{setTimeout(()=>{p=!0,T()},t)})),S.push(new Promise((T,U)=>{let b={numThreads:n};if(l)b.wasmBinary=l;else if(f||a)b.locateFile=w=>f??a+w;else if(i&&i.indexOf("blob:")!==0)b.locateFile=w=>new URL(w,i).href;else if(d){let w=Fe();w&&(b.locateFile=C=>w+C)}c(b).then(w=>{le=!1,Te=!0,he=w,T(),d&&URL.revokeObjectURL(d)},w=>{le=!1,Ne=!0,U(w)})})),await Promise.race(S),p)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},E=()=>{if(Te&&he)return he;throw new Error("WebAssembly is not initialized yet.")}});var A,re,g,fe=M(()=>{"use strict";Y();A=(e,t)=>{let n=E(),o=n.lengthBytesUTF8(e)+1,r=n._malloc(o);return n.stringToUTF8(e,r,o),t.push(r),r},re=(e,t,n,o)=>{if(typeof e=="object"&&e!==null){if(n.has(e))throw new Error("Circular reference in options");n.add(e)}Object.entries(e).forEach(([r,a])=>{let s=t?t+r:r;if(typeof a=="object")re(a,s+".",n,o);else if(typeof a=="string"||typeof a=="number")o(s,a.toString());else if(typeof a=="boolean")o(s,a?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof a}`)})},g=e=>{let t=E(),n=t.stackSave();try{let o=t.PTR_SIZE,r=t.stackAlloc(2*o);t._OrtGetLastError(r,r+o);let a=Number(t.getValue(r,o===4?"i32":"i64")),s=t.getValue(r+o,"*"),i=s?t.UTF8ToString(s):"";throw new Error(`${e} ERROR_CODE: ${a}, ERROR_MESSAGE: ${i}`)}finally{t.stackRestore(n)}}});var $e,je=M(()=>{"use strict";Y();fe();$e=e=>{let t=E(),n=0,o=[],r=e||{};try{if(e?.logSeverityLevel===void 0)r.logSeverityLevel=2;else if(typeof e.logSeverityLevel!="number"||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log severity level is not valid: ${e.logSeverityLevel}`);if(e?.logVerbosityLevel===void 0)r.logVerbosityLevel=0;else if(typeof e.logVerbosityLevel!="number"||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);e?.terminate===void 0&&(r.terminate=!1);let a=0;return e?.tag!==void 0&&(a=A(e.tag,o)),n=t._OrtCreateRunOptions(r.logSeverityLevel,r.logVerbosityLevel,!!r.terminate,a),n===0&&g("Can't create run options."),e?.extra!==void 0&&re(e.extra,"",new WeakSet,(s,i)=>{let u=A(s,o),f=A(i,o);t._OrtAddRunConfigEntry(n,u,f)!==0&&g(`Can't set a run config entry: ${s} - ${i}.`)}),[n,o]}catch(a){throw n!==0&&t._OrtReleaseRunOptions(n),o.forEach(s=>t._free(s)),a}}});var Mt,Ct,Wt,pe,kt,ze,He=M(()=>{"use strict";Y();fe();Mt=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"layout":return 3;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},Ct=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},Wt=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some(n=>(typeof n=="string"?n:n.name)==="webgpu")&&(e.enableMemPattern=!1)},pe=(e,t,n,o)=>{let r=A(t,o),a=A(n,o);E()._OrtAddSessionConfigEntry(e,r,a)!==0&&g(`Can't set a session config entry: ${t} - ${n}.`)},kt=async(e,t,n)=>{for(let o of t){let r=typeof o=="string"?o:o.name,a=[];switch(r){case"webnn":if(r="WEBNN",typeof o!="string"){let d=o?.deviceType;d&&pe(e,"deviceType",d,n)}break;case"webgpu":if(r="JS",typeof o!="string"){let l=o;if(l?.preferredLayout){if(l.preferredLayout!=="NCHW"&&l.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${l.preferredLayout}`);pe(e,"preferredLayout",l.preferredLayout,n)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${r}`)}let s=A(r,n),i=a.length,u=0,f=0;if(i>0){u=E()._malloc(i*E().PTR_SIZE),n.push(u),f=E()._malloc(i*E().PTR_SIZE),n.push(f);for(let l=0;l<i;l++)E().setValue(u+l*E().PTR_SIZE,a[l][0],"*"),E().setValue(f+l*E().PTR_SIZE,a[l][1],"*")}await E()._OrtAppendExecutionProvider(e,s,u,f,i)!==0&&g(`Can't append execution provider: ${r}.`)}},ze=async e=>{let t=E(),n=0,o=[],r=e||{};Wt(r);try{let a=Mt(r.graphOptimizationLevel??"all"),s=Ct(r.executionMode??"sequential"),i=typeof r.logId=="string"?A(r.logId,o):0,u=r.logSeverityLevel??2;if(!Number.isInteger(u)||u<0||u>4)throw new Error(`log severity level is not valid: ${u}`);let f=r.logVerbosityLevel??0;if(!Number.isInteger(f)||f<0||f>4)throw new Error(`log verbosity level is not valid: ${f}`);let l=typeof r.optimizedModelFilePath=="string"?A(r.optimizedModelFilePath,o):0;if(n=t._OrtCreateSessionOptions(a,!!r.enableCpuMemArena,!!r.enableMemPattern,s,!!r.enableProfiling,0,i,u,f,l),n===0&&g("Can't create session options."),r.executionProviders&&await kt(n,r.executionProviders,o),r.enableGraphCapture!==void 0){if(typeof r.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${r.enableGraphCapture}`);pe(n,"enableGraphCapture",r.enableGraphCapture.toString(),o)}if(r.freeDimensionOverrides)for(let[d,c]of Object.entries(r.freeDimensionOverrides)){if(typeof d!="string")throw new Error(`free dimension override name must be a string: ${d}`);if(typeof c!="number"||!Number.isInteger(c)||c<0)throw new Error(`free dimension override value must be a non-negative integer: ${c}`);let p=A(d,o);t._OrtAddFreeDimensionOverride(n,p,c)!==0&&g(`Can't set a free dimension override: ${d} - ${c}.`)}return r.extra!==void 0&&re(r.extra,"",new WeakSet,(d,c)=>{pe(n,d,c,o)}),[n,o]}catch(a){throw n!==0&&t._OrtReleaseSessionOptions(n)!==0&&g("Can't release session options."),o.forEach(s=>t._free(s)),a}}});var Z,de,X,Ve,qe,me,be,Je,Ie=M(()=>{"use strict";Z=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;case"int4":return 22;case"uint4":return 21;default:throw new Error(`unsupported data type: ${e}`)}},de=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";case 22:return"int4";case 21:return"uint4";default:throw new Error(`unsupported data type: ${e}`)}},X=(e,t)=>{let n=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][e],o=typeof t=="number"?t:t.reduce((r,a)=>r*a,1);return n>0?Math.ceil(o*n):void 0},Ve=e=>{switch(e){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},qe=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},me=e=>e==="float32"||e==="float16"||e==="int32"||e==="int64"||e==="uint32"||e==="uint8"||e==="bool"||e==="uint4"||e==="int4",be=e=>e==="float32"||e==="float16"||e==="int32"||e==="int64"||e==="uint32"||e==="uint64"||e==="int8"||e==="uint8"||e==="bool"||e==="uint4"||e==="int4",Je=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;case"ml-tensor":return 5;default:throw new Error(`unsupported data location: ${e}`)}}});var ne,Oe=M(()=>{"use strict";ce();ne=async e=>{if(typeof e=="string")if(H)try{let{readFile:t}=require("node:fs/promises");return new Uint8Array(await t(e))}catch(t){if(t.code==="ERR_FS_FILE_TOO_LARGE"){let{createReadStream:n}=require("node:fs"),o=n(e),r=[];for await(let a of o)r.push(a);return new Uint8Array(Buffer.concat(r))}throw t}else{let t=await fetch(e);if(!t.ok)throw new Error(`failed to load external data file: ${e}`);let n=t.headers.get("Content-Length"),o=n?parseInt(n,10):0;if(o<1073741824)return new Uint8Array(await t.arrayBuffer());{if(!t.body)throw new Error(`failed to load external data file: ${e}, no response body.`);let r=t.body.getReader(),a;try{a=new ArrayBuffer(o)}catch(i){if(i instanceof RangeError){let u=Math.ceil(o/65536);a=new WebAssembly.Memory({initial:u,maximum:u}).buffer}else throw i}let s=0;for(;;){let{done:i,value:u}=await r.read();if(i)break;let f=u.byteLength;new Uint8Array(a,s,f).set(u),s+=f}return new Uint8Array(a,0,o)}}else return e instanceof Blob?new Uint8Array(await e.arrayBuffer()):e instanceof Uint8Array?e:new Uint8Array(e)}});var K,Ft,Xe,Ke,Q,Rt,Ye,Le,Qe,et,Ze,tt,rt,nt=M(()=>{"use strict";K=require("onnxruntime-common");je();He();Ie();Y();fe();Oe();Ft=(e,t)=>{E()._OrtInit(e,t)!==0&&g("Can't initialize onnxruntime.")},Xe=async e=>{Ft(e.wasm.numThreads,qe(e.logLevel))},Ke=async(e,t)=>{E().asyncInit?.();let n=e.webgpu.adapter;if(t==="webgpu"){if(typeof navigator>"u"||!navigator.gpu)throw new Error("WebGPU is not supported in current environment");if(n){if(typeof n.limits!="object"||typeof n.features!="object"||typeof n.requestDevice!="function")throw new Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.")}else{let o=e.webgpu.powerPreference;if(o!==void 0&&o!=="low-power"&&o!=="high-performance")throw new Error(`Invalid powerPreference setting: "${o}"`);let r=e.webgpu.forceFallbackAdapter;if(r!==void 0&&typeof r!="boolean")throw new Error(`Invalid forceFallbackAdapter setting: "${r}"`);if(n=await navigator.gpu.requestAdapter({powerPreference:o,forceFallbackAdapter:r}),!n)throw new Error('Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.')}}if(t==="webnn"&&(typeof navigator>"u"||!navigator.ml))throw new Error("WebNN is not supported in current environment")},Q=new Map,Rt=e=>{let t=E(),n=t.stackSave();try{let o=t.PTR_SIZE,r=t.stackAlloc(2*o);t._OrtGetInputOutputCount(e,r,r+o)!==0&&g("Can't get session input/output count.");let s=o===4?"i32":"i64";return[Number(t.getValue(r,s)),Number(t.getValue(r+o,s))]}finally{t.stackRestore(n)}},Ye=(e,t)=>{let n=E(),o=n.stackSave(),r=0;try{let a=n.PTR_SIZE,s=n.stackAlloc(2*a);n._OrtGetInputOutputMetadata(e,t,s,s+a)!==0&&g("Can't get session input/output metadata.");let u=Number(n.getValue(s,"*"));r=Number(n.getValue(s+a,"*"));let f=n.HEAP32[r/4];if(f===0)return[u,0];let l=n.HEAPU32[r/4+1],d=[];for(let c=0;c<l;c++){let p=Number(n.getValue(r+8+c*a,"*"));d.push(p!==0?n.UTF8ToString(p):Number(n.getValue(r+8+(c+l)*a,"*")))}return[u,f,d]}finally{n.stackRestore(o),r!==0&&n._OrtFree(r)}},Le=e=>{let t=E(),n=t._malloc(e.byteLength);if(n===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,n),[n,e.byteLength]},Qe=async(e,t)=>{let n,o,r=E();Array.isArray(e)?[n,o]=e:e.buffer===r.HEAPU8.buffer?[n,o]=[e.byteOffset,e.byteLength]:[n,o]=Le(e);let a=0,s=0,i=0,u=[],f=[],l=[];try{if([s,u]=await ze(t),t?.externalData&&r.mountExternalData){let y=[];for(let h of t.externalData){let B=typeof h=="string"?h:h.path;y.push(ne(typeof h=="string"?h:h.data).then(D=>{r.mountExternalData(B,D)}))}await Promise.all(y)}for(let y of t?.executionProviders??[])if((typeof y=="string"?y:y.name)==="webnn"){if(r.shouldTransferToMLTensor=!1,typeof y!="string"){let B=y,D=B?.context,P=B?.gpuDevice,ee=B?.deviceType,q=B?.powerPreference;D?r.currentContext=D:P?r.currentContext=await r.webnnCreateMLContext(P):r.currentContext=await r.webnnCreateMLContext({deviceType:ee,powerPreference:q})}else r.currentContext=await r.webnnCreateMLContext();break}a=await r._OrtCreateSession(n,o,s),r.webgpuOnCreateSession?.(a),a===0&&g("Can't create a session."),r.jsepOnCreateSession?.(),r.currentContext&&(r.webnnRegisterMLContext(a,r.currentContext),r.currentContext=void 0,r.shouldTransferToMLTensor=!0);let[d,c]=Rt(a),p=!!t?.enableGraphCapture,S=[],T=[],U=[],b=[],w=[];for(let y=0;y<d;y++){let[h,B,D]=Ye(a,y);h===0&&g("Can't get an input name."),f.push(h);let P=r.UTF8ToString(h);S.push(P),U.push(B===0?{name:P,isTensor:!1}:{name:P,isTensor:!0,type:de(B),shape:D})}for(let y=0;y<c;y++){let[h,B,D]=Ye(a,y+d);h===0&&g("Can't get an output name."),l.push(h);let P=r.UTF8ToString(h);T.push(P),b.push(B===0?{name:P,isTensor:!1}:{name:P,isTensor:!0,type:de(B),shape:D})}return Q.set(a,[a,f,l,null,p,!1]),[a,S,T,U,b]}catch(d){throw f.forEach(c=>r._OrtFree(c)),l.forEach(c=>r._OrtFree(c)),i!==0&&r._OrtReleaseBinding(i)!==0&&g("Can't release IO binding."),a!==0&&r._OrtReleaseSession(a)!==0&&g("Can't release session."),d}finally{r._free(n),s!==0&&r._OrtReleaseSessionOptions(s)!==0&&g("Can't release session options."),u.forEach(d=>r._free(d)),r.unmountExternalData?.()}},et=e=>{let t=E(),n=Q.get(e);if(!n)throw new Error(`cannot release session. invalid session id: ${e}`);let[o,r,a,s,i]=n;s&&(i&&t._OrtClearBoundOutputs(s.handle)!==0&&g("Can't clear bound outputs."),t._OrtReleaseBinding(s.handle)!==0&&g("Can't release IO binding.")),t.jsepOnReleaseSession?.(e),t.webnnOnReleaseSession?.(e),t.webgpuOnReleaseSession?.(e),r.forEach(u=>t._OrtFree(u)),a.forEach(u=>t._OrtFree(u)),t._OrtReleaseSession(o)!==0&&g("Can't release session."),Q.delete(e)},Ze=async(e,t,n,o,r,a,s=!1)=>{if(!e){t.push(0);return}let i=E(),u=i.PTR_SIZE,f=e[0],l=e[1],d=e[3],c=d,p,S;if(f==="string"&&(d==="gpu-buffer"||d==="ml-tensor"))throw new Error("String tensor is not supported on GPU.");if(s&&d!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${a} when enableGraphCapture is true.`);if(d==="gpu-buffer"){let b=e[2].gpuBuffer;S=X(Z(f),l);{let w=i.jsepRegisterBuffer;if(!w)throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');p=w(o,a,b,S)}}else if(d==="ml-tensor"){let b=e[2].mlTensor;S=X(Z(f),l);let w=i.webnnRegisterMLTensor;if(!w)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');p=w(o,b,Z(f),l)}else{let b=e[2];if(Array.isArray(b)){S=u*b.length,p=i._malloc(S),n.push(p);for(let w=0;w<b.length;w++){if(typeof b[w]!="string")throw new TypeError(`tensor data at index ${w} is not a string`);i.setValue(p+w*u,A(b[w],n),"*")}}else{let w=i.webnnIsGraphInput,C=i.webnnIsGraphOutput;if(f!=="string"&&w&&C){let y=i.UTF8ToString(r);if(w(o,y)||C(o,y)){let h=Z(f);S=X(h,l),c="ml-tensor";let B=i.webnnCreateTemporaryTensor,D=i.webnnUploadTensor;if(!B||!D)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');let P=await B(o,h,l);D(P,new Uint8Array(b.buffer,b.byteOffset,b.byteLength)),p=P}else S=b.byteLength,p=i._malloc(S),n.push(p),i.HEAPU8.set(new Uint8Array(b.buffer,b.byteOffset,S),p)}else S=b.byteLength,p=i._malloc(S),n.push(p),i.HEAPU8.set(new Uint8Array(b.buffer,b.byteOffset,S),p)}}let T=i.stackSave(),U=i.stackAlloc(4*l.length);try{l.forEach((w,C)=>i.setValue(U+C*u,w,u===4?"i32":"i64"));let b=i._OrtCreateTensor(Z(f),p,S,U,l.length,Je(c));b===0&&g(`Can't create tensor for input/output. session=${o}, index=${a}.`),t.push(b)}finally{i.stackRestore(T)}},tt=async(e,t,n,o,r,a)=>{let s=E(),i=s.PTR_SIZE,u=Q.get(e);if(!u)throw new Error(`cannot run inference. invalid session id: ${e}`);let f=u[0],l=u[1],d=u[2],c=u[3],p=u[4],S=u[5],T=t.length,U=o.length,b=0,w=[],C=[],y=[],h=[],B=[],D=s.stackSave(),P=s.stackAlloc(T*i),ee=s.stackAlloc(T*i),q=s.stackAlloc(U*i),_e=s.stackAlloc(U*i);try{[b,w]=$e(a),(0,K.TRACE_EVENT_BEGIN)("wasm prepareInputOutputTensor");for(let m=0;m<T;m++)await Ze(n[m],C,h,e,l[t[m]],t[m],p);for(let m=0;m<U;m++)await Ze(r[m],y,h,e,d[o[m]],T+o[m],p);(0,K.TRACE_EVENT_END)("wasm prepareInputOutputTensor");for(let m=0;m<T;m++)s.setValue(P+m*i,C[m],"*"),s.setValue(ee+m*i,l[t[m]],"*");for(let m=0;m<U;m++)s.setValue(q+m*i,y[m],"*"),s.setValue(_e+m*i,d[o[m]],"*");s.jsepOnRunStart?.(f),s.webnnOnRunStart?.(f);let x;x=await s._OrtRun(f,ee,P,T,_e,U,q,b),x!==0&&g("failed to call OrtRun().");let N=[],ve=[];(0,K.TRACE_EVENT_BEGIN)("wasm ProcessOutputTensor");for(let m=0;m<U;m++){let W=Number(s.getValue(q+m*i,"*"));if(W===y[m]||B.includes(y[m])){N.push(r[m]),W!==y[m]&&s._OrtReleaseTensor(W)!==0&&g("Can't release tensor.");continue}let Ue=s.stackSave(),k=s.stackAlloc(4*i),J=!1,O,_=0;try{s._OrtGetTensorData(W,k,k+i,k+2*i,k+3*i)!==0&&g(`Can't access output tensor data on index ${m}.`);let Ee=i===4?"i32":"i64",se=Number(s.getValue(k,Ee));_=s.getValue(k+i,"*");let De=s.getValue(k+i*2,"*"),yt=Number(s.getValue(k+i*3,Ee)),$=[];for(let L=0;L<yt;L++)$.push(Number(s.getValue(De+L*i,Ee)));s._OrtFree(De)!==0&&g("Can't free memory for tensor dims.");let j=$.reduce((L,I)=>L*I,1);O=de(se);let te=c?.outputPreferredLocations[o[m]];if(O==="string"){if(te==="gpu-buffer"||te==="ml-tensor")throw new Error("String tensor is not supported on GPU.");let L=[];for(let I=0;I<j;I++){let z=s.getValue(_+I*i,"*"),ae=s.getValue(_+(I+1)*i,"*"),Ae=I===j-1?void 0:ae-z;L.push(s.UTF8ToString(z,Ae))}N.push([O,$,L,"cpu"])}else if(te==="gpu-buffer"&&j>0){let L=s.jsepGetBuffer;if(!L)throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let I=L(_),z=X(se,j);if(z===void 0||!me(O))throw new Error(`Unsupported data type: ${O}`);J=!0,N.push([O,$,{gpuBuffer:I,download:s.jsepCreateDownloader(I,z,O),dispose:()=>{s._OrtReleaseTensor(W)!==0&&g("Can't release tensor.")}},"gpu-buffer"])}else if(te==="ml-tensor"&&j>0){let L=s.webnnEnsureTensor,I=s.webnnIsGraphInputOutputTypeSupported;if(!L||!I)throw new Error('preferredLocation "ml-tensor" is not supported without using WebNN.');if(X(se,j)===void 0||!be(O))throw new Error(`Unsupported data type: ${O}`);if(!I(e,O,!1))throw new Error(`preferredLocation "ml-tensor" for ${O} output is not supported by current WebNN Context.`);let ae=await L(e,_,se,$,!1);J=!0,N.push([O,$,{mlTensor:ae,download:s.webnnCreateMLTensorDownloader(_,O),dispose:()=>{s.webnnReleaseTensorId(_),s._OrtReleaseTensor(W)}},"ml-tensor"])}else if(te==="ml-tensor-cpu-output"&&j>0){let L=s.webnnCreateMLTensorDownloader(_,O)(),I=N.length;J=!0,ve.push((async()=>{let z=[I,await L];return s.webnnReleaseTensorId(_),s._OrtReleaseTensor(W),z})()),N.push([O,$,[],"cpu"])}else{let L=Ve(O),I=new L(j);new Uint8Array(I.buffer,I.byteOffset,I.byteLength).set(s.HEAPU8.subarray(_,_+I.byteLength)),N.push([O,$,I,"cpu"])}}finally{s.stackRestore(Ue),O==="string"&&_&&s._free(_),J||s._OrtReleaseTensor(W)}}c&&!p&&(s._OrtClearBoundOutputs(c.handle)!==0&&g("Can't clear bound outputs."),Q.set(e,[f,l,d,c,p,!1]));for(let[m,W]of await Promise.all(ve))N[m][2]=W;return(0,K.TRACE_EVENT_END)("wasm ProcessOutputTensor"),N}finally{s.webnnOnRunEnd?.(f),s.stackRestore(D),C.forEach(x=>s._OrtReleaseTensor(x)),y.forEach(x=>s._OrtReleaseTensor(x)),h.forEach(x=>s._free(x)),b!==0&&s._OrtReleaseRunOptions(b),w.forEach(x=>s._free(x))}},rt=e=>{let t=E(),n=Q.get(e);if(!n)throw new Error("invalid session id");let o=n[0],r=t._OrtEndProfiling(o);r===0&&g("Can't get an profile file name."),t._OrtFree(r)}});var we,Be,ot,st,at,it,ut,ct,lt,ft,pt,Pe=M(()=>{"use strict";we=require("onnxruntime-common");nt();Y();Se();Be=!1,ot=!1,st=!1,at=async()=>{if(!ot){if(Be)throw new Error("multiple calls to 'initWasm()' detected.");if(st)throw new Error("previous call to 'initWasm()' failed.");Be=!0;try{await Ge(we.env.wasm),await Xe(we.env),ot=!0}catch(e){throw st=!0,e}finally{Be=!1}}},it=async e=>{await Ke(we.env,e)},ut=async e=>Le(e),ct=async(e,t)=>Qe(e,t),lt=async e=>{et(e)},ft=async(e,t,n,o,r,a)=>tt(e,t,n,o,r,a),pt=async e=>{rt(e)}});var F,dt,Gt,ge,mt=M(()=>{"use strict";F=require("onnxruntime-common");Pe();Ie();ce();Oe();dt=(e,t)=>{switch(e.location){case"cpu":return[e.type,e.dims,e.data,"cpu"];case"gpu-buffer":return[e.type,e.dims,{gpuBuffer:e.gpuBuffer},"gpu-buffer"];case"ml-tensor":return[e.type,e.dims,{mlTensor:e.mlTensor},"ml-tensor"];default:throw new Error(`invalid data location: ${e.location} for ${t()}`)}},Gt=e=>{switch(e[3]){case"cpu":return new F.Tensor(e[0],e[2],e[1]);case"gpu-buffer":{let t=e[0];if(!me(t))throw new Error(`not supported data type: ${t} for deserializing GPU tensor`);let{gpuBuffer:n,download:o,dispose:r}=e[2];return F.Tensor.fromGpuBuffer(n,{dataType:t,dims:e[1],download:o,dispose:r})}case"ml-tensor":{let t=e[0];if(!be(t))throw new Error(`not supported data type: ${t} for deserializing MLTensor tensor`);let{mlTensor:n,download:o,dispose:r}=e[2];return F.Tensor.fromMLTensor(n,{dataType:t,dims:e[1],download:o,dispose:r})}default:throw new Error(`invalid data location: ${e[3]}`)}},ge=class{async fetchModelAndCopyToWasmMemory(t){return ut(await ne(t))}async loadModel(t,n){(0,F.TRACE_FUNC_BEGIN)();let o;typeof t=="string"?H?o=await ne(t):o=await this.fetchModelAndCopyToWasmMemory(t):o=t,[this.sessionId,this.inputNames,this.outputNames,this.inputMetadata,this.outputMetadata]=await ct(o,n),(0,F.TRACE_FUNC_END)()}async dispose(){return lt(this.sessionId)}async run(t,n,o){(0,F.TRACE_FUNC_BEGIN)();let r=[],a=[];Object.entries(t).forEach(c=>{let p=c[0],S=c[1],T=this.inputNames.indexOf(p);if(T===-1)throw new Error(`invalid input '${p}'`);r.push(S),a.push(T)});let s=[],i=[];Object.entries(n).forEach(c=>{let p=c[0],S=c[1],T=this.outputNames.indexOf(p);if(T===-1)throw new Error(`invalid output '${p}'`);s.push(S),i.push(T)});let u=r.map((c,p)=>dt(c,()=>`input "${this.inputNames[a[p]]}"`)),f=s.map((c,p)=>c?dt(c,()=>`output "${this.outputNames[i[p]]}"`):null),l=await ft(this.sessionId,a,u,i,f,o),d={};for(let c=0;c<l.length;c++)d[this.outputNames[i[c]]]=s[c]??Gt(l[c]);return(0,F.TRACE_FUNC_END)(),d}startProfiling(){}endProfiling(){pt(this.sessionId)}}});var wt={};xe(wt,{OnnxruntimeWebAssemblyBackend:()=>ye,initializeFlags:()=>bt,wasmBackend:()=>$t});var v,bt,ye,$t,gt=M(()=>{"use strict";v=require("onnxruntime-common");Pe();mt();bt=()=>{(typeof v.env.wasm.initTimeout!="number"||v.env.wasm.initTimeout<0)&&(v.env.wasm.initTimeout=0);let e=v.env.wasm.simd;if(typeof e!="boolean"&&e!==void 0&&e!=="fixed"&&e!=="relaxed"&&(console.warn(`Property "env.wasm.simd" is set to unknown value "${e}". Reset it to \`false\` and ignore SIMD feature checking.`),v.env.wasm.simd=!1),typeof v.env.wasm.proxy!="boolean"&&(v.env.wasm.proxy=!1),typeof v.env.wasm.trace!="boolean"&&(v.env.wasm.trace=!1),typeof v.env.wasm.numThreads!="number"||!Number.isInteger(v.env.wasm.numThreads)||v.env.wasm.numThreads<=0)if(typeof self<"u"&&!self.crossOriginIsolated)v.env.wasm.numThreads=1;else{let t=typeof navigator>"u"?require("node:os").cpus().length:navigator.hardwareConcurrency;v.env.wasm.numThreads=Math.min(4,Math.ceil((t||1)/2))}},ye=class{async init(t){bt(),await at(),await it(t)}async createInferenceSessionHandler(t,n){let o=new ge;return await o.loadModel(t,n),o}},$t=new ye});var R={};xe(R,{default:()=>zt});module.exports=Me(R);G(R,require("onnxruntime-common"),module.exports);var jt=Ot(require("onnxruntime-common")),oe=require("onnxruntime-common");var Ce="1.23.0";var zt=jt;{let e=(gt(),Me(wt)).wasmBackend;(0,oe.registerBackend)("cpu",e,10),(0,oe.registerBackend)("wasm",e,10)}Object.defineProperty(oe.env.versions,"web",{value:Ce,enumerable:!0});0&&(module.exports={...require("onnxruntime-common")});
//# sourceMappingURL=ort.node.min.js.map
