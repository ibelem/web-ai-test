/*!
 * ONNX Runtime Web v1.19.0
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
import{createRequire}from"module";const require=createRequire(import.meta.url);
var oe=Object.defineProperty;var ft=Object.getOwnPropertyDescriptor;var dt=Object.getOwnPropertyNames;var pt=Object.prototype.hasOwnProperty;var se=(e=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(e,{get:(t,n)=>(typeof require<"u"?require:t)[n]}):e)(function(e){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')});var P=(e,t)=>()=>(e&&(t=e(e=0)),t);var mt=(e,t)=>{for(var n in t)oe(e,n,{get:t[n],enumerable:!0})},gt=(e,t,n,s)=>{if(t&&typeof t=="object"||typeof t=="function")for(let r of dt(t))!pt.call(e,r)&&r!==n&&oe(e,r,{get:()=>t[r],enumerable:!(s=ft(t,r))||s.enumerable});return e};var yt=e=>gt(oe({},"__esModule",{value:!0}),e);var k,K=P(()=>{"use strict";k=!!(typeof process<"u"&&process.versions&&process.versions.node)});var D,bt,wt,ht,St,Et,Ot,ve,Q=P(()=>{"use strict";K();D=k?void 0:import.meta.url??(typeof document<"u"?document.currentScript?.src:typeof self<"u"?self.location?.href:void 0),bt=k||typeof location>"u"?void 0:location.origin,wt=(e,t)=>{try{let n=t??D;return(n?new URL(e,n):new URL(e)).origin===bt}catch{return!1}},ht=(e,t)=>{let n=t??D;try{return(n?new URL(e,n):new URL(e)).href}catch{return}},St=(e,t)=>`${t??"./"}${e}`,Et=async e=>{let n=await(await fetch(e,{credentials:"same-origin"})).blob();return URL.createObjectURL(n)},Ot=async e=>(await import(/*webpackIgnore:true*/e)).default,ve=async(e,t,n)=>{{let s="ort-wasm-simd-threaded.mjs",r=e??ht(s,t),a=!k&&n&&r&&!wt(r,t),o=a?await Et(r):r??St(s,t);return[a?o:void 0,await Ot(o)]}}});var ae,ie,Z,Ae,vt,At,Ie,E,W=P(()=>{"use strict";Q();ie=!1,Z=!1,Ae=!1,vt=()=>{if(typeof SharedArrayBuffer>"u")return!1;try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},At=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},Ie=async e=>{if(ie)return Promise.resolve();if(Z)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(Ae)throw new Error("previous call to 'initializeWebAssembly()' failed.");Z=!0;let t=e.initTimeout,n=e.numThreads;if(!At())throw new Error("WebAssembly SIMD is not supported in the current environment.");let s=vt();n>1&&!s&&(typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+n+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),e.numThreads=n=1);let r=e.wasmPaths,a=typeof r=="string"?r:void 0,o=r?.mjs,u=o?.href??o,c=r?.wasm,d=c?.href??c,[g,l]=await ve(u,a,n>1),i=!1,b=[];if(t>0&&b.push(new Promise(f=>{setTimeout(()=>{i=!0,f()},t)})),b.push(new Promise((f,y)=>{let S={numThreads:n};(d||a)&&(S.locateFile=(L,m)=>d??(a??m)+L),l(S).then(L=>{Z=!1,ie=!0,ae=L,f(),g&&URL.revokeObjectURL(g)},L=>{Z=!1,Ae=!0,y(L)})})),await Promise.race(b),i)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},E=()=>{if(ie&&ae)return ae;throw new Error("WebAssembly is not initialized yet.")}});var O,G,w,ee=P(()=>{"use strict";W();O=(e,t)=>{let n=E(),s=n.lengthBytesUTF8(e)+1,r=n._malloc(s);return n.stringToUTF8(e,r,s),t.push(r),r},G=(e,t,n,s)=>{if(typeof e=="object"&&e!==null){if(n.has(e))throw new Error("Circular reference in options");n.add(e)}Object.entries(e).forEach(([r,a])=>{let o=t?t+r:r;if(typeof a=="object")G(a,o+".",n,s);else if(typeof a=="string"||typeof a=="number")s(o,a.toString());else if(typeof a=="boolean")s(o,a?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof a}`)})},w=e=>{let t=E(),n=t.stackSave();try{let s=t.stackAlloc(8);t._OrtGetLastError(s,s+4);let r=t.HEAP32[s/4],a=t.HEAPU32[s/4+1],o=a?t.UTF8ToString(a):"";throw new Error(`${e} ERROR_CODE: ${r}, ERROR_MESSAGE: ${o}`)}finally{t.stackRestore(n)}}});var xe,Pe=P(()=>{"use strict";W();ee();xe=e=>{let t=E(),n=0,s=[],r=e||{};try{if(e?.logSeverityLevel===void 0)r.logSeverityLevel=2;else if(typeof e.logSeverityLevel!="number"||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(e?.logVerbosityLevel===void 0)r.logVerbosityLevel=0;else if(typeof e.logVerbosityLevel!="number"||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);e?.terminate===void 0&&(r.terminate=!1);let a=0;return e?.tag!==void 0&&(a=O(e.tag,s)),n=t._OrtCreateRunOptions(r.logSeverityLevel,r.logVerbosityLevel,!!r.terminate,a),n===0&&w("Can't create run options."),e?.extra!==void 0&&G(e.extra,"",new WeakSet,(o,u)=>{let c=O(o,s),d=O(u,s);t._OrtAddRunConfigEntry(n,c,d)!==0&&w(`Can't set a run config entry: ${o} - ${u}.`)}),[n,s]}catch(a){throw n!==0&&t._OrtReleaseRunOptions(n),s.forEach(o=>t._free(o)),a}}});var It,xt,Pt,Lt,Le,Te=P(()=>{"use strict";W();ee();It=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},xt=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},Pt=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some(n=>(typeof n=="string"?n:n.name)==="webgpu")&&(e.enableMemPattern=!1)},Lt=(e,t,n)=>{for(let s of t){let r=typeof s=="string"?s:s.name;switch(r){case"webnn":if(r="WEBNN",typeof s!="string"){let u=s?.deviceType;if(u){let c=O("deviceType",n),d=O(u,n);E()._OrtAddSessionConfigEntry(e,c,d)!==0&&w(`Can't set a session config entry: 'deviceType' - ${u}.`)}}break;case"webgpu":if(r="JS",typeof s!="string"){let o=s;if(o?.preferredLayout){if(o.preferredLayout!=="NCHW"&&o.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${o.preferredLayout}`);let u=O("preferredLayout",n),c=O(o.preferredLayout,n);E()._OrtAddSessionConfigEntry(e,u,c)!==0&&w(`Can't set a session config entry: 'preferredLayout' - ${o.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${r}`)}let a=O(r,n);E()._OrtAppendExecutionProvider(e,a)!==0&&w(`Can't append execution provider: ${r}.`)}},Le=e=>{let t=E(),n=0,s=[],r=e||{};Pt(r);try{let a=It(r.graphOptimizationLevel??"all"),o=xt(r.executionMode??"sequential"),u=typeof r.logId=="string"?O(r.logId,s):0,c=r.logSeverityLevel??2;if(!Number.isInteger(c)||c<0||c>4)throw new Error(`log serverity level is not valid: ${c}`);let d=r.logVerbosityLevel??0;if(!Number.isInteger(d)||d<0||d>4)throw new Error(`log verbosity level is not valid: ${d}`);let g=typeof r.optimizedModelFilePath=="string"?O(r.optimizedModelFilePath,s):0;if(n=t._OrtCreateSessionOptions(a,!!r.enableCpuMemArena,!!r.enableMemPattern,o,!!r.enableProfiling,0,u,c,d,g),n===0&&w("Can't create session options."),r.executionProviders&&Lt(n,r.executionProviders,s),r.enableGraphCapture!==void 0){if(typeof r.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${r.enableGraphCapture}`);let l=O("enableGraphCapture",s),i=O(r.enableGraphCapture.toString(),s);t._OrtAddSessionConfigEntry(n,l,i)!==0&&w(`Can't set a session config entry: 'enableGraphCapture' - ${r.enableGraphCapture}.`)}if(r.freeDimensionOverrides)for(let[l,i]of Object.entries(r.freeDimensionOverrides)){if(typeof l!="string")throw new Error(`free dimension override name must be a string: ${l}`);if(typeof i!="number"||!Number.isInteger(i)||i<0)throw new Error(`free dimension override value must be a non-negative integer: ${i}`);let b=O(l,s);t._OrtAddFreeDimensionOverride(n,b,i)!==0&&w(`Can't set a free dimension override: ${l} - ${i}.`)}return r.extra!==void 0&&G(r.extra,"",new WeakSet,(l,i)=>{let b=O(l,s),f=O(i,s);t._OrtAddSessionConfigEntry(n,b,f)!==0&&w(`Can't set a session config entry: ${l} - ${i}.`)}),[n,s]}catch(a){throw n!==0&&t._OrtReleaseSessionOptions(n),s.forEach(o=>t._free(o)),a}}});var ue,Ce,ce,Be,ke,te,Ue,le=P(()=>{"use strict";ue=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},Ce=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},ce=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],Be=e=>{switch(e){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},ke=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},te=e=>e==="float32"||e==="float16"||e==="int32"||e==="int64"||e==="uint32"||e==="uint8"||e==="bool",Ue=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${e}`)}}});var q,fe=P(()=>{"use strict";K();q=async e=>{if(typeof e=="string")if(k)try{let{readFile:t}=se("node:fs/promises");return new Uint8Array(await t(e))}catch(t){if(t.code==="ERR_FS_FILE_TOO_LARGE"){let{createReadStream:n}=se("node:fs"),s=n(e),r=[];for await(let a of s)r.push(a);return new Uint8Array(Buffer.concat(r))}throw t}else{let t=await fetch(e);if(!t.ok)throw new Error(`failed to load external data file: ${e}`);let n=t.headers.get("Content-Length"),s=n?parseInt(n,10):0;if(s<1073741824)return new Uint8Array(await t.arrayBuffer());{if(!t.body)throw new Error(`failed to load external data file: ${e}, no response body.`);let r=t.body.getReader(),a;try{a=new ArrayBuffer(s)}catch(u){if(u instanceof RangeError){let c=Math.ceil(s/65536);a=new WebAssembly.Memory({initial:c,maximum:c}).buffer}else throw u}let o=0;for(;;){let{done:u,value:c}=await r.read();if(u)break;let d=c.byteLength;new Uint8Array(a,o,d).set(c),o+=d}return new Uint8Array(a,0,s)}}else return e instanceof Blob?new Uint8Array(await e.arrayBuffer()):e instanceof Uint8Array?e:new Uint8Array(e)}});var Tt,De,Me,F,Ct,de,We,Fe,_e,Ne,Re,$e=P(()=>{"use strict";Pe();Te();le();W();ee();fe();Tt=(e,t)=>{E()._OrtInit(e,t)!==0&&w("Can't initialize onnxruntime.")},De=async e=>{Tt(e.wasm.numThreads,ke(e.logLevel))},Me=async(e,t)=>{},F=new Map,Ct=e=>{let t=E(),n=t.stackSave();try{let s=t.stackAlloc(8);return t._OrtGetInputOutputCount(e,s,s+4)!==0&&w("Can't get session input/output count."),[t.HEAP32[s/4],t.HEAP32[s/4+1]]}finally{t.stackRestore(n)}},de=e=>{let t=E(),n=t._malloc(e.byteLength);if(n===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,n),[n,e.byteLength]},We=async(e,t)=>{let n,s,r=E();Array.isArray(e)?[n,s]=e:e.buffer===r.HEAPU8.buffer?[n,s]=[e.byteOffset,e.byteLength]:[n,s]=de(e);let a=0,o=0,u=0,c=[],d=[],g=[];try{if([o,c]=Le(t),t?.externalData&&r.mountExternalData){let m=[];for(let h of t.externalData){let A=typeof h=="string"?h:h.path;m.push(q(typeof h=="string"?h:h.data).then(U=>{r.mountExternalData(A,U)}))}await Promise.all(m)}for(let m of t?.executionProviders??[])if((typeof m=="string"?m:m.name)==="webnn"){if(r.currentContext)throw new Error("WebNN execution provider is already set.");if(typeof m!="string"){let A=m,U=A?.context,N=A?.gpuDevice,V=A?.deviceType,R=A?.numThreads,J=A?.powerPreference;U?r.currentContext=U:N?r.currentContext=await navigator.ml.createContext(N):r.currentContext=await navigator.ml.createContext({deviceType:V,numThreads:R,powerPreference:J})}else r.currentContext=await navigator.ml.createContext();break}a=await r._OrtCreateSession(n,s,o),a===0&&w("Can't create a session."),r.currentContext&&(r.currentContext=void 0);let[l,i]=Ct(a),b=!!t?.enableGraphCapture,f=[],y=[],S=[];for(let m=0;m<l;m++){let h=r._OrtGetInputName(a,m);h===0&&w("Can't get an input name."),d.push(h),f.push(r.UTF8ToString(h))}for(let m=0;m<i;m++){let h=r._OrtGetOutputName(a,m);h===0&&w("Can't get an output name."),g.push(h);let A=r.UTF8ToString(h);y.push(A)}let L=null;return F.set(a,[a,d,g,L,b,!1]),[a,f,y]}catch(l){throw d.forEach(i=>r._OrtFree(i)),g.forEach(i=>r._OrtFree(i)),u!==0&&r._OrtReleaseBinding(u),a!==0&&r._OrtReleaseSession(a),l}finally{r._free(n),o!==0&&r._OrtReleaseSessionOptions(o),c.forEach(l=>r._free(l)),r.unmountExternalData?.()}},Fe=e=>{let t=E(),n=F.get(e);if(!n)throw new Error(`cannot release session. invalid session id: ${e}`);let[s,r,a,o,u]=n;o&&(u&&t._OrtClearBoundOutputs(o.handle),t._OrtReleaseBinding(o.handle)),t.jsepOnReleaseSession?.(e),r.forEach(c=>t._OrtFree(c)),a.forEach(c=>t._OrtFree(c)),t._OrtReleaseSession(s),F.delete(e)},_e=(e,t,n,s,r,a=!1)=>{if(!e){t.push(0);return}let o=E(),u=e[0],c=e[1],d=e[3],g,l;if(u==="string"&&d==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");if(a&&d!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${r} when enableGraphCapture is true.`);if(d==="gpu-buffer"){let f=e[2].gpuBuffer,y=ce(ue(u));l=c.reduce((L,m)=>L*m,1)*y;let S=o.jsepRegisterBuffer;if(!S)throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');g=S(s,r,f,l)}else{let f=e[2];if(Array.isArray(f)){l=4*f.length,g=o._malloc(l),n.push(g);let y=g/4;for(let S=0;S<f.length;S++){if(typeof f[S]!="string")throw new TypeError(`tensor data at index ${S} is not a string`);o.HEAPU32[y++]=O(f[S],n)}}else l=f.byteLength,g=o._malloc(l),n.push(g),o.HEAPU8.set(new Uint8Array(f.buffer,f.byteOffset,l),g)}let i=o.stackSave(),b=o.stackAlloc(4*c.length);try{let f=b/4;c.forEach(S=>o.HEAP32[f++]=S);let y=o._OrtCreateTensor(ue(u),g,l,b,c.length,Ue(d));y===0&&w(`Can't create tensor for input/output. session=${s}, index=${r}.`),t.push(y)}finally{o.stackRestore(i)}},Ne=async(e,t,n,s,r,a)=>{let o=E(),u=F.get(e);if(!u)throw new Error(`cannot run inference. invalid session id: ${e}`);let c=u[0],d=u[1],g=u[2],l=u[3],i=u[4],b=u[5],f=t.length,y=s.length,S=0,L=[],m=[],h=[],A=[],U=o.stackSave(),N=o.stackAlloc(f*4),V=o.stackAlloc(f*4),R=o.stackAlloc(y*4),J=o.stackAlloc(y*4);try{[S,L]=xe(a);for(let p=0;p<f;p++)_e(n[p],m,A,e,t[p],i);for(let p=0;p<y;p++)_e(r[p],h,A,e,f+s[p],i);let C=N/4,at=V/4,it=R/4,ut=J/4;for(let p=0;p<f;p++)o.HEAPU32[C++]=m[p],o.HEAPU32[at++]=d[t[p]];for(let p=0;p<y;p++)o.HEAPU32[it++]=h[p],o.HEAPU32[ut++]=g[s[p]];o.jsepOnRunStart?.(c);let ye;ye=await o._OrtRun(c,V,N,f,J,y,R,S),ye!==0&&w("failed to call OrtRun().");let $=[];for(let p=0;p<y;p++){let H=o.HEAPU32[R/4+p];if(H===h[p]){$.push(r[p]);continue}let be=o.stackSave(),_=o.stackAlloc(4*4),Y=!1,T,B=0;try{o._OrtGetTensorData(H,_,_+4,_+8,_+12)!==0&&w(`Can't access output tensor data on index ${p}.`);let X=_/4,we=o.HEAPU32[X++];B=o.HEAPU32[X++];let he=o.HEAPU32[X++],ct=o.HEAPU32[X++],j=[];for(let I=0;I<ct;I++)j.push(o.HEAPU32[he/4+I]);o._OrtFree(he);let z=j.reduce((I,x)=>I*x,1);T=Ce(we);let Se=l?.outputPreferredLocations[s[p]];if(T==="string"){if(Se==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");let I=[],x=B/4;for(let M=0;M<z;M++){let Ee=o.HEAPU32[x++],lt=M===z-1?void 0:o.HEAPU32[x]-Ee;I.push(o.UTF8ToString(Ee,lt))}$.push([T,j,I,"cpu"])}else if(Se==="gpu-buffer"&&z>0){let I=o.jsepGetBuffer;if(!I)throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let x=I(B),M=ce(we);if(M===void 0||!te(T))throw new Error(`Unsupported data type: ${T}`);Y=!0,$.push([T,j,{gpuBuffer:x,download:o.jsepCreateDownloader(x,z*M,T),dispose:()=>{o._OrtReleaseTensor(H)}},"gpu-buffer"])}else{let I=Be(T),x=new I(z);new Uint8Array(x.buffer,x.byteOffset,x.byteLength).set(o.HEAPU8.subarray(B,B+x.byteLength)),$.push([T,j,x,"cpu"])}}finally{o.stackRestore(be),T==="string"&&B&&o._free(B),Y||o._OrtReleaseTensor(H)}}return l&&!i&&(o._OrtClearBoundOutputs(l.handle),F.set(e,[c,d,g,l,i,!1])),$}finally{o.stackRestore(U),m.forEach(C=>o._OrtReleaseTensor(C)),h.forEach(C=>o._OrtReleaseTensor(C)),A.forEach(C=>o._free(C)),S!==0&&o._OrtReleaseRunOptions(S),L.forEach(C=>o._free(C))}},Re=e=>{let t=E(),n=F.get(e);if(!n)throw new Error("invalid session id");let s=n[0],r=t._OrtEndProfiling(s);r===0&&w("Can't get an profile file name."),t._OrtFree(r)}});import{env as me}from"onnxruntime-common";var pe,He,je,ze,Ge,qe,Ve,Je,Ye,Xe,ge=P(()=>{"use strict";$e();W();Q();pe=!1,He=!1,je=!1,ze=async()=>{if(!He){if(pe)throw new Error("multiple calls to 'initWasm()' detected.");if(je)throw new Error("previous call to 'initWasm()' failed.");pe=!0;try{await Ie(me.wasm),await De(me),He=!0}catch(e){throw je=!0,e}finally{pe=!1}}},Ge=async e=>{await Me(me,e)},qe=async e=>de(e),Ve=async(e,t)=>We(e,t),Je=async e=>{Fe(e)},Ye=async(e,t,n,s,r,a)=>Ne(e,t,n,s,r,a),Xe=async e=>{Re(e)}});import{Tensor as Ke,TRACE_FUNC_BEGIN as Qe,TRACE_FUNC_END as Ze}from"onnxruntime-common";var et,kt,re,tt=P(()=>{"use strict";ge();le();K();fe();et=(e,t)=>{switch(e.location){case"cpu":return[e.type,e.dims,e.data,"cpu"];case"gpu-buffer":return[e.type,e.dims,{gpuBuffer:e.gpuBuffer},"gpu-buffer"];default:throw new Error(`invalid data location: ${e.location} for ${t()}`)}},kt=e=>{switch(e[3]){case"cpu":return new Ke(e[0],e[2],e[1]);case"gpu-buffer":{let t=e[0];if(!te(t))throw new Error(`not supported data type: ${t} for deserializing GPU tensor`);let{gpuBuffer:n,download:s,dispose:r}=e[2];return Ke.fromGpuBuffer(n,{dataType:t,dims:e[1],download:s,dispose:r})}default:throw new Error(`invalid data location: ${e[3]}`)}},re=class{async fetchModelAndCopyToWasmMemory(t){return qe(await q(t))}async loadModel(t,n){Qe();let s;typeof t=="string"?k?s=await q(t):s=await this.fetchModelAndCopyToWasmMemory(t):s=t,[this.sessionId,this.inputNames,this.outputNames]=await Ve(s,n),Ze()}async dispose(){return Je(this.sessionId)}async run(t,n,s){Qe();let r=[],a=[];Object.entries(t).forEach(i=>{let b=i[0],f=i[1],y=this.inputNames.indexOf(b);if(y===-1)throw new Error(`invalid input '${b}'`);r.push(f),a.push(y)});let o=[],u=[];Object.entries(n).forEach(i=>{let b=i[0],f=i[1],y=this.outputNames.indexOf(b);if(y===-1)throw new Error(`invalid output '${b}'`);o.push(f),u.push(y)});let c=r.map((i,b)=>et(i,()=>`input "${this.inputNames[a[b]]}"`)),d=o.map((i,b)=>i?et(i,()=>`output "${this.outputNames[u[b]]}"`):null),g=await Ye(this.sessionId,a,c,u,d,s),l={};for(let i=0;i<g.length;i++)l[this.outputNames[u[i]]]=o[i]??kt(g[i]);return Ze(),l}startProfiling(){}endProfiling(){Xe(this.sessionId)}}});import{env as v}from"onnxruntime-common";var Ut,ne,rt=P(()=>{"use strict";ge();tt();Q();Ut=()=>{if((typeof v.wasm.initTimeout!="number"||v.wasm.initTimeout<0)&&(v.wasm.initTimeout=0),v.wasm.simd===!1&&console.warn('Deprecated property "env.wasm.simd" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'),typeof v.wasm.proxy!="boolean"&&(v.wasm.proxy=!1),typeof v.wasm.trace!="boolean"&&(v.wasm.trace=!1),typeof v.wasm.numThreads!="number"||!Number.isInteger(v.wasm.numThreads)||v.wasm.numThreads<=0)if(typeof self<"u"&&!self.crossOriginIsolated)v.wasm.numThreads=1;else{let e=typeof navigator>"u"?se("node:os").cpus().length:navigator.hardwareConcurrency;v.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}v.wasm.wasmPaths===void 0&&D&&D.indexOf("blob:")!==0&&(v.wasm.wasmPaths=D.substring(0,D.lastIndexOf("/")+1))},ne=class{async init(t){Ut(),await ze(),await Ge(t)}async createInferenceSessionHandler(t,n){let s=new re;return await s.loadModel(t,n),Promise.resolve(s)}}});var nt={};mt(nt,{wasmBackend:()=>_t});var _t,ot=P(()=>{"use strict";rt();_t=new ne});export*from"onnxruntime-common";import*as Dt from"onnxruntime-common";import{registerBackend as st,env as Mt}from"onnxruntime-common";var Oe="1.19.0";var Ur=Dt;{let e=(ot(),yt(nt)).wasmBackend;st("cpu",e,10),st("wasm",e,10)}Object.defineProperty(Mt.versions,"web",{value:Oe,enumerable:!0});export{Ur as default};
//# sourceMappingURL=ort.node.min.mjs.map
