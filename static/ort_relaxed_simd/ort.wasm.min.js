/*!
 * ONNX Runtime Web v1.21.0
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
"use strict";var ort=(()=>{var je=Object.defineProperty;var Tr=Object.getOwnPropertyDescriptor;var Sr=Object.getOwnPropertyNames;var Ar=Object.prototype.hasOwnProperty;var He=(t=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(t,{get:(e,n)=>(typeof require<"u"?require:e)[n]}):t)(function(t){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+t+'" is not supported')});var b=(t,e)=>()=>(t&&(e=t(t=0)),e);var ye=(t,e)=>{for(var n in e)je(t,n,{get:e[n],enumerable:!0})},Or=(t,e,n,o)=>{if(e&&typeof e=="object"||typeof e=="function")for(let r of Sr(e))!Ar.call(t,r)&&r!==n&&je(t,r,{get:()=>e[r],enumerable:!(o=Tr(e,r))||o.enumerable});return t};var Ve=t=>Or(je({},"__esModule",{value:!0}),t);var we,j,K,xr,be,ge=b(()=>{"use strict";we=new Map,j=[],K=(t,e,n)=>{if(e&&typeof e.init=="function"&&typeof e.createInferenceSessionHandler=="function"){let o=we.get(t);if(o===void 0)we.set(t,{backend:e,priority:n});else{if(o.priority>n)return;if(o.priority===n&&o.backend!==e)throw new Error(`cannot register backend "${t}" using priority ${n}`)}if(n>=0){let r=j.indexOf(t);r!==-1&&j.splice(r,1);for(let i=0;i<j.length;i++)if(we.get(j[i]).priority<=n){j.splice(i,0,t);return}j.push(t)}return}throw new TypeError("not a valid backend")},xr=async t=>{let e=we.get(t);if(!e)return"backend not found.";if(e.initialized)return e.backend;if(e.aborted)return e.error;{let n=!!e.initPromise;try{return n||(e.initPromise=e.backend.init(t)),await e.initPromise,e.initialized=!0,e.backend}catch(o){return n||(e.error=`${o}`,e.aborted=!0),e.error}finally{delete e.initPromise}}},be=async t=>{let e=t.executionProviders||[],n=e.map(u=>typeof u=="string"?u:u.name),o=n.length===0?j:n,r,i=[],s=new Set;for(let u of o){let f=await xr(u);typeof f=="string"?i.push({name:u,err:f}):(r||(r=f),r===f&&s.add(u))}if(!r)throw new Error(`no available backend found. ERR: ${i.map(u=>`[${u.name}] ${u.err}`).join(", ")}`);for(let{name:u,err:f}of i)n.includes(u)&&console.warn(`removing requested execution provider "${u}" from session options because it is not available: ${f}`);let a=e.filter(u=>s.has(typeof u=="string"?u:u.name));return[r,new Proxy(t,{get:(u,f)=>f==="executionProviders"?a:Reflect.get(u,f)})]}});var ft=b(()=>{"use strict";ge()});var ct,lt=b(()=>{"use strict";ct="1.21.0"});var dt,U,Ye=b(()=>{"use strict";lt();dt="warning",U={wasm:{},webgl:{},webgpu:{},versions:{common:ct},set logLevel(t){if(t!==void 0){if(typeof t!="string"||["verbose","info","warning","error","fatal"].indexOf(t)===-1)throw new Error(`Unsupported logging level: ${t}`);dt=t}},get logLevel(){return dt}};Object.defineProperty(U,"logLevel",{enumerable:!0})});var S,pt=b(()=>{"use strict";Ye();S=U});var mt,ht,yt=b(()=>{"use strict";mt=(t,e)=>{let n=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);n.width=t.dims[3],n.height=t.dims[2];let o=n.getContext("2d");if(o!=null){let r,i;e?.tensorLayout!==void 0&&e.tensorLayout==="NHWC"?(r=t.dims[2],i=t.dims[3]):(r=t.dims[3],i=t.dims[2]);let s=e?.format!==void 0?e.format:"RGB",a=e?.norm,u,f;a===void 0||a.mean===void 0?u=[255,255,255,255]:typeof a.mean=="number"?u=[a.mean,a.mean,a.mean,a.mean]:(u=[a.mean[0],a.mean[1],a.mean[2],0],a.mean[3]!==void 0&&(u[3]=a.mean[3])),a===void 0||a.bias===void 0?f=[0,0,0,0]:typeof a.bias=="number"?f=[a.bias,a.bias,a.bias,a.bias]:(f=[a.bias[0],a.bias[1],a.bias[2],0],a.bias[3]!==void 0&&(f[3]=a.bias[3]));let d=i*r,l=0,c=d,p=d*2,g=-1;s==="RGBA"?(l=0,c=d,p=d*2,g=d*3):s==="RGB"?(l=0,c=d,p=d*2):s==="RBG"&&(l=0,p=d,c=d*2);for(let m=0;m<i;m++)for(let h=0;h<r;h++){let O=(t.data[l++]-f[0])*u[0],y=(t.data[c++]-f[1])*u[1],w=(t.data[p++]-f[2])*u[2],A=g===-1?255:(t.data[g++]-f[3])*u[3];o.fillStyle="rgba("+O+","+y+","+w+","+A+")",o.fillRect(h,m,1,1)}if("toDataURL"in n)return n.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},ht=(t,e)=>{let n=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d"),o;if(n!=null){let r,i,s;e?.tensorLayout!==void 0&&e.tensorLayout==="NHWC"?(r=t.dims[2],i=t.dims[1],s=t.dims[3]):(r=t.dims[3],i=t.dims[2],s=t.dims[1]);let a=e!==void 0&&e.format!==void 0?e.format:"RGB",u=e?.norm,f,d;u===void 0||u.mean===void 0?f=[255,255,255,255]:typeof u.mean=="number"?f=[u.mean,u.mean,u.mean,u.mean]:(f=[u.mean[0],u.mean[1],u.mean[2],255],u.mean[3]!==void 0&&(f[3]=u.mean[3])),u===void 0||u.bias===void 0?d=[0,0,0,0]:typeof u.bias=="number"?d=[u.bias,u.bias,u.bias,u.bias]:(d=[u.bias[0],u.bias[1],u.bias[2],0],u.bias[3]!==void 0&&(d[3]=u.bias[3]));let l=i*r;if(e!==void 0&&(e.format!==void 0&&s===4&&e.format!=="RGBA"||s===3&&e.format!=="RGB"&&e.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let c=4,p=0,g=1,m=2,h=3,O=0,y=l,w=l*2,A=-1;a==="RGBA"?(O=0,y=l,w=l*2,A=l*3):a==="RGB"?(O=0,y=l,w=l*2):a==="RBG"&&(O=0,w=l,y=l*2),o=n.createImageData(r,i);for(let P=0;P<i*r;p+=c,g+=c,m+=c,h+=c,P++)o.data[p]=(t.data[O++]-d[0])*f[0],o.data[g]=(t.data[y++]-d[1])*f[1],o.data[m]=(t.data[w++]-d[2])*f[2],o.data[h]=A===-1?255:(t.data[A++]-d[3])*f[3]}else throw new Error("Can not access image data");return o}});var qe,wt,bt,gt,Et,Tt,St=b(()=>{"use strict";Ee();qe=(t,e)=>{if(t===void 0)throw new Error("Image buffer must be defined");if(e.height===void 0||e.width===void 0)throw new Error("Image height and width must be defined");if(e.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:n,width:o}=e,r=e.norm??{mean:255,bias:0},i,s;typeof r.mean=="number"?i=[r.mean,r.mean,r.mean,r.mean]:i=[r.mean[0],r.mean[1],r.mean[2],r.mean[3]??255],typeof r.bias=="number"?s=[r.bias,r.bias,r.bias,r.bias]:s=[r.bias[0],r.bias[1],r.bias[2],r.bias[3]??0];let a=e.format!==void 0?e.format:"RGBA",u=e.tensorFormat!==void 0&&e.tensorFormat!==void 0?e.tensorFormat:"RGB",f=n*o,d=u==="RGBA"?new Float32Array(f*4):new Float32Array(f*3),l=4,c=0,p=1,g=2,m=3,h=0,O=f,y=f*2,w=-1;a==="RGB"&&(l=3,c=0,p=1,g=2,m=-1),u==="RGBA"?w=f*3:u==="RBG"?(h=0,y=f,O=f*2):u==="BGR"&&(y=0,O=f,h=f*2);for(let P=0;P<f;P++,c+=l,g+=l,p+=l,m+=l)d[h++]=(t[c]+s[0])/i[0],d[O++]=(t[p]+s[1])/i[1],d[y++]=(t[g]+s[2])/i[2],w!==-1&&m!==-1&&(d[w++]=(t[m]+s[3])/i[3]);return u==="RGBA"?new L("float32",d,[1,4,n,o]):new L("float32",d,[1,3,n,o])},wt=async(t,e)=>{let n=typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement,o=typeof ImageData<"u"&&t instanceof ImageData,r=typeof ImageBitmap<"u"&&t instanceof ImageBitmap,i=typeof t=="string",s,a=e??{},u=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},f=d=>typeof HTMLCanvasElement<"u"&&d instanceof HTMLCanvasElement||d instanceof OffscreenCanvas?d.getContext("2d"):null;if(n){let d=u();d.width=t.width,d.height=t.height;let l=f(d);if(l!=null){let c=t.height,p=t.width;if(e!==void 0&&e.resizedHeight!==void 0&&e.resizedWidth!==void 0&&(c=e.resizedHeight,p=e.resizedWidth),e!==void 0){if(a=e,e.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");a.tensorFormat="RGBA",a.height=c,a.width=p}else a.tensorFormat="RGBA",a.height=c,a.width=p;l.drawImage(t,0,0),s=l.getImageData(0,0,p,c).data}else throw new Error("Can not access image data")}else if(o){let d,l;if(e!==void 0&&e.resizedWidth!==void 0&&e.resizedHeight!==void 0?(d=e.resizedHeight,l=e.resizedWidth):(d=t.height,l=t.width),e!==void 0&&(a=e),a.format="RGBA",a.height=d,a.width=l,e!==void 0){let c=u();c.width=l,c.height=d;let p=f(c);if(p!=null)p.putImageData(t,0,0),s=p.getImageData(0,0,l,d).data;else throw new Error("Can not access image data")}else s=t.data}else if(r){if(e===void 0)throw new Error("Please provide image config with format for Imagebitmap");let d=u();d.width=t.width,d.height=t.height;let l=f(d);if(l!=null){let c=t.height,p=t.width;return l.drawImage(t,0,0,p,c),s=l.getImageData(0,0,p,c).data,a.height=c,a.width=p,qe(s,a)}else throw new Error("Can not access image data")}else{if(i)return new Promise((d,l)=>{let c=u(),p=f(c);if(!t||!p)return l();let g=new Image;g.crossOrigin="Anonymous",g.src=t,g.onload=()=>{c.width=g.width,c.height=g.height,p.drawImage(g,0,0,c.width,c.height);let m=p.getImageData(0,0,c.width,c.height);a.height=c.height,a.width=c.width,d(qe(m.data,a))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(s!==void 0)return qe(s,a);throw new Error("Input data provided is not supported - aborted tensor creation")},bt=(t,e)=>{let{width:n,height:o,download:r,dispose:i}=e,s=[1,o,n,4];return new L({location:"texture",type:"float32",texture:t,dims:s,download:r,dispose:i})},gt=(t,e)=>{let{dataType:n,dims:o,download:r,dispose:i}=e;return new L({location:"gpu-buffer",type:n??"float32",gpuBuffer:t,dims:o,download:r,dispose:i})},Et=(t,e)=>{let{dataType:n,dims:o,download:r,dispose:i}=e;return new L({location:"ml-tensor",type:n??"float32",mlTensor:t,dims:o,download:r,dispose:i})},Tt=(t,e,n)=>new L({location:"cpu-pinned",type:t,data:e,dims:n??[e.length]})});var H,ne,At,Ot,xt=b(()=>{"use strict";H=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),ne=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),At=!1,Ot=()=>{if(!At){At=!0;let t=typeof BigInt64Array<"u"&&BigInt64Array.from,e=typeof BigUint64Array<"u"&&BigUint64Array.from,n=typeof Float16Array<"u"&&Float16Array.from;t&&(H.set("int64",BigInt64Array),ne.set(BigInt64Array,"int64")),e&&(H.set("uint64",BigUint64Array),ne.set(BigUint64Array,"uint64")),n?(H.set("float16",Float16Array),ne.set(Float16Array,"float16")):H.set("float16",Uint16Array)}}});var vt,It,Pt=b(()=>{"use strict";Ee();vt=t=>{let e=1;for(let n=0;n<t.length;n++){let o=t[n];if(typeof o!="number"||!Number.isSafeInteger(o))throw new TypeError(`dims[${n}] must be an integer, got: ${o}`);if(o<0)throw new RangeError(`dims[${n}] must be a non-negative integer, got: ${o}`);e*=o}return e},It=(t,e)=>{switch(t.location){case"cpu":return new L(t.type,t.data,e);case"cpu-pinned":return new L({location:"cpu-pinned",data:t.data,type:t.type,dims:e});case"texture":return new L({location:"texture",texture:t.texture,type:t.type,dims:e});case"gpu-buffer":return new L({location:"gpu-buffer",gpuBuffer:t.gpuBuffer,type:t.type,dims:e});case"ml-tensor":return new L({location:"ml-tensor",mlTensor:t.mlTensor,type:t.type,dims:e});default:throw new Error(`tensorReshape: tensor location ${t.location} is not supported`)}}});var L,Ee=b(()=>{"use strict";yt();St();xt();Pt();L=class{constructor(e,n,o){Ot();let r,i;if(typeof e=="object"&&"location"in e)switch(this.dataLocation=e.location,r=e.type,i=e.dims,e.location){case"cpu-pinned":{let a=H.get(r);if(!a)throw new TypeError(`unsupported type "${r}" to create tensor from pinned buffer`);if(!(e.data instanceof a))throw new TypeError(`buffer should be of type ${a.name}`);this.cpuData=e.data;break}case"texture":{if(r!=="float32")throw new TypeError(`unsupported type "${r}" to create tensor from texture`);this.gpuTextureData=e.texture,this.downloader=e.download,this.disposer=e.dispose;break}case"gpu-buffer":{if(r!=="float32"&&r!=="float16"&&r!=="int32"&&r!=="int64"&&r!=="uint32"&&r!=="uint8"&&r!=="bool"&&r!=="uint4"&&r!=="int4")throw new TypeError(`unsupported type "${r}" to create tensor from gpu buffer`);this.gpuBufferData=e.gpuBuffer,this.downloader=e.download,this.disposer=e.dispose;break}case"ml-tensor":{if(r!=="float32"&&r!=="float16"&&r!=="int32"&&r!=="int64"&&r!=="uint32"&&r!=="uint64"&&r!=="int8"&&r!=="uint8"&&r!=="bool"&&r!=="uint4"&&r!=="int4")throw new TypeError(`unsupported type "${r}" to create tensor from MLTensor`);this.mlTensorData=e.mlTensor,this.downloader=e.download,this.disposer=e.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let a,u;if(typeof e=="string")if(r=e,u=o,e==="string"){if(!Array.isArray(n))throw new TypeError("A string tensor's data must be a string array.");a=n}else{let f=H.get(e);if(f===void 0)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(n)){if(e==="float16"&&f===Uint16Array||e==="uint4"||e==="int4")throw new TypeError(`Creating a ${e} tensor from number array is not supported. Please use ${f.name} as data.`);e==="uint64"||e==="int64"?a=f.from(n,BigInt):a=f.from(n)}else if(n instanceof f)a=n;else if(n instanceof Uint8ClampedArray)if(e==="uint8")a=Uint8Array.from(n);else throw new TypeError("A Uint8ClampedArray tensor's data must be type of uint8");else throw new TypeError(`A ${r} tensor's data must be type of ${f}`)}else if(u=n,Array.isArray(e)){if(e.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let f=typeof e[0];if(f==="string")r="string",a=e;else if(f==="boolean")r="bool",a=Uint8Array.from(e);else throw new TypeError(`Invalid element type of data array: ${f}.`)}else if(e instanceof Uint8ClampedArray)r="uint8",a=Uint8Array.from(e);else{let f=ne.get(e.constructor);if(f===void 0)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);r=f,a=e}if(u===void 0)u=[a.length];else if(!Array.isArray(u))throw new TypeError("A tensor's dims must be a number array");i=u,this.cpuData=a,this.dataLocation="cpu"}let s=vt(i);if(this.cpuData&&s!==this.cpuData.length&&!((r==="uint4"||r==="int4")&&Math.ceil(s/2)===this.cpuData.length))throw new Error(`Tensor's size(${s}) does not match data length(${this.cpuData.length}).`);this.type=r,this.dims=i,this.size=s}static async fromImage(e,n){return wt(e,n)}static fromTexture(e,n){return bt(e,n)}static fromGpuBuffer(e,n){return gt(e,n)}static fromMLTensor(e,n){return Et(e,n)}static fromPinnedBuffer(e,n,o){return Tt(e,n,o)}toDataURL(e){return mt(this,e)}toImageData(e){return ht(this,e)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(e){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let n=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=n,e&&this.disposer&&(this.disposer(),this.disposer=void 0),n}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(e){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return It(this,e)}}});var I,Te=b(()=>{"use strict";Ee();I=L});var Je,Ct,F,W,Xe=b(()=>{"use strict";Ye();Je=(t,e)=>{(typeof U.trace>"u"?!U.wasm.trace:!U.trace)||console.timeStamp(`${t}::ORT::${e}`)},Ct=(t,e)=>{let n=new Error().stack?.split(/\r\n|\r|\n/g)||[],o=!1;for(let r=0;r<n.length;r++){if(o&&!n[r].includes("TRACE_FUNC")){let i=`FUNC_${t}::${n[r].trim().split(" ")[1]}`;e&&(i+=`::${e}`),Je("CPU",i);return}n[r].includes("TRACE_FUNC")&&(o=!0)}},F=t=>{(typeof U.trace>"u"?!U.wasm.trace:!U.trace)||Ct("BEGIN",t)},W=t=>{(typeof U.trace>"u"?!U.wasm.trace:!U.trace)||Ct("END",t)}});var Se,Lt=b(()=>{"use strict";ge();Te();Xe();Se=class t{constructor(e){this.handler=e}async run(e,n,o){F();let r={},i={};if(typeof e!="object"||e===null||e instanceof I||Array.isArray(e))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let s=!0;if(typeof n=="object"){if(n===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(n instanceof I)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(n)){if(n.length===0)throw new TypeError("'fetches' cannot be an empty array.");s=!1;for(let f of n){if(typeof f!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(f)===-1)throw new RangeError(`'fetches' contains invalid output name: ${f}.`);r[f]=null}if(typeof o=="object"&&o!==null)i=o;else if(typeof o<"u")throw new TypeError("'options' must be an object.")}else{let f=!1,d=Object.getOwnPropertyNames(n);for(let l of this.outputNames)if(d.indexOf(l)!==-1){let c=n[l];(c===null||c instanceof I)&&(f=!0,s=!1,r[l]=c)}if(f){if(typeof o=="object"&&o!==null)i=o;else if(typeof o<"u")throw new TypeError("'options' must be an object.")}else i=n}}else if(typeof n<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let f of this.inputNames)if(typeof e[f]>"u")throw new Error(`input '${f}' is missing in 'feeds'.`);if(s)for(let f of this.outputNames)r[f]=null;let a=await this.handler.run(e,r,i),u={};for(let f in a)if(Object.hasOwnProperty.call(a,f)){let d=a[f];d instanceof I?u[f]=d:u[f]=new I(d.type,d.data,d.dims)}return W(),u}async release(){return this.handler.dispose()}static async create(e,n,o,r){F();let i,s={};if(typeof e=="string"){if(i=e,typeof n=="object"&&n!==null)s=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof Uint8Array){if(i=e,typeof n=="object"&&n!==null)s=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&e instanceof SharedArrayBuffer){let d=e,l=0,c=e.byteLength;if(typeof n=="object"&&n!==null)s=n;else if(typeof n=="number"){if(l=n,!Number.isSafeInteger(l))throw new RangeError("'byteOffset' must be an integer.");if(l<0||l>=d.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${d.byteLength}).`);if(c=e.byteLength-l,typeof o=="number"){if(c=o,!Number.isSafeInteger(c))throw new RangeError("'byteLength' must be an integer.");if(c<=0||l+c>d.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${d.byteLength-l}].`);if(typeof r=="object"&&r!==null)s=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else if(typeof o<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof n<"u")throw new TypeError("'options' must be an object.");i=new Uint8Array(d,l,c)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let[a,u]=await be(s),f=await a.createInferenceSessionHandler(i,u);return W(),new t(f)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}});var Bt,Mt=b(()=>{"use strict";Lt();Bt=Se});var Rt=b(()=>{"use strict"});var Ut=b(()=>{"use strict"});var Dt=b(()=>{"use strict"});var _t=b(()=>{"use strict"});var vr,Ae,kt=b(()=>{"use strict";ge();Te();vr="Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.",Ae=class t{constructor(e,n,o){this.handler=e,this.hasOptimizerModel=n,this.hasEvalModel=o}get trainingInputNames(){return this.handler.inputNames}get trainingOutputNames(){return this.handler.outputNames}get evalInputNames(){if(this.hasEvalModel)return this.handler.evalInputNames;throw new Error("This training session has no evalModel loaded.")}get evalOutputNames(){if(this.hasEvalModel)return this.handler.evalOutputNames;throw new Error("This training session has no evalModel loaded.")}static async create(e,n){let o=e.evalModel||"",r=e.optimizerModel||"",i=n||{},[s,a]=await be(i);if(s.createTrainingSessionHandler){let u=await s.createTrainingSessionHandler(e.checkpointState,e.trainModel,o,r,a);return new t(u,!!e.optimizerModel,!!e.evalModel)}else throw new Error(vr)}typeNarrowingForRunStep(e,n,o,r,i){let s={},a={};if(typeof o!="object"||o===null||o instanceof I||Array.isArray(o))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let u=!0;if(typeof r=="object"){if(r===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(r instanceof I)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(r)){if(r.length===0)throw new TypeError("'fetches' cannot be an empty array.");u=!1;for(let f of r){if(typeof f!="string")throw new TypeError("'fetches' must be a string array or an object.");if(n.indexOf(f)===-1)throw new RangeError(`'fetches' contains invalid output name: ${f}.`);s[f]=null}if(typeof i=="object"&&i!==null)a=i;else if(typeof i<"u")throw new TypeError("'options' must be an object.")}else{let f=!1,d=Object.getOwnPropertyNames(r);for(let l of n)if(d.indexOf(l)!==-1){let c=r[l];(c===null||c instanceof I)&&(f=!0,u=!1,s[l]=c)}if(f){if(typeof i=="object"&&i!==null)a=i;else if(typeof i<"u")throw new TypeError("'options' must be an object.")}else a=r}}else if(typeof r<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let f of e)if(typeof o[f]>"u")throw new Error(`input '${f}' is missing in 'feeds'.`);if(u)for(let f of n)s[f]=null;return[s,a]}convertHandlerReturnTypeToMapOfTensors(e){let n={};for(let o in e)if(Object.hasOwnProperty.call(e,o)){let r=e[o];r instanceof I?n[o]=r:n[o]=new I(r.type,r.data,r.dims)}return n}async lazyResetGrad(){await this.handler.lazyResetGrad()}async runTrainStep(e,n,o){let[r,i]=this.typeNarrowingForRunStep(this.trainingInputNames,this.trainingOutputNames,e,n,o),s=await this.handler.runTrainStep(e,r,i);return this.convertHandlerReturnTypeToMapOfTensors(s)}async runOptimizerStep(e){if(this.hasOptimizerModel)await this.handler.runOptimizerStep(e||{});else throw new Error("This TrainingSession has no OptimizerModel loaded.")}async runEvalStep(e,n,o){if(this.hasEvalModel){let[r,i]=this.typeNarrowingForRunStep(this.evalInputNames,this.evalOutputNames,e,n,o),s=await this.handler.runEvalStep(e,r,i);return this.convertHandlerReturnTypeToMapOfTensors(s)}else throw new Error("This TrainingSession has no EvalModel loaded.")}async getParametersSize(e=!0){return this.handler.getParametersSize(e)}async loadParametersBuffer(e,n=!0){let o=await this.getParametersSize(n);if(e.length!==4*o)throw new Error("Size of the buffer passed into loadParametersBuffer must match the number of parameters in the model. Please use getParametersSize method to check.");return this.handler.loadParametersBuffer(e,n)}async getContiguousParameters(e=!0){return this.handler.getContiguousParameters(e)}async release(){return this.handler.dispose()}}});var Nt,Ft=b(()=>{"use strict";kt();Nt=Ae});var Ze={};ye(Ze,{InferenceSession:()=>Bt,TRACE:()=>Je,TRACE_FUNC_BEGIN:()=>F,TRACE_FUNC_END:()=>W,Tensor:()=>I,TrainingSession:()=>Nt,env:()=>S,registerBackend:()=>K});var V=b(()=>{"use strict";ft();pt();Mt();Te();Rt();Ut();Xe();Dt();_t();Ft()});var Oe=b(()=>{"use strict"});var Gt={};ye(Gt,{default:()=>Ir});var $t,zt,Ir,jt=b(()=>{"use strict";Ke();Y();oe();$t="ort-wasm-proxy-worker",zt=globalThis.self?.name===$t;zt&&(self.onmessage=t=>{let{type:e,in:n}=t.data;try{switch(e){case"init-wasm":xe(n.wasm).then(()=>{ve(n).then(()=>{postMessage({type:e})},o=>{postMessage({type:e,err:o})})},o=>{postMessage({type:e,err:o})});break;case"init-ep":{let{epName:o,env:r}=n;Ie(r,o).then(()=>{postMessage({type:e})},i=>{postMessage({type:e,err:i})});break}case"copy-from":{let{buffer:o}=n,r=se(o);postMessage({type:e,out:r});break}case"create":{let{model:o,options:r}=n;Pe(o,r).then(i=>{postMessage({type:e,out:i})},i=>{postMessage({type:e,err:i})});break}case"release":Ce(n),postMessage({type:e});break;case"run":{let{sessionId:o,inputIndices:r,inputs:i,outputIndices:s,options:a}=n;Le(o,r,i,s,new Array(s.length).fill(null),a).then(u=>{u.some(f=>f[3]!=="cpu")?postMessage({type:e,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:e,out:u},Me([...i,...u]))},u=>{postMessage({type:e,err:u})});break}case"end-profiling":Be(n),postMessage({type:e});break;default:}}catch(o){postMessage({type:e,err:o})}});Ir=zt?null:t=>new Worker(t??D,{type:"classic",name:$t})});var D,Pr,Vt,Cr,Lr,Yt,Br,Ht,qt,Jt,oe=b(()=>{"use strict";Oe();D=!1?void 0:typeof document<"u"?document.currentScript?.src:typeof self<"u"?self.location?.href:void 0,Pr=!1||typeof location>"u"?void 0:location.origin,Vt=(t,e)=>{try{let n=e??D;return(n?new URL(t,n):new URL(t)).origin===Pr}catch{return!1}},Cr=(t,e)=>{let n=e??D;try{return(n?new URL(t,n):new URL(t)).href}catch{return}},Lr=(t,e)=>`${e??"./"}${t}`,Yt=async t=>{let n=await(await fetch(t,{credentials:"same-origin"})).blob();return URL.createObjectURL(n)},Br=async t=>(await import(/*webpackIgnore:true*/t)).default,Ht=(jt(),Ve(Gt)).default,qt=async()=>{if(!D)throw new Error("Failed to load proxy worker: cannot determine the script source URL.");if(Vt(D))return[void 0,Ht()];let t=await Yt(D);return[t,Ht(t)]},Jt=async(t,e,n,o)=>{{let r=o?"ort-wasm-relaxedsimd-threaded.mjs":"ort-wasm-simd-threaded.mjs",i=t??Cr(r,e),s=!!1&&n&&i&&!Vt(i,e),a=s?await Yt(i):i??Lr(r,e);return[s?a:void 0,await Br(a)]}}});var Qe,et,Re,Xt,Mr,Rr,Ur,xe,x,Y=b(()=>{"use strict";oe();et=!1,Re=!1,Xt=!1,Mr=()=>{if(typeof SharedArrayBuffer>"u")return!1;try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},Rr=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},Ur=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,5,1,96,0,1,123,3,2,1,0,10,19,1,17,0,65,1,253,15,65,2,253,15,65,3,253,15,253,147,2,11]))}catch{return!1}},xe=async t=>{if(et)return Promise.resolve();if(Re)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(Xt)throw new Error("previous call to 'initializeWebAssembly()' failed.");Re=!0;let e=t.initTimeout,n=t.numThreads,o=t.relaxedSimd;if(!Rr())throw new Error("WebAssembly SIMD is not supported in the current environment.");let r=o&&Ur(),i=Mr();n>1&&!i&&(typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+n+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),t.numThreads=n=1);let s=t.wasmPaths,a=typeof s=="string"?s:void 0,u=s?.mjs,f=u?.href??u,d=s?.wasm,l=d?.href??d,c=t.wasmBinary,[p,g]=await Jt(f,a,n>1,r),m=!1,h=[];if(e>0&&h.push(new Promise(O=>{setTimeout(()=>{m=!0,O()},e)})),h.push(new Promise((O,y)=>{let w={numThreads:n};c?w.wasmBinary=c:(l||a)&&(w.locateFile=(A,P)=>l??(a??P)+A),g(w).then(A=>{Re=!1,et=!0,Qe=A,O(),p&&URL.revokeObjectURL(p)},A=>{Re=!1,Xt=!0,y(A)})})),await Promise.race(h),m)throw new Error(`WebAssembly backend initializing failed due to timeout: ${e}ms`)},x=()=>{if(et&&Qe)return Qe;throw new Error("WebAssembly is not initialized yet.")}});var v,ie,T,Ue=b(()=>{"use strict";Y();v=(t,e)=>{let n=x(),o=n.lengthBytesUTF8(t)+1,r=n._malloc(o);return n.stringToUTF8(t,r,o),e.push(r),r},ie=(t,e,n,o)=>{if(typeof t=="object"&&t!==null){if(n.has(t))throw new Error("Circular reference in options");n.add(t)}Object.entries(t).forEach(([r,i])=>{let s=e?e+r:r;if(typeof i=="object")ie(i,s+".",n,o);else if(typeof i=="string"||typeof i=="number")o(s,i.toString());else if(typeof i=="boolean")o(s,i?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof i}`)})},T=t=>{let e=x(),n=e.stackSave();try{let o=e.PTR_SIZE,r=e.stackAlloc(2*o);e._OrtGetLastError(r,r+o);let i=Number(e.getValue(r,o===4?"i32":"i64")),s=e.getValue(r+o,"*"),a=s?e.UTF8ToString(s):"";throw new Error(`${t} ERROR_CODE: ${i}, ERROR_MESSAGE: ${a}`)}finally{e.stackRestore(n)}}});var Zt,Kt=b(()=>{"use strict";Y();Ue();Zt=t=>{let e=x(),n=0,o=[],r=t||{};try{if(t?.logSeverityLevel===void 0)r.logSeverityLevel=2;else if(typeof t.logSeverityLevel!="number"||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(t?.logVerbosityLevel===void 0)r.logVerbosityLevel=0;else if(typeof t.logVerbosityLevel!="number"||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);t?.terminate===void 0&&(r.terminate=!1);let i=0;return t?.tag!==void 0&&(i=v(t.tag,o)),n=e._OrtCreateRunOptions(r.logSeverityLevel,r.logVerbosityLevel,!!r.terminate,i),n===0&&T("Can't create run options."),t?.extra!==void 0&&ie(t.extra,"",new WeakSet,(s,a)=>{let u=v(s,o),f=v(a,o);e._OrtAddRunConfigEntry(n,u,f)!==0&&T(`Can't set a run config entry: ${s} - ${a}.`)}),[n,o]}catch(i){throw n!==0&&e._OrtReleaseRunOptions(n),o.forEach(s=>e._free(s)),i}}});var Dr,_r,kr,Nr,Qt,er=b(()=>{"use strict";Y();Ue();Dr=t=>{switch(t){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${t}`)}},_r=t=>{switch(t){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${t}`)}},kr=t=>{t.extra||(t.extra={}),t.extra.session||(t.extra.session={});let e=t.extra.session;e.use_ort_model_bytes_directly||(e.use_ort_model_bytes_directly="1"),t.executionProviders&&t.executionProviders.some(n=>(typeof n=="string"?n:n.name)==="webgpu")&&(t.enableMemPattern=!1)},Nr=(t,e,n)=>{for(let o of e){let r=typeof o=="string"?o:o.name;switch(r){case"webnn":if(r="WEBNN",typeof o!="string"){let a=o?.deviceType;if(a){let u=v("deviceType",n),f=v(a,n);x()._OrtAddSessionConfigEntry(t,u,f)!==0&&T(`Can't set a session config entry: 'deviceType' - ${a}.`)}}break;case"webgpu":if(r="JS",typeof o!="string"){let s=o;if(s?.preferredLayout){if(s.preferredLayout!=="NCHW"&&s.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${s.preferredLayout}`);let a=v("preferredLayout",n),u=v(s.preferredLayout,n);x()._OrtAddSessionConfigEntry(t,a,u)!==0&&T(`Can't set a session config entry: 'preferredLayout' - ${s.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${r}`)}let i=v(r,n);x()._OrtAppendExecutionProvider(t,i)!==0&&T(`Can't append execution provider: ${r}.`)}},Qt=t=>{let e=x(),n=0,o=[],r=t||{};kr(r);try{let i=Dr(r.graphOptimizationLevel??"all"),s=_r(r.executionMode??"sequential"),a=typeof r.logId=="string"?v(r.logId,o):0,u=r.logSeverityLevel??2;if(!Number.isInteger(u)||u<0||u>4)throw new Error(`log serverity level is not valid: ${u}`);let f=r.logVerbosityLevel??0;if(!Number.isInteger(f)||f<0||f>4)throw new Error(`log verbosity level is not valid: ${f}`);let d=typeof r.optimizedModelFilePath=="string"?v(r.optimizedModelFilePath,o):0;if(n=e._OrtCreateSessionOptions(i,!!r.enableCpuMemArena,!!r.enableMemPattern,s,!!r.enableProfiling,0,a,u,f,d),n===0&&T("Can't create session options."),r.executionProviders&&Nr(n,r.executionProviders,o),r.enableGraphCapture!==void 0){if(typeof r.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${r.enableGraphCapture}`);let l=v("enableGraphCapture",o),c=v(r.enableGraphCapture.toString(),o);e._OrtAddSessionConfigEntry(n,l,c)!==0&&T(`Can't set a session config entry: 'enableGraphCapture' - ${r.enableGraphCapture}.`)}if(r.freeDimensionOverrides)for(let[l,c]of Object.entries(r.freeDimensionOverrides)){if(typeof l!="string")throw new Error(`free dimension override name must be a string: ${l}`);if(typeof c!="number"||!Number.isInteger(c)||c<0)throw new Error(`free dimension override value must be a non-negative integer: ${c}`);let p=v(l,o);e._OrtAddFreeDimensionOverride(n,p,c)!==0&&T(`Can't set a free dimension override: ${l} - ${c}.`)}return r.extra!==void 0&&ie(r.extra,"",new WeakSet,(l,c)=>{let p=v(l,o),g=v(c,o);e._OrtAddSessionConfigEntry(n,p,g)!==0&&T(`Can't set a session config entry: ${l} - ${c}.`)}),[n,o]}catch(i){throw n!==0&&e._OrtReleaseSessionOptions(n)!==0&&T("Can't release session options."),o.forEach(s=>e._free(s)),i}}});var ae,tr,ue,rr,nr,De,_e,or,tt=b(()=>{"use strict";ae=t=>{switch(t){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;case"int4":return 22;case"uint4":return 21;default:throw new Error(`unsupported data type: ${t}`)}},tr=t=>{switch(t){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";case 22:return"int4";case 21:return"uint4";default:throw new Error(`unsupported data type: ${t}`)}},ue=(t,e)=>{let n=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][t],o=typeof e=="number"?e:e.reduce((r,i)=>r*i,1);return n>0?Math.ceil(o*n):void 0},rr=t=>{switch(t){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${t}`)}},nr=t=>{switch(t){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${t}`)}},De=t=>t==="float32"||t==="float16"||t==="int32"||t==="int64"||t==="uint32"||t==="uint8"||t==="bool"||t==="uint4"||t==="int4",_e=t=>t==="float32"||t==="float16"||t==="int32"||t==="int64"||t==="uint32"||t==="uint64"||t==="int8"||t==="uint8"||t==="bool"||t==="uint4"||t==="int4",or=t=>{switch(t){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;case"ml-tensor":return 5;default:throw new Error(`unsupported data location: ${t}`)}}});var fe,rt=b(()=>{"use strict";Oe();fe=async t=>{if(typeof t=="string")if(!1)try{let{readFile:e}=He("node:fs/promises");return new Uint8Array(await e(t))}catch(e){if(e.code==="ERR_FS_FILE_TOO_LARGE"){let{createReadStream:n}=He("node:fs"),o=n(t),r=[];for await(let i of o)r.push(i);return new Uint8Array(Buffer.concat(r))}throw e}else{let e=await fetch(t);if(!e.ok)throw new Error(`failed to load external data file: ${t}`);let n=e.headers.get("Content-Length"),o=n?parseInt(n,10):0;if(o<1073741824)return new Uint8Array(await e.arrayBuffer());{if(!e.body)throw new Error(`failed to load external data file: ${t}, no response body.`);let r=e.body.getReader(),i;try{i=new ArrayBuffer(o)}catch(a){if(a instanceof RangeError){let u=Math.ceil(o/65536);i=new WebAssembly.Memory({initial:u,maximum:u}).buffer}else throw a}let s=0;for(;;){let{done:a,value:u}=await r.read();if(a)break;let f=u.byteLength;new Uint8Array(i,s,f).set(u),s+=f}return new Uint8Array(i,0,o)}}else return t instanceof Blob?new Uint8Array(await t.arrayBuffer()):t instanceof Uint8Array?t:new Uint8Array(t)}});var Fr,ve,Ie,Q,Wr,se,Pe,Ce,sr,Le,Be,Me,Ke=b(()=>{"use strict";Kt();er();tt();Y();Ue();rt();Fr=(t,e)=>{x()._OrtInit(t,e)!==0&&T("Can't initialize onnxruntime.")},ve=async t=>{Fr(t.wasm.numThreads,nr(t.logLevel))},Ie=async(t,e)=>{},Q=new Map,Wr=t=>{let e=x(),n=e.stackSave();try{let o=e.PTR_SIZE,r=e.stackAlloc(2*o);e._OrtGetInputOutputCount(t,r,r+o)!==0&&T("Can't get session input/output count.");let s=o===4?"i32":"i64";return[Number(e.getValue(r,s)),Number(e.getValue(r+o,s))]}finally{e.stackRestore(n)}},se=t=>{let e=x(),n=e._malloc(t.byteLength);if(n===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${t.byteLength}.`);return e.HEAPU8.set(t,n),[n,t.byteLength]},Pe=async(t,e)=>{let n,o,r=x();Array.isArray(t)?[n,o]=t:t.buffer===r.HEAPU8.buffer?[n,o]=[t.byteOffset,t.byteLength]:[n,o]=se(t);let i=0,s=0,a=0,u=[],f=[],d=[];try{if([s,u]=Qt(e),e?.externalData&&r.mountExternalData){let y=[];for(let w of e.externalData){let A=typeof w=="string"?w:w.path;y.push(fe(typeof w=="string"?w:w.data).then(P=>{r.mountExternalData(A,P)}))}await Promise.all(y)}for(let y of e?.executionProviders??[])if((typeof y=="string"?y:y.name)==="webnn"){if(r.shouldTransferToMLTensor=!1,r.currentContext)throw new Error("WebNN execution provider is already set.");if(typeof y!="string"){let A=y,P=A?.context,le=A?.gpuDevice,de=A?.deviceType,pe=A?.powerPreference;P?r.currentContext=P:le?r.currentContext=await r.jsepCreateMLContext(le):r.currentContext=await r.jsepCreateMLContext({deviceType:de,powerPreference:pe})}else r.currentContext=await r.jsepCreateMLContext();break}i=await r._OrtCreateSession(n,o,s),i===0&&T("Can't create a session."),r.jsepOnCreateSession?.(),r.currentContext&&(r.jsepRegisterMLContext(i,r.currentContext),r.currentContext=void 0,r.shouldTransferToMLTensor=!0);let[l,c]=Wr(i),p=!!e?.enableGraphCapture,g=[],m=[],h=[];for(let y=0;y<l;y++){let w=r._OrtGetInputName(i,y);w===0&&T("Can't get an input name."),f.push(w),g.push(r.UTF8ToString(w))}for(let y=0;y<c;y++){let w=r._OrtGetOutputName(i,y);w===0&&T("Can't get an output name."),d.push(w);let A=r.UTF8ToString(w);m.push(A)}let O=null;return Q.set(i,[i,f,d,O,p,!1]),[i,g,m]}catch(l){throw f.forEach(c=>r._OrtFree(c)),d.forEach(c=>r._OrtFree(c)),a!==0&&r._OrtReleaseBinding(a)!==0&&T("Can't release IO binding."),i!==0&&r._OrtReleaseSession(i)!==0&&T("Can't release session."),l}finally{r._free(n),s!==0&&r._OrtReleaseSessionOptions(s)!==0&&T("Can't release session options."),u.forEach(l=>r._free(l)),r.unmountExternalData?.()}},Ce=t=>{let e=x(),n=Q.get(t);if(!n)throw new Error(`cannot release session. invalid session id: ${t}`);let[o,r,i,s,a]=n;s&&(a&&e._OrtClearBoundOutputs(s.handle)!==0&&T("Can't clear bound outputs."),e._OrtReleaseBinding(s.handle)!==0&&T("Can't release IO binding.")),e.jsepOnReleaseSession?.(t),r.forEach(u=>e._OrtFree(u)),i.forEach(u=>e._OrtFree(u)),e._OrtReleaseSession(o)!==0&&T("Can't release session."),Q.delete(t)},sr=(t,e,n,o,r,i=!1)=>{if(!t){e.push(0);return}let s=x(),a=s.PTR_SIZE,u=t[0],f=t[1],d=t[3],l,c;if(u==="string"&&(d==="gpu-buffer"||d==="ml-tensor"))throw new Error("String tensor is not supported on GPU.");if(i&&d!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${r} when enableGraphCapture is true.`);if(d==="gpu-buffer"){let m=t[2].gpuBuffer;c=ue(ae(u),f);let h=s.jsepRegisterBuffer;if(!h)throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');l=h(o,r,m,c)}else if(d==="ml-tensor"){let m=t[2].mlTensor;c=ue(ae(u),f);let h=s.jsepRegisterMLTensor;if(!h)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');l=h(m,ae(u),f)}else{let m=t[2];if(Array.isArray(m)){c=a*m.length,l=s._malloc(c),n.push(l);for(let h=0;h<m.length;h++){if(typeof m[h]!="string")throw new TypeError(`tensor data at index ${h} is not a string`);s.setValue(l+h*a,v(m[h],n),"*")}}else c=m.byteLength,l=s._malloc(c),n.push(l),s.HEAPU8.set(new Uint8Array(m.buffer,m.byteOffset,c),l)}let p=s.stackSave(),g=s.stackAlloc(4*f.length);try{f.forEach((h,O)=>s.setValue(g+O*a,h,a===4?"i32":"i64"));let m=s._OrtCreateTensor(ae(u),l,c,g,f.length,or(d));m===0&&T(`Can't create tensor for input/output. session=${o}, index=${r}.`),e.push(m)}finally{s.stackRestore(p)}},Le=async(t,e,n,o,r,i)=>{let s=x(),a=s.PTR_SIZE,u=Q.get(t);if(!u)throw new Error(`cannot run inference. invalid session id: ${t}`);let f=u[0],d=u[1],l=u[2],c=u[3],p=u[4],g=u[5],m=e.length,h=o.length,O=0,y=[],w=[],A=[],P=[],le=s.stackSave(),de=s.stackAlloc(m*a),pe=s.stackAlloc(m*a),ze=s.stackAlloc(h*a),it=s.stackAlloc(h*a);try{s.jsepOnRunStart?.(f),[O,y]=Zt(i);for(let E=0;E<m;E++)sr(n[E],w,P,t,e[E],p);for(let E=0;E<h;E++)sr(r[E],A,P,t,m+o[E],p);for(let E=0;E<m;E++)s.setValue(de+E*a,w[E],"*"),s.setValue(pe+E*a,d[e[E]],"*");for(let E=0;E<h;E++)s.setValue(ze+E*a,A[E],"*"),s.setValue(it+E*a,l[o[E]],"*");let k;k=await s._OrtRun(f,pe,de,m,it,h,ze,O),k!==0&&T("failed to call OrtRun().");let X=[];for(let E=0;E<h;E++){let Z=Number(s.getValue(ze+E*a,"*"));if(Z===A[E]){X.push(r[E]);continue}let at=s.stackSave(),N=s.stackAlloc(4*a),re=!1,B,R=0;try{s._OrtGetTensorData(Z,N,N+a,N+2*a,N+3*a)!==0&&T(`Can't access output tensor data on index ${E}.`);let Ge=a===4?"i32":"i64",me=Number(s.getValue(N,Ge));R=s.getValue(N+a,"*");let ut=s.getValue(N+a*2,"*"),br=Number(s.getValue(N+a*3,Ge)),$=[];for(let M=0;M<br;M++)$.push(Number(s.getValue(ut+M*a,Ge)));s._OrtFree(ut)!==0&&T("Can't free memory for tensor dims.");let z=$.reduce((M,C)=>M*C,1);B=tr(me);let he=c?.outputPreferredLocations[o[E]];if(B==="string"){if(he==="gpu-buffer"||he==="ml-tensor")throw new Error("String tensor is not supported on GPU.");let M=[];for(let C=0;C<z;C++){let G=s.getValue(R+C*a,"*"),gr=s.getValue(R+(C+1)*a,"*"),Er=C===z-1?void 0:gr-G;M.push(s.UTF8ToString(G,Er))}X.push([B,$,M,"cpu"])}else if(he==="gpu-buffer"&&z>0){let M=s.jsepGetBuffer;if(!M)throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let C=M(R),G=ue(me,z);if(G===void 0||!De(B))throw new Error(`Unsupported data type: ${B}`);re=!0,X.push([B,$,{gpuBuffer:C,download:s.jsepCreateDownloader(C,G,B),dispose:()=>{s._OrtReleaseTensor(Z)!==0&&T("Can't release tensor.")}},"gpu-buffer"])}else if(he==="ml-tensor"&&z>0){let M=s.jsepEnsureTensor;if(!M)throw new Error('preferredLocation "ml-tensor" is not supported without using WebNN.');if(ue(me,z)===void 0||!_e(B))throw new Error(`Unsupported data type: ${B}`);let G=await M(R,me,$,!1);re=!0,X.push([B,$,{mlTensor:G,download:s.jsepCreateMLTensorDownloader(R,B),dispose:()=>{s.jsepReleaseTensorId(R),s._OrtReleaseTensor(Z)}},"ml-tensor"])}else{let M=rr(B),C=new M(z);new Uint8Array(C.buffer,C.byteOffset,C.byteLength).set(s.HEAPU8.subarray(R,R+C.byteLength)),X.push([B,$,C,"cpu"])}}finally{s.stackRestore(at),B==="string"&&R&&s._free(R),re||s._OrtReleaseTensor(Z)}}return c&&!p&&(s._OrtClearBoundOutputs(c.handle)!==0&&T("Can't clear bound outputs."),Q.set(t,[f,d,l,c,p,!1])),X}finally{s.stackRestore(le),w.forEach(k=>s._OrtReleaseTensor(k)),A.forEach(k=>s._OrtReleaseTensor(k)),P.forEach(k=>s._free(k)),O!==0&&s._OrtReleaseRunOptions(O),y.forEach(k=>s._free(k))}},Be=t=>{let e=x(),n=Q.get(t);if(!n)throw new Error("invalid session id");let o=n[0],r=e._OrtEndProfiling(o);r===0&&T("Can't get an profile file name."),e._OrtFree(r)},Me=t=>{let e=[];for(let n of t){let o=n[2];!Array.isArray(o)&&"buffer"in o&&e.push(o.buffer)}return e}});var J,_,ce,Ne,Fe,ke,nt,ot,ee,te,zr,ir,ar,ur,fr,cr,lr,dr,st=b(()=>{"use strict";V();Ke();Y();oe();J=()=>!!S.wasm.proxy&&typeof document<"u",ce=!1,Ne=!1,Fe=!1,ot=new Map,ee=(t,e)=>{let n=ot.get(t);n?n.push(e):ot.set(t,[e])},te=()=>{if(ce||!Ne||Fe||!_)throw new Error("worker not ready")},zr=t=>{switch(t.data.type){case"init-wasm":ce=!1,t.data.err?(Fe=!0,nt[1](t.data.err)):(Ne=!0,nt[0]()),ke&&(URL.revokeObjectURL(ke),ke=void 0);break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let e=ot.get(t.data.type);t.data.err?e.shift()[1](t.data.err):e.shift()[0](t.data.out);break}default:}},ir=async()=>{if(!Ne){if(ce)throw new Error("multiple calls to 'initWasm()' detected.");if(Fe)throw new Error("previous call to 'initWasm()' failed.");if(ce=!0,J())return new Promise((t,e)=>{_?.terminate(),qt().then(([n,o])=>{try{_=o,_.onerror=i=>e(i),_.onmessage=zr,nt=[t,e];let r={type:"init-wasm",in:S};_.postMessage(r),ke=n}catch(r){e(r)}},e)});try{await xe(S.wasm),await ve(S),Ne=!0}catch(t){throw Fe=!0,t}finally{ce=!1}}},ar=async t=>{if(J())return te(),new Promise((e,n)=>{ee("init-ep",[e,n]);let o={type:"init-ep",in:{epName:t,env:S}};_.postMessage(o)});await Ie(S,t)},ur=async t=>J()?(te(),new Promise((e,n)=>{ee("copy-from",[e,n]);let o={type:"copy-from",in:{buffer:t}};_.postMessage(o,[t.buffer])})):se(t),fr=async(t,e)=>{if(J()){if(e?.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return te(),new Promise((n,o)=>{ee("create",[n,o]);let r={type:"create",in:{model:t,options:{...e}}},i=[];t instanceof Uint8Array&&i.push(t.buffer),_.postMessage(r,i)})}else return Pe(t,e)},cr=async t=>{if(J())return te(),new Promise((e,n)=>{ee("release",[e,n]);let o={type:"release",in:t};_.postMessage(o)});Ce(t)},lr=async(t,e,n,o,r,i)=>{if(J()){if(n.some(s=>s[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if(r.some(s=>s))throw new Error("pre-allocated output tensor is not supported for proxy.");return te(),new Promise((s,a)=>{ee("run",[s,a]);let u=n,f={type:"run",in:{sessionId:t,inputIndices:e,inputs:u,outputIndices:o,options:i}};_.postMessage(f,Me(u))})}else return Le(t,e,n,o,r,i)},dr=async t=>{if(J())return te(),new Promise((e,n)=>{ee("end-profiling",[e,n]);let o={type:"end-profiling",in:t};_.postMessage(o)});Be(t)}});var pr,Gr,We,mr=b(()=>{"use strict";V();st();tt();Oe();rt();pr=(t,e)=>{switch(t.location){case"cpu":return[t.type,t.dims,t.data,"cpu"];case"gpu-buffer":return[t.type,t.dims,{gpuBuffer:t.gpuBuffer},"gpu-buffer"];case"ml-tensor":return[t.type,t.dims,{mlTensor:t.mlTensor},"ml-tensor"];default:throw new Error(`invalid data location: ${t.location} for ${e()}`)}},Gr=t=>{switch(t[3]){case"cpu":return new I(t[0],t[2],t[1]);case"gpu-buffer":{let e=t[0];if(!De(e))throw new Error(`not supported data type: ${e} for deserializing GPU tensor`);let{gpuBuffer:n,download:o,dispose:r}=t[2];return I.fromGpuBuffer(n,{dataType:e,dims:t[1],download:o,dispose:r})}case"ml-tensor":{let e=t[0];if(!_e(e))throw new Error(`not supported data type: ${e} for deserializing MLTensor tensor`);let{mlTensor:n,download:o,dispose:r}=t[2];return I.fromMLTensor(n,{dataType:e,dims:t[1],download:o,dispose:r})}default:throw new Error(`invalid data location: ${t[3]}`)}},We=class{async fetchModelAndCopyToWasmMemory(e){return ur(await fe(e))}async loadModel(e,n){F();let o;typeof e=="string"?!1?o=await fe(e):o=await this.fetchModelAndCopyToWasmMemory(e):o=e,[this.sessionId,this.inputNames,this.outputNames]=await fr(o,n),W()}async dispose(){return cr(this.sessionId)}async run(e,n,o){F();let r=[],i=[];Object.entries(e).forEach(c=>{let p=c[0],g=c[1],m=this.inputNames.indexOf(p);if(m===-1)throw new Error(`invalid input '${p}'`);r.push(g),i.push(m)});let s=[],a=[];Object.entries(n).forEach(c=>{let p=c[0],g=c[1],m=this.outputNames.indexOf(p);if(m===-1)throw new Error(`invalid output '${p}'`);s.push(g),a.push(m)});let u=r.map((c,p)=>pr(c,()=>`input "${this.inputNames[i[p]]}"`)),f=s.map((c,p)=>c?pr(c,()=>`output "${this.outputNames[a[p]]}"`):null),d=await lr(this.sessionId,i,u,a,f,o),l={};for(let c=0;c<d.length;c++)l[this.outputNames[a[c]]]=s[c]??Gr(d[c]);return W(),l}startProfiling(){}endProfiling(){dr(this.sessionId)}}});var yr={};ye(yr,{OnnxruntimeWebAssemblyBackend:()=>$e,initializeFlags:()=>hr,wasmBackend:()=>jr});var hr,$e,jr,wr=b(()=>{"use strict";V();st();mr();oe();hr=()=>{if((typeof S.wasm.initTimeout!="number"||S.wasm.initTimeout<0)&&(S.wasm.initTimeout=0),S.wasm.simd===!1&&console.warn('Deprecated property "env.wasm.simd" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'),typeof S.wasm.relaxedSimd!="boolean"&&(S.wasm.relaxedSimd=!1),typeof S.wasm.proxy!="boolean"&&(S.wasm.proxy=!1),typeof S.wasm.trace!="boolean"&&(S.wasm.trace=!1),typeof S.wasm.numThreads!="number"||!Number.isInteger(S.wasm.numThreads)||S.wasm.numThreads<=0)if(typeof self<"u"&&!self.crossOriginIsolated)S.wasm.numThreads=1;else{let t=typeof navigator>"u"?He("node:os").cpus().length:navigator.hardwareConcurrency;S.wasm.numThreads=Math.min(4,Math.ceil((t||1)/2))}S.wasm.wasmPaths===void 0&&D&&D.indexOf("blob:")!==0&&(S.wasm.wasmPaths=D.substring(0,D.lastIndexOf("/")+1))},$e=class{async init(e){hr(),await ir(),await ar(e)}async createInferenceSessionHandler(e,n){let o=new We;return await o.loadModel(e,n),Promise.resolve(o)}},jr=new $e});var Vr={};ye(Vr,{InferenceSession:()=>Bt,TRACE:()=>Je,TRACE_FUNC_BEGIN:()=>F,TRACE_FUNC_END:()=>W,Tensor:()=>I,TrainingSession:()=>Nt,default:()=>Hr,env:()=>S,registerBackend:()=>K});V();V();V();var Wt="1.21.0";var Hr=Ze;{let t=(wr(),Ve(yr)).wasmBackend;K("cpu",t,10),K("wasm",t,10)}Object.defineProperty(S.versions,"web",{value:Wt,enumerable:!0});return Ve(Vr);})();
typeof exports=="object"&&typeof module=="object"&&(module.exports=ort);
//# sourceMappingURL=ort.wasm.min.js.map
